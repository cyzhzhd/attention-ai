!(function (t) {
  var e = {};
  function n(r) {
    if (e[r]) return e[r].exports;
    var i = (e[r] = { i: r, l: !1, exports: {} });
    return t[r].call(i.exports, i, i.exports, n), (i.l = !0), i.exports;
  }
  (n.m = t),
    (n.c = e),
    (n.d = function (t, e, r) {
      n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: r });
    }),
    (n.r = function (t) {
      "undefined" != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
        Object.defineProperty(t, "__esModule", { value: !0 });
    }),
    (n.t = function (t, e) {
      if ((1 & e && (t = n(t)), 8 & e)) return t;
      if (4 & e && "object" == typeof t && t && t.__esModule) return t;
      var r = Object.create(null);
      if (
        (n.r(r),
        Object.defineProperty(r, "default", { enumerable: !0, value: t }),
        2 & e && "string" != typeof t)
      )
        for (var i in t)
          n.d(
            r,
            i,
            function (e) {
              return t[e];
            }.bind(null, i)
          );
      return r;
    }),
    (n.n = function (t) {
      var e =
        t && t.__esModule
          ? function () {
              return t.default;
            }
          : function () {
              return t;
            };
      return n.d(e, "a", e), e;
    }),
    (n.o = function (t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }),
    (n.p = ""),
    n((n.s = 24));
})([
  function (t, e, n) {
    "use strict";
    (function (t, r, i, a) {
      n.d(e, "a", function () {
        return ch;
      }),
        n.d(e, "b", function () {
          return wt;
        }),
        n.d(e, "c", function () {
          return Nt;
        }),
        n.d(e, "d", function () {
          return us;
        }),
        n.d(e, "e", function () {
          return cs;
        }),
        n.d(e, "f", function () {
          return ls;
        }),
        n.d(e, "g", function () {
          return uu;
        }),
        n.d(e, "h", function () {
          return cu;
        }),
        n.d(e, "i", function () {
          return Nc;
        }),
        n.d(e, "j", function () {
          return Ic;
        }),
        n.d(e, "k", function () {
          return kc;
        }),
        n.d(e, "l", function () {
          return _c;
        }),
        n.d(e, "m", function () {
          return ps;
        }),
        n.d(e, "n", function () {
          return hs;
        }),
        n.d(e, "o", function () {
          return fs;
        }),
        n.d(e, "p", function () {
          return pu;
        }),
        n.d(e, "q", function () {
          return ds;
        }),
        n.d(e, "r", function () {
          return vc;
        }),
        n.d(e, "s", function () {
          return bc;
        }),
        n.d(e, "t", function () {
          return Ze;
        }),
        n.d(e, "u", function () {
          return $s;
        }),
        n.d(e, "v", function () {
          return Qs;
        }),
        n.d(e, "w", function () {
          return tu;
        }),
        n.d(e, "x", function () {
          return eu;
        }),
        n.d(e, "y", function () {
          return Xn;
        }),
        n.d(e, "z", function () {
          return th;
        }),
        n.d(e, "A", function () {
          return Jn;
        }),
        n.d(e, "B", function () {
          return ms;
        }),
        n.d(e, "C", function () {
          return vs;
        }),
        n.d(e, "D", function () {
          return hn;
        }),
        n.d(e, "E", function () {
          return An;
        }),
        n.d(e, "F", function () {
          return Tn;
        }),
        n.d(e, "G", function () {
          return Rn;
        }),
        n.d(e, "H", function () {
          return Dn;
        }),
        n.d(e, "I", function () {
          return Fn;
        }),
        n.d(e, "J", function () {
          return Zu;
        }),
        n.d(e, "K", function () {
          return Xu;
        }),
        n.d(e, "L", function () {
          return rc;
        }),
        n.d(e, "M", function () {
          return Yu;
        }),
        n.d(e, "N", function () {
          return gs;
        }),
        n.d(e, "O", function () {
          return ys;
        }),
        n.d(e, "P", function () {
          return Ve;
        }),
        n.d(e, "Q", function () {
          return tr;
        }),
        n.d(e, "R", function () {
          return Qu;
        }),
        n.d(e, "S", function () {
          return qe;
        }),
        n.d(e, "T", function () {
          return hu;
        }),
        n.d(e, "U", function () {
          return fu;
        }),
        n.d(e, "V", function () {
          return ol;
        }),
        n.d(e, "W", function () {
          return Pc;
        }),
        n.d(e, "X", function () {
          return Ue;
        }),
        n.d(e, "Y", function () {
          return h;
        }),
        n.d(e, "Z", function () {
          return _u;
        }),
        n.d(e, "ab", function () {
          return bs;
        }),
        n.d(e, "bb", function () {
          return ws;
        }),
        n.d(e, "cb", function () {
          return er;
        }),
        n.d(e, "db", function () {
          return xs;
        }),
        n.d(e, "eb", function () {
          return nr;
        }),
        n.d(e, "fb", function () {
          return $c;
        }),
        n.d(e, "gb", function () {
          return Sn;
        }),
        n.d(e, "hb", function () {
          return Cs;
        }),
        n.d(e, "ib", function () {
          return mu;
        }),
        n.d(e, "jb", function () {
          return Vl;
        }),
        n.d(e, "kb", function () {
          return Vu;
        }),
        n.d(e, "lb", function () {
          return il;
        }),
        n.d(e, "mb", function () {
          return Tu;
        }),
        n.d(e, "nb", function () {
          return Ru;
        }),
        n.d(e, "ob", function () {
          return Qc;
        }),
        n.d(e, "pb", function () {
          return dn;
        }),
        n.d(e, "qb", function () {
          return Ml;
        }),
        n.d(e, "rb", function () {
          return Jp;
        }),
        n.d(e, "sb", function () {
          return el;
        }),
        n.d(e, "tb", function () {
          return Ke;
        }),
        n.d(e, "ub", function () {
          return zc;
        }),
        n.d(e, "vb", function () {
          return Mu;
        }),
        n.d(e, "wb", function () {
          return ju;
        }),
        n.d(e, "xb", function () {
          return kl;
        }),
        n.d(e, "yb", function () {
          return Nn;
        }),
        n.d(e, "zb", function () {
          return Gc;
        }),
        n.d(e, "Ab", function () {
          return Os;
        }),
        n.d(e, "Bb", function () {
          return Es;
        }),
        n.d(e, "Cb", function () {
          return Wr;
        }),
        n.d(e, "Db", function () {
          return nu;
        }),
        n.d(e, "Eb", function () {
          return ru;
        }),
        n.d(e, "Fb", function () {
          return iu;
        }),
        n.d(e, "Gb", function () {
          return ac;
        }),
        n.d(e, "Hb", function () {
          return Tc;
        }),
        n.d(e, "Ib", function () {
          return mc;
        }),
        n.d(e, "Jb", function () {
          return yc;
        }),
        n.d(e, "Kb", function () {
          return vu;
        }),
        n.d(e, "Lb", function () {
          return Rc;
        }),
        n.d(e, "Mb", function () {
          return Ge;
        }),
        n.d(e, "Nb", function () {
          return Dc;
        }),
        n.d(e, "Ob", function () {
          return yu;
        }),
        n.d(e, "Pb", function () {
          return wu;
        }),
        n.d(e, "Qb", function () {
          return Fc;
        }),
        n.d(e, "Rb", function () {
          return Cu;
        }),
        n.d(e, "Sb", function () {
          return Ou;
        }),
        n.d(e, "Tb", function () {
          return rr;
        }),
        n.d(e, "Ub", function () {
          return Ns;
        }),
        n.d(e, "Vb", function () {
          return wh;
        }),
        n.d(e, "Wb", function () {
          return Lu;
        }),
        n.d(e, "Xb", function () {
          return ir;
        }),
        n.d(e, "Yb", function () {
          return On;
        }),
        n.d(e, "Zb", function () {
          return kn;
        }),
        n.d(e, "ac", function () {
          return ar;
        }),
        n.d(e, "bc", function () {
          return Eu;
        }),
        n.d(e, "cc", function () {
          return Lc;
        }),
        n.d(e, "dc", function () {
          return jc;
        }),
        n.d(e, "ec", function () {
          return pr;
        }),
        n.d(e, "fc", function () {
          return fr;
        }),
        n.d(e, "gc", function () {
          return In;
        }),
        n.d(e, "hc", function () {
          return fn;
        }),
        n.d(e, "ic", function () {
          return Is;
        }),
        n.d(e, "jc", function () {
          return Bc;
        }),
        n.d(e, "kc", function () {
          return dr;
        }),
        n.d(e, "lc", function () {
          return uc;
        }),
        n.d(e, "mc", function () {
          return tl;
        }),
        n.d(e, "nc", function () {
          return ks;
        }),
        n.d(e, "oc", function () {
          return _s;
        }),
        n.d(e, "pc", function () {
          return gn;
        }),
        n.d(e, "qc", function () {
          return Jc;
        }),
        n.d(e, "rc", function () {
          return Uc;
        }),
        n.d(e, "sc", function () {
          return nc;
        }),
        n.d(e, "tc", function () {
          return ih;
        }),
        n.d(e, "uc", function () {
          return xr;
        }),
        n.d(e, "vc", function () {
          return As;
        }),
        n.d(e, "wc", function () {
          return Ts;
        }),
        n.d(e, "xc", function () {
          return Ms;
        }),
        n.d(e, "yc", function () {
          return js;
        }),
        n.d(e, "zc", function () {
          return wc;
        }),
        n.d(e, "Ac", function () {
          return xc;
        }),
        n.d(e, "Bc", function () {
          return Cc;
        }),
        n.d(e, "Cc", function () {
          return Oc;
        }),
        n.d(e, "Dc", function () {
          return Ec;
        }),
        n.d(e, "Ec", function () {
          return Br;
        }),
        n.d(e, "Fc", function () {
          return Ps;
        }),
        n.d(e, "Gc", function () {
          return mr;
        }),
        n.d(e, "Hc", function () {
          return rl;
        }),
        n.d(e, "Ic", function () {
          return Mn;
        }),
        n.d(e, "Jc", function () {
          return zs;
        }),
        n.d(e, "Kc", function () {
          return as;
        }),
        n.d(e, "Lc", function () {
          return ss;
        }),
        n.d(e, "Mc", function () {
          return vr;
        }),
        n.d(e, "Nc", function () {
          return gr;
        }),
        n.d(e, "Oc", function () {
          return Xc;
        }),
        n.d(e, "Pc", function () {
          return Iu;
        }),
        n.d(e, "Qc", function () {
          return Mc;
        }),
        n.d(e, "Rc", function () {
          return Bs;
        }),
        n.d(e, "Sc", function () {
          return Ws;
        }),
        n.d(e, "Tc", function () {
          return mn;
        }),
        n.d(e, "Uc", function () {
          return yn;
        }),
        n.d(e, "Vc", function () {
          return bn;
        }),
        n.d(e, "Wc", function () {
          return wn;
        }),
        n.d(e, "Xc", function () {
          return xn;
        }),
        n.d(e, "Yc", function () {
          return Ft;
        }),
        n.d(e, "Zc", function () {
          return He;
        }),
        n.d(e, "ad", function () {
          return yr;
        }),
        n.d(e, "bd", function () {
          return Yc;
        }),
        n.d(e, "cd", function () {
          return yh;
        }),
        n.d(e, "dd", function () {
          return Vc;
        }),
        n.d(e, "ed", function () {
          return br;
        }),
        n.d(e, "fd", function () {
          return wr;
        }),
        n.d(e, "gd", function () {
          return lt;
        }),
        n.d(e, "hd", function () {
          return Cn;
        }),
        n.d(e, "id", function () {
          return uh;
        }),
        n.d(e, "jd", function () {
          return ou;
        }),
        n.d(e, "kd", function () {
          return su;
        }),
        n.d(e, "ld", function () {
          return En;
        }),
        n.d(e, "md", function () {
          return _n;
        });
      /**
       * @license
       * Copyright 2020 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       * http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       * =============================================================================
       */
      var o = function (t, e) {
        return (o =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (t, e) {
              t.__proto__ = e;
            }) ||
          function (t, e) {
            for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
          })(t, e);
      };
      function s(t, e) {
        function n() {
          this.constructor = t;
        }
        o(t, e),
          (t.prototype =
            null === e
              ? Object.create(e)
              : ((n.prototype = e.prototype), new n()));
      }
      function u(t, e, n, r) {
        return new (n || (n = Promise))(function (i, a) {
          function o(t) {
            try {
              u(r.next(t));
            } catch (t) {
              a(t);
            }
          }
          function s(t) {
            try {
              u(r.throw(t));
            } catch (t) {
              a(t);
            }
          }
          function u(t) {
            t.done
              ? i(t.value)
              : new n(function (e) {
                  e(t.value);
                }).then(o, s);
          }
          u((r = r.apply(t, e || [])).next());
        });
      }
      function c(t, e) {
        var n,
          r,
          i,
          a,
          o = {
            label: 0,
            sent: function () {
              if (1 & i[0]) throw i[1];
              return i[1];
            },
            trys: [],
            ops: [],
          };
        return (
          (a = { next: s(0), throw: s(1), return: s(2) }),
          "function" == typeof Symbol &&
            (a[Symbol.iterator] = function () {
              return this;
            }),
          a
        );
        function s(a) {
          return function (s) {
            return (function (a) {
              if (n) throw new TypeError("Generator is already executing.");
              for (; o; )
                try {
                  if (
                    ((n = 1),
                    r &&
                      (i =
                        2 & a[0]
                          ? r.return
                          : a[0]
                          ? r.throw || ((i = r.return) && i.call(r), 0)
                          : r.next) &&
                      !(i = i.call(r, a[1])).done)
                  )
                    return i;
                  switch (((r = 0), i && (a = [2 & a[0], i.value]), a[0])) {
                    case 0:
                    case 1:
                      i = a;
                      break;
                    case 4:
                      return o.label++, { value: a[1], done: !1 };
                    case 5:
                      o.label++, (r = a[1]), (a = [0]);
                      continue;
                    case 7:
                      (a = o.ops.pop()), o.trys.pop();
                      continue;
                    default:
                      if (
                        !(i = (i = o.trys).length > 0 && i[i.length - 1]) &&
                        (6 === a[0] || 2 === a[0])
                      ) {
                        o = 0;
                        continue;
                      }
                      if (3 === a[0] && (!i || (a[1] > i[0] && a[1] < i[3]))) {
                        o.label = a[1];
                        break;
                      }
                      if (6 === a[0] && o.label < i[1]) {
                        (o.label = i[1]), (i = a);
                        break;
                      }
                      if (i && o.label < i[2]) {
                        (o.label = i[2]), o.ops.push(a);
                        break;
                      }
                      i[2] && o.ops.pop(), o.trys.pop();
                      continue;
                  }
                  a = e.call(t, o);
                } catch (t) {
                  (a = [6, t]), (r = 0);
                } finally {
                  n = i = 0;
                }
              if (5 & a[0]) throw a[1];
              return { value: a[0] ? a[1] : void 0, done: !0 };
            })([a, s]);
          };
        }
      }
      var l = (function () {
        function t(t) {
          (this.global = t),
            (this.flags = {}),
            (this.flagRegistry = {}),
            (this.urlFlags = {}),
            this.populateURLFlags();
        }
        return (
          (t.prototype.setPlatform = function (t, e) {
            null != this.platform &&
              console.warn(
                "Platform " +
                  this.platformName +
                  " has already been set. Overwriting the platform with " +
                  e +
                  "."
              ),
              (this.platformName = t),
              (this.platform = e);
          }),
          (t.prototype.registerFlag = function (t, e, n) {
            if (
              ((this.flagRegistry[t] = { evaluationFn: e, setHook: n }),
              null != this.urlFlags[t])
            ) {
              var r = this.urlFlags[t];
              console.warn(
                "Setting feature override from URL " + t + ": " + r + "."
              ),
                this.set(t, r);
            }
          }),
          (t.prototype.get = function (t) {
            return (
              t in this.flags || (this.flags[t] = this.evaluateFlag(t)),
              this.flags[t]
            );
          }),
          (t.prototype.getNumber = function (t) {
            return this.get(t);
          }),
          (t.prototype.getBool = function (t) {
            return this.get(t);
          }),
          (t.prototype.getFlags = function () {
            return this.flags;
          }),
          Object.defineProperty(t.prototype, "features", {
            get: function () {
              return this.flags;
            },
            enumerable: !0,
            configurable: !0,
          }),
          (t.prototype.set = function (t, e) {
            if (null == this.flagRegistry[t])
              throw new Error(
                "Cannot set flag " + t + " as it has not been registered."
              );
            (this.flags[t] = e),
              null != this.flagRegistry[t].setHook &&
                this.flagRegistry[t].setHook(e);
          }),
          (t.prototype.evaluateFlag = function (t) {
            if (null == this.flagRegistry[t])
              throw new Error(
                "Cannot evaluate flag '" +
                  t +
                  "': no evaluation function found."
              );
            return this.flagRegistry[t].evaluationFn();
          }),
          (t.prototype.setFlags = function (t) {
            this.flags = Object.assign({}, t);
          }),
          (t.prototype.reset = function () {
            (this.flags = {}), (this.urlFlags = {}), this.populateURLFlags();
          }),
          (t.prototype.populateURLFlags = function () {
            var t = this;
            if (
              void 0 !== this.global &&
              void 0 !== this.global.location &&
              void 0 !== this.global.location.search
            ) {
              var e,
                n,
                r =
                  ((e = this.global.location.search),
                  (n = {}),
                  e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (t) {
                    for (var e = [], r = 1; r < arguments.length; r++)
                      e[r - 1] = arguments[r];
                    return p(n, e[0], e[1]), e.join("=");
                  }),
                  n);
              "tfjsflags" in r &&
                r.tfjsflags.split(",").forEach(function (e) {
                  var n = e.split(":"),
                    r = n[0],
                    i = n[1];
                  t.urlFlags[r] = (function (t, e) {
                    if ("true" === (e = e.toLowerCase()) || "false" === e)
                      return "true" === e;
                    if ("" + +e === e) return +e;
                    throw new Error(
                      "Could not parse value flag value " +
                        e +
                        " for flag " +
                        t +
                        "."
                    );
                  })(r, i);
                });
            }
          }),
          t
        );
      })();
      function p(t, e, n) {
        t[decodeURIComponent(e)] = decodeURIComponent(n || "");
      }
      function h() {
        return f;
      }
      var f = null,
        d = new Map(),
        m = new Map();
      function v(t, e) {
        var n = w(t, e);
        return d.get(n);
      }
      function g(t) {
        for (var e = d.entries(), n = []; ; ) {
          var r = e.next(),
            i = r.done,
            a = r.value;
          if (i) break;
          var o = a[0],
            s = a[1];
          o.split("_")[0] === t && n.push(s);
        }
        return n;
      }
      function y(t) {
        var e = t.kernelName,
          n = t.backendName,
          r = w(e, n);
        if (d.has(r))
          throw new Error(
            "The kernel '" +
              e +
              "' for backend '" +
              n +
              "' is already registered"
          );
        d.set(r, t);
      }
      function b(t) {
        var e = t.kernelName;
        m.has(e) && console.warn("Overriding the gradient for '" + e + "'"),
          m.set(e, t);
      }
      function w(t, e) {
        return e + "_" + t;
      }
      function x(t) {
        for (var e = t.length, n = 0, r = 0; e > 0; )
          (r = (Math.random() * e) | 0),
            (n = t[--e]),
            (t[e] = t[r]),
            (t[r] = n);
      }
      function C(t, e, n) {
        return Math.max(t, Math.min(e, n));
      }
      function O(t) {
        return t % 2 == 0 ? t : t + 1;
      }
      function E(t) {
        for (var e = 0, n = 0; n < t.length; n++) e += t[n];
        return e;
      }
      function S(t, e) {
        if (!t) throw new Error("string" == typeof e ? e : e());
      }
      function N(t, e, n) {
        void 0 === n && (n = ""),
          S(A(t, e), function () {
            return n + " Shapes " + t + " and " + e + " must match";
          });
      }
      function I(t) {
        S(null != t, function () {
          return "The input to the tensor constructor must be a non-null value.";
        });
      }
      function k(t, e, n) {
        if (
          (void 0 === e && (e = []),
          void 0 === n && (n = !1),
          null == e && (e = []),
          Array.isArray(t) || (G(t) && !n))
        )
          for (var r = 0; r < t.length; ++r) k(t[r], e, n);
        else e.push(t);
        return e;
      }
      function _(t) {
        if (0 === t.length) return 1;
        for (var e = t[0], n = 1; n < t.length; n++) e *= t[n];
        return e;
      }
      function A(t, e) {
        if (t === e) return !0;
        if (null == t || null == e) return !1;
        if (t.length !== e.length) return !1;
        for (var n = 0; n < t.length; n++) if (t[n] !== e[n]) return !1;
        return !0;
      }
      function T(t) {
        return t % 1 == 0;
      }
      function R(t) {
        if (null != Math.tanh) return Math.tanh(t);
        if (t === 1 / 0) return 1;
        if (t === -1 / 0) return -1;
        var e = Math.exp(2 * t);
        return (e - 1) / (e + 1);
      }
      function D(t) {
        var e = Math.ceil(Math.sqrt(t));
        return [e, Math.ceil(t / e)];
      }
      function F(t, e) {
        return e <= t.length ? t : t + " ".repeat(e - t.length);
      }
      function M(t, e, n) {
        return (
          void 0 === e &&
            (e = function (t) {
              return 0;
            }),
          new Promise(function (r, i) {
            var a = 0,
              o = function () {
                if (t()) r();
                else {
                  a++;
                  var s = e(a);
                  null != n && a >= n ? i() : setTimeout(o, s);
                }
              };
            o();
          })
        );
      }
      function j(t, e) {
        for (var n = 1, r = -1, i = 0; i < t.length; ++i)
          if (t[i] >= 0) n *= t[i];
          else if (-1 === t[i]) {
            if (-1 !== r)
              throw Error(
                "Shapes can only have 1 implicit size. Found -1 at dim " +
                  r +
                  " and dim " +
                  i
              );
            r = i;
          } else if (t[i] < 0)
            throw Error(
              "Shapes can not be < 0. Found " + t[i] + " at dim " + i
            );
        if (-1 === r) {
          if (e > 0 && e !== n)
            throw Error("Size(" + e + ") must match the product of shape " + t);
          return t;
        }
        if (0 === n)
          throw Error(
            "Cannot infer the missing size in [" +
              t +
              "] when there are 0 elements"
          );
        if (e % n != 0)
          throw Error(
            "The implicit shape can't be a fractional number. Got " +
              e +
              " / " +
              n
          );
        var a = t.slice();
        return (a[r] = e / n), a;
      }
      function P(t, e) {
        var n = e.length;
        return (
          S(
            (t =
              null == t
                ? e.map(function (t, e) {
                    return e;
                  })
                : [].concat(t)).every(function (t) {
              return t >= -n && t < n;
            }),
            function () {
              return (
                "All values in axis param must be in range [-" +
                n +
                ", " +
                n +
                ") but got axis " +
                t
              );
            }
          ),
          S(
            t.every(function (t) {
              return T(t);
            }),
            function () {
              return (
                "All values in axis param must be integers but got axis " + t
              );
            }
          ),
          t.map(function (t) {
            return t < 0 ? n + t : t;
          })
        );
      }
      function z(t, e) {
        for (
          var n = [],
            r = [],
            i = null != e && Array.isArray(e) && 0 === e.length,
            a = null == e || i ? null : P(e, t).sort(),
            o = 0,
            s = 0;
          s < t.length;
          ++s
        ) {
          if (null != a) {
            if (a[o] === s && 1 !== t[s])
              throw new Error(
                "Can't squeeze axis " +
                  s +
                  " since its dim '" +
                  t[s] +
                  "' is not 1"
              );
            (null == a[o] || a[o] > s) &&
              1 === t[s] &&
              (n.push(t[s]), r.push(s)),
              a[o] <= s && o++;
          }
          1 !== t[s] && (n.push(t[s]), r.push(s));
        }
        return { newShape: n, keptDims: r };
      }
      function L(t, e) {
        var n = null;
        if (null == t || "float32" === t) n = new Float32Array(e);
        else if ("int32" === t) n = new Int32Array(e);
        else {
          if ("bool" !== t) throw new Error("Unknown data type " + t);
          n = new Uint8Array(e);
        }
        return n;
      }
      function B(t, e) {
        var n = null;
        if (null == t || "float32" === t) n = new Float32Array(e);
        else if ("int32" === t) n = new Int32Array(e);
        else if ("bool" === t) n = new Uint8Array(e);
        else {
          if ("string" !== t) throw new Error("Unknown data type " + t);
          n = new Array(e);
        }
        return n;
      }
      function W(t, e) {
        for (var n = 0; n < t.length; n++) {
          var r = t[n];
          if (isNaN(r) || !isFinite(r))
            throw Error(
              "A tensor of type " + e + " being uploaded contains " + r + "."
            );
        }
      }
      function U(t) {
        return (
          "bool" === t ||
          "complex64" === t ||
          "float32" === t ||
          "int32" === t ||
          "string" === t
        );
      }
      function V(t, e) {
        return !(
          "complex64" === e ||
          ("float32" === e && "complex64" !== t) ||
          ("int32" === e && "float32" !== t && "complex64" !== t) ||
          ("bool" === e && "bool" === t)
        );
      }
      function G(t) {
        return (
          t instanceof Float32Array ||
          t instanceof Int32Array ||
          t instanceof Uint8Array
        );
      }
      function H(t) {
        if ("float32" === t || "int32" === t) return 4;
        if ("complex64" === t) return 8;
        if ("bool" === t) return 1;
        throw new Error("Unknown dtype " + t);
      }
      function q(t) {
        if (null == t) return 0;
        var e = 0;
        return (
          t.forEach(function (t) {
            return (e += t.length);
          }),
          e
        );
      }
      function K(t) {
        return "string" == typeof t || t instanceof String;
      }
      function Z(t) {
        return "boolean" == typeof t;
      }
      function X(t) {
        return "number" == typeof t;
      }
      function Y(t) {
        return Array.isArray(t)
          ? Y(t[0])
          : t instanceof Float32Array
          ? "float32"
          : t instanceof Int32Array || t instanceof Uint8Array
          ? "int32"
          : X(t)
          ? "float32"
          : K(t)
          ? "string"
          : Z(t)
          ? "bool"
          : "float32";
      }
      function J(t) {
        return !!(t && t.constructor && t.call && t.apply);
      }
      function $(t, e) {
        for (var n = e; n < t; ++n) if (t % n == 0) return n;
        return t;
      }
      function Q(t) {
        var e = t.length;
        if (e < 2) return [];
        var n = new Array(e - 1);
        n[e - 2] = t[e - 1];
        for (var r = e - 3; r >= 0; --r) n[r] = n[r + 1] * t[r + 1];
        return n;
      }
      function tt(t, e, n) {
        if ("string" === e)
          throw new Error("Cannot convert a string[] to a TypedArray");
        if (
          (Array.isArray(t) && (t = k(t)),
          n && W(t, e),
          (function (t, e) {
            return (
              (t instanceof Float32Array && "float32" === e) ||
              (t instanceof Int32Array && "int32" === e) ||
              (t instanceof Uint8Array && "bool" === e)
            );
          })(t, e))
        )
          return t;
        if (null == e || "float32" === e || "complex64" === e)
          return new Float32Array(t);
        if ("int32" === e) return new Int32Array(t);
        if ("bool" === e) {
          for (var r = new Uint8Array(t.length), i = 0; i < r.length; ++i)
            0 !== Math.round(t[i]) && (r[i] = 1);
          return r;
        }
        throw new Error("Unknown data type " + e);
      }
      function et(t, e) {
        if (0 === t.length) return e[0];
        var n = t.reduce(function (t, e) {
          return t * e;
        });
        if (0 === n) return [];
        if (n !== e.length)
          throw new Error("[" + t + "] does not match the input size.");
        return (function t(e, n, r) {
          var i = new Array();
          if (1 === n.length)
            for (var a = n[0], o = 0; o < a; o++) i[o] = r[e + o];
          else {
            a = n[0];
            var s = n.slice(1),
              u = s.reduce(function (t, e) {
                return t * e;
              });
            for (o = 0; o < a; o++) i[o] = t(e + o * u, s, r);
          }
          return i;
        })(0, t, e);
      }
      function nt(t, e) {
        for (var n = rt(t, e), r = 0; r < n.length; r++) n[r] = 1;
        return n;
      }
      function rt(t, e) {
        if (null == e || "float32" === e || "complex64" === e)
          return new Float32Array(t);
        if ("int32" === e) return new Int32Array(t);
        if ("bool" === e) return new Uint8Array(t);
        throw new Error("Unknown data type " + e);
      }
      function it() {
        return h().platform.now();
      }
      function at(t) {
        t.forEach(function (e) {
          S(Number.isInteger(e) && e >= 0, function () {
            return (
              "Tensor must have a shape comprised of positive integers but got shape [" +
              t +
              "]."
            );
          });
        });
      }
      function ot(t, e) {
        return (
          void 0 === e && (e = "utf-8"),
          (e = e || "utf-8"),
          h().platform.encode(t, e)
        );
      }
      function st(t, e) {
        return (
          void 0 === e && (e = "utf-8"),
          (e = e || "utf-8"),
          h().platform.decode(t, e)
        );
      }
      function ut(t, e, n) {
        if (0 === e) return 0;
        if (1 === e) return t[0];
        for (var r = t[t.length - 1], i = 0; i < t.length - 1; ++i)
          r += n[i] * t[i];
        return r;
      }
      function ct(t, e, n) {
        if (0 === e) return [];
        if (1 === e) return [t];
        for (var r = new Array(e), i = 0; i < r.length - 1; ++i)
          (r[i] = Math.floor(t / n[i])), (t -= r[i] * n[i]);
        return (r[r.length - 1] = t), r;
      }
      var lt = Object.freeze({
          shuffle: x,
          clamp: C,
          nearestLargerEven: O,
          sum: E,
          randUniform: function (t, e) {
            var n = Math.random();
            return e * n + (1 - n) * t;
          },
          distSquared: function (t, e) {
            for (var n = 0, r = 0; r < t.length; r++) {
              var i = Number(t[r]) - Number(e[r]);
              n += i * i;
            }
            return n;
          },
          assert: S,
          assertShapesMatch: N,
          assertNonNull: I,
          flatten: k,
          sizeFromShape: _,
          isScalarShape: function (t) {
            return 0 === t.length;
          },
          arraysEqual: A,
          isInt: T,
          tanh: R,
          sizeToSquarishShape: D,
          createShuffledIndices: function (t) {
            for (var e = new Uint32Array(t), n = 0; n < t; ++n) e[n] = n;
            return x(e), e;
          },
          rightPad: F,
          repeatedTry: M,
          inferFromImplicitShape: j,
          parseAxisParam: P,
          squeezeShape: z,
          getTypedArrayFromDType: L,
          getArrayFromDType: B,
          checkConversionForErrors: W,
          isValidDtype: U,
          hasEncodingLoss: V,
          isTypedArray: G,
          bytesPerElement: H,
          bytesFromStringArray: q,
          isString: K,
          isBoolean: Z,
          isNumber: X,
          inferDtype: Y,
          isFunction: J,
          nearestDivisor: $,
          computeStrides: Q,
          toTypedArray: tt,
          toNestedArray: et,
          makeOnesTypedArray: nt,
          makeZerosTypedArray: rt,
          now: it,
          assertNonNegativeIntegerDimensions: at,
          fetch: function (t, e) {
            return h().platform.fetch(t, e);
          },
          encodeString: ot,
          decodeString: st,
          locToIndex: ut,
          indexToLoc: ct,
        }),
        pt = (function () {
          function t(t, e) {
            (this.backendTimer = t),
              (this.logger = e),
              null == e && (this.logger = new ht());
          }
          return (
            (t.prototype.profileKernel = function (t, e, n) {
              var r,
                i = this,
                a = this.backendTimer.time(function () {
                  r = n();
                });
              return (
                r.forEach(function (n) {
                  n.data().then(function (r) {
                    !(function (t, e, n) {
                      if ("float32" !== e) return !1;
                      for (var r = 0; r < t.length; r++) {
                        var i = t[r];
                        if (isNaN(i) || !isFinite(i))
                          return (
                            console.warn(
                              "Found " + i + " in the result of '" + n + "'"
                            ),
                            !0
                          );
                      }
                    })(r, n.dtype, t),
                      a.then(function (a) {
                        var o = "";
                        null != a.getExtraProfileInfo &&
                          (o = a.getExtraProfileInfo()),
                          i.logger.logKernelProfile(t, n, r, a.kernelMs, e, o);
                      });
                  });
                }),
                r
              );
            }),
            t
          );
        })(),
        ht = (function () {
          function t() {}
          return (
            (t.prototype.logKernelProfile = function (t, e, n, r, i, a) {
              var o = "number" == typeof r ? F(r + "ms", 9) : r.error,
                s = F(t, 25),
                u = e.rank,
                c = e.size,
                l = F(e.shape.toString(), 14),
                p = "";
              for (var h in i) {
                var f = i[h].shape || e.shape,
                  d = f.length;
                p += h + ": " + d + "D " + (d > 0 ? f : "") + " ";
              }
              console.log(
                "%c" +
                  s +
                  "\t%c" +
                  o +
                  "\t%c" +
                  u +
                  "D " +
                  l +
                  "\t%c" +
                  c +
                  "\t%c" +
                  p +
                  "\t%c" +
                  a,
                "font-weight:bold",
                "color:red",
                "color:blue",
                "color: orange",
                "color: green",
                "color: steelblue"
              );
            }),
            t
          );
        })();
      function ft(t, e, n) {
        return F(
          Array.isArray(t)
            ? parseFloat(t[0].toFixed(7)) +
                " + " +
                parseFloat(t[1].toFixed(7)) +
                "j"
            : K(t)
            ? "'" + t + "'"
            : "bool" === n
            ? dt(t)
            : parseFloat(t.toFixed(7)).toString(),
          e
        );
      }
      function dt(t) {
        return 0 === t ? "false" : "true";
      }
      function mt(t) {
        for (var e = [], n = 0; n < t.length; n += 2) e.push([t[n], t[n + 1]]);
        return e;
      }
      var vt = (function () {
          function t(t, e, n) {
            var r = this;
            if (
              ((this.dtype = e),
              (this.shape = t.slice()),
              (this.size = _(t)),
              null != n)
            ) {
              var i = n.length;
              S(i === this.size, function () {
                return (
                  "Length of values '" +
                  i +
                  "' does not match the size inferred by the shape '" +
                  r.size +
                  "'."
                );
              });
            }
            if ("complex64" === e)
              throw new Error(
                "complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag)."
              );
            (this.values = n || B(e, this.size)), (this.strides = Q(t));
          }
          return (
            (t.prototype.set = function (t) {
              for (var e = this, n = [], r = 1; r < arguments.length; r++)
                n[r - 1] = arguments[r];
              0 === n.length && (n = [0]),
                S(n.length === this.rank, function () {
                  return (
                    "The number of provided coordinates (" +
                    n.length +
                    ") must match the rank (" +
                    e.rank +
                    ")"
                  );
                });
              var i = this.locToIndex(n);
              this.values[i] = t;
            }),
            (t.prototype.get = function () {
              for (var t = [], e = 0; e < arguments.length; e++)
                t[e] = arguments[e];
              0 === t.length && (t = [0]);
              for (var n = 0, r = 0, i = t; r < i.length; r++) {
                var a = i[r];
                if (a < 0 || a >= this.shape[n]) {
                  var o =
                    "Requested out of range element at " +
                    t +
                    ".   Buffer shape=" +
                    this.shape;
                  throw new Error(o);
                }
                n++;
              }
              for (var s = t[t.length - 1], u = 0; u < t.length - 1; ++u)
                s += this.strides[u] * t[u];
              return this.values[s];
            }),
            (t.prototype.locToIndex = function (t) {
              if (0 === this.rank) return 0;
              if (1 === this.rank) return t[0];
              for (var e = t[t.length - 1], n = 0; n < t.length - 1; ++n)
                e += this.strides[n] * t[n];
              return e;
            }),
            (t.prototype.indexToLoc = function (t) {
              if (0 === this.rank) return [];
              if (1 === this.rank) return [t];
              for (
                var e = new Array(this.shape.length), n = 0;
                n < e.length - 1;
                ++n
              )
                (e[n] = Math.floor(t / this.strides[n])),
                  (t -= e[n] * this.strides[n]);
              return (e[e.length - 1] = t), e;
            }),
            Object.defineProperty(t.prototype, "rank", {
              get: function () {
                return this.shape.length;
              },
              enumerable: !0,
              configurable: !0,
            }),
            (t.prototype.toTensor = function () {
              return gt().makeTensor(this.values, this.shape, this.dtype);
            }),
            t
          );
        })(),
        gt = null,
        yt = null,
        bt = null,
        wt = (function () {
          function t(t, e, n, r) {
            (this.kept = !1),
              (this.isDisposedInternal = !1),
              (this.shape = t.slice()),
              (this.dtype = e || "float32"),
              (this.size = _(t)),
              (this.strides = Q(t)),
              (this.dataId = n),
              (this.id = r),
              (this.rankType = this.rank < 5 ? this.rank.toString() : "higher");
          }
          return (
            (t.prototype.flatten = function () {
              return this.throwIfDisposed(), this.as1D();
            }),
            (t.prototype.asScalar = function () {
              return (
                this.throwIfDisposed(),
                S(1 === this.size, function () {
                  return "The array must have only 1 element.";
                }),
                this.reshape([])
              );
            }),
            (t.prototype.as1D = function () {
              return this.throwIfDisposed(), this.reshape([this.size]);
            }),
            (t.prototype.as2D = function (t, e) {
              return this.throwIfDisposed(), this.reshape([t, e]);
            }),
            (t.prototype.as3D = function (t, e, n) {
              return this.throwIfDisposed(), this.reshape([t, e, n]);
            }),
            (t.prototype.as4D = function (t, e, n, r) {
              return this.throwIfDisposed(), this.reshape([t, e, n, r]);
            }),
            (t.prototype.as5D = function (t, e, n, r, i) {
              return this.throwIfDisposed(), this.reshape([t, e, n, r, i]);
            }),
            (t.prototype.asType = function (t) {
              return this.throwIfDisposed(), yt.cast(this, t);
            }),
            Object.defineProperty(t.prototype, "rank", {
              get: function () {
                return this.shape.length;
              },
              enumerable: !0,
              configurable: !0,
            }),
            (t.prototype.buffer = function () {
              return u(this, void 0, void 0, function () {
                var t;
                return c(this, function (e) {
                  switch (e.label) {
                    case 0:
                      return [4, this.data()];
                    case 1:
                      return (
                        (t = e.sent()),
                        [2, yt.buffer(this.shape, this.dtype, t)]
                      );
                  }
                });
              });
            }),
            (t.prototype.bufferSync = function () {
              return yt.buffer(this.shape, this.dtype, this.dataSync());
            }),
            (t.prototype.array = function () {
              return u(this, void 0, void 0, function () {
                var t;
                return c(this, function (e) {
                  switch (e.label) {
                    case 0:
                      return [4, this.data()];
                    case 1:
                      return (t = e.sent()), [2, et(this.shape, t)];
                  }
                });
              });
            }),
            (t.prototype.arraySync = function () {
              return et(this.shape, this.dataSync());
            }),
            (t.prototype.data = function () {
              return u(this, void 0, void 0, function () {
                var t, e;
                return c(this, function (n) {
                  switch (n.label) {
                    case 0:
                      return (
                        this.throwIfDisposed(),
                        (t = gt().read(this.dataId)),
                        "string" !== this.dtype ? [3, 2] : [4, t]
                      );
                    case 1:
                      e = n.sent();
                      try {
                        return [
                          2,
                          e.map(function (t) {
                            return st(t);
                          }),
                        ];
                      } catch (t) {
                        throw new Error(
                          "Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes()."
                        );
                      }
                      n.label = 2;
                    case 2:
                      return [2, t];
                  }
                });
              });
            }),
            (t.prototype.dataSync = function () {
              this.throwIfDisposed();
              var t = gt().readSync(this.dataId);
              if ("string" === this.dtype)
                try {
                  return t.map(function (t) {
                    return st(t);
                  });
                } catch (t) {
                  throw new Error(
                    "Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes()."
                  );
                }
              return t;
            }),
            (t.prototype.bytes = function () {
              return u(this, void 0, void 0, function () {
                var t;
                return c(this, function (e) {
                  switch (e.label) {
                    case 0:
                      return (
                        this.throwIfDisposed(), [4, gt().read(this.dataId)]
                      );
                    case 1:
                      return (
                        (t = e.sent()),
                        "string" === this.dtype
                          ? [2, t]
                          : [2, new Uint8Array(t.buffer)]
                      );
                  }
                });
              });
            }),
            (t.prototype.dispose = function () {
              this.isDisposed ||
                (gt().disposeTensor(this), (this.isDisposedInternal = !0));
            }),
            Object.defineProperty(t.prototype, "isDisposed", {
              get: function () {
                return this.isDisposedInternal;
              },
              enumerable: !0,
              configurable: !0,
            }),
            (t.prototype.throwIfDisposed = function () {
              if (this.isDisposed) throw new Error("Tensor is disposed.");
            }),
            (t.prototype.toFloat = function () {
              return this.asType("float32");
            }),
            (t.prototype.toInt = function () {
              return this.asType("int32");
            }),
            (t.prototype.toBool = function () {
              return this.asType("bool");
            }),
            (t.prototype.print = function (t) {
              return void 0 === t && (t = !1), yt.print(this, t);
            }),
            (t.prototype.reshape = function (t) {
              return this.throwIfDisposed(), yt.reshape(this, t);
            }),
            (t.prototype.reshapeAs = function (t) {
              return this.throwIfDisposed(), this.reshape(t.shape);
            }),
            (t.prototype.expandDims = function (t) {
              return void 0 === t && (t = 0), yt.expandDims(this, t);
            }),
            (t.prototype.cumsum = function (t, e, n) {
              return (
                void 0 === t && (t = 0),
                void 0 === e && (e = !1),
                void 0 === n && (n = !1),
                yt.cumsum(this, t, e, n)
              );
            }),
            (t.prototype.squeeze = function (t) {
              return this.throwIfDisposed(), yt.squeeze(this, t);
            }),
            (t.prototype.clone = function () {
              return this.throwIfDisposed(), yt.clone(this);
            }),
            (t.prototype.oneHot = function (t, e, n) {
              return this.throwIfDisposed(), yt.oneHot(this, t, e, n);
            }),
            (t.prototype.toString = function (t) {
              return (
                void 0 === t && (t = !1),
                (function (t, e, n, r) {
                  var i = Q(e),
                    a = (function (t, e, n, r) {
                      var i = _(e),
                        a = r[r.length - 1],
                        o = new Array(a).fill(0),
                        s = e.length,
                        u = "complex64" === n ? mt(t) : t;
                      if (s > 1)
                        for (var c = 0; c < i / a; c++)
                          for (var l = c * a, p = 0; p < a; p++)
                            o[p] = Math.max(o[p], ft(u[l + p], 0, n).length);
                      return o;
                    })(t, e, n, i),
                    o = e.length,
                    s = (function t(e, n, r, i, a, o) {
                      void 0 === o && (o = !0);
                      var s = "complex64" === r ? 2 : 1,
                        u = n[0],
                        c = n.length;
                      if (0 === c)
                        return "complex64" === r
                          ? [ft(mt(e)[0], 0, r)]
                          : "bool" === r
                          ? [dt(e[0])]
                          : [e[0].toString()];
                      if (1 === c) {
                        if (u > 20) {
                          var l = 3 * s,
                            p = Array.from(e.slice(0, l)),
                            h = Array.from(e.slice((u - 3) * s, u * s));
                          return (
                            "complex64" === r && ((p = mt(p)), (h = mt(h))),
                            [
                              "[" +
                                p
                                  .map(function (t, e) {
                                    return ft(t, a[e], r);
                                  })
                                  .join(", ") +
                                ", ..., " +
                                h
                                  .map(function (t, e) {
                                    return ft(t, a[u - 3 + e], r);
                                  })
                                  .join(", ") +
                                "]",
                            ]
                          );
                        }
                        return [
                          "[" +
                            ("complex64" === r ? mt(e) : Array.from(e))
                              .map(function (t, e) {
                                return ft(t, a[e], r);
                              })
                              .join(", ") +
                            "]",
                        ];
                      }
                      var f = n.slice(1),
                        d = i.slice(1),
                        m = i[0] * s,
                        v = [];
                      if (u > 20) {
                        for (var g = 0; g < 3; g++) {
                          var y = (b = g * m) + m;
                          v.push.apply(v, t(e.slice(b, y), f, r, d, a, !1));
                        }
                        for (v.push("..."), g = u - 3; g < u; g++)
                          (y = (b = g * m) + m),
                            v.push.apply(
                              v,
                              t(e.slice(b, y), f, r, d, a, g === u - 1)
                            );
                      } else
                        for (g = 0; g < u; g++) {
                          var b;
                          (y = (b = g * m) + m),
                            v.push.apply(
                              v,
                              t(e.slice(b, y), f, r, d, a, g === u - 1)
                            );
                        }
                      var w = 2 === c ? "," : "";
                      for (v[0] = "[" + v[0] + w, g = 1; g < v.length - 1; g++)
                        v[g] = " " + v[g] + w;
                      var x = ",\n";
                      for (g = 2; g < c; g++) x += "\n";
                      return (
                        (v[v.length - 1] =
                          " " + v[v.length - 1] + "]" + (o ? "" : x)),
                        v
                      );
                    })(t, e, n, i, a),
                    u = ["Tensor"];
                  return (
                    r &&
                      (u.push("  dtype: " + n),
                      u.push("  rank: " + o),
                      u.push("  shape: [" + e + "]"),
                      u.push("  values:")),
                    u.push(
                      s
                        .map(function (t) {
                          return "    " + t;
                        })
                        .join("\n")
                    ),
                    u.join("\n")
                  );
                })(this.dataSync(), this.shape, this.dtype, t)
              );
            }),
            (t.prototype.tile = function (t) {
              return this.throwIfDisposed(), yt.tile(this, t);
            }),
            (t.prototype.gather = function (t, e) {
              return (
                void 0 === e && (e = 0),
                this.throwIfDisposed(),
                yt.gather(this, t, e)
              );
            }),
            (t.prototype.matMul = function (t, e, n) {
              return (
                void 0 === e && (e = !1),
                void 0 === n && (n = !1),
                this.throwIfDisposed(),
                yt.matMul(this, t, e, n)
              );
            }),
            (t.prototype.dot = function (t) {
              return this.throwIfDisposed(), yt.dot(this, t);
            }),
            (t.prototype.norm = function (t, e, n) {
              return (
                void 0 === t && (t = "euclidean"),
                void 0 === e && (e = null),
                void 0 === n && (n = !1),
                this.throwIfDisposed(),
                yt.norm(this, t, e, n)
              );
            }),
            (t.prototype.slice = function (t, e) {
              return this.throwIfDisposed(), yt.slice(this, t, e);
            }),
            (t.prototype.reverse = function (t) {
              return this.throwIfDisposed(), yt.reverse(this, t);
            }),
            (t.prototype.concat = function (e, n) {
              return (
                void 0 === n && (n = 0),
                this.throwIfDisposed(),
                e instanceof t && (e = [e]),
                yt.concat([this].concat(e), n)
              );
            }),
            (t.prototype.split = function (t, e) {
              return (
                void 0 === e && (e = 0),
                this.throwIfDisposed(),
                yt.split(this, t, e)
              );
            }),
            (t.prototype.stack = function (t, e) {
              return void 0 === e && (e = 0), yt.stack([this, t], e);
            }),
            (t.prototype.unstack = function (t) {
              return void 0 === t && (t = 0), yt.unstack(this, t);
            }),
            (t.prototype.pad = function (t, e) {
              return void 0 === e && (e = 0), yt.pad(this, t, e);
            }),
            (t.prototype.batchNormalization = function (t, e, n, r, i) {
              return (
                void 0 === n && (n = 0.001),
                bt(
                  "tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"
                ),
                this.batchNorm(t, e, i, r, n)
              );
            }),
            (t.prototype.batchNorm = function (t, e, n, r, i) {
              return (
                void 0 === i && (i = 0.001),
                this.throwIfDisposed(),
                yt.batchNorm(this, t, e, n, r, i)
              );
            }),
            (t.prototype.all = function (t, e) {
              return (
                void 0 === t && (t = null),
                void 0 === e && (e = !1),
                this.throwIfDisposed(),
                yt.all(this, t, e)
              );
            }),
            (t.prototype.any = function (t, e) {
              return (
                void 0 === t && (t = null),
                void 0 === e && (e = !1),
                this.throwIfDisposed(),
                yt.any(this, t, e)
              );
            }),
            (t.prototype.logSumExp = function (t, e) {
              return (
                void 0 === t && (t = null),
                void 0 === e && (e = !1),
                this.throwIfDisposed(),
                yt.logSumExp(this, t, e)
              );
            }),
            (t.prototype.sum = function (t, e) {
              return (
                void 0 === t && (t = null),
                void 0 === e && (e = !1),
                this.throwIfDisposed(),
                yt.sum(this, t, e)
              );
            }),
            (t.prototype.prod = function (t, e) {
              return (
                void 0 === t && (t = null),
                void 0 === e && (e = !1),
                this.throwIfDisposed(),
                yt.prod(this, t, e)
              );
            }),
            (t.prototype.mean = function (t, e) {
              return (
                void 0 === t && (t = null),
                void 0 === e && (e = !1),
                this.throwIfDisposed(),
                yt.mean(this, t, e)
              );
            }),
            (t.prototype.min = function (t, e) {
              return (
                void 0 === t && (t = null),
                void 0 === e && (e = !1),
                this.throwIfDisposed(),
                yt.min(this, t, e)
              );
            }),
            (t.prototype.max = function (t, e) {
              return (
                void 0 === t && (t = null),
                void 0 === e && (e = !1),
                this.throwIfDisposed(),
                yt.max(this, t, e)
              );
            }),
            (t.prototype.argMin = function (t) {
              return (
                void 0 === t && (t = null),
                this.throwIfDisposed(),
                yt.argMin(this, t)
              );
            }),
            (t.prototype.argMax = function (t) {
              return (
                void 0 === t && (t = null),
                this.throwIfDisposed(),
                yt.argMax(this, t)
              );
            }),
            (t.prototype.cast = function (t) {
              return this.throwIfDisposed(), yt.cast(this, t);
            }),
            (t.prototype.add = function (t) {
              return this.throwIfDisposed(), yt.add(this, t);
            }),
            (t.prototype.addStrict = function (t) {
              return this.throwIfDisposed(), yt.addStrict(this, t);
            }),
            (t.prototype.atan2 = function (t) {
              return this.throwIfDisposed(), yt.atan2(this, t);
            }),
            (t.prototype.sub = function (t) {
              return this.throwIfDisposed(), yt.sub(this, t);
            }),
            (t.prototype.subStrict = function (t) {
              return this.throwIfDisposed(), yt.subStrict(this, t);
            }),
            (t.prototype.pow = function (t) {
              return this.throwIfDisposed(), yt.pow(this, t);
            }),
            (t.prototype.powStrict = function (t) {
              return this.throwIfDisposed(), yt.powStrict(this, t);
            }),
            (t.prototype.mul = function (t) {
              return this.throwIfDisposed(), yt.mul(this, t);
            }),
            (t.prototype.mulStrict = function (t) {
              return this.throwIfDisposed(), yt.mulStrict(this, t);
            }),
            (t.prototype.div = function (t) {
              return this.throwIfDisposed(), yt.div(this, t);
            }),
            (t.prototype.divNoNan = function (t) {
              return this.throwIfDisposed(), yt.divNoNan(this, t);
            }),
            (t.prototype.floorDiv = function (t) {
              return this.throwIfDisposed(), yt.floorDiv(this, t);
            }),
            (t.prototype.divStrict = function (t) {
              return this.throwIfDisposed(), yt.divStrict(this, t);
            }),
            (t.prototype.minimum = function (t) {
              return this.throwIfDisposed(), yt.minimum(this, t);
            }),
            (t.prototype.minimumStrict = function (t) {
              return this.throwIfDisposed(), yt.minimumStrict(this, t);
            }),
            (t.prototype.maximum = function (t) {
              return this.throwIfDisposed(), yt.maximum(this, t);
            }),
            (t.prototype.maximumStrict = function (t) {
              return this.throwIfDisposed(), yt.maximumStrict(this, t);
            }),
            (t.prototype.mod = function (t) {
              return this.throwIfDisposed(), yt.mod(this, t);
            }),
            (t.prototype.modStrict = function (t) {
              return this.throwIfDisposed(), yt.modStrict(this, t);
            }),
            (t.prototype.squaredDifferenceStrict = function (t) {
              return (
                this.throwIfDisposed(), yt.squaredDifferenceStrict(this, t)
              );
            }),
            (t.prototype.transpose = function (t) {
              return this.throwIfDisposed(), yt.transpose(this, t);
            }),
            (t.prototype.notEqual = function (t) {
              return this.throwIfDisposed(), yt.notEqual(this, t);
            }),
            (t.prototype.notEqualStrict = function (t) {
              return this.throwIfDisposed(), yt.notEqualStrict(this, t);
            }),
            (t.prototype.less = function (t) {
              return this.throwIfDisposed(), yt.less(this, t);
            }),
            (t.prototype.lessStrict = function (t) {
              return this.throwIfDisposed(), yt.lessStrict(this, t);
            }),
            (t.prototype.equal = function (t) {
              return this.throwIfDisposed(), yt.equal(this, t);
            }),
            (t.prototype.equalStrict = function (t) {
              return this.throwIfDisposed(), yt.equalStrict(this, t);
            }),
            (t.prototype.lessEqual = function (t) {
              return this.throwIfDisposed(), yt.lessEqual(this, t);
            }),
            (t.prototype.lessEqualStrict = function (t) {
              return this.throwIfDisposed(), yt.lessEqualStrict(this, t);
            }),
            (t.prototype.greater = function (t) {
              return this.throwIfDisposed(), yt.greater(this, t);
            }),
            (t.prototype.greaterStrict = function (t) {
              return this.throwIfDisposed(), yt.greaterStrict(this, t);
            }),
            (t.prototype.greaterEqual = function (t) {
              return this.throwIfDisposed(), yt.greaterEqual(this, t);
            }),
            (t.prototype.greaterEqualStrict = function (t) {
              return this.throwIfDisposed(), yt.greaterEqualStrict(this, t);
            }),
            (t.prototype.logicalAnd = function (t) {
              return this.throwIfDisposed(), yt.logicalAnd(this, t);
            }),
            (t.prototype.logicalOr = function (t) {
              return this.throwIfDisposed(), yt.logicalOr(this, t);
            }),
            (t.prototype.logicalNot = function () {
              return this.throwIfDisposed(), yt.logicalNot(this);
            }),
            (t.prototype.logicalXor = function (t) {
              return this.throwIfDisposed(), yt.logicalXor(this, t);
            }),
            (t.prototype.where = function (t, e) {
              return this.throwIfDisposed(), yt.where(t, this, e);
            }),
            (t.prototype.neg = function () {
              return this.throwIfDisposed(), yt.neg(this);
            }),
            (t.prototype.ceil = function () {
              return this.throwIfDisposed(), yt.ceil(this);
            }),
            (t.prototype.floor = function () {
              return this.throwIfDisposed(), yt.floor(this);
            }),
            (t.prototype.sign = function () {
              return this.throwIfDisposed(), yt.sign(this);
            }),
            (t.prototype.isNaN = function () {
              return this.throwIfDisposed(), yt.isNaN(this);
            }),
            (t.prototype.isInf = function () {
              return this.throwIfDisposed(), yt.isInf(this);
            }),
            (t.prototype.isFinite = function () {
              return this.throwIfDisposed(), yt.isFinite(this);
            }),
            (t.prototype.exp = function () {
              return this.throwIfDisposed(), yt.exp(this);
            }),
            (t.prototype.expm1 = function () {
              return this.throwIfDisposed(), yt.expm1(this);
            }),
            (t.prototype.log = function () {
              return this.throwIfDisposed(), yt.log(this);
            }),
            (t.prototype.log1p = function () {
              return this.throwIfDisposed(), yt.log1p(this);
            }),
            (t.prototype.sqrt = function () {
              return this.throwIfDisposed(), yt.sqrt(this);
            }),
            (t.prototype.rsqrt = function () {
              return this.throwIfDisposed(), yt.rsqrt(this);
            }),
            (t.prototype.square = function () {
              return this.throwIfDisposed(), yt.square(this);
            }),
            (t.prototype.reciprocal = function () {
              return this.throwIfDisposed(), yt.reciprocal(this);
            }),
            (t.prototype.abs = function () {
              return this.throwIfDisposed(), yt.abs(this);
            }),
            (t.prototype.clipByValue = function (t, e) {
              return this.throwIfDisposed(), yt.clipByValue(this, t, e);
            }),
            (t.prototype.relu = function () {
              return this.throwIfDisposed(), yt.relu(this);
            }),
            (t.prototype.relu6 = function () {
              return this.throwIfDisposed(), yt.relu6(this);
            }),
            (t.prototype.elu = function () {
              return this.throwIfDisposed(), yt.elu(this);
            }),
            (t.prototype.selu = function () {
              return this.throwIfDisposed(), yt.selu(this);
            }),
            (t.prototype.leakyRelu = function (t) {
              return (
                void 0 === t && (t = 0.2),
                this.throwIfDisposed(),
                yt.leakyRelu(this, t)
              );
            }),
            (t.prototype.prelu = function (t) {
              return this.throwIfDisposed(), yt.prelu(this, t);
            }),
            (t.prototype.sigmoid = function () {
              return this.throwIfDisposed(), yt.sigmoid(this);
            }),
            (t.prototype.logSigmoid = function () {
              return this.throwIfDisposed(), yt.logSigmoid(this);
            }),
            (t.prototype.softplus = function () {
              return this.throwIfDisposed(), yt.softplus(this);
            }),
            (t.prototype.zerosLike = function () {
              return this.throwIfDisposed(), yt.zerosLike(this);
            }),
            (t.prototype.onesLike = function () {
              return this.throwIfDisposed(), yt.onesLike(this);
            }),
            (t.prototype.sin = function () {
              return this.throwIfDisposed(), yt.sin(this);
            }),
            (t.prototype.cos = function () {
              return this.throwIfDisposed(), yt.cos(this);
            }),
            (t.prototype.tan = function () {
              return this.throwIfDisposed(), yt.tan(this);
            }),
            (t.prototype.asin = function () {
              return this.throwIfDisposed(), yt.asin(this);
            }),
            (t.prototype.acos = function () {
              return this.throwIfDisposed(), yt.acos(this);
            }),
            (t.prototype.atan = function () {
              return this.throwIfDisposed(), yt.atan(this);
            }),
            (t.prototype.sinh = function () {
              return this.throwIfDisposed(), yt.sinh(this);
            }),
            (t.prototype.cosh = function () {
              return this.throwIfDisposed(), yt.cosh(this);
            }),
            (t.prototype.tanh = function () {
              return this.throwIfDisposed(), yt.tanh(this);
            }),
            (t.prototype.asinh = function () {
              return this.throwIfDisposed(), yt.asinh(this);
            }),
            (t.prototype.acosh = function () {
              return this.throwIfDisposed(), yt.acosh(this);
            }),
            (t.prototype.atanh = function () {
              return this.throwIfDisposed(), yt.atanh(this);
            }),
            (t.prototype.erf = function () {
              return this.throwIfDisposed(), yt.erf(this);
            }),
            (t.prototype.round = function () {
              return this.throwIfDisposed(), yt.round(this);
            }),
            (t.prototype.step = function (t) {
              return (
                void 0 === t && (t = 0),
                this.throwIfDisposed(),
                yt.step(this, t)
              );
            }),
            (t.prototype.softmax = function (t) {
              return (
                void 0 === t && (t = -1),
                this.throwIfDisposed(),
                yt.softmax(this, t)
              );
            }),
            (t.prototype.logSoftmax = function (t) {
              return (
                void 0 === t && (t = -1),
                this.throwIfDisposed(),
                yt.logSoftmax(this, t)
              );
            }),
            (t.prototype.resizeBilinear = function (t, e) {
              return (
                void 0 === e && (e = !1),
                this.throwIfDisposed(),
                yt.image.resizeBilinear(this, t, e)
              );
            }),
            (t.prototype.resizeNearestNeighbor = function (t, e) {
              return (
                void 0 === e && (e = !1),
                this.throwIfDisposed(),
                yt.image.resizeNearestNeighbor(this, t, e)
              );
            }),
            (t.prototype.conv1d = function (t, e, n, r, i, a) {
              return (
                void 0 === r && (r = "NWC"),
                void 0 === i && (i = 1),
                this.throwIfDisposed(),
                yt.conv1d(this, t, e, n, r, i, a)
              );
            }),
            (t.prototype.conv2d = function (t, e, n, r, i, a) {
              return (
                void 0 === r && (r = "NHWC"),
                void 0 === i && (i = [1, 1]),
                this.throwIfDisposed(),
                yt.conv2d(this, t, e, n, r, i, a)
              );
            }),
            (t.prototype.conv2dTranspose = function (t, e, n, r, i) {
              return (
                this.throwIfDisposed(), yt.conv2dTranspose(this, t, e, n, r, i)
              );
            }),
            (t.prototype.depthwiseConv2D = function (t, e, n, r, i, a) {
              return (
                void 0 === r && (r = "NHWC"),
                void 0 === i && (i = [1, 1]),
                this.throwIfDisposed(),
                yt.depthwiseConv2d(this, t, e, n, r, i, a)
              );
            }),
            (t.prototype.separableConv2d = function (t, e, n, r, i, a) {
              return (
                void 0 === i && (i = [1, 1]),
                void 0 === a && (a = "NHWC"),
                this.throwIfDisposed(),
                yt.separableConv2d(this, t, e, n, r, i, a)
              );
            }),
            (t.prototype.avgPool = function (t, e, n, r) {
              return this.throwIfDisposed(), yt.avgPool(this, t, e, n, r);
            }),
            (t.prototype.maxPool = function (t, e, n, r) {
              return this.throwIfDisposed(), yt.maxPool(this, t, e, n, r);
            }),
            (t.prototype.localResponseNormalization = function (t, e, n, r) {
              return (
                void 0 === t && (t = 5),
                void 0 === e && (e = 1),
                void 0 === n && (n = 1),
                void 0 === r && (r = 0.5),
                yt.localResponseNormalization(this, t, e, n, r)
              );
            }),
            (t.prototype.pool = function (t, e, n, r, i) {
              return this.throwIfDisposed(), yt.pool(this, t, e, n, r, i);
            }),
            (t.prototype.variable = function (t, e, n) {
              return (
                void 0 === t && (t = !0),
                this.throwIfDisposed(),
                gt().makeVariable(this, t, e, n)
              );
            }),
            (t.prototype.unsortedSegmentSum = function (t, e) {
              return this.throwIfDisposed(), yt.unsortedSegmentSum(this, t, e);
            }),
            (t.prototype.batchToSpaceND = function (t, e) {
              return this.throwIfDisposed(), yt.batchToSpaceND(this, t, e);
            }),
            (t.prototype.spaceToBatchND = function (t, e) {
              return this.throwIfDisposed(), yt.spaceToBatchND(this, t, e);
            }),
            (t.prototype.topk = function (t, e) {
              return (
                void 0 === t && (t = 1),
                void 0 === e && (e = !0),
                this.throwIfDisposed(),
                yt.topk(this, t, e)
              );
            }),
            (t.prototype.stridedSlice = function (t, e, n, r, i, a, o, s) {
              return (
                void 0 === r && (r = 0),
                void 0 === i && (i = 0),
                void 0 === a && (a = 0),
                void 0 === o && (o = 0),
                void 0 === s && (s = 0),
                this.throwIfDisposed(),
                yt.stridedSlice(this, t, e, n, r, i, a, o, s)
              );
            }),
            (t.prototype.depthToSpace = function (t, e) {
              return this.throwIfDisposed(), yt.depthToSpace(this, t, e);
            }),
            (t.prototype.fft = function () {
              return this.throwIfDisposed(), yt.spectral.fft(this);
            }),
            (t.prototype.ifft = function () {
              return this.throwIfDisposed(), yt.spectral.ifft(this);
            }),
            (t.prototype.rfft = function () {
              return this.throwIfDisposed(), yt.spectral.rfft(this);
            }),
            (t.prototype.irfft = function () {
              return this.throwIfDisposed(), yt.spectral.irfft(this);
            }),
            t
          );
        })();
      Object.defineProperty(wt, Symbol.hasInstance, {
        value: function (t) {
          return !!t && null != t.dataId && null != t.shape && null != t.dtype;
        },
      });
      var xt,
        Ct,
        Ot,
        Et,
        St,
        Nt = (function (t) {
          function e(e, n, r, i) {
            var a = t.call(this, e.shape, e.dtype, e.dataId, i) || this;
            return (a.trainable = n), (a.name = r), a;
          }
          return (
            s(e, t),
            (e.prototype.assign = function (t) {
              if (t.dtype !== this.dtype)
                throw new Error(
                  "dtype of the new value (" +
                    t.dtype +
                    ") and previous value (" +
                    this.dtype +
                    ") must match"
                );
              if (!A(t.shape, this.shape))
                throw new Error(
                  "shape of the new value (" +
                    t.shape +
                    ") and previous value (" +
                    this.shape +
                    ") must match"
                );
              gt().disposeTensor(this),
                (this.dataId = t.dataId),
                gt().incRef(this, null);
            }),
            (e.prototype.dispose = function () {
              gt().disposeVariable(this), (this.isDisposedInternal = !0);
            }),
            e
          );
        })(wt);
      Object.defineProperty(Nt, Symbol.hasInstance, {
        value: function (t) {
          return (
            t instanceof wt && null != t.assign && t.assign instanceof Function
          );
        },
      }),
        (function (t) {
          (t.R0 = "R0"),
            (t.R1 = "R1"),
            (t.R2 = "R2"),
            (t.R3 = "R3"),
            (t.R4 = "R4"),
            (t.R5 = "R5"),
            (t.R6 = "R6");
        })(xt || (xt = {})),
        (function (t) {
          (t.float32 = "float32"),
            (t.int32 = "int32"),
            (t.bool = "int32"),
            (t.complex64 = "complex64");
        })(Ct || (Ct = {})),
        (function (t) {
          (t.float32 = "float32"),
            (t.int32 = "int32"),
            (t.bool = "bool"),
            (t.complex64 = "complex64");
        })(Ot || (Ot = {})),
        (function (t) {
          (t.float32 = "float32"),
            (t.int32 = "float32"),
            (t.bool = "float32"),
            (t.complex64 = "complex64");
        })(Et || (Et = {})),
        (function (t) {
          (t.float32 = "complex64"),
            (t.int32 = "complex64"),
            (t.bool = "complex64"),
            (t.complex64 = "complex64");
        })(St || (St = {}));
      var It = { float32: Et, int32: Ct, bool: Ot, complex64: St };
      function kt(t, e) {
        if ("string" === t || "string" === e) {
          if ("string" === t && "string" === e) return "string";
          throw new Error("Can not upcast " + t + " with " + e);
        }
        return It[t][e];
      }
      function _t(t) {
        return kt(t, "int32");
      }
      function At(t, e) {
        if (t.dtype === e.dtype) return [t, e];
        var n = kt(t.dtype, e.dtype);
        return [t.cast(n), e.cast(n)];
      }
      function Tt(t, e) {
        S(t.dtype === e.dtype, function () {
          return (
            "The dtypes of the first(" +
            t.dtype +
            ") and second(" +
            e.dtype +
            ") input must match"
          );
        });
      }
      function Rt(t) {
        var e = [];
        return (
          (function t(e, n, r) {
            if (null != e)
              if (e instanceof wt) n.push(e);
              else if (((i = e), Array.isArray(i) || "object" == typeof i)) {
                var i,
                  a = e;
                for (var o in a) {
                  var s = a[o];
                  r.has(s) || (r.add(s), t(s, n, r));
                }
              }
          })(t, e, new Set()),
          e
        );
      }
      var Dt,
        Ft = Object.freeze({
          makeTypesMatch: At,
          assertTypesMatch: Tt,
          isTensorInList: function (t, e) {
            return e.some(function (e) {
              return e.id === t.id;
            });
          },
          getTensorsInContainer: Rt,
        }),
        Mt = (function () {
          function t() {
            (this.registeredVariables = {}),
              (this.nextTapeNodeId = 0),
              (this.numBytes = 0),
              (this.numTensors = 0),
              (this.numStringTensors = 0),
              (this.numDataBuffers = 0),
              (this.gradientDepth = 0),
              (this.kernelDepth = 0),
              (this.scopeStack = []),
              (this.numDataMovesStack = []),
              (this.nextScopeId = 0),
              (this.tensorInfo = new WeakMap()),
              (this.profiling = !1),
              (this.activeProfile = {
                newBytes: 0,
                newTensors: 0,
                peakBytes: 0,
                kernels: [],
                result: null,
              });
          }
          return (
            (t.prototype.dispose = function () {
              for (var t in this.registeredVariables)
                this.registeredVariables[t].dispose();
            }),
            t
          );
        })(),
        jt = (function () {
          function t(t) {
            (this.ENV = t),
              (this.registry = {}),
              (this.registryFactory = {}),
              (this.pendingBackendInitId = 0),
              (this.state = new Mt());
          }
          return (
            (t.prototype.ready = function () {
              return u(this, void 0, void 0, function () {
                var t, e, n;
                return c(this, function (r) {
                  switch (r.label) {
                    case 0:
                      if (null != this.pendingBackendInit)
                        return [
                          2,
                          this.pendingBackendInit.then(function () {}),
                        ];
                      if (null != this.backendInstance) return [2];
                      (t = this.getSortedBackends()), (e = 0), (r.label = 1);
                    case 1:
                      return e < t.length
                        ? ((n = t[e]), [4, this.initializeBackend(n).success])
                        : [3, 5];
                    case 2:
                      return r.sent() ? [4, this.setBackend(n)] : [3, 4];
                    case 3:
                      return r.sent(), [2];
                    case 4:
                      return e++, [3, 1];
                    case 5:
                      throw new Error(
                        "Could not initialize any backends, all backend initializations failed."
                      );
                  }
                });
              });
            }),
            Object.defineProperty(t.prototype, "backend", {
              get: function () {
                if (null != this.pendingBackendInit)
                  throw new Error(
                    "Backend '" +
                      this.backendName +
                      "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods"
                  );
                if (null == this.backendInstance) {
                  var t = this.initializeBackendsAndReturnBest(),
                    e = t.name;
                  if (t.asyncInit)
                    throw new Error(
                      "The highest priority backend '" +
                        e +
                        "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods"
                    );
                  this.setBackend(e);
                }
                return this.backendInstance;
              },
              enumerable: !0,
              configurable: !0,
            }),
            (t.prototype.backendNames = function () {
              return Object.keys(this.registryFactory);
            }),
            (t.prototype.findBackend = function (t) {
              if (!(t in this.registry)) {
                if (!(t in this.registryFactory)) return null;
                if (this.initializeBackend(t).asyncInit) return null;
              }
              return this.registry[t];
            }),
            (t.prototype.findBackendFactory = function (t) {
              return t in this.registryFactory
                ? this.registryFactory[t].factory
                : null;
            }),
            (t.prototype.registerBackend = function (t, e, n) {
              return (
                void 0 === n && (n = 1),
                t in this.registryFactory
                  ? (console.warn(
                      t +
                        " backend was already registered. Reusing existing backend factory."
                    ),
                    !1)
                  : ((this.registryFactory[t] = { factory: e, priority: n }),
                    !0)
              );
            }),
            (t.prototype.setBackend = function (t) {
              return u(this, void 0, void 0, function () {
                var e, n, r;
                return c(this, function (i) {
                  switch (i.label) {
                    case 0:
                      if (null == this.registryFactory[t])
                        throw new Error(
                          "Backend name '" + t + "' not found in registry"
                        );
                      return (
                        (this.backendName = t),
                        null != this.registry[t]
                          ? [3, 4]
                          : ((this.backendInstance = null),
                            (e = this.initializeBackend(t)),
                            (n = e.success),
                            e.asyncInit ? [4, n] : [3, 2])
                      );
                    case 1:
                      return (r = i.sent()), [3, 3];
                    case 2:
                      (r = n), (i.label = 3);
                    case 3:
                      if (!r) return [2, !1];
                      i.label = 4;
                    case 4:
                      return (
                        (this.backendInstance = this.registry[t]),
                        this.setupRegisteredKernels(),
                        (this.profiler = new pt(this.backendInstance)),
                        [2, !0]
                      );
                  }
                });
              });
            }),
            (t.prototype.setupRegisteredKernels = function () {
              var t = this;
              g(this.backendName).forEach(function (e) {
                null != e.setupFunc && e.setupFunc(t.backendInstance);
              });
            }),
            (t.prototype.disposeRegisteredKernels = function (t) {
              var e = this;
              g(t).forEach(function (n) {
                null != n.disposeFunc && n.disposeFunc(e.registry[t]);
              });
            }),
            (t.prototype.initializeBackend = function (t) {
              var e = this,
                n = this.registryFactory[t];
              if (null == n)
                throw new Error(
                  "Cannot initialize backend " + t + ", no registration found."
                );
              try {
                var r = n.factory();
                if (Promise.resolve(r) === r) {
                  var i = ++this.pendingBackendInitId,
                    a = r
                      .then(function (n) {
                        return !(
                          i < e.pendingBackendInitId ||
                          ((e.registry[t] = n),
                          (e.pendingBackendInit = null),
                          0)
                        );
                      })
                      .catch(function (n) {
                        return !(
                          i < e.pendingBackendInitId ||
                          ((e.pendingBackendInit = null),
                          console.warn(
                            "Initialization of backend " + t + " failed"
                          ),
                          console.warn(n.stack || n.message),
                          1)
                        );
                      });
                  return (
                    (this.pendingBackendInit = a), { success: a, asyncInit: !0 }
                  );
                }
                return (this.registry[t] = r), { success: !0, asyncInit: !1 };
              } catch (e) {
                return (
                  console.warn("Initialization of backend " + t + " failed"),
                  console.warn(e.stack || e.message),
                  { success: !1, asyncInit: !1 }
                );
              }
            }),
            (t.prototype.removeBackend = function (t) {
              if (!(t in this.registryFactory))
                throw new Error(t + " backend not found in registry");
              this.backendName === t &&
                null != this.pendingBackendInit &&
                this.pendingBackendInitId++,
                t in this.registry &&
                  (this.disposeRegisteredKernels(t),
                  this.registry[t].dispose(),
                  delete this.registry[t]),
                delete this.registryFactory[t],
                this.backendName === t &&
                  ((this.pendingBackendInit = null),
                  (this.backendName = null),
                  (this.backendInstance = null));
            }),
            (t.prototype.getSortedBackends = function () {
              var t = this;
              if (0 === Object.keys(this.registryFactory).length)
                throw new Error("No backend found in registry.");
              return Object.keys(this.registryFactory).sort(function (e, n) {
                return (
                  t.registryFactory[n].priority - t.registryFactory[e].priority
                );
              });
            }),
            (t.prototype.initializeBackendsAndReturnBest = function () {
              for (var t = this.getSortedBackends(), e = 0; e < t.length; e++) {
                var n = t[e],
                  r = this.initializeBackend(n),
                  i = r.success,
                  a = r.asyncInit;
                if (a || i) return { name: n, asyncInit: a };
              }
              throw new Error(
                "Could not initialize any backends, all backend initializations failed."
              );
            }),
            (t.prototype.moveData = function (t, e) {
              var n = this.state.tensorInfo.get(e),
                r = n.backend,
                i = this.readSync(e);
              r.disposeData(e),
                (n.backend = t),
                t.move(e, i, n.shape, n.dtype),
                this.shouldCheckForMemLeaks() &&
                  this.state.numDataMovesStack[
                    this.state.numDataMovesStack.length - 1
                  ]++;
            }),
            (t.prototype.tidy = function (t, e) {
              var n,
                r = this,
                i = null;
              if (null == e) {
                if ("function" != typeof t)
                  throw new Error("Please provide a function to tidy()");
                e = t;
              } else {
                if ("string" != typeof t && !(t instanceof String))
                  throw new Error(
                    "When calling with two arguments, the first argument to tidy() must be a string"
                  );
                if ("function" != typeof e)
                  throw new Error(
                    "When calling with two arguments, the 2nd argument to tidy() must be a function"
                  );
                i = t;
              }
              return this.scopedRun(
                function () {
                  return r.startScope(i);
                },
                function () {
                  return r.endScope(n);
                },
                function () {
                  return (
                    (n = e()) instanceof Promise &&
                      console.error("Cannot return a Promise inside of tidy."),
                    n
                  );
                }
              );
            }),
            (t.prototype.scopedRun = function (t, e, n) {
              t();
              try {
                var r = n();
                return e(), r;
              } catch (t) {
                throw (e(), t);
              }
            }),
            (t.prototype.nextTensorId = function () {
              return t.nextTensorId++;
            }),
            (t.prototype.nextVariableId = function () {
              return t.nextVariableId++;
            }),
            (t.prototype.clone = function (t) {
              var e = this.makeTensorFromDataId(t.dataId, t.shape, t.dtype),
                n = { x: t };
              return (
                this.addTapeNode(
                  this.state.activeScope.name,
                  n,
                  [e],
                  function (t) {
                    return {
                      x: function () {
                        return t.toFloat();
                      },
                    };
                  },
                  []
                ),
                e
              );
            }),
            (t.prototype.runKernel = function (t, e, n, r, i) {
              return this.runKernelFunc(null, e, null, t, n, r, i);
            }),
            (t.prototype.shouldCheckForMemLeaks = function () {
              return this.ENV.getBool("IS_TEST");
            }),
            (t.prototype.checkKernelForMemLeak = function (t, e, n) {
              var r = this.backend.numDataIds(),
                i = 0;
              n.forEach(function (t) {
                i += "complex64" === t.dtype ? 3 : 1;
              });
              var a = this.state.numDataMovesStack[
                  this.state.numDataMovesStack.length - 1
                ],
                o = r - e - i - a;
              if (o > 0)
                throw new Error(
                  "Backend '" +
                    this.backendName +
                    "' has an internal memory leak (" +
                    o +
                    " data ids) after running '" +
                    t +
                    "'"
                );
            }),
            (t.prototype.runKernelFunc = function (t, e, n, r, i, a, o) {
              var s,
                u = this;
              void 0 === a && (a = []), void 0 === o && (o = []);
              var c = [],
                l = this.isTapeOn();
              null == r &&
                (r =
                  null != this.state.activeScope
                    ? this.state.activeScope.name
                    : "");
              var p,
                h = function (t) {
                  l &&
                    (c = t.map(function (t) {
                      return u.keep(u.clone(t));
                    }));
                },
                f = this.state.numBytes,
                d = this.state.numTensors;
              this.shouldCheckForMemLeaks() &&
                this.state.numDataMovesStack.push(0);
              var m,
                g = v(r, this.backendName);
              return (
                (p =
                  null != g
                    ? function () {
                        var t = u.backend.numDataIds();
                        m = g.kernelFunc({
                          inputs: e,
                          attrs: i,
                          backend: u.backend,
                        });
                        var n = Array.isArray(m) ? m : [m];
                        u.shouldCheckForMemLeaks() &&
                          u.checkKernelForMemLeak(r, t, n);
                        var s = n.map(function (t) {
                            var e = t.dataId,
                              n = t.shape,
                              r = t.dtype;
                            return u.makeTensorFromDataId(e, n, r);
                          }),
                          c = s.filter(function (t, e) {
                            return o[e];
                          });
                        return h((a || []).slice().concat(c)), s;
                      }
                    : function () {
                        var e = u.backend.numDataIds();
                        m = u.tidy(function () {
                          return t(u.backend, h);
                        });
                        var n = Array.isArray(m) ? m : [m];
                        return (
                          u.shouldCheckForMemLeaks() &&
                            u.checkKernelForMemLeak(r, e, n),
                          n
                        );
                      }),
                this.scopedRun(
                  function () {
                    return u.state.kernelDepth++;
                  },
                  function () {
                    return u.state.kernelDepth--;
                  },
                  function () {
                    s = u.ENV.getBool("DEBUG")
                      ? u.profiler.profileKernel(r, e, function () {
                          return p();
                        })
                      : p();
                  }
                ),
                l && this.addTapeNode(r, e, s, n, c),
                this.state.profiling &&
                  this.state.activeProfile.kernels.push({
                    name: r,
                    bytesAdded: this.state.numBytes - f,
                    totalBytesSnapshot: this.state.numBytes,
                    tensorsAdded: this.state.numTensors - d,
                    totalTensorsSnapshot: this.state.numTensors,
                    inputShapes: Object.keys(e).map(function (t) {
                      return e[t].shape;
                    }),
                    outputShapes: s.map(function (t) {
                      return t.shape;
                    }),
                  }),
                Array.isArray(m) ? s : s[0]
              );
            }),
            (t.prototype.makeTensor = function (t, e, n, r) {
              if (null == t)
                throw new Error(
                  "Values passed to engine.makeTensor() are null"
                );
              (n = n || "float32"), (r = r || this.backend);
              var i = t;
              "string" === n &&
                K(t[0]) &&
                (i = t.map(function (t) {
                  return ot(t);
                }));
              var a = r.write(i, e, n),
                o = new wt(e, n, a, this.nextTensorId());
              if ((this.incRef(o, r), "string" === n)) {
                var s = this.state.tensorInfo.get(a),
                  u = q(i);
                (this.state.numBytes += u - s.bytes), (s.bytes = u);
              }
              return o;
            }),
            (t.prototype.makeTensorFromDataId = function (t, e, n, r) {
              var i = new wt(e, (n = n || "float32"), t, this.nextTensorId());
              return this.incRef(i, r), i;
            }),
            (t.prototype.makeVariable = function (t, e, n, r) {
              void 0 === e && (e = !0),
                (n = n || this.nextVariableId().toString()),
                null != r && r !== t.dtype && (t = t.asType(r));
              var i = new Nt(t, e, n, this.nextTensorId());
              if (null != this.state.registeredVariables[i.name])
                throw new Error(
                  "Variable with name " + i.name + " was already registered"
                );
              return (
                (this.state.registeredVariables[i.name] = i),
                this.incRef(i, this.backend),
                i
              );
            }),
            (t.prototype.incRef = function (t, e) {
              var n = this.state.tensorInfo.has(t.dataId)
                ? this.state.tensorInfo.get(t.dataId).refCount
                : 0;
              if (
                (this.state.numTensors++,
                "string" === t.dtype && this.state.numStringTensors++,
                0 === n)
              ) {
                this.state.numDataBuffers++;
                var r = 0;
                "complex64" !== t.dtype &&
                  "string" !== t.dtype &&
                  (r = t.size * H(t.dtype)),
                  this.state.tensorInfo.set(t.dataId, {
                    backend: e || this.backend,
                    dtype: t.dtype,
                    shape: t.shape,
                    bytes: r,
                    refCount: 0,
                  }),
                  (this.state.numBytes += r);
              }
              this.state.tensorInfo.get(t.dataId).refCount++,
                t instanceof Nt || this.track(t);
            }),
            (t.prototype.disposeTensor = function (t) {
              if (this.state.tensorInfo.has(t.dataId)) {
                this.state.numTensors--,
                  "string" === t.dtype && this.state.numStringTensors--;
                var e = this.state.tensorInfo.get(t.dataId);
                e.refCount <= 1
                  ? ("complex64" !== t.dtype &&
                      (this.state.numBytes -= e.bytes),
                    this.state.numDataBuffers--,
                    e.backend.disposeData(t.dataId),
                    this.state.tensorInfo.delete(t.dataId))
                  : this.state.tensorInfo.get(t.dataId).refCount--;
              }
            }),
            (t.prototype.disposeVariables = function () {
              for (var t in this.state.registeredVariables) {
                var e = this.state.registeredVariables[t];
                this.disposeVariable(e);
              }
            }),
            (t.prototype.disposeVariable = function (t) {
              this.disposeTensor(t),
                null != this.state.registeredVariables[t.name] &&
                  delete this.state.registeredVariables[t.name];
            }),
            (t.prototype.memory = function () {
              var t = this.backend.memory();
              return (
                (t.numTensors = this.state.numTensors),
                (t.numDataBuffers = this.state.numDataBuffers),
                (t.numBytes = this.state.numBytes),
                this.state.numStringTensors > 0 &&
                  ((t.unreliable = !0),
                  null == t.reasons && (t.reasons = []),
                  t.reasons.push(
                    "Memory usage by string tensors is approximate (2 bytes per character)"
                  )),
                t
              );
            }),
            (t.prototype.profile = function (t) {
              return u(this, void 0, void 0, function () {
                var e, n;
                return c(this, function (r) {
                  return (
                    (this.state.profiling = !0),
                    (e = this.state.numBytes),
                    (n = this.state.numTensors),
                    (this.state.activeProfile.kernels = []),
                    (this.state.activeProfile.result = t()),
                    (this.state.profiling = !1),
                    (this.state.activeProfile.peakBytes = Math.max.apply(
                      Math,
                      this.state.activeProfile.kernels.map(function (t) {
                        return t.totalBytesSnapshot;
                      })
                    )),
                    (this.state.activeProfile.newBytes =
                      this.state.numBytes - e),
                    (this.state.activeProfile.newTensors =
                      this.state.numTensors - n),
                    [2, this.state.activeProfile]
                  );
                });
              });
            }),
            (t.prototype.isTapeOn = function () {
              return (
                this.state.gradientDepth > 0 && 0 === this.state.kernelDepth
              );
            }),
            (t.prototype.addTapeNode = function (t, e, n, r, i) {
              var a = this,
                o = {
                  id: this.state.nextTapeNodeId++,
                  kernelName: t,
                  inputs: e,
                  outputs: n,
                  saved: i,
                },
                s = (function (t) {
                  return m.get(t);
                })(t);
              null != s && (r = s.gradFunc),
                null != r &&
                  (o.gradient = function (t) {
                    return (
                      (t = t.map(function (t, e) {
                        if (null == t) {
                          var r = n[e],
                            i = rt(r.size, r.dtype);
                          return a.makeTensor(i, r.shape, r.dtype);
                        }
                        return t;
                      })),
                      r(t.length > 1 ? t : t[0], i)
                    );
                  }),
                this.state.activeTape.push(o);
            }),
            (t.prototype.keep = function (t) {
              return (t.kept = !0), t;
            }),
            (t.prototype.startTape = function () {
              0 === this.state.gradientDepth && (this.state.activeTape = []),
                this.state.gradientDepth++;
            }),
            (t.prototype.endTape = function () {
              this.state.gradientDepth--;
            }),
            (t.prototype.startScope = function (t) {
              var e = {
                track: [],
                name: "unnamed scope",
                id: this.state.nextScopeId++,
              };
              t && (e.name = t),
                this.state.scopeStack.push(e),
                (this.state.activeScope = e);
            }),
            (t.prototype.endScope = function (t) {
              for (
                var e = this,
                  n = Rt(t),
                  r = new Set(
                    n.map(function (t) {
                      return t.id;
                    })
                  ),
                  i = 0;
                i < this.state.activeScope.track.length;
                i++
              ) {
                var a = this.state.activeScope.track[i];
                a.kept || r.has(a.id) || a.dispose();
              }
              var o = this.state.scopeStack.pop();
              (this.state.activeScope =
                0 === this.state.scopeStack.length
                  ? null
                  : this.state.scopeStack[this.state.scopeStack.length - 1]),
                n.forEach(function (t) {
                  t.kept || t.scopeId !== o.id || e.track(t);
                });
            }),
            (t.prototype.gradients = function (t, e, n, r) {
              var i = this;
              if (
                (void 0 === r && (r = !1),
                S(e.length > 0, function () {
                  return "gradients() received an empty list of xs.";
                }),
                null != n && "float32" !== n.dtype)
              )
                throw new Error(
                  "dy must have 'float32' dtype, but has '" + n.dtype + "'"
                );
              var a = this.scopedRun(
                function () {
                  return i.startTape();
                },
                function () {
                  return i.endTape();
                },
                function () {
                  return i.tidy("forward", t);
                }
              );
              S(a instanceof wt, function () {
                return "The result y returned by f() must be a tensor.";
              });
              var o = (function (t, e, n) {
                for (var r = {}, i = {}, a = 0; a < e.length; a++)
                  r[e[a].id] = !0;
                for (a = 0; a < t.length; a++) {
                  var o = (d = t[a]).inputs;
                  for (var s in o) {
                    for (var u = o[s], c = !1, l = 0; l < e.length; l++)
                      if (r[u.id]) {
                        d.outputs.forEach(function (t) {
                          return (r[t.id] = !0);
                        }),
                          (c = !0),
                          (i[d.id] = !0);
                        break;
                      }
                    if (c) break;
                  }
                }
                var p = {};
                p[n.id] = !0;
                var h = {};
                for (a = t.length - 1; a >= 0; a--)
                  for (o = (d = t[a]).inputs, l = 0; l < d.outputs.length; l++)
                    if (p[d.outputs[l].id]) {
                      for (var s in o) (p[o[s].id] = !0), (h[d.id] = !0);
                      break;
                    }
                var f = [];
                for (a = 0; a < t.length; a++) {
                  var d;
                  if (i[(d = t[a]).id] && h[d.id]) {
                    var m = {};
                    for (var s in d.inputs) {
                      var v = d.inputs[s];
                      r[v.id] && (m[s] = v);
                    }
                    var g = Object.assign({}, d);
                    (g.inputs = m), (g.outputs = d.outputs), f.push(g);
                  }
                }
                return f;
              })(this.state.activeTape, e, a);
              if (!r && 0 === o.length && e.length > 0)
                throw new Error(
                  "Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y."
                );
              return this.tidy("backward", function () {
                var t,
                  r,
                  s = {};
                (s[a.id] =
                  null == n
                    ? ((r = nt(_((t = a.shape)), "float32")),
                      Pt.makeTensor(r, t, "float32"))
                    : n),
                  (function (t, e, n) {
                    for (
                      var r = function (r) {
                          var i = e[r],
                            a = [];
                          if (
                            (i.outputs.forEach(function (e) {
                              var n = t[e.id];
                              null != n ? a.push(n) : a.push(null);
                            }),
                            null == i.gradient)
                          )
                            throw new Error(
                              "Cannot compute gradient: gradient function not found for " +
                                i.kernelName +
                                "."
                            );
                          var o = i.gradient(a),
                            s = function (e) {
                              if (!(e in o))
                                throw new Error(
                                  "Cannot backprop through input " +
                                    e +
                                    ". Available gradients found: " +
                                    Object.keys(o) +
                                    "."
                                );
                              var r = n(function () {
                                return o[e]();
                              });
                              if ("float32" !== r.dtype)
                                throw new Error(
                                  "Error in gradient for op " +
                                    i.kernelName +
                                    ". The gradient of input " +
                                    e +
                                    " must have 'float32' dtype, but has '" +
                                    r.dtype +
                                    "'"
                                );
                              var a = i.inputs[e];
                              if (!A(r.shape, a.shape))
                                throw new Error(
                                  "Error in gradient for op " +
                                    i.kernelName +
                                    ". The gradient of input '" +
                                    e +
                                    "' has shape '" +
                                    r.shape +
                                    "', which does not match the shape of the input '" +
                                    a.shape +
                                    "'"
                                );
                              if (null == t[a.id]) t[a.id] = r;
                              else {
                                var s = t[a.id];
                                (t[a.id] = s.add(r)), s.dispose();
                              }
                            };
                          for (var u in i.inputs) s(u);
                        },
                        i = e.length - 1;
                      i >= 0;
                      i--
                    )
                      r(i);
                  })(s, o, function (t) {
                    return i.tidy(t);
                  });
                var u = e.map(function (t) {
                  return s[t.id];
                });
                return (
                  0 === i.state.gradientDepth &&
                    (i.state.activeTape.forEach(function (t) {
                      for (var e = 0, n = t.saved; e < n.length; e++)
                        n[e].dispose();
                    }),
                    (i.state.activeTape = null)),
                  { value: a, grads: u }
                );
              });
            }),
            (t.prototype.customGrad = function (t) {
              var e = this;
              return (
                S(J(t), function () {
                  return "The f passed in customGrad(f) must be a function.";
                }),
                function () {
                  for (var n, r = [], i = 0; i < arguments.length; i++)
                    r[i] = arguments[i];
                  S(
                    r.every(function (t) {
                      return t instanceof wt;
                    }),
                    function () {
                      return "The args passed in customGrad(f)(x1, x2,...) must all be tensors";
                    }
                  );
                  var a = {};
                  return (
                    r.forEach(function (t, e) {
                      a[e] = t;
                    }),
                    e.runKernelFunc(
                      function (e, i) {
                        return (
                          S(
                            (n = t.apply(void 0, r.concat([i])))
                              .value instanceof wt,
                            function () {
                              return "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor";
                            }
                          ),
                          S(J(n.gradFunc), function () {
                            return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.";
                          }),
                          n.value
                        );
                      },
                      a,
                      function (t, e) {
                        var i = n.gradFunc(t, e),
                          a = Array.isArray(i) ? i : [i];
                        S(a.length === r.length, function () {
                          return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).";
                        }),
                          S(
                            a.every(function (t) {
                              return t instanceof wt;
                            }),
                            function () {
                              return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.";
                            }
                          );
                        var o = {};
                        return (
                          a.forEach(function (t, e) {
                            o[e] = function () {
                              return t;
                            };
                          }),
                          o
                        );
                      }
                    )
                  );
                }
              );
            }),
            (t.prototype.readSync = function (t) {
              return this.state.tensorInfo.get(t).backend.readSync(t);
            }),
            (t.prototype.read = function (t) {
              return this.state.tensorInfo.get(t).backend.read(t);
            }),
            (t.prototype.time = function (t) {
              return u(this, void 0, void 0, function () {
                var e, n;
                return c(this, function (r) {
                  switch (r.label) {
                    case 0:
                      return (e = it()), [4, this.backend.time(t)];
                    case 1:
                      return ((n = r.sent()).wallMs = it() - e), [2, n];
                  }
                });
              });
            }),
            (t.prototype.track = function (t) {
              return (
                null != this.state.activeScope &&
                  ((t.scopeId = this.state.activeScope.id),
                  this.state.activeScope.track.push(t)),
                t
              );
            }),
            Object.defineProperty(t.prototype, "registeredVariables", {
              get: function () {
                return this.state.registeredVariables;
              },
              enumerable: !0,
              configurable: !0,
            }),
            (t.prototype.reset = function () {
              for (var t in (this.pendingBackendInitId++,
              this.state.dispose(),
              this.ENV.reset(),
              (this.state = new Mt()),
              this.registry))
                this.disposeRegisteredKernels(t),
                  this.registry[t].dispose(),
                  delete this.registry[t];
              (this.backendName = null),
                (this.backendInstance = null),
                (this.pendingBackendInit = null);
            }),
            (t.nextTensorId = 0),
            (t.nextVariableId = 0),
            t
          );
        })(),
        Pt = (function () {
          var e = (function () {
            if (null == Dt) {
              var e = void 0;
              if ("undefined" != typeof window) e = window;
              else if (void 0 !== t) e = t;
              else if (void 0 !== r) e = r;
              else {
                if ("undefined" == typeof self)
                  throw new Error("Could not find a global object");
                e = self;
              }
              Dt = e;
            }
            return Dt;
          })();
          if (null == e._tfengine) {
            var n = new l(e);
            e._tfengine = new jt(n);
          }
          return (
            (function (t) {
              f = t;
            })(e._tfengine.ENV),
            (gt = function () {
              return e._tfengine;
            }),
            e._tfengine
          );
        })();
      function zt() {
        return (
          ("undefined" != typeof window && null != window.document) ||
          "undefined" != typeof WorkerGlobalScope
        );
      }
      var Lt = h();
      Lt.registerFlag(
        "DEBUG",
        function () {
          return !1;
        },
        function (t) {
          t &&
            console.warn(
              "Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance."
            );
        }
      ),
        Lt.registerFlag("IS_BROWSER", function () {
          return zt();
        }),
        Lt.registerFlag("IS_NODE", function () {
          return (
            void 0 !== r && void 0 !== r.versions && void 0 !== r.versions.node
          );
        }),
        Lt.registerFlag("IS_CHROME", function () {
          return (
            "undefined" != typeof navigator &&
            null != navigator &&
            null != navigator.userAgent &&
            /Chrome/.test(navigator.userAgent) &&
            /Google Inc/.test(navigator.vendor)
          );
        }),
        Lt.registerFlag("PROD", function () {
          return !1;
        }),
        Lt.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", function () {
          return Lt.getBool("DEBUG");
        }),
        Lt.registerFlag("DEPRECATION_WARNINGS_ENABLED", function () {
          return !0;
        }),
        Lt.registerFlag("IS_TEST", function () {
          return !1;
        });
      var Bt,
        Wt,
        Ut,
        Vt = {},
        Gt = {
          alpha: !1,
          antialias: !1,
          premultipliedAlpha: !1,
          preserveDrawingBuffer: !1,
          depth: !1,
          stencil: !1,
          failIfMajorPerformanceCaveat: !0,
        };
      function Ht(t, e) {
        Vt[t] = e;
      }
      function qt(t) {
        t in Vt ||
          (Vt[t] = (function (t) {
            if (1 !== t && 2 !== t)
              throw new Error(
                "Cannot get WebGL rendering context, WebGL is disabled."
              );
            var e = (function (t) {
              if ("undefined" != typeof OffscreenCanvas && 2 === t)
                return new OffscreenCanvas(300, 150);
              if ("undefined" != typeof document)
                return document.createElement("canvas");
              throw new Error("Cannot create a canvas in this context");
            })(t);
            return (
              e.addEventListener(
                "webglcontextlost",
                function (e) {
                  e.preventDefault(), delete Vt[t];
                },
                !1
              ),
              1 === t
                ? e.getContext("webgl", Gt) ||
                  e.getContext("experimental-webgl", Gt)
                : e.getContext("webgl2", Gt)
            );
          })(t));
        var e = Vt[t];
        return e.isContextLost()
          ? (delete Vt[t], qt(t))
          : (e.disable(e.DEPTH_TEST),
            e.disable(e.STENCIL_TEST),
            e.disable(e.BLEND),
            e.disable(e.DITHER),
            e.disable(e.POLYGON_OFFSET_FILL),
            e.disable(e.SAMPLE_COVERAGE),
            e.enable(e.SCISSOR_TEST),
            e.enable(e.CULL_FACE),
            e.cullFace(e.BACK),
            Vt[t]);
      }
      function Kt(t, e) {
        return [e, t];
      }
      function Zt(t) {
        var e = _(t);
        return D(Math.ceil(e / 4));
      }
      function Xt(t, e) {
        return [Math.max(1, Math.ceil(e / 2)), Math.max(1, Math.ceil(t / 2))];
      }
      function Yt(t, e) {
        var n,
          r,
          i,
          a,
          o,
          s,
          u,
          c,
          l,
          p = t;
        return (
          2 === h().getNumber("WEBGL_VERSION")
            ? ((n = p.R32F),
              (r = p.R16F),
              (i = p.RGBA16F),
              (a = p.RGBA32F),
              (o = p.RED),
              (s = 4),
              (u = 1),
              (c = p.HALF_FLOAT),
              (l = p.FLOAT))
            : ((n = t.RGBA),
              (r = t.RGBA),
              (i = t.RGBA),
              (a = p.RGBA),
              (o = t.RGBA),
              (s = 4),
              (u = 4),
              (c = null != e ? e.HALF_FLOAT_OES : null),
              (l = t.FLOAT)),
          {
            internalFormatFloat: n,
            internalFormatHalfFloat: r,
            internalFormatPackedHalfFloat: i,
            internalFormatPackedFloat: a,
            textureFormatFloat: o,
            downloadTextureFormat: t.RGBA,
            downloadUnpackNumChannels: s,
            defaultNumChannels: u,
            textureTypeHalfFloat: c,
            textureTypeFloat: l,
          }
        );
      }
      function Jt(t, e, n) {
        var r = n();
        return (
          e &&
            (function (t) {
              var e = t.getError();
              if (e !== t.NO_ERROR) throw new Error("WebGL Error: " + Qt(t, e));
            })(t),
          r
        );
      }
      !(function (t) {
        (t[(t.DENSE = 0)] = "DENSE"),
          (t[(t.SHARED_BATCH = 1)] = "SHARED_BATCH");
      })(Bt || (Bt = {})),
        (function (t) {
          (t[(t.RENDER = 0)] = "RENDER"),
            (t[(t.UPLOAD = 1)] = "UPLOAD"),
            (t[(t.PIXELS = 2)] = "PIXELS"),
            (t[(t.DOWNLOAD = 3)] = "DOWNLOAD");
        })(Wt || (Wt = {})),
        (function (t) {
          (t[(t.UNPACKED_FLOAT16 = 0)] = "UNPACKED_FLOAT16"),
            (t[(t.UNPACKED_FLOAT32 = 1)] = "UNPACKED_FLOAT32"),
            (t[(t.PACKED_4X1_UNSIGNED_BYTE = 2)] = "PACKED_4X1_UNSIGNED_BYTE"),
            (t[(t.PACKED_2X2_FLOAT32 = 3)] = "PACKED_2X2_FLOAT32"),
            (t[(t.PACKED_2X2_FLOAT16 = 4)] = "PACKED_2X2_FLOAT16");
        })(Ut || (Ut = {}));
      function $t(t) {
        return !!(
          h().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ||
          0 === t ||
          (5.96e-8 < Math.abs(t) && Math.abs(t) < 65504)
        );
      }
      function Qt(t, e) {
        switch (e) {
          case t.NO_ERROR:
            return "NO_ERROR";
          case t.INVALID_ENUM:
            return "INVALID_ENUM";
          case t.INVALID_VALUE:
            return "INVALID_VALUE";
          case t.INVALID_OPERATION:
            return "INVALID_OPERATION";
          case t.INVALID_FRAMEBUFFER_OPERATION:
            return "INVALID_FRAMEBUFFER_OPERATION";
          case t.OUT_OF_MEMORY:
            return "OUT_OF_MEMORY";
          case t.CONTEXT_LOST_WEBGL:
            return "CONTEXT_LOST_WEBGL";
          default:
            return "Unknown error code " + e;
        }
      }
      function te(t, e, n) {
        return Oe(
          t,
          e,
          function () {
            return t.getExtension(n);
          },
          'Extension "' + n + '" not supported on this browser.'
        );
      }
      function ee(t, e, n) {
        var r = Oe(
          t,
          e,
          function () {
            return t.createShader(t.VERTEX_SHADER);
          },
          "Unable to create vertex WebGLShader."
        );
        if (
          (Jt(t, e, function () {
            return t.shaderSource(r, n);
          }),
          Jt(t, e, function () {
            return t.compileShader(r);
          }),
          !1 === t.getShaderParameter(r, t.COMPILE_STATUS))
        )
          throw (
            (console.log(t.getShaderInfoLog(r)),
            new Error("Failed to compile vertex shader."))
          );
        return r;
      }
      function ne(t, e, n) {
        var r = Oe(
          t,
          e,
          function () {
            return t.createShader(t.FRAGMENT_SHADER);
          },
          "Unable to create fragment WebGLShader."
        );
        if (
          (Jt(t, e, function () {
            return t.shaderSource(r, n);
          }),
          Jt(t, e, function () {
            return t.compileShader(r);
          }),
          !1 === t.getShaderParameter(r, t.COMPILE_STATUS))
        )
          throw (
            ((function (t, e) {
              var n = ae.exec(e);
              if (null == n)
                return (
                  console.log("Couldn't parse line number in error: " + e),
                  void console.log(t)
                );
              for (
                var r = +n[1],
                  i = t.split("\n"),
                  a = i.length.toString().length + 2,
                  o = i.map(function (t, e) {
                    return F((e + 1).toString(), a) + t;
                  }),
                  s = 0,
                  u = 0;
                u < o.length;
                u++
              )
                s = Math.max(o[u].length, s);
              var c = o.slice(0, r - 1),
                l = o.slice(r - 1, r),
                p = o.slice(r);
              console.log(c.join("\n")),
                console.log(e.split("\n")[0]),
                console.log(
                  "%c " + F(l[0], s),
                  "border:1px solid red; background-color:#e3d2d2; color:#a61717"
                ),
                console.log(p.join("\n"));
            })(n, t.getShaderInfoLog(r)),
            new Error("Failed to compile fragment shader."))
          );
        return r;
      }
      var re,
        ie,
        ae = /ERROR: [0-9]+:([0-9]+):/g;
      function oe(t, e) {
        return Oe(
          t,
          e,
          function () {
            return t.createProgram();
          },
          "Unable to create WebGLProgram."
        );
      }
      function se(t, e, n) {
        if (
          (Jt(t, e, function () {
            return t.linkProgram(n);
          }),
          !1 === t.getProgramParameter(n, t.LINK_STATUS))
        )
          throw (
            (console.log(t.getProgramInfoLog(n)),
            new Error("Failed to link vertex and fragment shaders."))
          );
      }
      function ue(t, e, n) {
        if (
          (Jt(t, e, function () {
            return t.validateProgram(n);
          }),
          !1 === t.getProgramParameter(n, t.VALIDATE_STATUS))
        )
          throw (
            (console.log(t.getProgramInfoLog(n)),
            new Error("Shader program validation failed."))
          );
      }
      function ce(t, e, n) {
        var r = Oe(
          t,
          e,
          function () {
            return t.createBuffer();
          },
          "Unable to create WebGLBuffer"
        );
        return (
          Jt(t, e, function () {
            return t.bindBuffer(t.ARRAY_BUFFER, r);
          }),
          Jt(t, e, function () {
            return t.bufferData(t.ARRAY_BUFFER, n, t.STATIC_DRAW);
          }),
          r
        );
      }
      function le(t, e, n) {
        var r = Oe(
          t,
          e,
          function () {
            return t.createBuffer();
          },
          "Unable to create WebGLBuffer"
        );
        return (
          Jt(t, e, function () {
            return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, r);
          }),
          Jt(t, e, function () {
            return t.bufferData(t.ELEMENT_ARRAY_BUFFER, n, t.STATIC_DRAW);
          }),
          r
        );
      }
      function pe(t, e) {
        return Oe(
          t,
          e,
          function () {
            return t.createTexture();
          },
          "Unable to create WebGLTexture."
        );
      }
      function he(t, e) {
        var n = h().getNumber("WEBGL_MAX_TEXTURE_SIZE");
        if (t <= 0 || e <= 0) {
          var r = "[" + t + "x" + e + "]";
          throw new Error("Requested texture size " + r + " is invalid.");
        }
        if (t > n || e > n)
          throw (
            ((r = "[" + t + "x" + e + "]"),
            new Error(
              "Requested texture size " +
                r +
                " greater than WebGL maximum on this browser / GPU [" +
                n +
                "x" +
                n +
                "]."
            ))
          );
      }
      function fe(t, e) {
        return Oe(
          t,
          e,
          function () {
            return t.createFramebuffer();
          },
          "Unable to create WebGLFramebuffer."
        );
      }
      function de(t, e, n, r, i, a, o, s) {
        var u = t.getAttribLocation(n, r);
        return (
          -1 !== u &&
          (Jt(t, e, function () {
            return t.bindBuffer(t.ARRAY_BUFFER, i);
          }),
          Jt(t, e, function () {
            return t.vertexAttribPointer(u, a, t.FLOAT, !1, o, s);
          }),
          Jt(t, e, function () {
            return t.enableVertexAttribArray(u);
          }),
          !0)
        );
      }
      function me(t, e, n, r) {
        Ee(t, r),
          Jt(t, e, function () {
            return t.activeTexture(t.TEXTURE0 + r);
          }),
          Jt(t, e, function () {
            return t.bindTexture(t.TEXTURE_2D, n);
          });
      }
      function ve(t, e, n, r) {
        return Oe(
          t,
          e,
          function () {
            return t.getUniformLocation(n, r);
          },
          'uniform "' + r + '" not present in program.'
        );
      }
      function ge(t, e, n) {
        return t.getUniformLocation(e, n);
      }
      function ye(t, e, n, r, i, a) {
        Jt(t, e, function () {
          return me(t, e, r, a);
        }),
          Jt(t, e, function () {
            return t.uniform1i(i, a);
          });
      }
      function be(t, e, n, r) {
        Jt(t, e, function () {
          return t.bindFramebuffer(t.FRAMEBUFFER, r);
        }),
          Jt(t, e, function () {
            return t.framebufferTexture2D(
              t.FRAMEBUFFER,
              t.COLOR_ATTACHMENT0,
              t.TEXTURE_2D,
              n,
              0
            );
          });
      }
      function we(t, e, n) {
        Jt(t, e, function () {
          return t.bindFramebuffer(t.FRAMEBUFFER, n);
        }),
          Jt(t, e, function () {
            return t.framebufferTexture2D(
              t.FRAMEBUFFER,
              t.COLOR_ATTACHMENT0,
              t.TEXTURE_2D,
              null,
              0
            );
          });
      }
      function xe(t) {
        var e = t.checkFramebufferStatus(t.FRAMEBUFFER);
        if (e !== t.FRAMEBUFFER_COMPLETE)
          throw new Error("Error binding framebuffer: " + Ce(t, e));
      }
      function Ce(t, e) {
        switch (e) {
          case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
          case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
          case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
          case t.FRAMEBUFFER_UNSUPPORTED:
            return "FRAMEBUFFER_UNSUPPORTED";
          default:
            return "unknown error " + e;
        }
      }
      function Oe(t, e, n, r) {
        var i = Jt(t, e, function () {
          return n();
        });
        if (null == i) throw new Error(r);
        return i;
      }
      function Ee(t, e) {
        var n = t.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1,
          r = e + t.TEXTURE0;
        if (r < t.TEXTURE0 || r > n)
          throw new Error(
            "textureUnit must be in [gl.TEXTURE0, gl.TEXTURE" + n + "]."
          );
      }
      function Se(t, e) {
        return void 0 === e && (e = 2), _(t.slice(0, t.length - e));
      }
      function Ne(t) {
        if (0 === t.length)
          throw Error("Cannot get rows and columns of an empty shape array.");
        return [t.length > 1 ? t[t.length - 2] : 1, t[t.length - 1]];
      }
      function Ie(t) {
        var e = [1, 1, 1];
        return (
          0 === t.length ||
            (1 === t.length && 1 === t[0]) ||
            (e = [Se(t)].concat(Ne(t))),
          e
        );
      }
      function ke(t, e) {
        var n;
        void 0 === e && (e = !1);
        var r = h().getNumber("WEBGL_MAX_TEXTURE_SIZE");
        if (
          (e &&
            ((r *= 2),
            1 ===
              (t = t.map(function (e, n) {
                return n >= t.length - 2 ? O(t[n]) : t[n];
              })).length && (t = [2, t[0]])),
          2 !== t.length)
        ) {
          var i = z(t);
          t = i.newShape;
        }
        var a = _(t);
        if (t.length <= 1 && a <= r) return [1, a];
        if (2 === t.length && t[0] <= r && t[1] <= r) return t;
        if (3 === t.length && t[0] * t[1] <= r && t[2] <= r)
          return [t[0] * t[1], t[2]];
        if (3 === t.length && t[0] <= r && t[1] * t[2] <= r)
          return [t[0], t[1] * t[2]];
        if (4 === t.length && t[0] * t[1] * t[2] <= r && t[3] <= r)
          return [t[0] * t[1] * t[2], t[3]];
        if (4 === t.length && t[0] <= r && t[1] * t[2] * t[3] <= r)
          return [t[0], t[1] * t[2] * t[3]];
        if (e) {
          var o = Se(t),
            s = 2,
            u = 2;
          return (
            t.length && ((s = (n = Ne(t))[0]), (u = n[1])),
            D((a = o * (s / 2) * (u / 2))).map(function (t) {
              return 2 * t;
            })
          );
        }
        return D(a);
      }
      function _e(t) {
        return t % 2 == 0;
      }
      function Ae(t, e) {
        if (A((t = t.slice(-2)), (e = e.slice(-2)))) return !0;
        if (!t.length || !e.length) return !0;
        if (0 === t[0] || 0 === t[1] || 0 === e[0] || 0 === e[1]) return !0;
        if (t.length !== e.length) {
          var n = t.slice(-1)[0],
            r = e.slice(-1)[0];
          if (n === r) return !0;
          if (_e(n) && _e(r) && (1 === t[0] || 1 === e[0])) return !0;
        }
        return t[1] === e[1] && _e(t[0]) && _e(e[0]);
      }
      function Te(t) {
        if (null == re) {
          var e = qt(t);
          re = e.getParameter(e.MAX_TEXTURE_SIZE);
        }
        return re;
      }
      function Re(t) {
        if (null == ie) {
          var e = qt(t);
          ie = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS);
        }
        return Math.min(16, ie);
      }
      function De(t) {
        if (0 === t) return 0;
        var e = qt(t);
        return Fe(e, "EXT_disjoint_timer_query_webgl2") && 2 === t
          ? 2
          : Fe(e, "EXT_disjoint_timer_query")
          ? 1
          : 0;
      }
      function Fe(t, e) {
        return null != t.getExtension(e);
      }
      function Me(t) {
        try {
          if (null != qt(t)) return !0;
        } catch (t) {
          return !1;
        }
        return !1;
      }
      function je(t) {
        if (0 === t) return !1;
        var e = qt(t);
        if (1 === t) {
          if (!Fe(e, "OES_texture_float")) return !1;
        } else if (!Fe(e, "EXT_color_buffer_float")) return !1;
        return ze(e);
      }
      function Pe(t) {
        if (0 === t) return !1;
        var e = qt(t);
        if (1 !== t) {
          if (Fe(e, "EXT_color_buffer_float")) return ze(e);
          if (Fe(e, "EXT_color_buffer_half_float")) {
            var n = e.getExtension("EXT_color_buffer_half_float");
            return (function (t, e) {
              var n = Yt(t, e),
                r = t.createTexture();
              t.bindTexture(t.TEXTURE_2D, r),
                t.texImage2D(
                  t.TEXTURE_2D,
                  0,
                  n.internalFormatHalfFloat,
                  1,
                  1,
                  0,
                  n.textureFormatFloat,
                  n.textureTypeHalfFloat,
                  null
                );
              var i = t.createFramebuffer();
              t.bindFramebuffer(t.FRAMEBUFFER, i),
                t.framebufferTexture2D(
                  t.FRAMEBUFFER,
                  t.COLOR_ATTACHMENT0,
                  t.TEXTURE_2D,
                  r,
                  0
                );
              var a =
                t.checkFramebufferStatus(t.FRAMEBUFFER) ===
                t.FRAMEBUFFER_COMPLETE;
              return (
                t.bindTexture(t.TEXTURE_2D, null),
                t.bindFramebuffer(t.FRAMEBUFFER, null),
                t.deleteTexture(r),
                t.deleteFramebuffer(i),
                a
              );
            })(e, n);
          }
          return !1;
        }
        return (
          !!Fe(e, "OES_texture_float") &&
          !!Fe(e, "WEBGL_color_buffer_float") &&
          ze(e)
        );
      }
      function ze(t) {
        var e = Yt(t),
          n = t.createTexture();
        t.bindTexture(t.TEXTURE_2D, n),
          t.texImage2D(
            t.TEXTURE_2D,
            0,
            e.internalFormatFloat,
            1,
            1,
            0,
            e.textureFormatFloat,
            e.textureTypeFloat,
            null
          );
        var r = t.createFramebuffer();
        t.bindFramebuffer(t.FRAMEBUFFER, r),
          t.framebufferTexture2D(
            t.FRAMEBUFFER,
            t.COLOR_ATTACHMENT0,
            t.TEXTURE_2D,
            n,
            0
          );
        var i =
          t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE;
        return (
          t.bindTexture(t.TEXTURE_2D, null),
          t.bindFramebuffer(t.FRAMEBUFFER, null),
          t.deleteTexture(n),
          t.deleteFramebuffer(r),
          i
        );
      }
      function Le(t) {
        return 2 === t && null != qt(t).fenceSync;
      }
      var Be = Object.freeze({
          callAndCheck: Jt,
          canBeRepresented: $t,
          getWebGLErrorMessage: Qt,
          getExtensionOrThrow: te,
          createVertexShader: ee,
          createFragmentShader: ne,
          createProgram: oe,
          linkProgram: se,
          validateProgram: ue,
          createStaticVertexBuffer: ce,
          createStaticIndexBuffer: le,
          getNumChannels: function () {
            return 2 === h().getNumber("WEBGL_VERSION") ? 1 : 4;
          },
          createTexture: pe,
          validateTextureSize: he,
          createFramebuffer: fe,
          bindVertexBufferToProgramAttribute: de,
          bindTextureUnit: me,
          unbindTextureUnit: function (t, e, n) {
            Ee(t, n),
              Jt(t, e, function () {
                return t.activeTexture(t.TEXTURE0 + n);
              }),
              Jt(t, e, function () {
                return t.bindTexture(t.TEXTURE_2D, null);
              });
          },
          getProgramUniformLocationOrThrow: ve,
          getProgramUniformLocation: ge,
          bindTextureToProgramUniformSampler: ye,
          bindCanvasToFramebuffer: function (t, e) {
            Jt(t, e, function () {
              return t.bindFramebuffer(t.FRAMEBUFFER, null);
            }),
              Jt(t, e, function () {
                return t.viewport(0, 0, t.canvas.width, t.canvas.height);
              }),
              Jt(t, e, function () {
                return t.scissor(0, 0, t.canvas.width, t.canvas.height);
              });
          },
          bindColorTextureToFramebuffer: be,
          unbindColorTextureFromFramebuffer: we,
          validateFramebuffer: xe,
          getFramebufferErrorMessage: Ce,
          getBatchDim: Se,
          getRowsCols: Ne,
          getShapeAs3D: Ie,
          getTextureShapeFromLogicalShape: ke,
          isReshapeFree: Ae,
          getWebGLMaxTextureSize: Te,
          resetMaxTextureSize: function () {
            re = null;
          },
          resetMaxTexturesInShader: function () {
            ie = null;
          },
          getMaxTexturesInShader: Re,
          getWebGLDisjointQueryTimerVersion: De,
          hasExtension: Fe,
          isWebGLVersionEnabled: Me,
          isCapableOfRenderingToFloatTexture: je,
          isDownloadFloatTextureEnabled: Pe,
          isWebGLFenceEnabled: Le,
        }),
        We = h();
      function Ue() {
        h().set("PROD", !0);
      }
      function Ve(t) {
        h().getBool("DEPRECATION_WARNINGS_ENABLED") &&
          console.warn(
            t +
              " You can disable deprecation warnings with tf.disableDeprecationWarnings()."
          );
      }
      function Ge() {
        return Pt.memory();
      }
      function He(t, e) {
        return Pt.tidy(t, e);
      }
      function qe(t) {
        Rt(t).forEach(function (t) {
          return t.dispose();
        });
      }
      function Ke(t) {
        return Pt.keep(t);
      }
      function Ze() {
        return Pt.backend;
      }
      function Xe() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
        h().getBool("IS_TEST") || console.warn.apply(console, t);
      }
      function Ye(t, e) {
        var n = t;
        if (G(t)) return "string" === e ? [] : [t.length];
        if (!Array.isArray(t)) return [];
        for (var r = []; Array.isArray(n) || (G(n) && "string" !== e); )
          r.push(n.length), (n = n[0]);
        return (
          Array.isArray(t) &&
            h().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") &&
            (function t(e, n, r) {
              if (((r = r || []), Array.isArray(e) || G(e))) {
                S(n.length > 0, function () {
                  return (
                    "Element arr[" +
                    r.join("][") +
                    "] should be a primitive, but is an array of " +
                    e.length +
                    " elements"
                  );
                }),
                  S(e.length === n[0], function () {
                    return (
                      "Element arr[" +
                      r.join("][") +
                      "] should have " +
                      n[0] +
                      " elements, but has " +
                      e.length +
                      " elements"
                    );
                  });
                for (var i = n.slice(1), a = 0; a < e.length; ++a)
                  t(e[a], i, r.concat(a));
              } else
                S(0 === n.length, function () {
                  return (
                    "Element arr[" +
                    r.join("][") +
                    "] is a primitive, but should be an array/TypedArray of " +
                    n[0] +
                    " elements"
                  );
                });
            })(t, r, []),
          r
        );
      }
      function Je(t, e, n, r) {
        if (
          null != t &&
          (("numeric" !== t && t !== e) || ("numeric" === t && "string" === e))
        )
          throw new Error(
            "Argument '" +
              n +
              "' passed to '" +
              r +
              "' must be " +
              t +
              " tensor, but got " +
              e +
              " tensor"
          );
      }
      function $e(t, e, n, r) {
        if ((void 0 === r && (r = "numeric"), t instanceof wt))
          return Je(r, t.dtype, e, n), t;
        var i = Y(t);
        if (
          ("string" !== i &&
            ["bool", "int32", "float32"].indexOf(r) >= 0 &&
            (i = r),
          Je(r, i, e, n),
          null == t ||
            (!G(t) &&
              !Array.isArray(t) &&
              "number" != typeof t &&
              "boolean" != typeof t &&
              "string" != typeof t))
        ) {
          var a = null == t ? "null" : t.constructor.name;
          throw new Error(
            "Argument '" +
              e +
              "' passed to '" +
              n +
              "' must be a Tensor or TensorLike, but got '" +
              a +
              "'"
          );
        }
        var o = Ye(t, i);
        G(t) || Array.isArray(t) || (t = [t]);
        var s = "string" !== i ? tt(t, i, h().getBool("DEBUG")) : k(t, [], !0);
        return Pt.makeTensor(s, o, i);
      }
      function Qe(t, e, n, r) {
        if ((void 0 === r && (r = "numeric"), !Array.isArray(t)))
          throw new Error(
            "Argument " +
              e +
              " passed to " +
              n +
              " must be a `Tensor[]` or `TensorLike[]`"
          );
        return t.map(function (t, r) {
          return $e(t, e + "[" + r + "]", n);
        }, r);
      }
      function tn(t, e) {
        for (var n = 0; n < t.length; ++n)
          if (t[t.length - n - 1] !== e - 1 - n) return !1;
        return !0;
      }
      function en(t, e, n) {
        for (
          var r = t.length + e.length, i = [], a = 0, o = 0, s = 0;
          s < r;
          s++
        )
          -1 === n.indexOf(s) ? i.push(t[a++]) : i.push(e[o++]);
        return i;
      }
      function nn(t, e) {
        for (var n = [], r = t.length, i = 0; i < r; i++)
          -1 === e.indexOf(i) && n.push(t[i]);
        return [
          n,
          e.map(function (e) {
            return t[e];
          }),
        ];
      }
      function rn(t, e) {
        return en(
          t,
          e.map(function (t) {
            return 1;
          }),
          e
        );
      }
      function an(t, e, n) {
        S(tn(e, n), function () {
          return (
            t +
            " supports only inner-most axes for now. Got axes " +
            e +
            " and rank-" +
            n +
            " input."
          );
        });
      }
      function on(t, e) {
        if (tn(t, e)) return null;
        for (var n = [], r = 0; r < e; ++r) -1 === t.indexOf(r) && n.push(r);
        return (
          t.forEach(function (t) {
            return n.push(t);
          }),
          n
        );
      }
      function sn(t) {
        return t
          .map(function (t, e) {
            return [e, t];
          })
          .sort(function (t, e) {
            return t[1] - e[1];
          })
          .map(function (t) {
            return t[0];
          });
      }
      function un(t, e) {
        for (var n = [], r = e - t; r < e; ++r) n.push(r);
        return n;
      }
      function cn(t, e) {
        var n = t[0].length;
        t.forEach(function (t, e) {
          S(t.length === n, function () {
            return (
              "Error in concat" +
              n +
              "D: rank of tensors[" +
              e +
              "] must be the same as the rank of the rest (" +
              n +
              ")"
            );
          });
        }),
          S(e >= 0 && e < n, function () {
            return (
              "Error in concat" +
              n +
              "D: axis must be between 0 and " +
              (n - 1) +
              "."
            );
          });
        var r = t[0];
        t.forEach(function (t, i) {
          for (var a = 0; a < n; a++)
            S(a === e || t[a] === r[a], function () {
              return (
                "Error in concat" +
                n +
                "D: Shape of tensors[" +
                i +
                "] (" +
                t +
                ") does not match the shape of the rest (" +
                r +
                ") along the non-concatenated axis " +
                i +
                "."
              );
            });
        });
      }
      function ln(t, e) {
        for (var n = t[0].slice(), r = 1; r < t.length; r++) n[e] += t[r][e];
        return n;
      }
      function pn(t) {
        var e = Object.keys(t);
        if (1 !== e.length)
          throw new Error(
            "Please provide an object with a single key (operation name) mapping to a function. Got an object with " +
              e.length +
              " keys."
          );
        var n = e[0],
          r = t[n];
        n.endsWith("_") && (n = n.substring(0, n.length - 1));
        var i = function () {
          for (var t = [], e = 0; e < arguments.length; e++)
            t[e] = arguments[e];
          Pt.startScope(n);
          try {
            var i = r.apply(void 0, t);
            return (
              i instanceof Promise &&
                console.error("Cannot return a Promise inside of tidy."),
              Pt.endScope(i),
              i
            );
          } catch (t) {
            throw (Pt.endScope(null), t);
          }
        };
        return (
          Object.defineProperty(i, "name", { value: n, configurable: !0 }), i
        );
      }
      We.registerFlag("HAS_WEBGL", function () {
        return We.getNumber("WEBGL_VERSION") > 0;
      }),
        We.registerFlag("WEBGL_VERSION", function () {
          return Me(2) ? 2 : Me(1) ? 1 : 0;
        }),
        We.registerFlag("WEBGL_BUFFER_SUPPORTED", function () {
          return 2 === We.get("WEBGL_VERSION");
        }),
        We.registerFlag("WEBGL_CPU_FORWARD", function () {
          return !0;
        }),
        We.registerFlag("WEBGL_FORCE_F16_TEXTURES", function () {
          return !1;
        }),
        We.registerFlag("WEBGL_PACK", function () {
          return We.getBool("HAS_WEBGL");
        }),
        We.registerFlag("WEBGL_PACK_NORMALIZATION", function () {
          return We.getBool("WEBGL_PACK");
        }),
        We.registerFlag("WEBGL_PACK_CLIP", function () {
          return We.getBool("WEBGL_PACK");
        }),
        We.registerFlag("WEBGL_PACK_DEPTHWISECONV", function () {
          return !1;
        }),
        We.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", function () {
          return We.getBool("WEBGL_PACK");
        }),
        We.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", function () {
          return We.getBool("WEBGL_PACK");
        }),
        We.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", function () {
          return We.getBool("WEBGL_PACK");
        }),
        We.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", function () {
          return We.getBool("WEBGL_PACK");
        }),
        We.registerFlag("WEBGL_PACK_REDUCE", function () {
          return We.getBool("WEBGL_PACK");
        }),
        We.registerFlag("WEBGL_LAZILY_UNPACK", function () {
          return We.getBool("WEBGL_PACK");
        }),
        We.registerFlag("WEBGL_CONV_IM2COL", function () {
          return We.getBool("WEBGL_PACK");
        }),
        We.registerFlag("WEBGL_MAX_TEXTURE_SIZE", function () {
          return Te(We.getNumber("WEBGL_VERSION"));
        }),
        We.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", function () {
          return Re(We.getNumber("WEBGL_VERSION"));
        }),
        We.registerFlag(
          "WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",
          function () {
            var t = We.getNumber("WEBGL_VERSION");
            return 0 === t ? 0 : De(t);
          }
        ),
        We.registerFlag(
          "WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",
          function () {
            return (
              We.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") >
                0 &&
              ((t = navigator.userAgent || navigator.vendor || window.opera),
              !(
                /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(
                  t
                ) ||
                /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
                  t.substr(0, 4)
                )
              ))
            );
            var t;
          }
        ),
        We.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", function () {
          return je(We.getNumber("WEBGL_VERSION"));
        }),
        We.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", function () {
          return (
            !We.getBool("WEBGL_FORCE_F16_TEXTURES") &&
            We.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")
          );
        }),
        We.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", function () {
          return Pe(We.getNumber("WEBGL_VERSION"));
        }),
        We.registerFlag("WEBGL_FENCE_API_ENABLED", function () {
          return Le(We.getNumber("WEBGL_VERSION"));
        }),
        We.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", function () {
          return We.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0;
        }),
        (bt = Ve);
      var hn = pn({
          complex_: function (t, e) {
            var n = $e(t, "real", "complex"),
              r = $e(e, "imag", "complex");
            return (
              N(
                n.shape,
                r.shape,
                "real and imag shapes, " +
                  n.shape +
                  " and " +
                  r.shape +
                  ", must match in call to tf.complex()."
              ),
              Pt.runKernelFunc(
                function (t) {
                  return t.complex(n, r);
                },
                { $real: n, $imag: r }
              )
            );
          },
        }),
        fn = pn({
          real_: function (t) {
            var e = $e(t, "input", "real");
            return Pt.runKernelFunc(
              function (t) {
                return t.real(e);
              },
              { $input: e }
            );
          },
        }),
        dn = pn({
          imag_: function (t) {
            var e = $e(t, "input", "imag");
            return Pt.runKernelFunc(
              function (t) {
                return t.imag(e);
              },
              { $input: e }
            );
          },
        });
      function mn(t, e, n) {
        return vn(t, e, Ye(t, n), n);
      }
      function vn(t, e, n, r) {
        if ((null == r && (r = Y(t)), "complex64" === r))
          throw new Error(
            "Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag)."
          );
        if (
          !G(t) &&
          !Array.isArray(t) &&
          "number" != typeof t &&
          "boolean" != typeof t &&
          "string" != typeof t
        )
          throw new Error(
            "values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray"
          );
        if (null != e) {
          at(e);
          var i = _(e),
            a = _(n);
          S(i === a, function () {
            return (
              "Based on the provided shape, [" +
              e +
              "], the tensor should have " +
              i +
              " values but has " +
              a
            );
          });
          for (var o = 0; o < n.length; ++o) {
            var s = n[o],
              u = o !== n.length - 1 || s !== _(e.slice(o));
            S(n[o] === e[o] || !u, function () {
              return (
                "Error creating a new Tensor. Inferred shape (" +
                n +
                ") does not match the provided shape (" +
                e +
                "). "
              );
            });
          }
        }
        return (
          G(t) || Array.isArray(t) || (t = [t]),
          (e = e || n),
          (t = "string" !== r ? tt(t, r, h().getBool("DEBUG")) : k(t, [], !0)),
          Pt.makeTensor(t, e, r)
        );
      }
      function gn(t, e) {
        if (((G(t) && "string" !== e) || Array.isArray(t)) && "complex64" !== e)
          throw new Error(
            "Error creating a new Scalar: value must be a primitive (number|boolean|string)"
          );
        if ("string" === e && G(t) && !(t instanceof Uint8Array))
          throw new Error(
            "When making a scalar from encoded string, the value must be `Uint8Array`."
          );
        return vn(t, [], [], e);
      }
      function yn(t, e) {
        I(t);
        var n = Ye(t, e);
        if (1 !== n.length)
          throw new Error("tensor1d() requires values to be a flat/TypedArray");
        return vn(t, null, n, e);
      }
      function bn(t, e, n) {
        if ((I(t), null != e && 2 !== e.length))
          throw new Error("tensor2d() requires shape to have two numbers");
        var r = Ye(t, n);
        if (2 !== r.length && 1 !== r.length)
          throw new Error(
            "tensor2d() requires values to be number[][] or flat/TypedArray"
          );
        if (1 === r.length && null == e)
          throw new Error(
            "tensor2d() requires shape to be provided when `values` are a flat/TypedArray"
          );
        return vn(t, e, r, n);
      }
      function wn(t, e, n) {
        if ((I(t), null != e && 3 !== e.length))
          throw new Error("tensor3d() requires shape to have three numbers");
        var r = Ye(t, n);
        if (3 !== r.length && 1 !== r.length)
          throw new Error(
            "tensor3d() requires values to be number[][][] or flat/TypedArray"
          );
        if (1 === r.length && null == e)
          throw new Error(
            "tensor3d() requires shape to be provided when `values` are a flat array"
          );
        return vn(t, e, r, n);
      }
      function xn(t, e, n) {
        if ((I(t), null != e && 4 !== e.length))
          throw new Error("tensor4d() requires shape to have four numbers");
        var r = Ye(t, n);
        if (4 !== r.length && 1 !== r.length)
          throw new Error(
            "tensor4d() requires values to be number[][][][] or flat/TypedArray"
          );
        if (1 === r.length && null == e)
          throw new Error(
            "tensor4d() requires shape to be provided when `values` are a flat array"
          );
        return vn(t, e, r, n);
      }
      function Cn(t, e, n, r) {
        return void 0 === e && (e = !0), Pt.makeVariable(t, e, n, r);
      }
      function On(t, e) {
        if ((void 0 === e && (e = "float32"), "complex64" === e)) {
          var n = On(t, "float32"),
            r = En(t, "float32");
          return hn(n, r);
        }
        var i = nt(_(t), e);
        return Pt.makeTensor(i, t, e);
      }
      function En(t, e) {
        if ((void 0 === e && (e = "float32"), "complex64" === e)) {
          var n = En(t, "float32"),
            r = En(t, "float32");
          return hn(n, r);
        }
        var i = rt(_(t), e);
        return Pt.makeTensor(i, t, e);
      }
      function Sn(t, e, n) {
        return Pt.runKernelFunc(function (r) {
          return r.fill(t, e, n);
        }, {});
      }
      function Nn(t, e, n) {
        if (n <= 0) throw new Error("The number of values should be positive.");
        return Pt.runKernelFunc(function (r) {
          return r.linspace(t, e, n);
        }, {});
      }
      function In(t, e, n, r) {
        if ((void 0 === n && (n = 1), void 0 === r && (r = "float32"), 0 === n))
          throw new Error("Cannot have a step of zero");
        if (t === e || (t < e && n < 0) || (e < t && n > 1)) return En([0], r);
        var i = rt(Math.abs(Math.ceil((e - t) / n)), r);
        e < t && 1 === n && (n = -1), (i[0] = t);
        for (var a = 1; a < i.length; a++) i[a] = i[a - 1] + n;
        return yn(i, r);
      }
      var kn = pn({
          onesLike_: function (t) {
            var e = $e(t, "x", "onesLike");
            if ("complex64" === e.dtype) {
              var n = kn(fn(e)),
                r = _n(dn(e));
              return hn(n, r);
            }
            return Pt.runKernelFunc(
              function (t) {
                return t.onesLike(e);
              },
              { $x: e },
              function (t, e) {
                return {
                  $x: function () {
                    return _n(t);
                  },
                };
              }
            );
          },
        }),
        _n = pn({
          zerosLike_: function (t) {
            var e = $e(t, "x", "zerosLike");
            return Pt.runKernelFunc(
              function (t) {
                return t.zerosLike(e);
              },
              { $x: e },
              function (t, e) {
                return {
                  $x: function () {
                    return _n(t);
                  },
                };
              }
            );
          },
        }),
        An = pn({
          concat_: function (t, e) {
            void 0 === e && (e = 0),
              S(t.length >= 1, function () {
                return "Pass at least one tensor to concat";
              });
            var n = Qe(t, "tensors", "concat");
            "complex64" === n[0].dtype &&
              n.forEach(function (t) {
                if ("complex64" !== t.dtype)
                  throw new Error(
                    "Cannot concatenate complex64 tensors with a tensor\n          with dtype " +
                      t.dtype +
                      ". "
                  );
              }),
              (e = P(e, n[0].shape)[0]);
            var r = ln(
              n.map(function (t) {
                return t.shape;
              }),
              e
            );
            if (0 === _(r)) return mn([], r);
            if (
              1 ===
              (n = n.filter(function (t) {
                return t.size > 0;
              })).length
            )
              return n[0];
            var i = n.map(function (t) {
              return t.shape;
            });
            cn(i, e);
            var a = n,
              o = { axis: e };
            return Pt.runKernelFunc(
              function (t) {
                return t.concat(n, e);
              },
              a,
              function (t) {
                var n = i.map(function (t) {
                  return t[e];
                });
                return Mn(t, n, e).map(function (t) {
                  return function () {
                    return t;
                  };
                });
              },
              "Concat",
              o
            );
          },
        }),
        Tn = pn({
          concat1d_: function (t) {
            return An(t, 0);
          },
        }),
        Rn = pn({
          concat2d_: function (t, e) {
            return An(t, e);
          },
        }),
        Dn = pn({
          concat3d_: function (t, e) {
            return An(t, e);
          },
        }),
        Fn = pn({
          concat4d_: function (t, e) {
            return An(t, e);
          },
        }),
        Mn = pn({
          split_: function (t, e, n) {
            void 0 === n && (n = 0);
            var r,
              i = $e(t, "x", "split");
            return (
              (n = P(n, i.shape)[0]),
              "number" == typeof e
                ? (S(i.shape[n] % e == 0, function () {
                    return "Number of splits must evenly divide the axis.";
                  }),
                  (r = new Array(e).fill(i.shape[n] / e)))
                : (S(
                    i.shape[n] ===
                      e.reduce(function (t, e) {
                        return t + e;
                      }),
                    function () {
                      return "The sum of sizes must match the size of the axis dimension.";
                    }
                  ),
                  (r = e)),
              Pt.runKernelFunc(
                function (t) {
                  return t.split(i, r, n);
                },
                { $x: i },
                function (t) {
                  return {
                    $x: function () {
                      return An(t, n);
                    },
                  };
                }
              )
            );
          },
        });
      function jn(t, e) {
        return t((e = { exports: {} }), e.exports), e.exports;
      }
      "undefined" != typeof globalThis
        ? globalThis
        : "undefined" != typeof window
        ? window
        : void 0 !== t || ("undefined" != typeof self && self);
      var Pn = jn(function (t) {
          !(function (t, e, n) {
            function r(t) {
              var e,
                n = this,
                r =
                  ((e = 4022871197),
                  function (t) {
                    t = t.toString();
                    for (var n = 0; n < t.length; n++) {
                      var r = 0.02519603282416938 * (e += t.charCodeAt(n));
                      (r -= e = r >>> 0),
                        (e = (r *= e) >>> 0),
                        (e += 4294967296 * (r -= e));
                    }
                    return 2.3283064365386963e-10 * (e >>> 0);
                  });
              (n.next = function () {
                var t = 2091639 * n.s0 + 2.3283064365386963e-10 * n.c;
                return (n.s0 = n.s1), (n.s1 = n.s2), (n.s2 = t - (n.c = 0 | t));
              }),
                (n.c = 1),
                (n.s0 = r(" ")),
                (n.s1 = r(" ")),
                (n.s2 = r(" ")),
                (n.s0 -= r(t)),
                n.s0 < 0 && (n.s0 += 1),
                (n.s1 -= r(t)),
                n.s1 < 0 && (n.s1 += 1),
                (n.s2 -= r(t)),
                n.s2 < 0 && (n.s2 += 1),
                (r = null);
            }
            function i(t, e) {
              return (
                (e.c = t.c), (e.s0 = t.s0), (e.s1 = t.s1), (e.s2 = t.s2), e
              );
            }
            function a(t, e) {
              var n = new r(t),
                a = e && e.state,
                o = n.next;
              return (
                (o.int32 = function () {
                  return (4294967296 * n.next()) | 0;
                }),
                (o.double = function () {
                  return o() + 11102230246251565e-32 * ((2097152 * o()) | 0);
                }),
                (o.quick = o),
                a &&
                  ("object" == typeof a && i(a, n),
                  (o.state = function () {
                    return i(n, {});
                  })),
                o
              );
            }
            e && e.exports ? (e.exports = a) : (this.alea = a);
          })(0, t);
        }),
        zn = jn(function (t) {
          !(function (t, e, n) {
            function r(t) {
              var e = this,
                n = "";
              (e.x = 0),
                (e.y = 0),
                (e.z = 0),
                (e.w = 0),
                (e.next = function () {
                  var t = e.x ^ (e.x << 11);
                  return (
                    (e.x = e.y),
                    (e.y = e.z),
                    (e.z = e.w),
                    (e.w ^= (e.w >>> 19) ^ t ^ (t >>> 8))
                  );
                }),
                t === (0 | t) ? (e.x = t) : (n += t);
              for (var r = 0; r < n.length + 64; r++)
                (e.x ^= 0 | n.charCodeAt(r)), e.next();
            }
            function i(t, e) {
              return (e.x = t.x), (e.y = t.y), (e.z = t.z), (e.w = t.w), e;
            }
            function a(t, e) {
              var n = new r(t),
                a = e && e.state,
                o = function () {
                  return (n.next() >>> 0) / 4294967296;
                };
              return (
                (o.double = function () {
                  do {
                    var t =
                      ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) /
                      (1 << 21);
                  } while (0 === t);
                  return t;
                }),
                (o.int32 = n.next),
                (o.quick = o),
                a &&
                  ("object" == typeof a && i(a, n),
                  (o.state = function () {
                    return i(n, {});
                  })),
                o
              );
            }
            e && e.exports ? (e.exports = a) : (this.xor128 = a);
          })(0, t);
        }),
        Ln = jn(function (t) {
          !(function (t, e, n) {
            function r(t) {
              var e = this,
                n = "";
              (e.next = function () {
                var t = e.x ^ (e.x >>> 2);
                return (
                  (e.x = e.y),
                  (e.y = e.z),
                  (e.z = e.w),
                  (e.w = e.v),
                  ((e.d = (e.d + 362437) | 0) +
                    (e.v = e.v ^ (e.v << 4) ^ t ^ (t << 1))) |
                    0
                );
              }),
                (e.x = 0),
                (e.y = 0),
                (e.z = 0),
                (e.w = 0),
                (e.v = 0),
                t === (0 | t) ? (e.x = t) : (n += t);
              for (var r = 0; r < n.length + 64; r++)
                (e.x ^= 0 | n.charCodeAt(r)),
                  r == n.length && (e.d = (e.x << 10) ^ (e.x >>> 4)),
                  e.next();
            }
            function i(t, e) {
              return (
                (e.x = t.x),
                (e.y = t.y),
                (e.z = t.z),
                (e.w = t.w),
                (e.v = t.v),
                (e.d = t.d),
                e
              );
            }
            function a(t, e) {
              var n = new r(t),
                a = e && e.state,
                o = function () {
                  return (n.next() >>> 0) / 4294967296;
                };
              return (
                (o.double = function () {
                  do {
                    var t =
                      ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) /
                      (1 << 21);
                  } while (0 === t);
                  return t;
                }),
                (o.int32 = n.next),
                (o.quick = o),
                a &&
                  ("object" == typeof a && i(a, n),
                  (o.state = function () {
                    return i(n, {});
                  })),
                o
              );
            }
            e && e.exports ? (e.exports = a) : (this.xorwow = a);
          })(0, t);
        }),
        Bn = jn(function (t) {
          !(function (t, e, n) {
            function r(t) {
              var e = this;
              (e.next = function () {
                var t,
                  n,
                  r = e.x,
                  i = e.i;
                return (
                  (t = r[i]),
                  (n = (t ^= t >>> 7) ^ (t << 24)),
                  (n ^= (t = r[(i + 1) & 7]) ^ (t >>> 10)),
                  (n ^= (t = r[(i + 3) & 7]) ^ (t >>> 3)),
                  (n ^= (t = r[(i + 4) & 7]) ^ (t << 7)),
                  (t = r[(i + 7) & 7]),
                  (n ^= (t ^= t << 13) ^ (t << 9)),
                  (r[i] = n),
                  (e.i = (i + 1) & 7),
                  n
                );
              }),
                (function (t, e) {
                  var n,
                    r = [];
                  if (e === (0 | e)) r[0] = e;
                  else
                    for (e = "" + e, n = 0; n < e.length; ++n)
                      r[7 & n] =
                        (r[7 & n] << 15) ^
                        ((e.charCodeAt(n) + r[(n + 1) & 7]) << 13);
                  for (; r.length < 8; ) r.push(0);
                  for (n = 0; n < 8 && 0 === r[n]; ++n);
                  for (
                    8 == n ? (r[7] = -1) : r[n], t.x = r, t.i = 0, n = 256;
                    n > 0;
                    --n
                  )
                    t.next();
                })(e, t);
            }
            function i(t, e) {
              return (e.x = t.x.slice()), (e.i = t.i), e;
            }
            function a(t, e) {
              null == t && (t = +new Date());
              var n = new r(t),
                a = e && e.state,
                o = function () {
                  return (n.next() >>> 0) / 4294967296;
                };
              return (
                (o.double = function () {
                  do {
                    var t =
                      ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) /
                      (1 << 21);
                  } while (0 === t);
                  return t;
                }),
                (o.int32 = n.next),
                (o.quick = o),
                a &&
                  (a.x && i(a, n),
                  (o.state = function () {
                    return i(n, {});
                  })),
                o
              );
            }
            e && e.exports ? (e.exports = a) : (this.xorshift7 = a);
          })(0, t);
        }),
        Wn = jn(function (t) {
          !(function (t, e, n) {
            function r(t) {
              var e = this;
              (e.next = function () {
                var t,
                  n,
                  r = e.w,
                  i = e.X,
                  a = e.i;
                return (
                  (e.w = r = (r + 1640531527) | 0),
                  (n = i[(a + 34) & 127]),
                  (t = i[(a = (a + 1) & 127)]),
                  (n ^= n << 13),
                  (t ^= t << 17),
                  (n ^= n >>> 15),
                  (t ^= t >>> 12),
                  (n = i[a] = n ^ t),
                  (e.i = a),
                  (n + (r ^ (r >>> 16))) | 0
                );
              }),
                (function (t, e) {
                  var n,
                    r,
                    i,
                    a,
                    o,
                    s = [],
                    u = 128;
                  for (
                    e === (0 | e)
                      ? ((r = e), (e = null))
                      : ((e += "\0"), (r = 0), (u = Math.max(u, e.length))),
                      i = 0,
                      a = -32;
                    a < u;
                    ++a
                  )
                    e && (r ^= e.charCodeAt((a + 32) % e.length)),
                      0 === a && (o = r),
                      (r ^= r << 10),
                      (r ^= r >>> 15),
                      (r ^= r << 4),
                      (r ^= r >>> 13),
                      a >= 0 &&
                        ((o = (o + 1640531527) | 0),
                        (i = 0 == (n = s[127 & a] ^= r + o) ? i + 1 : 0));
                  for (
                    i >= 128 && (s[127 & ((e && e.length) || 0)] = -1),
                      i = 127,
                      a = 512;
                    a > 0;
                    --a
                  )
                    (r = s[(i + 34) & 127]),
                      (n = s[(i = (i + 1) & 127)]),
                      (r ^= r << 13),
                      (n ^= n << 17),
                      (r ^= r >>> 15),
                      (n ^= n >>> 12),
                      (s[i] = r ^ n);
                  (t.w = o), (t.X = s), (t.i = i);
                })(e, t);
            }
            function i(t, e) {
              return (e.i = t.i), (e.w = t.w), (e.X = t.X.slice()), e;
            }
            function a(t, e) {
              null == t && (t = +new Date());
              var n = new r(t),
                a = e && e.state,
                o = function () {
                  return (n.next() >>> 0) / 4294967296;
                };
              return (
                (o.double = function () {
                  do {
                    var t =
                      ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) /
                      (1 << 21);
                  } while (0 === t);
                  return t;
                }),
                (o.int32 = n.next),
                (o.quick = o),
                a &&
                  (a.X && i(a, n),
                  (o.state = function () {
                    return i(n, {});
                  })),
                o
              );
            }
            e && e.exports ? (e.exports = a) : (this.xor4096 = a);
          })(0, t);
        }),
        Un = jn(function (t) {
          !(function (t, e, n) {
            function r(t) {
              var e = this,
                n = "";
              (e.next = function () {
                var t = e.b,
                  n = e.c,
                  r = e.d,
                  i = e.a;
                return (
                  (t = (t << 25) ^ (t >>> 7) ^ n),
                  (n = (n - r) | 0),
                  (r = (r << 24) ^ (r >>> 8) ^ i),
                  (i = (i - t) | 0),
                  (e.b = t = (t << 20) ^ (t >>> 12) ^ n),
                  (e.c = n = (n - r) | 0),
                  (e.d = (r << 16) ^ (n >>> 16) ^ i),
                  (e.a = (i - t) | 0)
                );
              }),
                (e.a = 0),
                (e.b = 0),
                (e.c = -1640531527),
                (e.d = 1367130551),
                t === Math.floor(t)
                  ? ((e.a = (t / 4294967296) | 0), (e.b = 0 | t))
                  : (n += t);
              for (var r = 0; r < n.length + 20; r++)
                (e.b ^= 0 | n.charCodeAt(r)), e.next();
            }
            function i(t, e) {
              return (e.a = t.a), (e.b = t.b), (e.c = t.c), (e.d = t.d), e;
            }
            function a(t, e) {
              var n = new r(t),
                a = e && e.state,
                o = function () {
                  return (n.next() >>> 0) / 4294967296;
                };
              return (
                (o.double = function () {
                  do {
                    var t =
                      ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) /
                      (1 << 21);
                  } while (0 === t);
                  return t;
                }),
                (o.int32 = n.next),
                (o.quick = o),
                a &&
                  ("object" == typeof a && i(a, n),
                  (o.state = function () {
                    return i(n, {});
                  })),
                o
              );
            }
            e && e.exports ? (e.exports = a) : (this.tychei = a);
          })(0, t);
        }),
        Vn = jn(function (t) {
          !(function (e, r) {
            var i,
              a = this,
              o = 256,
              s = "random",
              u = r.pow(o, 6),
              c = r.pow(2, 52),
              l = 2 * c,
              p = 255;
            function h(t, n, p) {
              var h = [],
                g = m(
                  (function t(e, n) {
                    var r,
                      i = [],
                      a = typeof e;
                    if (n && "object" == a)
                      for (r in e)
                        try {
                          i.push(t(e[r], n - 1));
                        } catch (t) {}
                    return i.length ? i : "string" == a ? e : e + "\0";
                  })(
                    (n = 1 == n ? { entropy: !0 } : n || {}).entropy
                      ? [t, v(e)]
                      : null == t
                      ? (function () {
                          try {
                            var t;
                            return (
                              i && (t = i.randomBytes)
                                ? (t = t(o))
                                : ((t = new Uint8Array(o)),
                                  (a.crypto || a.msCrypto).getRandomValues(t)),
                              v(t)
                            );
                          } catch (t) {
                            var n = a.navigator,
                              r = n && n.plugins;
                            return [+new Date(), a, r, a.screen, v(e)];
                          }
                        })()
                      : t,
                    3
                  ),
                  h
                ),
                y = new f(h),
                b = function () {
                  for (var t = y.g(6), e = u, n = 0; t < c; )
                    (t = (t + n) * o), (e *= o), (n = y.g(1));
                  for (; t >= l; ) (t /= 2), (e /= 2), (n >>>= 1);
                  return (t + n) / e;
                };
              return (
                (b.int32 = function () {
                  return 0 | y.g(4);
                }),
                (b.quick = function () {
                  return y.g(4) / 4294967296;
                }),
                (b.double = b),
                m(v(y.S), e),
                (
                  n.pass ||
                  p ||
                  function (t, e, n, i) {
                    return (
                      i &&
                        (i.S && d(i, y),
                        (t.state = function () {
                          return d(y, {});
                        })),
                      n ? ((r[s] = t), e) : t
                    );
                  }
                )(b, g, "global" in n ? n.global : this == r, n.state)
              );
            }
            function f(t) {
              var e,
                n = t.length,
                r = this,
                i = 0,
                a = (r.i = r.j = 0),
                s = (r.S = []);
              for (n || (t = [n++]); i < o; ) s[i] = i++;
              for (i = 0; i < o; i++)
                (s[i] = s[(a = p & (a + t[i % n] + (e = s[i])))]), (s[a] = e);
              (r.g = function (t) {
                for (var e, n = 0, i = r.i, a = r.j, s = r.S; t--; )
                  (e = s[(i = p & (i + 1))]),
                    (n =
                      n * o +
                      s[p & ((s[i] = s[(a = p & (a + e))]) + (s[a] = e))]);
                return (r.i = i), (r.j = a), n;
              })(o);
            }
            function d(t, e) {
              return (e.i = t.i), (e.j = t.j), (e.S = t.S.slice()), e;
            }
            function m(t, e) {
              for (var n, r = t + "", i = 0; i < r.length; )
                e[p & i] = p & ((n ^= 19 * e[p & i]) + r.charCodeAt(i++));
              return v(e);
            }
            function v(t) {
              return String.fromCharCode.apply(0, t);
            }
            if (((r.seedrandom = h), m(r.random(), e), t.exports)) {
              t.exports = h;
              try {
                i = n(17);
              } catch (t) {}
            }
          })([], Math);
        });
      (Vn.alea = Pn),
        (Vn.xor128 = zn),
        (Vn.xorwow = Ln),
        (Vn.xorshift7 = Bn),
        (Vn.xor4096 = Wn),
        (Vn.tychei = Un);
      var Gn = Vn.alea,
        Hn = (function () {
          function t(t, e, n, r, i) {
            (this.mean = t),
              (this.stdDev = e),
              (this.dtype = n),
              (this.nextVal = NaN),
              (this.truncated = r),
              this.truncated &&
                ((this.upper = this.mean + 2 * this.stdDev),
                (this.lower = this.mean - 2 * this.stdDev));
            var a = i || Math.random();
            this.random = Gn(a.toString());
          }
          return (
            (t.prototype.nextValue = function () {
              if (!isNaN(this.nextVal)) {
                var t = this.nextVal;
                return (this.nextVal = NaN), t;
              }
              for (var e, n, r = !1; !r; ) {
                var i = void 0,
                  a = void 0,
                  o = void 0;
                do {
                  o =
                    (i = 2 * this.random() - 1) * i +
                    (a = 2 * this.random() - 1) * a;
                } while (o >= 1 || 0 === o);
                var s = Math.sqrt((-2 * Math.log(o)) / o);
                (e = this.mean + this.stdDev * i * s),
                  (n = this.mean + this.stdDev * a * s),
                  (this.truncated && !this.isValidTruncated(e)) || (r = !0);
              }
              return (
                (this.truncated && !this.isValidTruncated(n)) ||
                  (this.nextVal = this.convertValue(n)),
                this.convertValue(e)
              );
            }),
            (t.prototype.convertValue = function (t) {
              return null == this.dtype || "float32" === this.dtype
                ? t
                : Math.round(t);
            }),
            (t.prototype.isValidTruncated = function (t) {
              return t <= this.upper && t >= this.lower;
            }),
            t
          );
        })(),
        qn = (function () {
          function t(t, e, n, r) {
            (this.alpha = t), (this.beta = 1 / e), (this.dtype = n);
            var i = r || Math.random();
            (this.randu = Gn(i.toString())),
              (this.randn = new Hn(0, 1, n, !1, this.randu())),
              (this.d = t < 1 ? t + 2 / 3 : t - 1 / 3),
              (this.c = 1 / Math.sqrt(9 * this.d));
          }
          return (
            (t.prototype.nextValue = function () {
              for (var t, e, n, r, i, a; ; ) {
                do {
                  (r = this.randn.nextValue()), (a = 1 + this.c * r);
                } while (a <= 0);
                if (
                  ((a *= a * a),
                  (e = 1 - 0.331 * (t = r * r) * t),
                  (n = 0.5 * t + this.d * (1 - a + Math.log(a))),
                  (i = this.randu()) < e || Math.log(i) < n)
                )
                  break;
              }
              return (
                (a = (1 / this.beta) * this.d * a),
                this.alpha < 1 && (a *= Math.pow(this.randu(), 1 / this.alpha)),
                this.convertValue(a)
              );
            }),
            (t.prototype.convertValue = function (t) {
              return "float32" === this.dtype ? t : Math.round(t);
            }),
            t
          );
        })(),
        Kn = (function () {
          function t(t, e, n, r) {
            var i = this;
            if (
              (void 0 === t && (t = 0),
              void 0 === e && (e = 1),
              (this.canReturnFloat = function () {
                return null == i.dtype || "float32" === i.dtype;
              }),
              (this.min = t),
              (this.range = e - t),
              (this.dtype = n),
              null == r && (r = Math.random()),
              "number" == typeof r && (r = r.toString()),
              !this.canReturnFloat() && this.range <= 1)
            )
              throw new Error(
                "The difference between " +
                  t +
                  " - " +
                  e +
                  " <= 1 and dtype is not float"
              );
            this.random = Gn(r);
          }
          return (
            (t.prototype.convertValue = function (t) {
              return this.canReturnFloat() ? t : Math.round(t);
            }),
            (t.prototype.nextValue = function () {
              return this.convertValue(this.min + this.range * this.random());
            }),
            t
          );
        })();
      function Zn(t, e, n) {
        return (
          void 0 === e && (e = "float32"),
          (e = e || "float32"),
          at(t),
          new vt(t, e, n)
        );
      }
      var Xn = pn({
          batchToSpaceND_: function (t, e, n) {
            var r = $e(t, "x", "batchToSpaceND"),
              i = e.reduce(function (t, e) {
                return t * e;
              });
            return (
              S(r.rank >= 1 + e.length, function () {
                return (
                  "input rank is " +
                  r.rank +
                  " but should be > than blockShape.length " +
                  e.length
                );
              }),
              S(n.length === e.length, function () {
                return (
                  "crops.length is " +
                  n.length +
                  " but should be equal to blockShape.length  " +
                  e.length
                );
              }),
              S(r.shape[0] % i == 0, function () {
                return (
                  "input tensor batch is " +
                  r.shape[0] +
                  " but is not divisible by the product of the elements of blockShape " +
                  e.join(" * ") +
                  " === " +
                  i
                );
              }),
              Pt.runKernelFunc(
                function (t) {
                  return t.batchToSpaceND(r, e, n);
                },
                { $x: r },
                function (t) {
                  return {
                    $x: function () {
                      return t.spaceToBatchND(e, n);
                    },
                  };
                }
              )
            );
          },
        }),
        Yn = pn({
          broadcastTo_: function (t, e) {
            var n = $e(t, "broadcastTo", "x"),
              r = n.shape;
            if (
              e.some(function (t) {
                return !(t > 0) || t % 1 != 0;
              })
            )
              throw new Error(
                "broadcastTo(): Invalid broadcast shape [" + e + "]."
              );
            if (e.length < n.rank)
              throw new Error(
                "broadcastTo(): shape.length=" +
                  e.length +
                  " < input.rank=" +
                  n.rank +
                  "."
              );
            if (e.length > n.rank) {
              for (var i = n.shape.slice(); i.length < e.length; ) i.unshift(1);
              n = n.reshape(i);
            }
            for (var a = Array.from(e), o = e.length - 1; o >= 0; o--)
              if (n.shape[o] === e[o]) a[o] = 1;
              else if (1 !== n.shape[o])
                throw new Error(
                  "broadcastTo(): [" +
                    r +
                    "] cannot be broadcast to [" +
                    e +
                    "]."
                );
            var s = a
              .map(function (t, e) {
                return t > 1 ? e : -1;
              })
              .filter(function (t) {
                return t >= 0;
              });
            return 0 === s.length
              ? n.clone()
              : Pt.runKernelFunc(
                  function (t) {
                    return t.tile(n, a);
                  },
                  { input: n },
                  function (t) {
                    return {
                      input: function () {
                        return t.sum(s, !0);
                      },
                    };
                  }
                );
          },
        }),
        Jn = pn({
          cast_: function (t, e) {
            var n = $e(t, "x", "cast");
            if (!U(e)) throw new Error("Failed to cast to unknown dtype " + e);
            if (
              ("string" === e && "string" !== n.dtype) ||
              ("string" !== e && "string" === n.dtype)
            )
              throw new Error("Only strings can be casted to strings");
            var r = { dtype: e };
            return Pt.runKernelFunc(
              function (t) {
                return t.cast(n, e);
              },
              { x: n },
              function (t) {
                return {
                  x: function () {
                    return t.clone();
                  },
                };
              },
              "Cast",
              r
            );
          },
        }),
        $n = pn({
          clone_: function (t) {
            var e = $e(t, "x", "clone", null);
            return Pt.runKernelFunc(
              function () {
                return Pt.makeTensorFromDataId(e.dataId, e.shape, e.dtype);
              },
              { $x: e },
              function (t) {
                return {
                  $x: function () {
                    return t.toFloat();
                  },
                };
              }
            );
          },
        }),
        Qn = pn({
          cumsum_: function (t, e, n, r) {
            void 0 === e && (e = 0),
              void 0 === n && (n = !1),
              void 0 === r && (r = !1);
            var i = $e(t, "x", "cumsum"),
              a = on([(e |= 0)], i.rank),
              o = i;
            null != a && (o = i.transpose(a));
            var s = un(1, i.rank)[0],
              u = Pt.runKernelFunc(
                function (t) {
                  return t.cumsum(o, s, n, r);
                },
                { permutedX: o },
                function (t) {
                  return {
                    permutedX: function () {
                      return t.cumsum(e, n, !r);
                    },
                  };
                }
              );
            return null != a && (u = u.transpose(a)), u;
          },
        }),
        tr = pn({
          depthToSpace_: function (t, e, n) {
            void 0 === n && (n = "NHWC");
            var r = $e(t, "x", "depthToSpace"),
              i = "NHWC" === n ? r.shape[1] : r.shape[2],
              a = "NHWC" === n ? r.shape[2] : r.shape[3],
              o = "NHWC" === n ? r.shape[3] : r.shape[1];
            return (
              S(i * e >= 0, function () {
                return (
                  "Negative dimension size caused by overflow when multiplying\n      " +
                  i +
                  " and " +
                  e +
                  "  for depthToSpace with input shape\n      " +
                  r.shape
                );
              }),
              S(a * e >= 0, function () {
                return (
                  "Negative dimension size caused by overflow when multiplying\n      " +
                  a +
                  " and " +
                  e +
                  " for depthToSpace with input shape\n          " +
                  r.shape
                );
              }),
              S(o % (e * e) == 0, function () {
                return (
                  "Dimension size must be evenly divisible by " +
                  e * e +
                  " but is " +
                  o +
                  " for depthToSpace with input shape " +
                  r.shape
                );
              }),
              Pt.runKernelFunc(
                function (t) {
                  return t.depthToSpace(r, e, n);
                },
                { $x: r }
              )
            );
          },
        }),
        er = pn({
          expandDims_: function (t, e) {
            void 0 === e && (e = 0);
            var n = $e(t, "x", "expandDims", null);
            S(e <= n.rank, function () {
              return "Axis must be <= rank of the tensor";
            });
            var r = n.shape.slice();
            return (
              e < 0 &&
                (S(-(n.rank + 1) <= e, function () {
                  return (
                    "Axis must be in the interval [" +
                    -(n.rank + 1) +
                    ", " +
                    n.rank +
                    "]"
                  );
                }),
                (e = n.rank + e + 1)),
              r.splice(e, 0, 1),
              dr(n, r)
            );
          },
        }),
        nr = pn({
          eye_: function (t, e, n, r) {
            void 0 === r && (r = "float32"), null == e && (e = t);
            for (var i = Zn([t, e], r), a = t <= e ? t : e, o = 0; o < a; ++o)
              i.set(1, o, o);
            var s = i.toTensor().as2D(t, e);
            if (null == n) return s;
            if (1 === n.length) return yr(er(s, 0), [n[0], 1, 1]);
            if (2 === n.length) return yr(er(er(s, 0), 0), [n[0], n[1], 1, 1]);
            if (3 === n.length)
              return yr(er(er(er(s, 0), 0), 0), [n[0], n[1], n[2], 1, 1]);
            throw new Error(
              "eye() currently supports only 1D and 2D batchShapes, but received " +
                n.length +
                "D."
            );
          },
        }),
        rr = pn({
          multinomial_: function (t, e, n, r) {
            void 0 === r && (r = !1);
            var i = $e(t, "logits", "multinomial"),
              a = i.size,
              o = i.rank;
            if (a < 2)
              throw new Error(
                "Error in multinomial: you need at least 2 outcomes, but got " +
                  a +
                  "."
              );
            if (o > 2)
              throw new Error(
                "Rank of probabilities must be 1 or 2, but is " + o
              );
            n = n || Math.random();
            var s = 1 === o ? i.as2D(1, -1) : i,
              u = Pt.runKernelFunc(
                function (t) {
                  return t.multinomial(s, r, e, n);
                },
                { logits2D: s }
              );
            return 1 === o ? u.as1D() : u;
          },
        }),
        ir = pn({
          oneHot_: function (t, e, n, r) {
            if ((void 0 === n && (n = 1), void 0 === r && (r = 0), e < 2))
              throw new Error(
                "Error in oneHot: depth must be >=2, but it is " + e
              );
            var i = $e(t, "indices", "oneHot", "int32"),
              a = i.shape.concat([e]);
            return (
              (i = i.flatten()),
              Pt.runKernelFunc(
                function (t) {
                  return t.oneHot(i, e, n, r);
                },
                { $indices: i },
                function (t) {
                  return {
                    $indices: function () {
                      return En(i.shape, "float32");
                    },
                  };
                }
              ).reshape(a)
            );
          },
        }),
        ar = pn({
          pad_: function (t, e, n) {
            void 0 === n && (n = 0);
            var r = $e(t, "x", "pad");
            if (0 === r.rank)
              throw new Error(
                "pad(scalar) is not defined. Pass non-scalar to pad"
              );
            var i = { paddings: e, constantValue: n };
            return Pt.runKernelFunc(
              function (t) {
                return t.pad(r, e, n);
              },
              { x: r },
              function (t) {
                var n = e.map(function (t) {
                  return t[0];
                });
                return {
                  x: function () {
                    return t.slice(n, r.shape);
                  },
                };
              },
              "PadV2",
              i
            );
          },
        }),
        or = pn({
          pad1d_: function (t, e, n) {
            return (
              void 0 === n && (n = 0),
              S(2 === e.length, function () {
                return "Invalid number of paddings. Must be length of 2.";
              }),
              ar(t, [e], n)
            );
          },
        }),
        sr = pn({
          pad2d_: function (t, e, n) {
            return (
              void 0 === n && (n = 0),
              S(
                2 === e.length && 2 === e[0].length && 2 === e[1].length,
                function () {
                  return "Invalid number of paddings. Must be length of 2 each.";
                }
              ),
              ar(t, e, n)
            );
          },
        }),
        ur = pn({
          pad3d_: function (t, e, n) {
            return (
              void 0 === n && (n = 0),
              S(
                3 === e.length &&
                  2 === e[0].length &&
                  2 === e[1].length &&
                  2 === e[2].length,
                function () {
                  return "Invalid number of paddings. Must be length of 2 each.";
                }
              ),
              ar(t, e, n)
            );
          },
        }),
        cr = pn({
          pad4d_: function (t, e, n) {
            return (
              void 0 === n && (n = 0),
              S(
                4 === e.length &&
                  2 === e[0].length &&
                  2 === e[1].length &&
                  2 === e[2].length &&
                  2 === e[3].length,
                function () {
                  return "Invalid number of paddings. Must be length of 2 each.";
                }
              ),
              ar(t, e, n)
            );
          },
        }),
        lr = pn({
          rand_: function (t, e, n) {
            var r = _(t),
              i = null;
            if (null == n || "float32" === n) i = new Float32Array(r);
            else if ("int32" === n) i = new Int32Array(r);
            else {
              if ("bool" !== n) throw new Error("Unknown data type " + n);
              i = new Uint8Array(r);
            }
            for (var a = 0; a < r; a++) i[a] = e();
            return Pt.makeTensor(i, t, n);
          },
        }),
        pr = pn({
          randomNormal_: function (t, e, n, r, i) {
            if (
              (void 0 === e && (e = 0),
              void 0 === n && (n = 1),
              null != r && "bool" === r)
            )
              throw new Error("Unsupported data type " + r);
            for (
              var a = new Hn(e, n, r, !1, i), o = Zn(t, r), s = 0;
              s < o.values.length;
              s++
            )
              o.values[s] = a.nextValue();
            return o.toTensor();
          },
        }),
        hr = pn({
          randomGamma_: function (t, e, n, r, i) {
            if (
              (void 0 === n && (n = 1),
              void 0 === r && (r = "float32"),
              null == n && (n = 1),
              null == r && (r = "float32"),
              "float32" !== r && "int32" !== r)
            )
              throw new Error("Unsupported data type " + r);
            for (
              var a = new qn(e, n, r, i), o = Zn(t, r), s = 0;
              s < o.values.length;
              s++
            )
              o.values[s] = a.nextValue();
            return o.toTensor();
          },
        }),
        fr = pn({
          randomUniform_: function (t, e, n, r, i) {
            void 0 === e && (e = 0),
              void 0 === n && (n = 1),
              void 0 === r && (r = "float32");
            for (
              var a = Zn(t, r), o = new Kn(e, n, null, i), s = 0;
              s < a.values.length;
              s++
            )
              a.values[s] = o.nextValue();
            return a.toTensor();
          },
        }),
        dr = pn({
          reshape_: function (t, e) {
            var n = $e(t, "x", "reshape", null);
            (e = j(e, n.size)),
              S(n.size === _(e), function () {
                return "new shape and old shape must have the same number of elements.";
              });
            var r = { shape: e };
            return Pt.runKernelFunc(
              function (t) {
                return t.reshape(n, e);
              },
              { x: n },
              function (t) {
                return {
                  x: function () {
                    return t.reshape(n.shape);
                  },
                };
              },
              "Reshape",
              r
            );
          },
        }),
        mr = pn({
          spaceToBatchND_: function (t, e, n) {
            var r = $e(t, "x", "spaceToBatchND");
            return (
              S(r.rank >= 1 + e.length, function () {
                return (
                  "input rank " +
                  r.rank +
                  " should be > than [blockShape] " +
                  e.length
                );
              }),
              S(n.length === e.length, function () {
                return (
                  "paddings.shape[0] " +
                  n.length +
                  " must be equal to [blockShape] " +
                  e.length
                );
              }),
              S(
                r.shape.reduce(function (t, r, i) {
                  return i > 0 && i <= e.length
                    ? t && (r + n[i - 1][0] + n[i - 1][1]) % e[i - 1] == 0
                    : t;
                }, !0),
                function () {
                  return (
                    "input spatial dimensions " +
                    r.shape.slice(1) +
                    " with paddings " +
                    n.toString() +
                    " must be divisible by blockShapes " +
                    e.toString()
                  );
                }
              ),
              Pt.runKernelFunc(
                function (t) {
                  return t.spaceToBatchND(r, e, n);
                },
                { $x: r },
                function (t) {
                  return {
                    $x: function () {
                      return t.batchToSpaceND(e, n);
                    },
                  };
                }
              )
            );
          },
        }),
        vr = pn({
          squeeze_: function (t, e) {
            var n = $e(t, "x", "squeeze");
            return dr(n, z(n.shape, e).newShape);
          },
        }),
        gr = pn({
          stack_: function (t, e) {
            void 0 === e && (e = 0);
            var n = Qe(t, "tensors", "stack");
            if (
              (S(n.length >= 1, function () {
                return "Pass at least one tensor to tf.stack";
              }),
              1 === n.length)
            )
              return n[0].expandDims(e);
            var r = n[0].rank,
              i = n[0].shape,
              a = n[0].dtype;
            S(e <= r, function () {
              return "Axis must be <= rank of the tensor";
            }),
              n.forEach(function (t) {
                N(
                  i,
                  t.shape,
                  "All tensors passed to stack must have matching shapes"
                );
              }),
              n.forEach(function (t) {
                S(a === t.dtype, function () {
                  return "All tensors passed to stack must have matching dtypes";
                });
              });
            var o = n.map(function (t) {
              return t.expandDims(e);
            });
            return An(o, e);
          },
        }),
        yr = pn({
          tile_: function (t, e) {
            var n = $e(t, "x", "tile", null);
            S(n.rank === e.length, function () {
              return (
                "Error in transpose: rank of input " +
                n.rank +
                " must match length of reps " +
                e +
                "."
              );
            });
            var r = [n],
              i = { reps: e };
            return Pt.runKernelFunc(
              function (t, r) {
                var i = t.tile(n, e);
                return r([n]), i;
              },
              { x: n },
              function (t, n) {
                var r = n[0];
                return {
                  x: function () {
                    var n = _n(r);
                    if (1 === r.rank)
                      for (var i = 0; i < e[0]; ++i)
                        n = n.add(t.slice([i * r.shape[0]], [r.shape[0]]));
                    else if (2 === r.rank)
                      for (i = 0; i < e[0]; ++i)
                        for (var a = 0; a < e[1]; ++a)
                          n = n.add(
                            t.slice(
                              [i * r.shape[0], a * r.shape[1]],
                              [r.shape[0], r.shape[1]]
                            )
                          );
                    else if (3 === r.rank)
                      for (i = 0; i < e[0]; ++i)
                        for (a = 0; a < e[1]; ++a)
                          for (var o = 0; o < e[2]; ++o)
                            n = n.add(
                              t.slice(
                                [
                                  i * r.shape[0],
                                  a * r.shape[1],
                                  o * r.shape[2],
                                ],
                                [r.shape[0], r.shape[1], r.shape[2]]
                              )
                            );
                    else {
                      if (4 !== r.rank)
                        throw new Error(
                          "Gradient for tile operation is not implemented for rank-" +
                            r.rank +
                            " tensors yet."
                        );
                      for (i = 0; i < e[0]; ++i)
                        for (a = 0; a < e[1]; ++a)
                          for (o = 0; o < e[2]; ++o)
                            for (var s = 0; s < e[3]; ++s)
                              n = n.add(
                                t.slice(
                                  [
                                    i * r.shape[0],
                                    a * r.shape[1],
                                    o * r.shape[2],
                                    s * r.shape[3],
                                  ],
                                  [
                                    r.shape[0],
                                    r.shape[1],
                                    r.shape[2],
                                    r.shape[3],
                                  ]
                                )
                              );
                    }
                    return n;
                  },
                };
              },
              "Tile",
              i,
              r
            );
          },
        }),
        br = pn({
          truncatedNormal_: function (t, e, n, r, i) {
            if (
              (void 0 === e && (e = 0),
              void 0 === n && (n = 1),
              null != r && "bool" === r)
            )
              throw new Error("Unsupported data type " + r);
            for (
              var a = new Hn(e, n, r, !0, i), o = Zn(t, r), s = 0;
              s < o.values.length;
              s++
            )
              o.values[s] = a.nextValue();
            return o.toTensor();
          },
        }),
        wr = pn({
          unstack_: function (t, e) {
            void 0 === e && (e = 0), (e = e || 0);
            var n = $e(t, "x", "unstack");
            S(e >= -n.shape.length && e < n.shape.length, function () {
              return (
                "Axis = " +
                e +
                " is not in [-" +
                n.shape.length +
                ", " +
                n.shape.length +
                ")"
              );
            }),
              e < 0 && (e += n.shape.length);
            var r = { axis: e };
            return Pt.runKernelFunc(
              function (t) {
                return t.unstack(n, e);
              },
              { x: n },
              function (t) {
                return {
                  x: function () {
                    return gr(t, e);
                  },
                };
              },
              "Unpack",
              r
            );
          },
        }),
        xr = function (t, e) {
          return u(this, void 0, void 0, function () {
            var n, r, i, a, o, s, u, l, p, h;
            return c(this, function (c) {
              switch (c.label) {
                case 0:
                  return (
                    (n = $e(t, "x", "setdiff1d")),
                    (r = $e(e, "y", "setdiff1d")),
                    S(n.dtype === r.dtype, function () {
                      return (
                        "x and y should have the same dtype, but got x (" +
                        n.dtype +
                        ") and y (" +
                        r.dtype +
                        ")."
                      );
                    }),
                    S(1 === n.rank, function () {
                      return (
                        "x should be 1D tensor, but got x (" + n.shape + ")."
                      );
                    }),
                    S(1 === r.rank, function () {
                      return (
                        "y should be 1D tensor, but got y (" + r.shape + ")."
                      );
                    }),
                    [4, n.data()]
                  );
                case 1:
                  return (i = c.sent()), [4, r.data()];
                case 2:
                  for (
                    a = c.sent(), o = new Set(a), s = 0, p = 0;
                    p < i.length;
                    p++
                  )
                    o.has(i[p]) || s++;
                  for (
                    u = new vt([s], n.dtype),
                      l = new vt([s], "int32"),
                      p = 0,
                      h = 0;
                    p < i.length;
                    p++
                  )
                    o.has(i[p]) ||
                      ((u.values[h] = i[p]), (l.values[h] = p), h++);
                  return [2, [u.toTensor(), l.toTensor()]];
              }
            });
          });
        };
      function Cr(t, e, n, r) {
        void 0 === r && (r = !0);
        var i = [];
        if (r)
          (i = i.concat(e.slice(0))).push(t[0] / n), (i = i.concat(t.slice(1)));
        else {
          i = i.concat(t[0]);
          for (var a = e.length, o = 0; o < a; ++o)
            i = i.concat([t[o + 1] / e[o], e[o]]);
          i = i.concat(t.slice(a + 1));
        }
        return i;
      }
      function Or(t, e, n) {
        void 0 === n && (n = !0);
        var r = [];
        if (n) {
          r.push(e);
          for (var i = e + 1; i < t; ++i)
            i <= 2 * e ? (r.push(i), r.push(i - (e + 1))) : r.push(i);
        } else {
          var a = [],
            o = [];
          for (i = 1; i < t; ++i)
            i >= 2 * e + 1 || i % 2 == 1 ? o.push(i) : a.push(i);
          r.push.apply(r, a), r.push(0), r.push.apply(r, o);
        }
        return r;
      }
      function Er(t, e, n, r) {
        void 0 === r && (r = !0);
        var i = [];
        r ? i.push(t[0] / n) : i.push(t[0] * n);
        for (var a = 1; a < t.length; ++a)
          a <= e.length
            ? r
              ? i.push(e[a - 1] * t[a])
              : i.push(t[a] / e[a - 1])
            : i.push(t[a]);
        return i;
      }
      function Sr(t, e) {
        for (var n = [0], r = 0; r < e; ++r) n.push(t[r][0]);
        return n;
      }
      function Nr(t, e, n) {
        for (var r = t.slice(0, 1), i = 0; i < n; ++i)
          r.push(t[i + 1] - e[i][0] - e[i][1]);
        return r;
      }
      function Ir(t, e) {
        if (t.rank < 1)
          throw new Error(
            "tf.gatherND() expects the input to be rank 1 or higher, but the rank was " +
              t.rank +
              "."
          );
        if (e.rank < 1)
          throw new Error(
            "tf.gatherND() expects the indices to be rank 1 or higher, but the rank was " +
              e.rank +
              "."
          );
        if ("int32" !== e.dtype)
          throw new Error(
            "tf.gatherND() expects the indices to be int32 type, but the dtype was " +
              e.dtype +
              "."
          );
        if (e.shape[e.rank - 1] > t.rank)
          throw new Error(
            "index innermost dimension length must be <= tensor rank; saw: " +
              e.shape[e.rank - 1] +
              " vs. " +
              t.rank
          );
        if (0 === t.size)
          throw new Error(
            "Requested more than 0 entries, but input is empty. Input shape: " +
              t.shape +
              "."
          );
        for (
          var n = e.shape, r = n[n.length - 1], i = 1, a = 0;
          a < n.length - 1;
          ++a
        )
          i *= n[a];
        var o = t.shape,
          s = n.slice();
        s.pop();
        var u = 1;
        for (a = r; a < t.rank; ++a) (u *= o[a]), s.push(o[a]);
        var c = Q(t.shape)
          .map(function (t) {
            return t / u;
          })
          .concat([1])
          .slice(0, r);
        return [s, i, u, c];
      }
      Object.freeze({ prepareAndValidate: Ir });
      function kr(t) {
        return t <= 30 ? t : $(t, Math.floor(Math.sqrt(t)));
      }
      function _r(t, e, n) {
        var r = e.rank > 1 ? e.shape[e.rank - 1] : 1,
          i = e.rank > 1 ? e.rank - 1 : 1,
          a =
            "Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: " +
            n.shape +
            ", indices.shape: " +
            e.shape +
            ", shape: " +
            t +
            ", sliceDim: " +
            r +
            ", and batchDim: " +
            i +
            ".";
        if (n.rank < i) throw new Error(a + " update.rank < " + i + ". ");
        if (t.length < r + (n.rank - i))
          throw new Error(a + " Output shape length < " + (r + (n.rank - i)));
        if (n.rank !== i + t.length - r)
          throw new Error(a + " update.rank != " + (i + t.length - r));
        for (var o = 0; o < i; ++o)
          if (n.shape[o] !== e.shape[o])
            throw new Error(
              a +
                " updates.shape[" +
                o +
                "] (" +
                n.shape[o] +
                ") != indices.shape[" +
                o +
                "] (" +
                e.shape[o] +
                ")."
            );
        for (o = 0; o < n.rank - i; ++o)
          if (n.shape[o + i] !== t[o + r])
            throw new Error(
              a +
                " updates.shape[" +
                (o + i) +
                "] (" +
                n.shape[o + i] +
                ") != shape[" +
                (o + i) +
                "] (" +
                t[o + i] +
                ")"
            );
      }
      function Ar(t, e, n) {
        if (e.rank < 1)
          throw new Error(
            "tf.scatterND() expects the indices to be rank 1 or higher, but the rank was " +
              e.rank +
              "."
          );
        if (t.rank < 1)
          throw new Error(
            "tf.scatterND() expects the updates to be rank 1 or higher, but the rank was " +
              t.rank +
              "."
          );
        if ("int32" !== e.dtype)
          throw new Error(
            "The dtype of 'indices' should be int32, but got dtype: " + e.dtype
          );
        if (n.length < 1)
          throw new Error(
            "Output rank must be greater or equal to 1, but got shape: " + n
          );
        if (0 === n.length) {
          if (0 === e.size)
            throw new Error(
              "Indices specified for empty output. indices shape: " + e.shape
            );
          if (0 === t.size)
            throw new Error(
              "Updates specified for empty output. updates shape: " + t.shape
            );
        }
        _r(n, e, t);
      }
      function Tr(t, e, n) {
        for (
          var r = e.shape.length,
            i = r > 1 ? e.shape[r - 1] : 1,
            a = n.length,
            o = 1,
            s = i;
          s < a;
          ++s
        )
          o *= n[s];
        var u = i < 1 ? 1 : i;
        return {
          sliceRank: i,
          numUpdates: _(e.shape) / u,
          sliceSize: o,
          strides: Q(n.slice(0, i)).concat([1]),
          outputSize: _(n),
        };
      }
      Object.freeze({
        validateUpdateShape: _r,
        validateInput: Ar,
        calculateShapes: Tr,
      });
      function Rr(t, e, n) {
        S(t.rank === e.length, function () {
          return (
            "Error in slice" +
            t.rank +
            "D: Length of begin " +
            e +
            " must match the rank of the array (" +
            t.rank +
            ")."
          );
        }),
          S(t.rank === n.length, function () {
            return (
              "Error in slice" +
              t.rank +
              "D: Length of size " +
              n +
              " must match the rank of the array (" +
              t.rank +
              ")."
            );
          });
        for (
          var r = function (r) {
              S(e[r] + n[r] <= t.shape[r], function () {
                return (
                  "Error in slice" +
                  t.rank +
                  "D: begin[" +
                  r +
                  "] + size[" +
                  r +
                  "] (" +
                  (e[r] + n[r]) +
                  ") would overflow input.shape[" +
                  r +
                  "] (" +
                  t.shape[r] +
                  ")"
                );
              });
            },
            i = 0;
          i < t.rank;
          ++i
        )
          r(i);
      }
      function Dr(t) {
        for (var e = [], n = 0; t > 0; ) 1 & t && e.push(n), (t /= 2), n++;
        return e;
      }
      function Fr(t, e, n) {
        for (var r = [], i = 0; i < t.length; i++)
          r[i] = Math.ceil((e[i] - t[i]) / n[i]);
        return r;
      }
      function Mr(t, e, n, r, i) {
        var a = e[i],
          o = n[i] || 1;
        (t & (1 << i) || null == a) &&
          (a = o > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
        var s = r[i];
        return a < 0 && (a += s), C(0, a, s - 1);
      }
      function jr(t, e, n, r, i) {
        var a = e[i],
          o = n[i] || 1;
        (t & (1 << i) || null == a) &&
          (a = o > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
        var s = r[i];
        return a < 0 && (a += s), o > 0 ? C(0, a, s) : C(-1, a, s - 1);
      }
      function Pr(t, e, n) {
        for (var r = n.length, i = 0; i < n.length; i++)
          if (n[i] > 1) {
            r = i;
            break;
          }
        for (i = r + 1; i < n.length; i++)
          if (e[i] > 0 || n[i] !== t[i]) return !1;
        return !0;
      }
      function zr(t, e) {
        for (
          var n = t.length > 0 ? t[t.length - 1] : 1, r = 0;
          r < t.length - 1;
          r++
        )
          n += t[r] * e[r];
        return n;
      }
      Object.freeze({
        assertParamsValid: Rr,
        maskToAxes: Dr,
        computeOutShape: Fr,
        startForAxis: Mr,
        stopForAxis: jr,
        isSliceContinous: Pr,
        computeFlatOffset: zr,
      });
      function Lr(t) {
        return Pt.customGrad(t);
      }
      var Br = pn({
          softmax_: function (t, e) {
            void 0 === e && (e = -1);
            var n = $e(t, "logits", "softmax", "float32");
            if ((-1 === e && (e = n.rank - 1), e !== n.rank - 1))
              throw Error(
                "Softmax along a non-last dimension is not yet supported. Logits was rank " +
                  n.rank +
                  " and dim was " +
                  e
              );
            return Pt.runKernelFunc(
              function (t, r) {
                var i = t.softmax(n, e);
                return r([i]), i;
              },
              { logits: n },
              function (t, n) {
                var r = n[0],
                  i = t.mul(r);
                return {
                  logits: function () {
                    return i.sub(i.sum([e], !0).mul(r));
                  },
                };
              },
              "Softmax",
              { dim: e },
              [],
              [!0]
            );
          },
        }),
        Wr = pn({
          logSoftmax_: function (t, e) {
            void 0 === e && (e = -1);
            var n = $e(t, "logits", "logSoftmax");
            if ((-1 === e && (e = n.rank - 1), e !== n.rank - 1))
              throw Error(
                "Log Softmax along a non-last dimension is not yet supported. Logits was rank " +
                  n.rank +
                  " and axis was " +
                  e
              );
            return Lr(function (t, n) {
              var r = t.max(e, !0),
                i = t.sub(r),
                a = i.toFloat().sub(i.exp().sum(e, !0).log());
              return (
                n([a]),
                {
                  value: a,
                  gradFunc: function (t, n) {
                    var r = n[0].exp();
                    return t.sub(t.sum(e, !0).mul(r));
                  },
                }
              );
            })(n);
          },
        }),
        Ur = (function () {
          function t(t, e) {
            (this.backend = t),
              (this.dataMover = e),
              (this.data = new WeakMap()),
              (this.dataIdsCount = 0);
          }
          return (
            (t.prototype.get = function (t) {
              return (
                this.data.has(t) || this.dataMover.moveData(this.backend, t),
                this.data.get(t)
              );
            }),
            (t.prototype.set = function (t, e) {
              this.dataIdsCount++, this.data.set(t, e);
            }),
            (t.prototype.has = function (t) {
              return this.data.has(t);
            }),
            (t.prototype.delete = function (t) {
              return this.dataIdsCount--, this.data.delete(t);
            }),
            (t.prototype.numDataIds = function () {
              return this.dataIdsCount;
            }),
            t
          );
        })(),
        Vr = (function () {
          function t() {}
          return (
            (t.prototype.time = function (t) {
              return Gr("time");
            }),
            (t.prototype.read = function (t) {
              return Gr("read");
            }),
            (t.prototype.readSync = function (t) {
              return Gr("readSync");
            }),
            (t.prototype.numDataIds = function () {
              return Gr("numDataIds");
            }),
            (t.prototype.disposeData = function (t) {
              return Gr("disposeData");
            }),
            (t.prototype.write = function (t, e, n) {
              return Gr("write");
            }),
            (t.prototype.move = function (t, e, n, r) {
              return Gr("move");
            }),
            (t.prototype.memory = function () {
              return Gr("memory");
            }),
            (t.prototype.floatPrecision = function () {
              return Gr("floatPrecision");
            }),
            (t.prototype.epsilon = function () {
              return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
            }),
            (t.prototype.batchMatMul = function (t, e, n, r) {
              return Gr("batchMatMul");
            }),
            (t.prototype.fusedBatchMatMul = function (t) {
              return (
                t.a,
                t.b,
                t.transposeA,
                t.transposeB,
                t.bias,
                t.activation,
                t.preluActivationWeights,
                Gr("fusedBatchMatMul")
              );
            }),
            (t.prototype.slice = function (t, e, n) {
              return Gr("slice");
            }),
            (t.prototype.stridedSlice = function (t, e, n, r) {
              return Gr("stridedSlice");
            }),
            (t.prototype.unstack = function (t, e) {
              return Gr("unstack");
            }),
            (t.prototype.reverse = function (t, e) {
              return Gr("reverse");
            }),
            (t.prototype.concat = function (t, e) {
              return Gr("concat");
            }),
            (t.prototype.neg = function (t) {
              return Gr("neg");
            }),
            (t.prototype.add = function (t, e) {
              return Gr("add");
            }),
            (t.prototype.addN = function (t) {
              return Gr("addN");
            }),
            (t.prototype.subtract = function (t, e) {
              return Gr("subtract");
            }),
            (t.prototype.multiply = function (t, e) {
              return Gr("multiply");
            }),
            (t.prototype.realDivide = function (t, e) {
              return Gr("realDivide");
            }),
            (t.prototype.floorDiv = function (t, e) {
              return Gr("floorDiv");
            }),
            (t.prototype.sum = function (t, e) {
              return Gr("sum");
            }),
            (t.prototype.prod = function (t, e) {
              return Gr("prod");
            }),
            (t.prototype.unsortedSegmentSum = function (t, e, n) {
              return Gr("unsortedSegmentSum");
            }),
            (t.prototype.argMin = function (t, e) {
              return Gr("argMin");
            }),
            (t.prototype.argMax = function (t, e) {
              return Gr("argMax");
            }),
            (t.prototype.equal = function (t, e) {
              return Gr("equal");
            }),
            (t.prototype.notEqual = function (t, e) {
              return Gr("notEqual");
            }),
            (t.prototype.less = function (t, e) {
              return Gr("less");
            }),
            (t.prototype.lessEqual = function (t, e) {
              return Gr("lessEqual");
            }),
            (t.prototype.greater = function (t, e) {
              return Gr("greater");
            }),
            (t.prototype.greaterEqual = function (t, e) {
              return Gr("greaterEqual");
            }),
            (t.prototype.logicalNot = function (t) {
              return Gr("logicalNot");
            }),
            (t.prototype.logicalAnd = function (t, e) {
              return Gr("logicalAnd");
            }),
            (t.prototype.logicalOr = function (t, e) {
              return Gr("logicalOr");
            }),
            (t.prototype.where = function (t) {
              return Gr("where");
            }),
            (t.prototype.select = function (t, e, n) {
              return Gr("select");
            }),
            (t.prototype.topk = function (t, e, n) {
              return Gr("topk");
            }),
            (t.prototype.min = function (t, e) {
              return Gr("min");
            }),
            (t.prototype.minimum = function (t, e) {
              return Gr("minimum");
            }),
            (t.prototype.mod = function (t, e) {
              return Gr("mod");
            }),
            (t.prototype.max = function (t, e) {
              return Gr("max");
            }),
            (t.prototype.maximum = function (t, e) {
              return Gr("maximum");
            }),
            (t.prototype.all = function (t, e) {
              return Gr("all");
            }),
            (t.prototype.any = function (t, e) {
              return Gr("any");
            }),
            (t.prototype.squaredDifference = function (t, e) {
              return Gr("squaredDifference");
            }),
            (t.prototype.ceil = function (t) {
              return Gr("ceil");
            }),
            (t.prototype.floor = function (t) {
              return Gr("floor");
            }),
            (t.prototype.round = function (t) {
              return Gr("round");
            }),
            (t.prototype.sign = function (t) {
              return Gr("sign");
            }),
            (t.prototype.isNaN = function (t) {
              return Gr("isNaN");
            }),
            (t.prototype.isInf = function (t) {
              return Gr("isInf");
            }),
            (t.prototype.isFinite = function (t) {
              return Gr("isFinite");
            }),
            (t.prototype.pow = function (t, e) {
              return Gr("pow");
            }),
            (t.prototype.exp = function (t) {
              return Gr("exp");
            }),
            (t.prototype.expm1 = function (t) {
              return Gr("expm1");
            }),
            (t.prototype.softmax = function (t, e) {
              return Gr("softmax");
            }),
            (t.prototype.log = function (t) {
              return Gr("log");
            }),
            (t.prototype.log1p = function (t) {
              return Gr("log1p");
            }),
            (t.prototype.sqrt = function (t) {
              return Gr("sqrt");
            }),
            (t.prototype.rsqrt = function (t) {
              return Gr("rsqrt");
            }),
            (t.prototype.square = function (t) {
              return Gr("square");
            }),
            (t.prototype.reciprocal = function (t) {
              return Gr("reciprocal");
            }),
            (t.prototype.relu = function (t) {
              return Gr("relu");
            }),
            (t.prototype.relu6 = function (t) {
              return Gr("relu6");
            }),
            (t.prototype.prelu = function (t, e) {
              return Gr("prelu");
            }),
            (t.prototype.elu = function (t) {
              return Gr("elu");
            }),
            (t.prototype.eluDer = function (t, e) {
              return Gr("eluDer");
            }),
            (t.prototype.selu = function (t) {
              return Gr("selu");
            }),
            (t.prototype.int = function (t) {
              return Gr("int");
            }),
            (t.prototype.clip = function (t, e, n) {
              return Gr("clip");
            }),
            (t.prototype.abs = function (t) {
              return Gr("abs");
            }),
            (t.prototype.complexAbs = function (t) {
              return Gr("complexAbs");
            }),
            (t.prototype.sigmoid = function (t) {
              return Gr("sigmoid");
            }),
            (t.prototype.softplus = function (t) {
              return Gr("softplus");
            }),
            (t.prototype.sin = function (t) {
              return Gr("sin");
            }),
            (t.prototype.cos = function (t) {
              return Gr("cos");
            }),
            (t.prototype.tan = function (t) {
              return Gr("tan");
            }),
            (t.prototype.asin = function (t) {
              return Gr("asin");
            }),
            (t.prototype.acos = function (t) {
              return Gr("acos");
            }),
            (t.prototype.atan = function (t) {
              return Gr("atan");
            }),
            (t.prototype.atan2 = function (t, e) {
              return Gr("atan2");
            }),
            (t.prototype.sinh = function (t) {
              return Gr("sinh");
            }),
            (t.prototype.cosh = function (t) {
              return Gr("cosh");
            }),
            (t.prototype.tanh = function (t) {
              return Gr("tanh");
            }),
            (t.prototype.asinh = function (t) {
              return Gr("asinh");
            }),
            (t.prototype.acosh = function (t) {
              return Gr("acosh");
            }),
            (t.prototype.atanh = function (t) {
              return Gr("atanh");
            }),
            (t.prototype.erf = function (t) {
              return Gr("erf");
            }),
            (t.prototype.step = function (t, e) {
              return Gr("step");
            }),
            (t.prototype.fusedConv2d = function (t) {
              return (
                t.input,
                t.filter,
                t.convInfo,
                t.bias,
                t.activation,
                t.preluActivationWeights,
                Gr("fusedConv2d")
              );
            }),
            (t.prototype.conv2d = function (t, e, n) {
              return Gr("conv2d");
            }),
            (t.prototype.conv2dDerInput = function (t, e, n) {
              return Gr("conv2dDerInput");
            }),
            (t.prototype.conv2dDerFilter = function (t, e, n) {
              return Gr("conv2dDerFilter");
            }),
            (t.prototype.fusedDepthwiseConv2D = function (t) {
              return (
                t.input,
                t.filter,
                t.convInfo,
                t.bias,
                t.activation,
                t.preluActivationWeights,
                Gr("fusedDepthwiseConv2D")
              );
            }),
            (t.prototype.depthwiseConv2D = function (t, e, n) {
              return Gr("depthwiseConv2D");
            }),
            (t.prototype.depthwiseConv2DDerInput = function (t, e, n) {
              return Gr("depthwiseConv2DDerInput");
            }),
            (t.prototype.depthwiseConv2DDerFilter = function (t, e, n) {
              return Gr("depthwiseConv2DDerFilter");
            }),
            (t.prototype.conv3d = function (t, e, n) {
              return Gr("conv3d");
            }),
            (t.prototype.conv3dDerInput = function (t, e, n) {
              return Gr("conv3dDerInput");
            }),
            (t.prototype.conv3dDerFilter = function (t, e, n) {
              return Gr("conv3dDerFilter");
            }),
            (t.prototype.maxPool = function (t, e) {
              return Gr("maxPool");
            }),
            (t.prototype.maxPoolBackprop = function (t, e, n, r) {
              return Gr("maxPoolBackprop");
            }),
            (t.prototype.avgPool = function (t, e) {
              return Gr("avgPool");
            }),
            (t.prototype.avgPoolBackprop = function (t, e, n) {
              return Gr("avgPoolBackprop");
            }),
            (t.prototype.avgPool3d = function (t, e) {
              return Gr("avgPool3d");
            }),
            (t.prototype.avgPool3dBackprop = function (t, e, n) {
              return Gr("avgPool3dBackprop");
            }),
            (t.prototype.maxPool3d = function (t, e) {
              return Gr("maxPool3d");
            }),
            (t.prototype.maxPool3dBackprop = function (t, e, n, r) {
              return Gr("maxPool3dBackprop");
            }),
            (t.prototype.reshape = function (t, e) {
              return Gr("reshape");
            }),
            (t.prototype.cast = function (t, e) {
              return Gr("cast");
            }),
            (t.prototype.tile = function (t, e) {
              return Gr("tile");
            }),
            (t.prototype.pad = function (t, e, n) {
              return Gr("pad");
            }),
            (t.prototype.transpose = function (t, e) {
              return Gr("transpose");
            }),
            (t.prototype.gather = function (t, e, n) {
              return Gr("gather");
            }),
            (t.prototype.gatherND = function (t, e) {
              return Gr("gatherND");
            }),
            (t.prototype.scatterND = function (t, e, n) {
              return Gr("scatterND");
            }),
            (t.prototype.batchToSpaceND = function (t, e, n) {
              return Gr("batchToSpaceND");
            }),
            (t.prototype.spaceToBatchND = function (t, e, n) {
              return Gr("spaceToBatchND");
            }),
            (t.prototype.resizeBilinear = function (t, e, n, r) {
              return Gr("resizeBilinear");
            }),
            (t.prototype.resizeBilinearBackprop = function (t, e, n) {
              return Gr("resizeBilinearBackprop");
            }),
            (t.prototype.resizeNearestNeighbor = function (t, e, n, r) {
              return Gr("resizeNearestNeighbor");
            }),
            (t.prototype.resizeNearestNeighborBackprop = function (t, e, n) {
              return Gr("resizeNearestNeighborBackprop");
            }),
            (t.prototype.batchNormalization = function (t, e, n, r, i, a) {
              return Gr("batchNormalization");
            }),
            (t.prototype.localResponseNormalization4D = function (
              t,
              e,
              n,
              r,
              i
            ) {
              return Gr("localResponseNormalization4D");
            }),
            (t.prototype.LRNGrad = function (t, e, n, r, i, a, o) {
              return Gr("LRNGrad");
            }),
            (t.prototype.multinomial = function (t, e, n, r) {
              return Gr("multinomial");
            }),
            (t.prototype.oneHot = function (t, e, n, r) {
              return Gr("oneHot");
            }),
            (t.prototype.cumsum = function (t, e, n, r) {
              return Gr("cumsum");
            }),
            (t.prototype.nonMaxSuppression = function (t, e, n, r, i) {
              return Gr("nonMaxSuppression");
            }),
            (t.prototype.fft = function (t) {
              return Gr("fft");
            }),
            (t.prototype.ifft = function (t) {
              return Gr("ifft");
            }),
            (t.prototype.complex = function (t, e) {
              return Gr("complex");
            }),
            (t.prototype.real = function (t) {
              return Gr("real");
            }),
            (t.prototype.imag = function (t) {
              return Gr("imag");
            }),
            (t.prototype.cropAndResize = function (t, e, n, r, i, a) {
              return Gr("cropAndResize");
            }),
            (t.prototype.depthToSpace = function (t, e, n) {
              return Gr("depthToSpace");
            }),
            (t.prototype.split = function (t, e, n) {
              return Gr("split");
            }),
            (t.prototype.sparseToDense = function (t, e, n, r) {
              return Gr("sparseToDense");
            }),
            (t.prototype.diag = function (t) {
              return Gr("diag");
            }),
            (t.prototype.fill = function (t, e, n) {
              return Gr("fill");
            }),
            (t.prototype.onesLike = function (t) {
              return Gr("onesLike");
            }),
            (t.prototype.zerosLike = function (t) {
              return Gr("zerosLike");
            }),
            (t.prototype.linspace = function (t, e, n) {
              return Gr("linspace");
            }),
            (t.prototype.dispose = function () {
              return Gr("dispose");
            }),
            t
          );
        })();
      function Gr(t) {
        throw new Error(
          "'" +
            t +
            "' not yet implemented or not found in the registry. Did you forget to import the kernel?"
        );
      }
      function Hr(t, e) {
        for (var n = t.length, r = [], i = 0; i < n; i++) {
          var a = n - 1 - i,
            o = t[a] || 1;
          (e[e.length - 1 - i] || 1) > 1 && 1 === o && r.unshift(a);
        }
        return r;
      }
      function qr(t, e) {
        for (var n = [], r = 0; r < e.length; r++) {
          var i = t[t.length - r - 1],
            a = e.length - r - 1,
            o = e[a];
          (null == i || (1 === i && o > 1)) && n.unshift(a);
        }
        return n;
      }
      function Kr(t, e) {
        for (var n = [], r = Math.max(t.length, e.length), i = 0; i < r; i++) {
          var a = t[t.length - i - 1];
          null == a && (a = 1);
          var o = e[e.length - i - 1];
          if ((null == o && (o = 1), 1 === a)) n.unshift(o);
          else if (1 === o) n.unshift(a);
          else {
            if (a !== o)
              throw Error(
                "Operands could not be broadcast together with shapes " +
                  t +
                  " and " +
                  e +
                  "."
              );
            n.unshift(a);
          }
        }
        return n;
      }
      function Zr(t, e, n, r, i, a, o) {
        void 0 === o && (o = "channelsLast");
        var s,
          u = Qr(e),
          c = u[0],
          l = u[1];
        if ("channelsLast" === o) s = [c, l, t[3], t[3]];
        else {
          if ("channelsFirst" !== o) throw new Error("Unknown dataFormat " + o);
          s = [c, l, t[1], t[1]];
        }
        return Yr(t, s, n, r, i, a, !1, o);
      }
      function Xr(t, e, n, r, i, a, o) {
        void 0 === o && (o = "NDHWC");
        var s,
          u,
          c = ti(e),
          l = c[0],
          p = c[1],
          h = c[2];
        if ("NDHWC" === o) (u = "channelsLast"), (s = [l, p, h, t[4], t[4]]);
        else {
          if ("NCDHW" !== o) throw new Error("Unknown dataFormat " + o);
          (u = "channelsFirst"), (s = [l, p, h, t[1], t[1]]);
        }
        return Jr(t, s, n, r, i, !1, u, a);
      }
      function Yr(t, e, n, r, i, a, o, s) {
        void 0 === o && (o = !1), void 0 === s && (s = "channelsLast");
        var u = [-1, -1, -1, -1],
          c = u[0],
          l = u[1],
          p = u[2],
          h = u[3];
        if ("channelsLast" === s)
          (c = t[0]), (l = t[1]), (p = t[2]), (h = t[3]);
        else {
          if ("channelsFirst" !== s) throw new Error("Unknown dataFormat " + s);
          (c = t[0]), (h = t[1]), (l = t[2]), (p = t[3]);
        }
        var f,
          d = e[0],
          m = e[1],
          v = e[3],
          g = Qr(n),
          y = g[0],
          b = g[1],
          w = Qr(r),
          x = w[0],
          C = w[1],
          O = ei(d, x),
          E = ei(m, C),
          N = (function (t, e, n, r, i, a, o, s) {
            var u, c, l;
            if ("number" == typeof t) {
              u = {
                top: t,
                bottom: t,
                left: t,
                right: t,
                type: 0 === t ? "VALID" : "NUMBER",
              };
              var p = (function (t, e, n, r, i) {
                null == r && (r = $r(t, e, n));
                var a = t[1],
                  o = ni((t[0] - e + 2 * r) / n + 1, i);
                S(T(o), function () {
                  return (
                    "The output # of rows (" +
                    o +
                    ") must be an integer. Change the stride and/or zero pad parameters"
                  );
                });
                var s = ni((a - e + 2 * r) / n + 1, i);
                return (
                  S(T(s), function () {
                    return (
                      "The output # of columns (" +
                      s +
                      ") must be an integer. Change the stride and/or zero pad parameters"
                    );
                  }),
                  [o, s]
                );
              })([e, n], a, r, t, s);
              (c = p[0]), (l = p[1]);
            } else if ("same" === t) {
              (c = Math.ceil(e / r)), (l = Math.ceil(n / i));
              var h = Math.max(0, (c - 1) * r + a - e),
                f = Math.max(0, (l - 1) * i + o - n),
                d = Math.floor(h / 2),
                m = h - d,
                v = Math.floor(f / 2);
              u = { top: d, bottom: m, left: v, right: f - v, type: "SAME" };
            } else {
              if ("valid" !== t) throw Error("Unknown padding parameter: " + t);
              (u = { top: 0, bottom: 0, left: 0, right: 0, type: "VALID" }),
                (c = Math.ceil((e - a + 1) / r)),
                (l = Math.ceil((n - o + 1) / i));
            }
            return { padInfo: u, outHeight: c, outWidth: l };
          })(i, l, p, y, b, O, E, a),
          I = N.padInfo,
          k = N.outHeight,
          _ = N.outWidth,
          A = o ? v * h : v;
        return (
          "channelsFirst" === s
            ? (f = [c, A, k, _])
            : "channelsLast" === s && (f = [c, k, _, A]),
          {
            batchSize: c,
            dataFormat: s,
            inHeight: l,
            inWidth: p,
            inChannels: h,
            outHeight: k,
            outWidth: _,
            outChannels: A,
            padInfo: I,
            strideHeight: y,
            strideWidth: b,
            filterHeight: d,
            filterWidth: m,
            effectiveFilterHeight: O,
            effectiveFilterWidth: E,
            dilationHeight: x,
            dilationWidth: C,
            inShape: t,
            outShape: f,
            filterShape: e,
          }
        );
      }
      function Jr(t, e, n, r, i, a, o, s) {
        void 0 === a && (a = !1), void 0 === o && (o = "channelsLast");
        var u = [-1, -1, -1, -1, -1],
          c = u[0],
          l = u[1],
          p = u[2],
          h = u[3],
          f = u[4];
        if ("channelsLast" === o)
          (c = t[0]), (l = t[1]), (p = t[2]), (h = t[3]), (f = t[4]);
        else {
          if ("channelsFirst" !== o) throw new Error("Unknown dataFormat " + o);
          (c = t[0]), (f = t[1]), (l = t[2]), (p = t[3]), (h = t[4]);
        }
        var d,
          m = e[0],
          v = e[1],
          g = e[2],
          y = e[4],
          b = ti(n),
          w = b[0],
          x = b[1],
          C = b[2],
          O = ti(r),
          E = O[0],
          N = O[1],
          I = O[2],
          k = ei(m, E),
          _ = ei(v, N),
          A = ei(g, I),
          R = (function (t, e, n, r, i, a, o, s, u, c, l) {
            var p, h, f, d;
            if ("number" == typeof t) {
              p = {
                top: t,
                bottom: t,
                left: t,
                right: t,
                front: t,
                back: t,
                type: 0 === t ? "VALID" : "NUMBER",
              };
              var m = (function (t, e, n, r, i, a) {
                null == i && (i = $r(t, e, r));
                var o = t[1],
                  s = t[2],
                  u = ni((t[0] - e + 2 * i) / r + 1, a);
                S(T(u), function () {
                  return (
                    "The output # of depths (" +
                    u +
                    ") must be an integer. Change the stride and/or zero pad parameters"
                  );
                });
                var c = ni((o - e + 2 * i) / r + 1, a);
                S(T(c), function () {
                  return (
                    "The output # of rows (" +
                    c +
                    ") must be an integer. Change the stride and/or zero pad parameters"
                  );
                });
                var l = ni((s - e + 2 * i) / r + 1, a);
                return (
                  S(T(l), function () {
                    return (
                      "The output # of columns (" +
                      l +
                      ") must be an integer. Change the stride and/or zero pad parameters"
                    );
                  }),
                  [u, c, l, 1]
                );
              })([e, n, r, 1], s, 0, i, t, l);
              (h = m[0]), (f = m[1]), (d = m[2]);
            } else if ("same" === t) {
              var v = ((h = Math.ceil(e / i)) - 1) * i + s - e,
                g = ((f = Math.ceil(n / a)) - 1) * a + u - n,
                y = ((d = Math.ceil(r / o)) - 1) * o + c - r,
                b = Math.floor(v / 2),
                w = v - b,
                x = Math.floor(g / 2),
                C = g - x,
                O = Math.floor(y / 2);
              p = {
                top: x,
                bottom: C,
                left: O,
                right: y - O,
                front: b,
                back: w,
                type: "SAME",
              };
            } else {
              if ("valid" !== t) throw Error("Unknown padding parameter: " + t);
              (p = {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0,
                front: 0,
                back: 0,
                type: "VALID",
              }),
                (h = Math.ceil((e - s + 1) / i)),
                (f = Math.ceil((n - u + 1) / a)),
                (d = Math.ceil((r - c + 1) / o));
            }
            return { padInfo: p, outDepth: h, outHeight: f, outWidth: d };
          })(i, l, p, h, w, x, C, k, _, A, s),
          D = R.padInfo,
          F = R.outDepth,
          M = R.outHeight,
          j = R.outWidth,
          P = a ? y * f : y;
        return (
          "channelsFirst" === o
            ? (d = [c, P, F, M, j])
            : "channelsLast" === o && (d = [c, F, M, j, P]),
          {
            batchSize: c,
            dataFormat: o,
            inDepth: l,
            inHeight: p,
            inWidth: h,
            inChannels: f,
            outDepth: F,
            outHeight: M,
            outWidth: j,
            outChannels: P,
            padInfo: D,
            strideDepth: w,
            strideHeight: x,
            strideWidth: C,
            filterDepth: m,
            filterHeight: v,
            filterWidth: g,
            effectiveFilterDepth: k,
            effectiveFilterHeight: _,
            effectiveFilterWidth: A,
            dilationDepth: E,
            dilationHeight: N,
            dilationWidth: I,
            inShape: t,
            outShape: d,
            filterShape: e,
          }
        );
      }
      function $r(t, e, n, r) {
        void 0 === r && (r = 1);
        var i = ei(e, r);
        return Math.floor((t[0] * (n - 1) - n + i) / 2);
      }
      function Qr(t) {
        return "number" == typeof t
          ? [t, t, t]
          : 2 === t.length
          ? [t[0], t[1], 1]
          : t;
      }
      function ti(t) {
        return "number" == typeof t ? [t, t, t] : t;
      }
      function ei(t, e) {
        return e <= 1 ? t : t + (t - 1) * (e - 1);
      }
      function ni(t, e) {
        if (!e) return t;
        switch (e) {
          case "round":
            return Math.round(t);
          case "ceil":
            return Math.ceil(t);
          case "floor":
            return Math.floor(t);
          default:
            throw new Error("Unknown roundingMode " + e);
        }
      }
      function ri(t) {
        var e = Qr(t),
          n = e[0],
          r = e[1],
          i = e[2];
        return 1 === n && 1 === r && 1 === i;
      }
      function ii(t, e) {
        return ri(t) || ri(e);
      }
      function ai(t) {
        if ("NHWC" === t) return "channelsLast";
        if ("NCHW" === t) return "channelsFirst";
        throw new Error("Unknown dataFormat " + t);
      }
      function oi(t, e, n) {
        if ("complex64" === e) {
          if ("complex64" === t.dtype) return t.clone();
          var r = En(t.shape),
            i = t.toFloat(),
            a = n.complex(i, r);
          return r.dispose(), i.dispose(), a;
        }
        if (!V(t.dtype, e))
          return Pt.makeTensorFromDataId(t.dataId, t.shape, e);
        if ("complex64" === t.dtype) {
          var o = n.real(t);
          return (a = o.cast(e)), o.dispose(), a;
        }
        if ("int32" === e) return n.int(t);
        if ("bool" === e) {
          var s = gn(0, t.dtype);
          return (a = n.notEqual(t, s)), s.dispose(), a;
        }
        throw new Error(
          "Error in Cast: failed to cast " + t.dtype + " to " + e
        );
      }
      function si(t, e) {
        return Pt.makeTensorFromDataId(t.dataId, e, t.dtype);
      }
      function ui(t, e, n) {
        var r = (e - t) / (n - 1),
          i = rt(n, "float32");
        i[0] = t;
        for (var a = 1; a < i.length; a++) i[a] = i[a - 1] + r;
        return yn(i, "float32");
      }
      Object.freeze({
        castTensor: oi,
        reshapeTensor: si,
        linspaceImpl: ui,
        upcastType: kt,
        axesAreInnerMostDims: tn,
        combineLocations: en,
        computeOutAndReduceShapes: nn,
        expandShapeToKeepDim: rn,
        assertAxesAreInnerMostDims: an,
        getAxesPermutation: on,
        getUndoAxesPermutation: sn,
        getInnerMostAxes: un,
        getBroadcastDims: Hr,
        getReductionAxes: qr,
        assertAndGetBroadcastShape: Kr,
        assertParamsConsistent: cn,
        computeOutShape: ln,
        computePool2DInfo: Zr,
        computePool3DInfo: Xr,
        computeConv2DInfo: Yr,
        computeConv3DInfo: Jr,
        computeDefaultPad: $r,
        tupleValuesAreOne: ri,
        eitherStridesOrDilationsAreOne: ii,
        convertConv2DDataFormat: ai,
        PARALLELIZE_THRESHOLD: 30,
        computeOptimalWindowSize: kr,
      });
      function ci(t, e) {
        if (t.length !== e.length)
          throw new Error(
            "Cannot merge real and imag arrays of different lengths. real:" +
              t.length +
              ", imag: " +
              e.length +
              "."
          );
        for (
          var n = new Float32Array(2 * t.length), r = 0;
          r < n.length;
          r += 2
        )
          (n[r] = t[r / 2]), (n[r + 1] = e[r / 2]);
        return n;
      }
      function li(t, e) {
        return { real: t[2 * e], imag: t[2 * e + 1] };
      }
      function pi(t, e, n, r) {
        (t[2 * r] = e), (t[2 * r + 1] = n);
      }
      function hi(t, e, n) {
        var r = (n ? 2 : -2) * Math.PI * (t / e);
        return { real: Math.cos(r), imag: Math.sin(r) };
      }
      function fi(t, e, n) {
        var r = (function (t, e, n) {
            return (function (t, e, n) {
              for (var r = 0, i = t.length, a = 0, o = !1; r < i; ) {
                var s = n(e, t[(a = r + ((i - r) >>> 1))]);
                s > 0 ? (r = a + 1) : ((i = a), (o = !s));
              }
              return o ? r : -r - 1;
            })(t, e, n || di);
          })(t, e, n),
          i = r < 0 ? -(r + 1) : r;
        t.splice(i, 0, e);
      }
      function di(t, e) {
        return t > e ? 1 : t < e ? -1 : 0;
      }
      function mi(t, e, n, r, i) {
        return gi(t, e, n, r, i, 0).selectedIndices;
      }
      function vi(t, e, n, r, i, a) {
        var o = gi(t, e, n, r, i, a, !0);
        return (
          o.numValidOutputs.dispose(),
          {
            selectedIndices: o.selectedIndices,
            selectedScores: o.selectedScores,
          }
        );
      }
      function gi(t, e, n, r, i, a, o, s) {
        void 0 === o && (o = !1), void 0 === s && (s = !1);
        for (
          var u = Array.from(e)
              .map(function (t, e) {
                return { score: t, boxIndex: e, suppressBeginIndex: 0 };
              })
              .filter(function (t) {
                return t.score > i;
              })
              .sort(wi),
            c = a > 0 ? -0.5 / a : 0,
            l = [],
            p = [];
          l.length < n && u.length > 0;

        ) {
          var h = u.pop(),
            f = h.score,
            d = h.boxIndex,
            m = h.suppressBeginIndex;
          if (f < i) break;
          for (var v = !1, g = l.length - 1; g >= m; --g) {
            var y = yi(t, d, l[g]);
            if (y >= r) {
              v = !0;
              break;
            }
            if (((h.score = h.score * bi(r, c, y)), h.score <= i)) break;
          }
          (h.suppressBeginIndex = l.length),
            v ||
              (h.score === f
                ? (l.push(d), p.push(h.score))
                : h.score > i && fi(u, h, wi));
        }
        var b = l.length;
        return (
          s && (l.fill(0, b), p.fill(0, b)),
          {
            selectedIndices: yn(l, "int32"),
            selectedScores: yn(p, "float32"),
            numValidOutputs: gn(b, "int32"),
          }
        );
      }
      function yi(t, e, n) {
        var r = t.subarray(4 * e, 4 * e + 4),
          i = t.subarray(4 * n, 4 * n + 4),
          a = Math.min(r[0], r[2]),
          o = Math.min(r[1], r[3]),
          s = Math.max(r[0], r[2]),
          u = Math.max(r[1], r[3]),
          c = Math.min(i[0], i[2]),
          l = Math.min(i[1], i[3]),
          p = Math.max(i[0], i[2]),
          h = Math.max(i[1], i[3]),
          f = (s - a) * (u - o),
          d = (p - c) * (h - l);
        if (f <= 0 || d <= 0) return 0;
        var m = Math.max(a, c),
          v = Math.max(o, l),
          g = Math.min(s, p),
          y = Math.min(u, h),
          b = Math.max(g - m, 0) * Math.max(y - v, 0);
        return b / (f + d - b);
      }
      function bi(t, e, n) {
        var r = Math.exp(e * n * n);
        return n <= t ? r : 0;
      }
      function wi(t, e) {
        return (
          t.score - e.score || (t.score === e.score && e.boxIndex - t.boxIndex)
        );
      }
      function xi(t, e, n) {
        var r = new Array(t.rank).fill(0),
          i = t.shape.slice();
        return e.map(function (e) {
          i[n] = e;
          var a = t.slice(r, i);
          return (r[n] += e), a;
        });
      }
      function Ci(t, e) {
        for (var n = new Array(t.rank), r = 0; r < n.length; r++)
          n[r] = t.shape[r] * e[r];
        var i = Zn(n, t.dtype);
        for (r = 0; r < i.values.length; ++r) {
          for (
            var a = i.indexToLoc(r), o = new Array(t.rank), s = 0;
            s < o.length;
            s++
          )
            o[s] = a[s] % t.shape[s];
          var u = t.locToIndex(o);
          i.values[r] = t.values[u];
        }
        return i.toTensor();
      }
      function Oi(t, e, n, r, i) {
        for (
          var a = e[e.length - 1],
            o = [t.length / a, a],
            s = o[0],
            u = o[1],
            c = L(n, s * r),
            l = L("int32", s * r),
            p = 0;
          p < s;
          p++
        ) {
          for (
            var h = p * u, f = t.subarray(h, h + u), d = [], m = 0;
            m < f.length;
            m++
          )
            d.push({ value: f[m], index: m });
          d.sort(function (t, e) {
            return e.value - t.value;
          });
          var v = p * r,
            g = c.subarray(v, v + r),
            y = l.subarray(v, v + r);
          for (m = 0; m < r; m++) (g[m] = d[m].value), (y[m] = d[m].index);
        }
        var b = e.slice();
        return (b[b.length - 1] = r), [mn(c, b, n), mn(l, b, "int32")];
      }
      function Ei(t, e) {
        for (var n = [], r = 0; r < e.length; r++) e[r] && n.push(r);
        var i = Zn(t, "int32"),
          a = Zn([n.length, t.length], "int32");
        for (r = 0; r < n.length; r++) {
          var o = i.indexToLoc(n[r]),
            s = r * t.length;
          a.values.set(o, s);
        }
        return a.toTensor();
      }
      var Si = function (t, e) {
          (this.outputShape = []),
            (this.outputShape = t),
            (this.variableNames = e.map(function (t, e) {
              return "T" + e;
            }));
          var n = [];
          this.variableNames.forEach(function (t) {
            n.push("float v" + t + " = get" + t + "AtOutCoords();");
          });
          var r = this.variableNames
            .map(function (t) {
              return "v" + t;
            })
            .join(" + ");
          this.userCode =
            "\n      void main() {\n        " +
            n.join("\n        ") +
            "\n\n        float result = " +
            r +
            ";\n        setOutput(result);\n      }\n    ";
        },
        Ni = function (t, e) {
          (this.outputShape = []),
            (this.packedInputs = !0),
            (this.packedOutput = !0),
            (this.outputShape = t),
            (this.variableNames = e.map(function (t, e) {
              return "T" + e;
            }));
          var n = [];
          this.variableNames.forEach(function (t) {
            n.push("vec4 v" + t + " = get" + t + "AtOutCoords();");
          });
          var r = this.variableNames
            .map(function (t) {
              return "v" + t;
            })
            .join(" + ");
          this.userCode =
            "\n      void main() {\n        " +
            n.join("\n        ") +
            "\n\n        vec4 result = " +
            r +
            ";\n        setOutput(result);\n      }\n    ";
        },
        Ii = function (t, e, n) {
          this.variableNames = ["A"];
          var r = t.windowSize,
            i = t.batchSize,
            a = t.inSize,
            o = Math.ceil(a / r);
          n || this.variableNames.push("bestIndicesA"),
            (this.outputShape = [i, o]);
          var s = "max" === e ? ">" : "<",
            u = n
              ? "inOffset + i;"
              : "round(getBestIndicesA(batch, inOffset + i));";
          this.userCode =
            "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " +
            r +
            ";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < " +
            r +
            "; i++) {\n          int inIdx = " +
            u +
            ";\n          float candidate = getA(batch, inIdx);\n          if (candidate " +
            s +
            " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ";
        };
      function ki(t, e) {
        return ["x", "y", "z", "w", "u", "v"].slice(0, e).map(function (e) {
          return t + "." + e;
        });
      }
      function _i(t, e) {
        return 1 === e ? [t] : ki(t, e);
      }
      function Ai() {
        var t, e, n, r, i, a, o, s, u, c;
        return (
          2 === h().getNumber("WEBGL_VERSION")
            ? ((t = "#version 300 es"),
              (e = "in"),
              (n = "out"),
              (r = "in"),
              (i = "texture"),
              (a = "outputColor"),
              (o = "out vec4 outputColor;"),
              (s =
                "\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    "),
              (u = ""),
              (c =
                "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "))
            : ((t = ""),
              (e = "attribute"),
              (n = "varying"),
              (r = "varying"),
              (i = "texture2D"),
              (a = "gl_FragColor"),
              (o = ""),
              (s =
                "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    "),
              (u =
                "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    "),
              (c =
                "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ")),
          {
            version: t,
            attribute: e,
            varyingVs: n,
            varyingFs: r,
            texture2D: i,
            output: a,
            defineOutput: o,
            defineSpecialNaN: s,
            defineSpecialInf: u,
            defineRound: c,
          }
        );
      }
      function Ti(t, e, n) {
        void 0 === n && (n = "index");
        var r = Q(e);
        return r
          .map(function (e, i) {
            return (
              "int " +
              t[i] +
              " = " +
              n +
              " / " +
              e +
              "; " +
              (i === r.length - 1
                ? "int " + t[i + 1] + " = " + n + " - " + t[i] + " * " + e
                : "index -= " + t[i] + " * " + e) +
              ";"
            );
          })
          .join("");
      }
      function Ri(t) {
        var e = Q(t).map(function (t) {
          return t.toString();
        });
        return (
          "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * " +
          e[0] +
          " + coords.y * " +
          e[1] +
          " + coords.z;\n  }\n"
        );
      }
      var Di =
        "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";
      function Fi(t, e, n, r) {
        var i = [];
        t.forEach(function (t) {
          var e = _(t.shapeInfo.logicalShape);
          t.shapeInfo.isUniform
            ? i.push(
                "uniform float " + t.name + (e > 1 ? "[" + e + "]" : "") + ";"
              )
            : (i.push("uniform sampler2D " + t.name + ";"),
              i.push("uniform int offset" + t.name + ";"));
        });
        var a,
          o,
          s = i.join("\n"),
          u = t
            .map(function (t) {
              return (function (t, e, n) {
                void 0 === n && (n = !1);
                var r = "";
                r += n
                  ? (function t(e) {
                      var n, r, i;
                      switch (e.shapeInfo.logicalShape.length) {
                        case 0:
                          return (
                            (n = e.name),
                            (r =
                              "get" + n.charAt(0).toUpperCase() + n.slice(1)),
                            (i = Ai()),
                            "\n    vec4 " +
                              r +
                              "() {\n      return " +
                              i.texture2D +
                              "(" +
                              n +
                              ", halfCR);\n    }\n  "
                          );
                        case 1:
                          return (function (t) {
                            var e = t.name,
                              n =
                                "get" + e.charAt(0).toUpperCase() + e.slice(1),
                              r = t.shapeInfo.texShape,
                              i = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)],
                              a = Ai();
                            return (
                              "\n    vec4 " +
                              n +
                              "(int index) {\n      vec2 uv = packedUVfrom1D(\n        " +
                              i[0] +
                              ", " +
                              i[1] +
                              ", index);\n      return " +
                              a.texture2D +
                              "(" +
                              e +
                              ", uv);\n    }\n  "
                            );
                          })(e);
                        case 2:
                          return (function (t) {
                            var e = t.shapeInfo.logicalShape,
                              n = t.name,
                              r =
                                "get" + n.charAt(0).toUpperCase() + n.slice(1),
                              i = t.shapeInfo.texShape,
                              a = i[0],
                              o = i[1],
                              s = Ai();
                            if (null != i && A(e, i))
                              return (
                                "\n      vec4 " +
                                r +
                                "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(" +
                                o +
                                ".0, " +
                                a +
                                ".0);\n\n        return " +
                                s.texture2D +
                                "(" +
                                n +
                                ", uv);\n      }\n    "
                              );
                            var u = [Math.ceil(i[0] / 2), Math.ceil(i[1] / 2)];
                            return (
                              "\n    vec4 " +
                              r +
                              "(int row, int col) {\n      vec2 uv = packedUVfrom2D(" +
                              Math.ceil(e[1] / 2) +
                              ", " +
                              u[0] +
                              ", " +
                              u[1] +
                              ", row, col);\n      return " +
                              s.texture2D +
                              "(" +
                              n +
                              ", uv);\n    }\n  "
                            );
                          })(e);
                        case 3:
                          return (function (e) {
                            var n = e.shapeInfo.logicalShape,
                              r = e.name,
                              i =
                                "get" + r.charAt(0).toUpperCase() + r.slice(1),
                              a = e.shapeInfo.texShape,
                              o = [Math.ceil(a[0] / 2), Math.ceil(a[1] / 2)];
                            if (1 === n[0]) {
                              var s = Ui(e, n.slice(1));
                              return (
                                "\n        " +
                                t(s) +
                                "\n        vec4 " +
                                i +
                                "(int b, int row, int col) {\n          return " +
                                i +
                                "(" +
                                Vi(["b", "row", "col"], [1, 2]) +
                                ");\n        }\n      "
                              );
                            }
                            var u = o[0],
                              c = o[1],
                              l = Math.ceil(n[2] / 2);
                            return (
                              "\n    vec4 " +
                              i +
                              "(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        " +
                              u +
                              ", " +
                              c +
                              ", " +
                              l * Math.ceil(n[1] / 2) +
                              ", " +
                              l +
                              ", b, row, col);\n      return " +
                              Ai().texture2D +
                              "(" +
                              r +
                              ", uv);\n    }\n  "
                            );
                          })(e);
                        default:
                          return (function (t) {
                            for (
                              var e = t.shapeInfo.logicalShape,
                                n = e.length,
                                r = t.name,
                                i =
                                  "get" +
                                  r.charAt(0).toUpperCase() +
                                  r.slice(1),
                                a = t.shapeInfo.texShape,
                                o = [Math.ceil(a[0] / 2), Math.ceil(a[1] / 2)],
                                s = o[0],
                                u = o[1],
                                c = Math.ceil(e[n - 1] / 2),
                                l = c * Math.ceil(e[n - 2] / 2),
                                p = "int b, int row, int col",
                                h =
                                  "b * " +
                                  l +
                                  " + (row / 2) * " +
                                  c +
                                  " + (col / 2)",
                                f = 2;
                              f < n - 1;
                              f++
                            )
                              (p = "int b" + f + ", " + p),
                                (h =
                                  "b" +
                                  f +
                                  " * " +
                                  (l *= e[n - f - 1]) +
                                  " + " +
                                  h);
                            return (
                              "\n    vec4 " +
                              i +
                              "(" +
                              p +
                              ") {\n      int index = " +
                              h +
                              ";\n      int texR = index / " +
                              u +
                              ";\n      int texC = index - texR * " +
                              u +
                              ";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" +
                              u +
                              ", " +
                              s +
                              ");\n      return " +
                              Ai().texture2D +
                              "(" +
                              r +
                              ", uv);\n    }\n  "
                            );
                          })(e);
                      }
                    })(t)
                  : (function t(e) {
                      var n = e.shapeInfo.logicalShape;
                      switch (n.length) {
                        case 0:
                          return (function (t) {
                            var e = t.name,
                              n =
                                "get" + e.charAt(0).toUpperCase() + e.slice(1);
                            if (t.shapeInfo.isUniform)
                              return "float " + n + "() {return " + e + ";}";
                            var r = t.shapeInfo.texShape,
                              i = r[0],
                              a = r[1];
                            if (1 === i && 1 === a)
                              return (
                                "\n      float " +
                                n +
                                "() {\n        return sampleTexture(" +
                                e +
                                ", halfCR);\n      }\n    "
                              );
                            var o = t.shapeInfo.texShape;
                            return (
                              "\n    float " +
                              n +
                              "() {\n      vec2 uv = uvFromFlat(" +
                              o[0] +
                              ", " +
                              o[1] +
                              ", " +
                              Li(e) +
                              ");\n      return sampleTexture(" +
                              e +
                              ", uv);\n    }\n  "
                            );
                          })(e);
                        case 1:
                          return (function (t) {
                            var e = t.name,
                              n =
                                "get" + e.charAt(0).toUpperCase() + e.slice(1);
                            if (t.shapeInfo.isUniform)
                              return (
                                "\n      float " +
                                n +
                                "(int index) {\n        " +
                                Bi(t) +
                                "\n      }\n    "
                              );
                            var r = t.shapeInfo.texShape,
                              i = r[0],
                              a = r[1];
                            if (1 === a && 1 === i)
                              return (
                                "\n      float " +
                                n +
                                "(int index) {\n        return sampleTexture(" +
                                e +
                                ", halfCR);\n      }\n    "
                              );
                            var o = Li(e);
                            return 1 === a
                              ? "\n      float " +
                                  n +
                                  "(int index) {\n        vec2 uv = vec2(0.5, (float(index + " +
                                  o +
                                  ") + 0.5) / " +
                                  i +
                                  ".0);\n        return sampleTexture(" +
                                  e +
                                  ", uv);\n      }\n    "
                              : 1 === i
                              ? "\n      float " +
                                n +
                                "(int index) {\n        vec2 uv = vec2((float(index + " +
                                o +
                                ") + 0.5) / " +
                                a +
                                ".0, 0.5);\n        return sampleTexture(" +
                                e +
                                ", uv);\n      }\n    "
                              : "\n    float " +
                                n +
                                "(int index) {\n      vec2 uv = uvFromFlat(" +
                                i +
                                ", " +
                                a +
                                ", index + " +
                                o +
                                ");\n      return sampleTexture(" +
                                e +
                                ", uv);\n    }\n  ";
                          })(e);
                        case 2:
                          return (function (e) {
                            var n = e.shapeInfo.logicalShape,
                              r = e.name,
                              i =
                                "get" + r.charAt(0).toUpperCase() + r.slice(1),
                              a = e.shapeInfo.texShape;
                            if (null != a && A(n, a)) {
                              var o = a[0];
                              return (
                                "\n    float " +
                                i +
                                "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" +
                                a[1] +
                                ".0, " +
                                o +
                                ".0);\n      return sampleTexture(" +
                                r +
                                ", uv);\n    }\n  "
                              );
                            }
                            var s = z(n),
                              u = s.newShape,
                              c = s.keptDims,
                              l = u;
                            if (l.length < n.length) {
                              var p = Ui(e, l);
                              return (
                                "\n      " +
                                t(p) +
                                "\n      float " +
                                i +
                                "(int row, int col) {\n        return " +
                                i +
                                "(" +
                                Vi(["row", "col"], c) +
                                ");\n      }\n    "
                              );
                            }
                            if (e.shapeInfo.isUniform)
                              return (
                                "\n      float " +
                                i +
                                "(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(" +
                                n[1] +
                                ", 1)));\n        " +
                                Bi(e) +
                                "\n      }\n    "
                              );
                            var h = a[0],
                              f = a[1],
                              d = Li(r);
                            return 1 === f
                              ? "\n    float " +
                                  i +
                                  "(int row, int col) {\n      float index = dot(vec3(row, col, " +
                                  d +
                                  "), vec3(" +
                                  n[1] +
                                  ", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / " +
                                  h +
                                  ".0);\n      return sampleTexture(" +
                                  r +
                                  ", uv);\n    }\n  "
                              : 1 === h
                              ? "\n    float " +
                                i +
                                "(int row, int col) {\n      float index = dot(vec3(row, col, " +
                                d +
                                "), vec3(" +
                                n[1] +
                                ", 1, 1));\n      vec2 uv = vec2((index + 0.5) / " +
                                f +
                                ".0, 0.5);\n      return sampleTexture(" +
                                r +
                                ", uv);\n    }\n  "
                              : "\n  float " +
                                i +
                                "(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * " +
                                n[1] +
                                " + col + " +
                                d +
                                ";\n    vec2 uv = uvFromFlat(" +
                                h +
                                ", " +
                                f +
                                ", index);\n    return sampleTexture(" +
                                r +
                                ", uv);\n  }\n";
                          })(e);
                        case 3:
                          return (function (e) {
                            var n = e.shapeInfo.logicalShape,
                              r = e.name,
                              i =
                                "get" + r.charAt(0).toUpperCase() + r.slice(1),
                              a = n[1] * n[2],
                              o = n[2],
                              s = z(n),
                              u = s.newShape,
                              c = s.keptDims,
                              l = u;
                            if (l.length < n.length) {
                              var p = Ui(e, l);
                              return (
                                "\n        " +
                                t(p) +
                                "\n        float " +
                                i +
                                "(int row, int col, int depth) {\n          return " +
                                i +
                                "(" +
                                Vi(["row", "col", "depth"], c) +
                                ");\n        }\n      "
                              );
                            }
                            if (e.shapeInfo.isUniform)
                              return (
                                "\n      float " +
                                i +
                                "(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(" +
                                a +
                                ", " +
                                o +
                                ", 1)));\n        " +
                                Bi(e) +
                                "\n      }\n    "
                              );
                            var h = e.shapeInfo.texShape,
                              f = h[0],
                              d = h[1],
                              m = e.shapeInfo.flatOffset;
                            return d === a && null == m
                              ? "\n        float " +
                                  i +
                                  "(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(" +
                                  o +
                                  ", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" +
                                  d +
                                  ".0, " +
                                  f +
                                  ".0);\n          return sampleTexture(" +
                                  r +
                                  ", uv);\n        }\n      "
                              : d === o && null == m
                              ? "\n    float " +
                                i +
                                "(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(" +
                                n[1] +
                                ", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" +
                                d +
                                ".0, " +
                                f +
                                ".0);\n      return sampleTexture(" +
                                r +
                                ", uv);\n    }\n  "
                              : "\n      float " +
                                i +
                                "(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * " +
                                a +
                                " + col * " +
                                o +
                                " + depth + " +
                                Li(r) +
                                ";\n        vec2 uv = uvFromFlat(" +
                                f +
                                ", " +
                                d +
                                ", index);\n        return sampleTexture(" +
                                r +
                                ", uv);\n      }\n  ";
                          })(e);
                        case 4:
                          return (function (e) {
                            var n = e.shapeInfo.logicalShape,
                              r = e.name,
                              i =
                                "get" + r.charAt(0).toUpperCase() + r.slice(1),
                              a = n[3],
                              o = n[2] * a,
                              s = n[1] * o,
                              u = z(n),
                              c = u.newShape,
                              l = u.keptDims;
                            if (c.length < n.length) {
                              var p = Ui(e, c);
                              return (
                                "\n      " +
                                t(p) +
                                "\n      float " +
                                i +
                                "(int row, int col, int depth, int depth2) {\n        return " +
                                i +
                                "(" +
                                Vi(["row", "col", "depth", "depth2"], l) +
                                ");\n      }\n    "
                              );
                            }
                            if (e.shapeInfo.isUniform)
                              return (
                                "\n      float " +
                                i +
                                "(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(" +
                                s +
                                ", " +
                                o +
                                ", " +
                                a +
                                ", 1)));\n        " +
                                Bi(e) +
                                "\n      }\n    "
                              );
                            var h = e.shapeInfo.flatOffset,
                              f = e.shapeInfo.texShape,
                              d = f[0],
                              m = f[1];
                            return m === s && null == h
                              ? "\n      float " +
                                  i +
                                  "(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(" +
                                  o +
                                  ", " +
                                  a +
                                  ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" +
                                  m +
                                  ".0, " +
                                  d +
                                  ".0);\n        return sampleTexture(" +
                                  r +
                                  ", uv);\n      }\n    "
                              : m === a && null == h
                              ? "\n      float " +
                                i +
                                "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(" +
                                n[1] * n[2] +
                                ", " +
                                n[2] +
                                ", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" +
                                m +
                                ".0, " +
                                d +
                                ".0);\n        return sampleTexture(" +
                                r +
                                ", uv);\n      }\n    "
                              : "\n    float " +
                                i +
                                "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " +
                                s +
                                " + col * " +
                                o +
                                " +\n          depth * " +
                                a +
                                " + depth2;\n      vec2 uv = uvFromFlat(" +
                                d +
                                ", " +
                                m +
                                ", index + " +
                                Li(r) +
                                ");\n      return sampleTexture(" +
                                r +
                                ", uv);\n    }\n  ";
                          })(e);
                        case 5:
                          return (function (e) {
                            var n = e.shapeInfo.logicalShape,
                              r = e.name,
                              i =
                                "get" + r.charAt(0).toUpperCase() + r.slice(1),
                              a = n[4],
                              o = n[3] * a,
                              s = n[2] * o,
                              u = n[1] * s,
                              c = z(n),
                              l = c.newShape,
                              p = c.keptDims;
                            if (l.length < n.length) {
                              var h = Ui(e, l);
                              return (
                                "\n      " +
                                t(h) +
                                "\n      float " +
                                i +
                                "(int row, int col, int depth, int depth2, int depth3) {\n        return " +
                                i +
                                "(" +
                                Vi(
                                  ["row", "col", "depth", "depth2", "depth3"],
                                  p
                                ) +
                                ");\n      }\n    "
                              );
                            }
                            if (e.shapeInfo.isUniform)
                              return (
                                "\n      float " +
                                i +
                                "(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" +
                                u +
                                ", " +
                                s +
                                ", " +
                                o +
                                ", " +
                                a +
                                ")) +\n          depth3;\n        " +
                                Bi(e) +
                                "\n      }\n    "
                              );
                            var f = e.shapeInfo.flatOffset,
                              d = e.shapeInfo.texShape,
                              m = d[0],
                              v = d[1];
                            return v === u && null == f
                              ? "\n      float " +
                                  i +
                                  "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(" +
                                  s +
                                  ", " +
                                  o +
                                  ", " +
                                  a +
                                  ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" +
                                  v +
                                  ".0, " +
                                  m +
                                  ".0);\n        return sampleTexture(" +
                                  r +
                                  ", uv);\n      }\n    "
                              : v === a && null == f
                              ? "\n      float " +
                                i +
                                "(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" +
                                n[1] * n[2] * n[3] +
                                ",\n               " +
                                n[2] * n[3] +
                                ", " +
                                n[3] +
                                ", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" +
                                v +
                                ".0, " +
                                m +
                                ".0);\n        return sampleTexture(" +
                                r +
                                ", uv);\n      }\n    "
                              : "\n    float " +
                                i +
                                "(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " +
                                u +
                                " + col * " +
                                s +
                                " + depth * " +
                                o +
                                " +\n          depth2 * " +
                                a +
                                " + depth3 + " +
                                Li(r) +
                                ";\n      vec2 uv = uvFromFlat(" +
                                m +
                                ", " +
                                v +
                                ", index);\n      return sampleTexture(" +
                                r +
                                ", uv);\n    }\n  ";
                          })(e);
                        case 6:
                          return (function (e) {
                            var n = e.shapeInfo.logicalShape,
                              r = e.name,
                              i =
                                "get" + r.charAt(0).toUpperCase() + r.slice(1),
                              a = z(n),
                              o = a.newShape,
                              s = a.keptDims;
                            if (o.length < n.length) {
                              var u = Ui(e, o);
                              return (
                                "\n      " +
                                t(u) +
                                "\n      float " +
                                i +
                                "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return " +
                                i +
                                "(" +
                                Vi(
                                  [
                                    "row",
                                    "col",
                                    "depth",
                                    "depth2",
                                    "depth3",
                                    "depth4",
                                  ],
                                  s
                                ) +
                                ");\n      }\n    "
                              );
                            }
                            var c = n[5],
                              l = n[4] * c,
                              p = n[3] * l,
                              h = n[2] * p,
                              f = n[1] * h;
                            if (e.shapeInfo.isUniform)
                              return (
                                "\n      float " +
                                i +
                                "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(" +
                                f +
                                ", " +
                                h +
                                ", " +
                                p +
                                ", " +
                                l +
                                ")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(" +
                                c +
                                ", 1)));\n        " +
                                Bi(e) +
                                "\n      }\n    "
                              );
                            var d = e.shapeInfo.flatOffset,
                              m = e.shapeInfo.texShape,
                              v = m[0],
                              g = m[1];
                            return g === f && null == d
                              ? "\n      float " +
                                  i +
                                  "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(" +
                                  h +
                                  ", " +
                                  p +
                                  ", " +
                                  l +
                                  ", " +
                                  c +
                                  ")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" +
                                  g +
                                  ".0, " +
                                  v +
                                  ".0);\n        return sampleTexture(" +
                                  r +
                                  ", uv);\n      }\n    "
                              : g === c && null == d
                              ? "\n      float " +
                                i +
                                "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(" +
                                n[1] * n[2] * n[3] * n[4] +
                                ",\n               " +
                                n[2] * n[3] * n[4] +
                                ",\n               " +
                                n[3] * n[4] +
                                ",\n               " +
                                n[4] +
                                ")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" +
                                g +
                                ".0, " +
                                v +
                                ".0);\n        return sampleTexture(" +
                                r +
                                ", uv);\n      }\n    "
                              : "\n    float " +
                                i +
                                "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " +
                                f +
                                " + col * " +
                                h +
                                " + depth * " +
                                p +
                                " +\n          depth2 * " +
                                l +
                                " + depth3 * " +
                                c +
                                " + depth4 + " +
                                Li(r) +
                                ";\n      vec2 uv = uvFromFlat(" +
                                v +
                                ", " +
                                g +
                                ", index);\n      return sampleTexture(" +
                                r +
                                ", uv);\n    }\n  ";
                          })(e);
                        default:
                          throw new Error(
                            n.length + "-D input sampling is not yet supported"
                          );
                      }
                    })(t);
                var i = t.shapeInfo.logicalShape,
                  a = e.logicalShape;
                return (
                  i.length <= a.length &&
                    (r += n
                      ? (function (t, e) {
                          var n,
                            r = t.name,
                            i = r.charAt(0).toUpperCase() + r.slice(1),
                            a = "get" + i + "AtOutCoords",
                            o = t.shapeInfo.logicalShape.length,
                            s = e.logicalShape.length,
                            u = Hr(t.shapeInfo.logicalShape, e.logicalShape),
                            c = Wi(s),
                            l = s - o,
                            p = ["x", "y", "z", "w", "u", "v"];
                          n =
                            0 === o
                              ? ""
                              : s < 2 && u.length >= 1
                              ? "coords = 0;"
                              : u
                                  .map(function (t) {
                                    return "coords." + p[t + l] + " = 0;";
                                  })
                                  .join("\n");
                          var h;
                          h =
                            s < 2 && o > 0
                              ? "coords"
                              : t.shapeInfo.logicalShape
                                  .map(function (t, e) {
                                    return "coords." + p[e + l];
                                  })
                                  .join(", ");
                          var f = "return outputValue;",
                            d = 1 === _(t.shapeInfo.logicalShape),
                            m = 1 === _(e.logicalShape);
                          if (1 !== o || d || m) {
                            if (d && !m)
                              f =
                                1 === s
                                  ? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      "
                                  : "\n        return vec4(outputValue.x);\n      ";
                            else if (u.length) {
                              var v = o - 2,
                                g = o - 1;
                              u.indexOf(v) > -1 && u.indexOf(g) > -1
                                ? (f = "return vec4(outputValue.x);")
                                : u.indexOf(v) > -1
                                ? (f =
                                    "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);")
                                : u.indexOf(g) > -1 &&
                                  (f =
                                    "return vec4(outputValue.xx, outputValue.zz);");
                            }
                          } else
                            f =
                              "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";
                          return (
                            "\n    vec4 " +
                            a +
                            "() {\n      " +
                            c +
                            " coords = getOutputCoords();\n      " +
                            n +
                            "\n      vec4 outputValue = get" +
                            i +
                            "(" +
                            h +
                            ");\n      " +
                            f +
                            "\n    }\n  "
                          );
                        })(t, e)
                      : (function (t, e) {
                          var n = t.name,
                            r = n.charAt(0).toUpperCase() + n.slice(1),
                            i = "get" + r + "AtOutCoords",
                            a = e.texShape,
                            o = t.shapeInfo.texShape,
                            s = t.shapeInfo.logicalShape.length,
                            u = e.logicalShape.length;
                          if (
                            !t.shapeInfo.isUniform &&
                            s === u &&
                            null == t.shapeInfo.flatOffset &&
                            A(o, a)
                          )
                            return (
                              "\n      float " +
                              i +
                              "() {\n        return sampleTexture(" +
                              n +
                              ", resultUV);\n      }\n    "
                            );
                          var c = Wi(u),
                            l = Hr(t.shapeInfo.logicalShape, e.logicalShape),
                            p = u - s,
                            h = ["x", "y", "z", "w", "u", "v"];
                          return (
                            "\n    float " +
                            i +
                            "() {\n      " +
                            c +
                            " coords = getOutputCoords();\n      " +
                            (0 === s
                              ? ""
                              : u < 2 && l.length >= 1
                              ? "coords = 0;"
                              : l
                                  .map(function (t) {
                                    return "coords." + h[t + p] + " = 0;";
                                  })
                                  .join("\n")) +
                            "\n      return get" +
                            r +
                            "(" +
                            (u < 2 && s > 0
                              ? "coords"
                              : t.shapeInfo.logicalShape
                                  .map(function (t, e) {
                                    return "coords." + h[e + p];
                                  })
                                  .join(", ")) +
                            ");\n    }\n  "
                          );
                        })(t, e)),
                  r
                );
              })(t, e, r);
            })
            .join("\n"),
          c = e.texShape,
          l = Ai(),
          p = (function (t) {
            return (
              "\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return " +
              t.texture2D +
              "(textureSampler, uv).r;\n    }\n  "
            );
          })(l),
          h = (function (t) {
            return (
              t.version +
              "\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    " +
              t.varyingFs +
              " vec2 resultUV;\n    " +
              t.defineOutput +
              "\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    " +
              t.defineSpecialNaN +
              "\n    " +
              t.defineSpecialInf +
              "\n    " +
              t.defineRound +
              "\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    " +
              Mi +
              "\n    " +
              ji +
              "\n    " +
              Pi +
              "\n  "
            );
          })(l);
        return (
          e.isPacked
            ? ((a = (function (t, e) {
                switch (t.length) {
                  case 0:
                    return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
                  case 1:
                    return (function (t, e) {
                      var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)];
                      return 1 === n[0]
                        ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * " +
                            n[1] +
                            ".0);\n      }\n    "
                        : 1 === n[1]
                        ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * " +
                          n[0] +
                          ".0);\n      }\n    "
                        : "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" +
                          n[0] +
                          ", " +
                          n[1] +
                          "));\n      return 2 * (resTexRC.x * " +
                          n[1] +
                          " + resTexRC.y);\n    }\n  ";
                    })(0, e);
                  case 2:
                    return (function (t, e) {
                      var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)];
                      if (A(t, e))
                        return (
                          "\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(" +
                          n[0] +
                          ", " +
                          n[1] +
                          "));\n      }\n    "
                        );
                      var r = Math.ceil(t[1] / 2);
                      return (
                        "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" +
                        n[0] +
                        ", " +
                        n[1] +
                        "));\n\n      int index = resTexRC.x * " +
                        n[1] +
                        " + resTexRC.y;\n      int r = 2 * (index / " +
                        r +
                        ");\n      int c = imod(index, " +
                        r +
                        ") * 2;\n\n      return ivec2(r, c);\n    }\n  "
                      );
                    })(t, e);
                  case 3:
                    return (
                      (n = t),
                      (r = e),
                      (i = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)]),
                      (o = (a = Math.ceil(n[2] / 2)) * Math.ceil(n[1] / 2)),
                      "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" +
                        i[0] +
                        ", " +
                        i[1] +
                        "));\n      int index = resTexRC.x * " +
                        i[1] +
                        " + resTexRC.y;\n\n      int b = index / " +
                        o +
                        ";\n      index -= b * " +
                        o +
                        ";\n\n      int r = 2 * (index / " +
                        a +
                        ");\n      int c = imod(index, " +
                        a +
                        ") * 2;\n\n      return ivec3(b, r, c);\n    }\n  "
                    );
                  default:
                    return (function (t, e) {
                      for (
                        var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)],
                          r = Math.ceil(t[t.length - 1] / 2),
                          i = r * Math.ceil(t[t.length - 2] / 2),
                          a = i,
                          o = "",
                          s = "b, r, c",
                          u = 2;
                        u < t.length - 1;
                        u++
                      )
                        (o =
                          "\n      int b" +
                          u +
                          " = index / " +
                          (a *= t[t.length - u - 1]) +
                          ";\n      index -= b" +
                          u +
                          " * " +
                          a +
                          ";\n    " +
                          o),
                          (s = "b" + u + ", " + s);
                      return (
                        "\n    ivec" +
                        t.length +
                        " getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" +
                        n[0] +
                        ", " +
                        n[1] +
                        "));\n      int index = resTexRC.x * " +
                        n[1] +
                        " + resTexRC.y;\n\n      " +
                        o +
                        "\n\n      int b = index / " +
                        i +
                        ";\n      index -= b * " +
                        i +
                        ";\n\n      int r = 2 * (index / " +
                        r +
                        ");\n      int c = imod(index, " +
                        r +
                        ") * 2;\n\n      return ivec" +
                        t.length +
                        "(" +
                        s +
                        ");\n    }\n  "
                      );
                    })(t, e);
                }
                var n, r, i, a, o;
              })(e.logicalShape, c)),
              (o = (function (t) {
                return (
                  "\n    void setOutput(vec4 val) {\n      " +
                  t.output +
                  " = val;\n    }\n  "
                );
              })(l)))
            : ((a = (function (t, e) {
                switch (t.length) {
                  case 0:
                    return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
                  case 1:
                    return (function (t, e) {
                      return 1 === e[0]
                        ? "\n      int getOutputCoords() {\n        return int(resultUV.x * " +
                            e[1] +
                            ".0);\n      }\n    "
                        : 1 === e[1]
                        ? "\n      int getOutputCoords() {\n        return int(resultUV.y * " +
                          e[0] +
                          ".0);\n      }\n    "
                        : "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" +
                          e[0] +
                          ", " +
                          e[1] +
                          "));\n      return resTexRC.x * " +
                          e[1] +
                          " + resTexRC.y;\n    }\n  ";
                    })(0, e);
                  case 2:
                    return (function (t, e) {
                      return A(t, e)
                        ? "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" +
                            e[0] +
                            ", " +
                            e[1] +
                            "));\n      }\n    "
                        : 1 === t[1]
                        ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" +
                          e[0] +
                          ", " +
                          e[1] +
                          "));\n        int index = resTexRC.x * " +
                          e[1] +
                          " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    "
                        : 1 === t[0]
                        ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" +
                          e[0] +
                          ", " +
                          e[1] +
                          "));\n        int index = resTexRC.x * " +
                          e[1] +
                          " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    "
                        : "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" +
                          e[0] +
                          ", " +
                          e[1] +
                          "));\n      int index = resTexRC.x * " +
                          e[1] +
                          " + resTexRC.y;\n      int r = index / " +
                          t[1] +
                          ";\n      int c = index - r * " +
                          t[1] +
                          ";\n      return ivec2(r, c);\n    }\n  ";
                    })(t, e);
                  case 3:
                    return (
                      (n = e),
                      (r = Ti(["r", "c", "d"], t)),
                      "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" +
                        n[0] +
                        ", " +
                        n[1] +
                        "));\n      int index = resTexRC.x * " +
                        n[1] +
                        " + resTexRC.y;\n      " +
                        r +
                        "\n      return ivec3(r, c, d);\n    }\n  "
                    );
                  case 4:
                    return (function (t, e) {
                      var n = Ti(["r", "c", "d", "d2"], t);
                      return (
                        "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" +
                        e[0] +
                        ", " +
                        e[1] +
                        "));\n      int index = resTexRC.x * " +
                        e[1] +
                        " + resTexRC.y;\n      " +
                        n +
                        "\n      return ivec4(r, c, d, d2);\n    }\n  "
                      );
                    })(t, e);
                  case 5:
                    return (function (t, e) {
                      var n = Ti(["r", "c", "d", "d2", "d3"], t);
                      return (
                        "\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(" +
                        e[0] +
                        ",\n                             " +
                        e[1] +
                        "));\n\n      int index = resTexRC.x * " +
                        e[1] +
                        " + resTexRC.y;\n\n      " +
                        n +
                        "\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  "
                      );
                    })(t, e);
                  case 6:
                    return (function (t, e) {
                      var n = Ti(["r", "c", "d", "d2", "d3", "d4"], t);
                      return (
                        "\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" +
                        e[0] +
                        ", " +
                        e[1] +
                        "));\n      int index = resTexRC.x * " +
                        e[1] +
                        " + resTexRC.y;\n\n      " +
                        n +
                        "\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  "
                      );
                    })(t, e);
                  default:
                    throw new Error(
                      t.length + "-D output sampling is not yet supported"
                    );
                }
                var n, r;
              })(e.logicalShape, c)),
              (o = (function (t) {
                return (
                  "\n    void setOutput(float val) {\n      " +
                  t.output +
                  " = vec4(val, 0, 0, 0);\n    }\n  "
                );
              })(l))),
          r && (h += zi),
          [h, p, o, s, a, u, n].join("\n")
        );
      }
      var Mi =
          "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
        ji =
          "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
        Pi =
          "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
        zi =
          "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";
      function Li(t) {
        return "offset" + t;
      }
      function Bi(t) {
        var e = t.name,
          n = _(t.shapeInfo.logicalShape);
        return n < 2
          ? "return " + e + ";"
          : "\n    for (int i = 0; i < " +
              n +
              "; i++) {\n      if (i == index) {\n        return " +
              e +
              "[i];\n      }\n    }\n  ";
      }
      function Wi(t) {
        if (t <= 1) return "int";
        if (2 === t) return "ivec2";
        if (3 === t) return "ivec3";
        if (4 === t) return "ivec4";
        if (5 === t) return "ivec5";
        if (6 === t) return "ivec6";
        throw Error("GPU for rank " + t + " is not yet supported");
      }
      function Ui(t, e) {
        var n = JSON.parse(JSON.stringify(t));
        return (n.shapeInfo.logicalShape = e), n;
      }
      function Vi(t, e) {
        return e
          .map(function (e) {
            return t[e];
          })
          .join(", ");
      }
      var Gi = function (t, e, n, r) {
          (this.variableNames = ["A"]),
            (this.packedInputs = !0),
            (this.packedOutput = !0),
            S(t.length > 2, function () {
              return (
                "Packed arg" +
                (n.charAt(0).toUpperCase() + n.slice(1)) +
                " supports only inputs with rank above 2."
              );
            });
          var i = t[t.length - 1],
            a = Math.ceil(i / e);
          (this.outputShape = t.slice(0, -1)),
            a > 1 && this.outputShape.push(a),
            r || this.variableNames.push("bestIndicesA");
          var o,
            s,
            u = this.outputShape,
            c = u.length,
            l = Wi(c),
            p = _i("coords", c);
          if (1 === a) {
            var h = Wi((s = c + 1));
            o =
              "\n        " +
              h +
              " sourceLocR = " +
              h +
              "(" +
              p.join() +
              ", 0);\n        ++" +
              p[c - 1] +
              ";\n        " +
              h +
              " sourceLocG = " +
              h +
              "(" +
              p.join() +
              ", 0);\n        ++" +
              p[c - 2] +
              ";\n        " +
              h +
              " sourceLocA = " +
              h +
              "(" +
              p.join() +
              ", 0);\n        --" +
              p[c - 1] +
              ";\n        " +
              h +
              " sourceLocB = " +
              h +
              "(" +
              p.join() +
              ", 0);\n        --" +
              p[c - 2] +
              ";";
          } else
            (s = c),
              (o =
                "\n        " +
                l +
                " sourceLocR = coords;\n        ++" +
                p[c - 1] +
                ";\n        " +
                l +
                " sourceLocG = coords;\n        ++" +
                p[c - 2] +
                ";\n        " +
                l +
                " sourceLocA = coords;\n        --" +
                p[c - 1] +
                ";\n        " +
                l +
                " sourceLocB = coords;\n        --" +
                p[c - 2] +
                ";");
          var f = ["x", "y", "z", "w", "u", "v"].slice(0, s),
            d = "." + f[s - 1],
            m = f.map(function (t) {
              return "int " + t;
            }),
            v = _i("sourceLocR", s - 1).concat("inIdx.r"),
            g = _i("sourceLocG", s - 1).concat("inIdx.g"),
            y = _i("sourceLocB", s - 1).concat("inIdx.b"),
            b = _i("sourceLocA", s - 1).concat("inIdx.a"),
            w = "max" === n ? "greaterThan" : "lessThan",
            x = r
              ? ""
              : "\n          inIdx = round(vec4(getBestIndicesAChannel(" +
                v.join() +
                "),\n                             getBestIndicesAChannel(" +
                g.join() +
                "),\n                             getBestIndicesAChannel(" +
                y.join() +
                "),\n                             getBestIndicesAChannel(" +
                b.join() +
                ")));",
            C =
              "vec4(\n            getAChannel(" +
              v.join() +
              "),\n            hasNextCol ? getAChannel(" +
              g.join() +
              ") : 0.,\n            hasNextRow ? getAChannel(" +
              y.join() +
              ") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(" +
              b.join() +
              ") : 0.)",
            O = r
              ? ""
              : "\n      float getBestIndicesAChannel(" +
                m.join() +
                ") {\n        return getChannel(getBestIndicesA(" +
                f.join() +
                "),\n                                          vec2(" +
                f.slice(-2).join() +
                "));\n      }";
          this.userCode =
            "\n      float getAChannel(" +
            m.join() +
            ") {\n        return getChannel(getA(" +
            f.join() +
            "),\n                               vec2(" +
            f.slice(-2).join() +
            "));\n      }\n      " +
            O +
            "\n      void main() {\n        " +
            l +
            " coords = getOutputCoords();\n        bool hasNextCol = " +
            p[c - 1] +
            " < " +
            (u[c - 1] - 1) +
            ";\n        bool hasNextRow = " +
            p[c - 2] +
            " < " +
            (u[c - 2] - 1) +
            ";\n        " +
            o +
            "\n        ivec4 srcIdx = ivec4(sourceLocR" +
            d +
            ", sourceLocG" +
            d +
            ",\n          sourceLocB" +
            d +
            ", sourceLocA" +
            d +
            ") * " +
            e +
            ";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = " +
            C +
            ";\n\n        for (int i = 0; i < " +
            e +
            "; i++) {\n          inIdx = srcIdx;\n          " +
            x +
            "\n          vec4 candidate = " +
            C +
            ";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(" +
            w +
            "(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ";
        },
        Hi = function (t) {
          (this.variableNames = ["dy"]), (this.outputShape = t.inShape);
          var e = t.filterHeight,
            n = t.filterWidth,
            r = t.strideHeight,
            i = t.strideWidth,
            a = t.dilationHeight,
            o = t.dilationWidth,
            s = t.effectiveFilterHeight,
            u = t.effectiveFilterWidth,
            c = s - 1 - t.padInfo.top,
            l = u - 1 - t.padInfo.left,
            p = 1 / (e * n);
          this.userCode =
            "\n      const ivec2 pads = ivec2(" +
            c +
            ", " +
            l +
            ");\n      const float avgMultiplier = float(" +
            p +
            ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " +
            s +
            ";\n            wR += " +
            a +
            ") {\n          float dyR = float(dyRCorner + wR) / " +
            r +
            ".0;\n\n          if (dyR < 0.0 || dyR >= " +
            t.outHeight +
            ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " +
            u +
            ";\n            wC+= " +
            o +
            ") {\n            float dyC = float(dyCCorner + wC) / " +
            i +
            ".0;\n\n            if (dyC < 0.0 || dyC >= " +
            t.outWidth +
            ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
        },
        qi = function (t) {
          (this.variableNames = ["dy"]), (this.outputShape = t.inShape);
          var e = t.filterDepth,
            n = t.filterHeight,
            r = t.filterWidth,
            i = t.strideDepth,
            a = t.strideHeight,
            o = t.strideWidth,
            s = t.dilationDepth,
            u = t.dilationHeight,
            c = t.dilationWidth,
            l = t.effectiveFilterDepth,
            p = t.effectiveFilterHeight,
            h = t.effectiveFilterWidth,
            f = l - 1 - t.padInfo.front,
            d = p - 1 - t.padInfo.top,
            m = h - 1 - t.padInfo.left,
            v = 1 / (e * n * r);
          this.userCode =
            "\n      const ivec3 pads = ivec3(" +
            f +
            ", " +
            d +
            ", " +
            m +
            ");\n      const float avgMultiplier = float(" +
            v +
            ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " +
            l +
            ";\n            wD += " +
            s +
            ") {\n          float dyD = float(dyDCorner + wD) / " +
            i +
            ".0;\n\n          if (dyD < 0.0 || dyD >= " +
            t.outDepth +
            ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " +
            p +
            ";\n              wR += " +
            u +
            ") {\n            float dyR = float(dyRCorner + wR) / " +
            a +
            ".0;\n\n            if (dyR < 0.0 || dyR >= " +
            t.outHeight +
            ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " +
            h +
            ";\n                wC += " +
            c +
            ") {\n              float dyC = float(dyCCorner + wC) / " +
            o +
            ".0;\n\n              if (dyC < 0.0 || dyC >= " +
            t.outWidth +
            ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
        },
        Ki = function (t, e, n, r, i, a) {
          (this.outputShape = []),
            (this.variableNames = ["x", "mean", "variance"]),
            Kr(t, e),
            Kr(t, n);
          var o = "0.0";
          null != r &&
            (Kr(t, r),
            this.variableNames.push("offset"),
            (o = "getOffsetAtOutCoords()"));
          var s = "1.0";
          null != i &&
            (Kr(t, i),
            this.variableNames.push("scale"),
            (s = "getScaleAtOutCoords()")),
            (this.outputShape = t),
            (this.userCode =
              "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " +
              o +
              ";\n        float scale = " +
              s +
              ";\n        float inv = scale * inversesqrt(variance + float(" +
              a +
              "));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ");
        },
        Zi = function (t, e, n, r, i, a) {
          (this.packedInputs = !0),
            (this.packedOutput = !0),
            (this.variableNames = ["x", "mean", "variance"]),
            Kr(t, e),
            Kr(t, n);
          var o = "vec4(0.0)";
          null != r &&
            (Kr(t, r),
            this.variableNames.push("offset"),
            (o = "getOffsetAtOutCoords()"));
          var s = "vec4(1.0)";
          null != i &&
            (Kr(t, i),
            this.variableNames.push("scale"),
            (s = "getScaleAtOutCoords()")),
            (this.outputShape = t),
            (this.userCode =
              "\n      void main() {\n        vec4 offset = " +
              o +
              ";\n        vec4 scale = " +
              s +
              ";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(" +
              a +
              "));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ");
        },
        Xi = function (t, e, n) {
          (this.variableNames = ["AReal", "AImag", "BReal", "BImag"]),
            (this.outputShape = Kr(e, n)),
            (this.userCode =
              "\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        " +
              t +
              "\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ");
        },
        Yi = "return a + b;",
        Ji = "return a - b;",
        $i = "return a * b;",
        Qi = "return (a < 0.) ? b * a : a;",
        ta = function (t, e, n) {
          (this.variableNames = ["A", "B"]),
            (this.outputShape = Kr(e, n)),
            (this.userCode =
              "\n      float binaryOperation(float a, float b) {\n        " +
              t +
              "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ");
        },
        ea =
          "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",
        na = function (t, e, n, r) {
          void 0 === r && (r = !1),
            (this.variableNames = ["A", "B"]),
            (this.supportsBroadcasting = !0),
            (this.packedInputs = !0),
            (this.packedOutput = !0),
            (this.outputShape = Kr(e, n));
          var i = this.outputShape.length,
            a = "";
          if (r)
            if (0 === i || 1 === _(this.outputShape))
              a =
                "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";
            else if (
              ((a =
                "\n          " +
                Wi(i) +
                " coords = getOutputCoords();\n        "),
              1 === i)
            )
              a +=
                "\n            result.y = (coords + 1) >= " +
                this.outputShape[0] +
                " ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";
            else {
              var o = _i("coords", i);
              a +=
                "\n            bool nextRowOutOfBounds =\n              (" +
                o[i - 2] +
                " + 1) >= " +
                this.outputShape[i - 2] +
                ";\n            bool nextColOutOfBounds =\n              (" +
                o[i - 1] +
                " + 1) >= " +
                this.outputShape[i - 1] +
                ";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ";
            }
          this.userCode =
            "\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        " +
            t +
            "\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        " +
            a +
            "\n\n        setOutput(result);\n      }\n    ";
        },
        ra = (function () {
          function t(t) {
            (this.variableNames = ["A"]),
              (this.outputShape = t),
              (this.userCode =
                "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    ");
          }
          return (
            (t.prototype.getCustomSetupFunc = function (t, e) {
              var n = this;
              return function (r, i) {
                null == n.minLoc &&
                  ((n.minLoc = r.getUniformLocationNoThrow(i, "minVal")),
                  (n.maxLoc = r.getUniformLocationNoThrow(i, "maxVal"))),
                  r.gl.uniform1f(n.minLoc, t),
                  r.gl.uniform1f(n.maxLoc, e);
              };
            }),
            t
          );
        })(),
        ia = (function () {
          function t(t) {
            (this.variableNames = ["A"]),
              (this.packedInputs = !0),
              (this.packedOutput = !0),
              (this.outputShape = t),
              (this.userCode =
                "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    ");
          }
          return (
            (t.prototype.getCustomSetupFunc = function (t, e) {
              var n = this;
              return function (r, i) {
                null == n.minLoc &&
                  ((n.minLoc = r.getUniformLocationNoThrow(i, "minVal")),
                  (n.maxLoc = r.getUniformLocationNoThrow(i, "maxVal"))),
                  r.gl.uniform1f(n.minLoc, t),
                  r.gl.uniform1f(n.maxLoc, e);
              };
            }),
            t
          );
        })(),
        aa = function (t) {
          (this.variableNames = ["real", "imag"]),
            (this.outputShape = t),
            (this.userCode =
              "\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    ");
        },
        oa = function (t) {
          (this.outputShape = []),
            (this.outputShape = ln(t, 1)),
            (this.variableNames = t.map(function (t, e) {
              return "T" + e;
            }));
          var e = new Array(t.length - 1);
          e[0] = t[0][1];
          for (var n = 1; n < e.length; n++) e[n] = e[n - 1] + t[n][1];
          var r = ["if (yC < " + e[0] + ") setOutput(getT0(yR, yC));"];
          for (n = 1; n < e.length; n++) {
            var i = e[n - 1];
            r.push(
              "else if (yC < " +
                e[n] +
                ") setOutput(getT" +
                n +
                "(yR, yC-" +
                i +
                "));"
            );
          }
          var a = e.length,
            o = e[e.length - 1];
          r.push("else setOutput(getT" + a + "(yR, yC-" + o + "));"),
            (this.userCode =
              "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        " +
              r.join("\n        ") +
              "\n      }\n    ");
        },
        sa = function (t, e) {
          (this.packedInputs = !0),
            (this.packedOutput = !0),
            (this.outputShape = []),
            (this.outputShape = ln(t, e));
          var n = this.outputShape,
            r = n.length,
            i = Wi(r),
            a = _i("coords", r),
            o = ["x", "y", "z", "w", "u", "v"].slice(0, r);
          this.variableNames = t.map(function (t, e) {
            return "T" + e;
          });
          var s = new Array(t.length - 1);
          s[0] = t[0][e];
          for (var u = 1; u < s.length; u++) s[u] = s[u - 1] + t[u][e];
          var c = o[e],
            l = o.slice(-2),
            p = o.join(),
            h =
              "if (" +
              c +
              " < " +
              s[0] +
              ") {\n        return getChannel(\n            getT0(" +
              p +
              "), vec2(" +
              l.join() +
              "));\n        }";
          for (u = 1; u < s.length; u++) {
            var f = s[u - 1];
            h +=
              "\n        if (" +
              c +
              " < " +
              s[u] +
              "  && " +
              c +
              " >= " +
              s[u - 1] +
              ") {\n          return getChannel(\n            getT" +
              u +
              "(" +
              ua(o, c, f) +
              "),\n            vec2(" +
              ua(l, c, f) +
              "));\n        }";
          }
          var d = s.length,
            m = s[s.length - 1];
          (h +=
            "\n        return getChannel(\n          getT" +
            d +
            "(" +
            ua(o, c, m) +
            "),\n          vec2(" +
            ua(l, c, m) +
            "));"),
            (this.userCode =
              "\n      float getValue(" +
              o.map(function (t) {
                return "int " + t;
              }) +
              ") {\n        " +
              h +
              "\n      }\n\n      void main() {\n        " +
              i +
              " coords = getOutputCoords();\n        vec4 result = vec4(getValue(" +
              a +
              "), 0., 0., 0.);\n\n        " +
              a[r - 1] +
              " = " +
              a[r - 1] +
              " + 1;\n        if (" +
              a[r - 1] +
              " < " +
              n[r - 1] +
              ") {\n          result.g = getValue(" +
              a +
              ");\n        }\n\n        " +
              a[r - 2] +
              " = " +
              a[r - 2] +
              " + 1;\n        if (" +
              a[r - 2] +
              " < " +
              n[r - 2] +
              ") {\n          result.a = getValue(" +
              a +
              ");\n        }\n\n        " +
              a[r - 1] +
              " = " +
              a[r - 1] +
              " - 1;\n        if (" +
              a[r - 2] +
              " < " +
              n[r - 2] +
              " &&\n            " +
              a[r - 1] +
              " < " +
              n[r - 1] +
              ") {\n          result.b = getValue(" +
              a +
              ");\n        }\n        setOutput(result);\n      }\n    ");
        };
      function ua(t, e, n) {
        var r = t.indexOf(e);
        return t
          .map(function (t, e) {
            return e === r ? t + " - " + n : t;
          })
          .join();
      }
      var ca = function (t) {
          (this.variableNames = ["x", "dy"]),
            (this.outputShape = t.filterShape);
          var e = t.strideHeight,
            n = t.strideWidth,
            r = t.padInfo.top,
            i = t.padInfo.left,
            a = "channelsLast" === t.dataFormat;
          this.userCode =
            "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " +
            t.batchSize +
            "; b++) {\n          for (int yR = 0; yR < " +
            t.outHeight +
            "; yR++) {\n            int xR = wR + yR * " +
            e +
            " - " +
            r +
            ";\n\n            if (xR < 0 || xR >= " +
            t.inHeight +
            ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " +
            t.outWidth +
            "; yC++) {\n              int xC = wC + yC * " +
            n +
            " - " +
            i +
            ";\n\n              if (xC < 0 || xC >= " +
            t.inWidth +
            ") {\n                continue;\n              }\n\n              if (" +
            a +
            ") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
        },
        la = function (t) {
          (this.variableNames = ["dy", "W"]), (this.outputShape = t.inShape);
          var e = t.filterHeight,
            n = t.filterWidth,
            r = t.strideHeight,
            i = t.strideWidth,
            a = "channelsLast" === t.dataFormat,
            o = e - 1 - t.padInfo.top,
            s = n - 1 - t.padInfo.left,
            u = a ? 1 : 2,
            c = a ? 2 : 3,
            l = a ? 3 : 1;
          this.userCode =
            "\n      const ivec2 pads = ivec2(" +
            o +
            ", " +
            s +
            ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[" +
            l +
            "];\n\n        ivec2 dyCorner = ivec2(coords[" +
            u +
            "], coords[" +
            c +
            "]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " +
            e +
            "; wR++) {\n          float dyR = float(dyRCorner + wR) / " +
            r +
            ".0;\n\n          if (dyR < 0.0 || dyR >= " +
            t.outHeight +
            ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " +
            e +
            " - 1 - wR;\n\n          for (int wC = 0; wC < " +
            n +
            "; wC++) {\n            float dyC = float(dyCCorner + wC) / " +
            i +
            ".0;\n\n            if (dyC < 0.0 || dyC >= " +
            t.outWidth +
            ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " +
            n +
            " - 1 - wC;\n\n            for (int d2 = 0; d2 < " +
            t.outChannels +
            "; d2++) {\n\n              if (" +
            a +
            ") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
        },
        pa = function (t) {
          (this.variableNames = ["x", "dy"]),
            (this.outputShape = t.filterShape);
          var e = t.strideDepth,
            n = t.strideHeight,
            r = t.strideWidth,
            i = t.padInfo.front,
            a = t.padInfo.top,
            o = t.padInfo.left;
          this.userCode =
            "\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " +
            t.batchSize +
            "; b++) {\n          for (int yF = 0; yF < " +
            t.outDepth +
            "; yF++) {\n            int xF = wF + yF * " +
            e +
            " - " +
            i +
            ";\n\n            if (xF < 0 || xF >= " +
            t.inDepth +
            ") {\n              continue;\n            }\n\n            for (int yR = 0; yR < " +
            t.outHeight +
            "; yR++) {\n              int xR = wR + yR * " +
            n +
            " - " +
            a +
            ";\n\n              if (xR < 0 || xR >= " +
            t.inHeight +
            ") {\n                continue;\n              }\n\n              for (int yC = 0; yC < " +
            t.outWidth +
            "; yC++) {\n                int xC = wC + yC * " +
            r +
            " - " +
            o +
            ";\n\n                if (xC < 0 || xC >= " +
            t.inWidth +
            ") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
        },
        ha = function (t) {
          (this.variableNames = ["dy", "W"]), (this.outputShape = t.inShape);
          var e = t.filterDepth,
            n = t.filterHeight,
            r = t.filterWidth,
            i = t.strideDepth,
            a = t.strideHeight,
            o = t.strideWidth,
            s = e - 1 - t.padInfo.front,
            u = n - 1 - t.padInfo.top,
            c = r - 1 - t.padInfo.left;
          this.userCode =
            "\n      const ivec3 pads = ivec3(" +
            s +
            ", " +
            u +
            ", " +
            c +
            ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " +
            e +
            "; wF++) {\n          float dyF = float(dyFCorner + wF) / " +
            i +
            ".0;\n\n          if (dyF < 0.0 || dyF >= " +
            t.outDepth +
            ".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = " +
            e +
            " - 1 - wF;\n\n          for (int wR = 0; wR < " +
            n +
            "; wR++) {\n            float dyR = float(dyRCorner + wR) / " +
            a +
            ".0;\n\n            if (dyR < 0.0 || dyR >= " +
            t.outHeight +
            ".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = " +
            n +
            " - 1 - wR;\n\n            for (int wC = 0; wC < " +
            r +
            "; wC++) {\n              float dyC = float(dyCCorner + wC) / " +
            o +
            ".0;\n\n              if (dyC < 0.0 || dyC >= " +
            t.outWidth +
            ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = " +
            r +
            " - 1 - wC;\n\n              for (int d2 = 0; d2 < " +
            t.outChannels +
            "; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
        },
        fa = function (t) {
          (this.variableNames = ["x", "dy"]),
            (this.outputShape = t.filterShape);
          var e = t.strideHeight,
            n = t.strideWidth,
            r = t.padInfo.top,
            i = t.padInfo.left,
            a = t.outChannels / t.inChannels;
          this.userCode =
            "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * " +
            a +
            " + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < " +
            t.batchSize +
            "; b++) {\n          for (int yR = 0; yR < " +
            t.outHeight +
            "; yR++) {\n            int xR = wR + yR * " +
            e +
            " - " +
            r +
            ";\n\n            if (xR < 0 || xR >= " +
            t.inHeight +
            ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " +
            t.outWidth +
            "; yC++) {\n              int xC = wC + yC * " +
            n +
            " - " +
            i +
            ";\n\n              if (xC < 0 || xC >= " +
            t.inWidth +
            ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
        },
        da = function (t) {
          (this.variableNames = ["dy", "W"]), (this.outputShape = t.inShape);
          var e = t.filterHeight,
            n = t.filterWidth,
            r = t.strideHeight,
            i = t.strideWidth,
            a = e - 1 - t.padInfo.top,
            o = n - 1 - t.padInfo.left,
            s = t.outChannels / t.inChannels;
          this.userCode =
            "\n      const ivec2 pads = ivec2(" +
            a +
            ", " +
            o +
            ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < " +
            e +
            "; wR++) {\n          float dyR = float(dyRCorner + wR) / " +
            r +
            ".0;\n\n          if (dyR < 0.0 || dyR >= " +
            t.outHeight +
            ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " +
            e +
            " - 1 - wR;\n\n          for (int wC = 0; wC < " +
            n +
            "; wC++) {\n            float dyC = float(dyCCorner + wC) / " +
            i +
            ".0;\n\n            if (dyC < 0.0 || dyC >= " +
            t.outWidth +
            ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " +
            n +
            " - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < " +
            s +
            "; dm++) {\n              int d2 = d1 * " +
            s +
            " + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
        },
        ma = function (t, e, n, r) {
          void 0 === e && (e = !1),
            void 0 === n && (n = null),
            void 0 === r && (r = !1),
            (this.variableNames = ["x", "W"]),
            (this.outputShape = t.outShape);
          var i = t.padInfo.top,
            a = t.padInfo.left,
            o = t.strideHeight,
            s = t.strideWidth,
            u = t.dilationHeight,
            c = t.dilationWidth,
            l = t.filterHeight,
            p = t.filterWidth,
            h = 4 * Math.floor(t.inChannels / 4),
            f = t.inChannels % 4,
            d = "channelsLast" === t.dataFormat,
            m = d ? 1 : 2,
            v = d ? 2 : 3,
            g = d ? 3 : 1,
            y = "",
            b = "";
          n &&
            ((y = r
              ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " +
                n +
                "\n        }"
              : "\n          float activation(float x) {\n            " +
                n +
                "\n          }\n        "),
            (b = "result = activation(result);"));
          var w = e ? "result += getBiasAtOutCoords();" : "";
          e && this.variableNames.push("bias"),
            r && this.variableNames.push("preluActivationWeights"),
            (this.userCode =
              "\n      " +
              y +
              "\n\n      const ivec2 strides = ivec2(" +
              o +
              ", " +
              s +
              ");\n      const ivec2 pads = ivec2(" +
              i +
              ", " +
              a +
              ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[" +
              g +
              "];\n\n        ivec2 xRCCorner =\n            ivec2(coords[" +
              m +
              "], coords[" +
              v +
              "]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " +
              l +
              "; wR++) {\n          int xR = xRCorner + wR * " +
              u +
              ";\n\n          if (xR < 0 || xR >= " +
              t.inHeight +
              ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " +
              p +
              "; wC++) {\n            int xC = xCCorner + wC * " +
              c +
              ";\n\n            if (xC < 0 || xC >= " +
              t.inWidth +
              ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " +
              h +
              "; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (" +
              d +
              ") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (" +
              (1 === f) +
              ") {\n\n              if (" +
              d +
              ") {\n                dotProd +=\n                    getX(batch, xR, xC, " +
              h +
              ") *\n                    getW(wR, wC, " +
              h +
              ", d2);\n              } else {\n                dotProd +=\n                    getX(batch, " +
              h +
              ", xR, xC) *\n                    getW(wR, wC, " +
              h +
              ", d2);\n              }\n\n            } else if (" +
              (2 === f) +
              ") {\n              vec2 wValues = vec2(\n                getW(wR, wC, " +
              h +
              ", d2),\n                getW(wR, wC, " +
              h +
              " + 1, d2)\n              );\n\n              if (" +
              d +
              ") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, " +
              h +
              "),\n                  getX(batch, xR, xC, " +
              h +
              " + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, " +
              h +
              ", xR, xC),\n                  getX(batch, " +
              h +
              " + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (" +
              (3 === f) +
              ") {\n              vec3 wValues = vec3(\n                getW(wR, wC, " +
              h +
              ", d2),\n                getW(wR, wC, " +
              h +
              " + 1, d2),\n                getW(wR, wC, " +
              h +
              " + 2, d2)\n              );\n\n              if (" +
              d +
              ") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, " +
              h +
              "),\n                  getX(batch, xR, xC, " +
              h +
              " + 1),\n                  getX(batch, xR, xC, " +
              h +
              " + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, " +
              h +
              ", xR, xC),\n                  getX(batch, " +
              h +
              " + 1, xR, xC),\n                  getX(batch, " +
              h +
              " + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        " +
              w +
              "\n        " +
              b +
              "\n        setOutput(result);\n      }\n    ");
        },
        va = function (t) {
          (this.variableNames = ["x", "W"]), (this.outputShape = t.outShape);
          var e = t.padInfo.front,
            n = t.padInfo.top,
            r = t.padInfo.left,
            i = t.strideDepth,
            a = t.strideHeight,
            o = t.strideWidth,
            s = t.dilationDepth,
            u = t.dilationHeight,
            c = t.dilationWidth,
            l = t.filterDepth,
            p = t.filterHeight,
            h = t.filterWidth,
            f = 4 * Math.floor(t.inChannels / 4),
            d = t.inChannels % 4;
          this.userCode =
            "\n      const ivec3 strides = ivec3(" +
            i +
            ", " +
            a +
            ", " +
            o +
            ");\n      const ivec3 pads = ivec3(" +
            e +
            ", " +
            n +
            ", " +
            r +
            ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " +
            l +
            "; wF++) {\n          int xF = xFCorner + wF * " +
            s +
            ";\n\n          if (xF < 0 || xF >= " +
            t.inDepth +
            ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " +
            p +
            "; wR++) {\n            int xR = xRCorner + wR * " +
            u +
            ";\n\n            if (xR < 0 || xR >= " +
            t.inHeight +
            ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " +
            h +
            "; wC++) {\n              int xC = xCCorner + wC * " +
            c +
            ";\n\n              if (xC < 0 || xC >= " +
            t.inWidth +
            ") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < " +
            f +
            "; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (" +
            (1 === d) +
            ") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, " +
            f +
            ") *\n                  getW(wF, wR, wC, " +
            f +
            ", d2);\n              } else if (" +
            (2 === d) +
            ") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, " +
            f +
            "),\n                  getX(batch, xF, xR, xC, " +
            f +
            " + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, " +
            f +
            ", d2),\n                  getW(wF, wR, wC, " +
            f +
            " + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (" +
            (3 === d) +
            ") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, " +
            f +
            "),\n                  getX(batch, xF, xR, xC, " +
            f +
            " + 1),\n                  getX(batch, xF, xR, xC, " +
            f +
            " + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, " +
            f +
            ", d2),\n                  getW(wF, wR, wC, " +
            f +
            " + 1, d2),\n                  getW(wF, wR, wC, " +
            f +
            " + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
        },
        ga = function (t, e, n, r) {
          void 0 === e && (e = !1),
            void 0 === n && (n = null),
            void 0 === r && (r = !1),
            (this.variableNames = ["x", "W"]),
            (this.outputShape = t.outShape);
          var i = t.inHeight,
            a = t.inWidth,
            o = t.padInfo.top,
            s = t.padInfo.left,
            u = t.strideHeight,
            c = t.strideWidth,
            l = t.dilationHeight,
            p = t.dilationWidth,
            h = t.filterHeight,
            f = t.filterWidth,
            d = t.outChannels / t.inChannels,
            m = "",
            v = "";
          n &&
            ((m = r
              ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " +
                n +
                "\n        }"
              : "\n          float activation(float x) {\n            " +
                n +
                "\n          }\n        "),
            (v = "result = activation(result);"));
          var g = e ? "result += getBiasAtOutCoords();" : "";
          e && this.variableNames.push("bias"),
            r && this.variableNames.push("preluActivationWeights"),
            (this.userCode =
              "\n      " +
              m +
              "\n\n      const ivec2 strides = ivec2(" +
              u +
              ", " +
              c +
              ");\n      const ivec2 pads = ivec2(" +
              o +
              ", " +
              s +
              ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " +
              d +
              ";\n        int q = d2 - d1 * " +
              d +
              ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " +
              h +
              "; wR++) {\n          int xR = xRCorner + wR * " +
              l +
              ";\n\n          if (xR < 0 || xR >= " +
              i +
              ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " +
              f +
              "; wC++) {\n            int xC = xCCorner + wC * " +
              p +
              ";\n\n            if (xC < 0 || xC >= " +
              a +
              ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        " +
              g +
              "\n        " +
              v +
              "\n        setOutput(result);\n      }\n    ");
        },
        ya = function (t, e, n, r) {
          void 0 === e && (e = !1),
            void 0 === n && (n = null),
            void 0 === r && (r = !1),
            (this.variableNames = ["x", "W"]),
            (this.packedInputs = !0),
            (this.packedOutput = !0),
            (this.outputShape = t.outShape);
          for (
            var i = t.inHeight,
              a = t.inWidth,
              o = t.padInfo.top,
              s = t.padInfo.left,
              u = t.strideHeight,
              c = t.strideWidth,
              l = t.dilationHeight,
              p = t.dilationWidth,
              h = t.filterHeight,
              f = t.filterWidth,
              d = f,
              m = "int xR; int xC; int xCOffset;",
              v = 0;
            v < h;
            v++
          )
            for (var g = 0; g < f; g++)
              m +=
                "\n          vec4 xTexelR" +
                v +
                "C" +
                2 * g +
                " = vec4(0.);\n          vec4 wR" +
                v +
                "C" +
                g +
                " = vec4(0.);\n          vec4 xR" +
                v +
                "C" +
                g +
                " = vec4(0.);";
          for (v = 0; v < h; v++)
            for (var y = 0; y < d; y++) {
              if (
                ((m +=
                  "\n          xR = xRCorner + " +
                  v * l +
                  ";\n          xC = xCCorner + " +
                  (g = 2 * y) * p +
                  ";\n        "),
                1 === c)
              ) {
                if (
                  g < f &&
                  ((m +=
                    s % 2 == 1
                      ? "\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < " +
                        i +
                        " && xCOffset >= 0 && xCOffset < " +
                        a +
                        ") {\n                  xTexelR" +
                        v +
                        "C" +
                        g +
                        " = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= " +
                        a +
                        ") {\n                    xTexelR" +
                        v +
                        "C" +
                        g +
                        ".zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR" +
                        v +
                        "C" +
                        g +
                        " = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < " +
                        i +
                        " && xCOffset >= 0 && xCOffset < " +
                        a +
                        ") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= " +
                        a +
                        ") {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR" +
                        v +
                        "C" +
                        g +
                        " = vec4(previous.zw, xTexelR" +
                        v +
                        "C" +
                        g +
                        ".xy);\n                } else {\n                  xR" +
                        v +
                        "C" +
                        g +
                        " = vec4(0, 0, xTexelR" +
                        v +
                        "C" +
                        g +
                        ".xy);\n                }\n              "
                      : "\n                if(xR >= 0 && xR < " +
                        i +
                        " && xC >= 0 && xC < " +
                        a +
                        ") {\n                  xTexelR" +
                        v +
                        "C" +
                        g +
                        " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" +
                        v +
                        "C" +
                        g +
                        " = vec4(0.);\n                }\n\n                xR" +
                        v +
                        "C" +
                        g +
                        " = xTexelR" +
                        v +
                        "C" +
                        g +
                        ";\n              "),
                  g + 1 < f)
                ) {
                  var b = s % 2 == 0 ? O(p) : p;
                  (p % 2 == 0 && s % 2 == 1) || (p % 2 != 0 && s % 2 != 1)
                    ? ((m +=
                        "\n                  xCOffset = xC + " +
                        (s % 2) +
                        " + " +
                        b +
                        ";\n\n                  if(xR >= 0 && xR < " +
                        i +
                        " &&\n                    xCOffset >= 0 && xCOffset < " +
                        a +
                        ") {\n                    xTexelR" +
                        v +
                        "C" +
                        (g + 2) +
                        " = getX(batch, xR, xCOffset, d1);\n                  }\n                "),
                      p > 1 &&
                        (m +=
                          "\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < " +
                          i +
                          " &&\n                      xCOffset >= 0 && xCOffset < " +
                          a +
                          ") {\n                      xTexelR" +
                          v +
                          "C" +
                          g +
                          " = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR" +
                          v +
                          "C" +
                          g +
                          " = vec4(0.);\n                    }\n                  "),
                      (m +=
                        "\n                  xR" +
                        v +
                        "C" +
                        (g + 1) +
                        " = vec4(\n                    xTexelR" +
                        v +
                        "C" +
                        g +
                        ".zw, xTexelR" +
                        v +
                        "C" +
                        (g + 2) +
                        ".xy);\n                "))
                    : (m +=
                        "\n                  xCOffset = xC + " +
                        b +
                        ";\n\n                  if(xR >= 0 && xR < " +
                        i +
                        " &&\n                    xCOffset >= 0 && xCOffset < " +
                        a +
                        ") {\n                    xTexelR" +
                        v +
                        "C" +
                        (g + 2) +
                        " = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR" +
                        v +
                        "C" +
                        (g + 1) +
                        " = xTexelR" +
                        v +
                        "C" +
                        (g + 2) +
                        ";\n                ");
                }
              } else
                g < f &&
                  ((m +=
                    "\n              if(xR >= 0 && xR < " +
                    i +
                    ") {\n            "),
                  s % 2 == 1
                    ? ((m +=
                        "\n                xCOffset = xC + 1 - " +
                        c +
                        ";\n                if(xCOffset >= 0 && xCOffset < " +
                        a +
                        ") {\n                  xTexelR" +
                        v +
                        "C" +
                        g +
                        " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" +
                        v +
                        "C" +
                        g +
                        " = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < " +
                        a +
                        ") {\n                  xTexelR" +
                        v +
                        "C" +
                        (g + 2) +
                        " = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR" +
                        v +
                        "C" +
                        (g + 2) +
                        " = vec4(0.);\n                }\n\n                xR" +
                        v +
                        "C" +
                        g +
                        " = vec4(\n                  xTexelR" +
                        v +
                        "C" +
                        g +
                        ".zw, xTexelR" +
                        v +
                        "C" +
                        (g + 2) +
                        ".zw);\n              "),
                      g + 1 < f &&
                        (m +=
                          "\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + " +
                          c +
                          ";\n                  if(xCOffset >= 0 && xCOffset < " +
                          a +
                          ") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR" +
                          v +
                          "C" +
                          (g + 1) +
                          " = vec4(xTexelR" +
                          v +
                          "C" +
                          (g + 2) +
                          ".xy, final.xy);\n                "))
                    : ((m +=
                        "\n                if(xC >= 0 && xC < " +
                        a +
                        ") {\n                  xTexelR" +
                        v +
                        "C" +
                        g +
                        " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" +
                        v +
                        "C" +
                        g +
                        " = vec4(0.);\n                }\n\n                xCOffset = xC + " +
                        c +
                        ";\n                if(xCOffset >= 0 && xCOffset < " +
                        a +
                        ") {\n                  xTexelR" +
                        v +
                        "C" +
                        (g + 2) +
                        " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" +
                        v +
                        "C" +
                        (g + 2) +
                        " = vec4(0.);\n                }\n\n                xR" +
                        v +
                        "C" +
                        g +
                        " = vec4(\n                  xTexelR" +
                        v +
                        "C" +
                        g +
                        ".xy, xTexelR" +
                        v +
                        "C" +
                        (g + 2) +
                        ".xy);\n              "),
                      g + 1 < f &&
                        (m +=
                          "\n                  xR" +
                          v +
                          "C" +
                          (g + 1) +
                          " = vec4(\n                    xTexelR" +
                          v +
                          "C" +
                          g +
                          ".zw, xTexelR" +
                          v +
                          "C" +
                          (g + 2) +
                          ".zw);\n                ")),
                  (m += "}"));
              g < f &&
                ((m +=
                  "\n            vec4 wTexelR" +
                  v +
                  "C" +
                  g +
                  " = getW(" +
                  v +
                  ", " +
                  g +
                  ", d1, q);\n            wR" +
                  v +
                  "C" +
                  g +
                  " = vec4(wTexelR" +
                  v +
                  "C" +
                  g +
                  ".xz, wTexelR" +
                  v +
                  "C" +
                  g +
                  ".xz);\n          "),
                g + 1 < f &&
                  (m +=
                    "\n              vec4 wTexelR" +
                    v +
                    "C" +
                    (g + 1) +
                    " = getW(" +
                    v +
                    ", " +
                    (g + 1) +
                    ", d1, q);\n              wR" +
                    v +
                    "C" +
                    (g + 1) +
                    " =\n                vec4(wTexelR" +
                    v +
                    "C" +
                    (g + 1) +
                    ".xz, wTexelR" +
                    v +
                    "C" +
                    (g + 1) +
                    ".xz);"));
            }
          for (v = 0; v < h; v++)
            for (g = 0; g < f; g++)
              m += "dotProd += xR" + v + "C" + g + " * wR" + v + "C" + g + ";";
          var w = "",
            x = "";
          n &&
            ((w = r
              ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " +
                n +
                "\n        }"
              : "vec4 activation(vec4 x) {\n          " + n + "\n        }"),
            (x = "result = activation(result);"));
          var C = e ? "result += getBiasAtOutCoords();" : "";
          e && this.variableNames.push("bias"),
            r && this.variableNames.push("preluActivationWeights"),
            (this.userCode =
              "\n      " +
              w +
              "\n\n      const ivec2 strides = ivec2(" +
              u +
              ", " +
              c +
              ");\n      const ivec2 pads = ivec2(" +
              o +
              ", " +
              s +
              ");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        " +
              m +
              "\n\n        vec4 result = dotProd;\n        " +
              C +
              "\n        " +
              x +
              "\n        setOutput(result);\n      }\n    ");
        },
        ba = function (t, e, n, r, i) {
          (this.variableNames = ["Image", "Boxes", "BoxInd"]),
            (this.outputShape = []);
          var a = t[0],
            o = t[1],
            s = t[2],
            u = t[3],
            c = e[0],
            l = n[0],
            p = n[1];
          this.outputShape = [c, l, p, u];
          var h = "bilinear" === r ? 1 : 0,
            f = [o - 1 + ".0", s - 1 + ".0"],
            d = f[0],
            m = f[1],
            v =
              l > 1
                ? [
                    "" + (o - 1) / (l - 1),
                    "(y2-y1) * height_ratio",
                    "y1*" + d + " + float(y)*(height_scale)",
                  ]
                : ["0.0", "0.0", "0.5 * (y1+y2) * " + d],
            g = v[0],
            y = v[1],
            b = v[2],
            w =
              p > 1
                ? [
                    "" + (s - 1) / (p - 1),
                    "(x2-x1) * width_ratio",
                    "x1*" + m + " + float(x)*(width_scale)",
                  ]
                : ["0.0", "0.0", "0.5 * (x1+x2) * " + m],
            x = w[0],
            C = w[1],
            O = w[2];
          this.userCode =
            "\n      const float height_ratio = float(" +
            g +
            ");\n      const float width_ratio = float(" +
            x +
            ");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= " +
            a +
            ") {\n          return;\n        }\n\n        float height_scale = " +
            y +
            ";\n        float width_scale = " +
            C +
            ";\n\n        float in_y = " +
            b +
            ";\n        if( in_y < 0.0 || in_y > " +
            d +
            " ) {\n          setOutput(float(" +
            i +
            "));\n          return;\n        }\n        float in_x = " +
            O +
            ";\n        if( in_x < 0.0 || in_x > " +
            m +
            " ) {\n          setOutput(float(" +
            i +
            "));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(" +
            h +
            " == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ";
        },
        wa = function (t, e, n) {
          (this.variableNames = ["x"]), (this.outputShape = t);
          var r = t.length,
            i = t[t.length - 1],
            a = n ? "<" : ">";
          this.userCode =
            "\n      int getIndex(int i) {\n        " +
            (n ? "return " + i + " -i - 1;" : "return i;") +
            "\n      }\n\n      void main() {\n        " +
            Wi(r) +
            " coords = getOutputCoords();\n        int end = " +
            xa(r, "coords") +
            ";\n        float val = 0.0;\n        for (int i = " +
            i +
            " - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx " +
            a +
            " end) {\n            continue;\n          }\n          if (idx == end && " +
            e +
            ") {\n            continue;\n          }\n          " +
            xa(r, "coords") +
            " = idx;\n          val += getX(" +
            (function (t, e) {
              if (1 === t) return "" + e;
              if (2 === t) return e + ".x, " + e + ".y";
              if (3 === t) return e + ".x, " + e + ".y, " + e + ".z";
              if (4 === t)
                return e + ".x, " + e + ".y, " + e + ".z, " + e + ".w";
              throw Error(
                "Cumulative sum for rank " + t + " is not yet supported"
              );
            })(r, "coords") +
            ");\n        }\n        setOutput(val);\n      }\n    ";
        };
      function xa(t, e) {
        if (1 === t) return "" + e;
        if (2 === t) return e + ".y";
        if (3 === t) return e + ".z";
        if (4 === t) return e + ".w";
        throw Error("Cumulative sum for rank " + t + " is not yet supported");
      }
      var Ca = function (t) {
          (this.variableNames = ["A"]),
            (this.packedInputs = !1),
            (this.packedOutput = !0),
            (this.outPackingScheme = Bt.DENSE);
          var e = Zt(t),
            n = Ai();
          (this.outputShape = t),
            (this.userCode =
              "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " +
              Ti(["r", "c", "d"], t) +
              "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" +
              e[0] +
              ", " +
              e[1] +
              "));\n        int index = 4 * (resTexRC.x * " +
              e[1] +
              " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        " +
              n.output +
              " = result;\n      }\n    ");
        },
        Oa = function (t) {
          (this.variableNames = ["A"]),
            (this.packedInputs = !0),
            (this.packedOutput = !0),
            (this.outPackingScheme = Bt.DENSE);
          var e = Zt(t),
            n = Ai();
          (this.outputShape = t),
            (this.userCode =
              "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " +
              Ti(["r", "c", "d"], t) +
              "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" +
              e[0] +
              ", " +
              e[1] +
              "));\n        int index = 4 * (resTexRC.x * " +
              e[1] +
              " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        " +
              n.output +
              " = result;\n      }\n    ");
        },
        Ea = (function () {
          function t(t, e, n) {
            (this.variableNames = ["x"]),
              (this.outputShape = []),
              (this.outputShape = t),
              (this.blockSize = e),
              (this.dataFormat = n),
              (this.userCode =
                "\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = " +
                this.getHeightCoordString() +
                ";\n      int w = " +
                this.getWidthCoordString() +
                ";\n      int d = " +
                this.getDepthCoordString() +
                ";\n\n      int in_h = h / " +
                e +
                ";\n      int offset_h = imod(h, " +
                e +
                ");\n      int in_w = w / " +
                e +
                ";\n      int offset_w = imod(w, " +
                e +
                ");\n      int offset_d = (offset_h * " +
                e +
                " + offset_w) *\n        " +
                this.getOutputDepthSize() +
                ";\n      int in_d = d + offset_d;\n\n      float result = " +
                this.getInputSamplingString() +
                ";\n      setOutput(result);\n    }\n  ");
          }
          return (
            (t.prototype.getHeightCoordString = function () {
              return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]";
            }),
            (t.prototype.getWidthCoordString = function () {
              return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]";
            }),
            (t.prototype.getDepthCoordString = function () {
              return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]";
            }),
            (t.prototype.getOutputDepthSize = function () {
              return "NHWC" === this.dataFormat
                ? this.outputShape[3]
                : this.outputShape[1];
            }),
            (t.prototype.getInputSamplingString = function () {
              return "NHWC" === this.dataFormat
                ? "getX(b, in_h, in_w, in_d)"
                : "getX(b, in_d, in_h, in_w)";
            }),
            t
          );
        })(),
        Sa = function (t) {
          (this.variableNames = ["X"]),
            (this.outputShape = [t, t]),
            (this.userCode =
              "\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    ");
        },
        Na = function (t) {
          (this.variableNames = ["A"]), (this.outTexUsage = Wt.DOWNLOAD);
          var e = Ai();
          (this.outputShape = t),
            (this.userCode =
              "\n      " +
              Di +
              "\n\n      void main() {\n        float x = getAAtOutCoords();\n        " +
              e.output +
              " = encode_float(x);\n      }\n    ");
        },
        Ia = function (t) {
          (this.variableNames = ["A"]),
            (this.packedInputs = !0),
            (this.packedOutput = !1),
            (this.outTexUsage = Wt.DOWNLOAD);
          var e = Ai();
          (this.outputShape = t),
            (this.userCode =
              "\n      " +
              Di +
              "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        " +
              e.output +
              " = encode_float(x);\n      }\n    ");
        },
        ka = function (t, e, n) {
          void 0 === n && (n = !1), (this.variableNames = ["A"]);
          var r = Ai(),
            i = e[0],
            a = e[1];
          this.outputShape = t;
          var o = "result";
          n && (o = "floor(result * 255. + 0.5)"),
            (this.userCode =
              "\n      " +
              Ri(t) +
              "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n        \n        int r = flatIndex / " +
              a +
              ";\n        int c = imod(flatIndex, " +
              a +
              ");\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(" +
              a +
              ".0, " +
              i +
              ".0);\n        vec4 values = " +
              r.texture2D +
              "(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        " +
              r.output +
              " = vec4(" +
              o +
              ", 0., 0., 0.);\n      }\n    ");
        },
        _a = function (t, e, n) {
          void 0 === n && (n = !1),
            (this.variableNames = ["A"]),
            (this.packedInputs = !1),
            (this.packedOutput = !0);
          var r = Ai(),
            i = e[0],
            a = e[1];
          this.outputShape = t;
          var o = "",
            s = "result";
          n && (s = "floor(result * 255. + 0.5)");
          for (var u = 0; u <= 1; u++)
            for (var c = 0; c <= 1; c++) {
              var l = 2 * u + c;
              o +=
                "\n          localCoords = coords;\n          if(localCoords[2] + " +
                c +
                " < " +
                t[2] +
                ") {\n            localCoords[2] += " +
                c +
                ";\n            if(localCoords[1] + " +
                u +
                " < " +
                t[1] +
                ") {\n              localCoords[1] += " +
                u +
                ";\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / " +
                a +
                ";\n              c = imod(flatIndex, " +
                a +
                ");\n              uv = (vec2(c, r) + halfCR) / vec2(" +
                a +
                ".0, " +
                i +
                ".0);\n              values = " +
                r.texture2D +
                "(A, uv);\n\n              if(offset == 0) {\n                result[" +
                l +
                "] = values[0];\n              } else if(offset == 1) {\n                result[" +
                l +
                "] = values[1];\n              } else if(offset == 2) {\n                result[" +
                l +
                "] = values[2];\n              } else {\n                result[" +
                l +
                "] = values[3];\n              }\n            }\n          }\n        ";
            }
          this.userCode =
            "\n      " +
            Ri(t) +
            "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        " +
            o +
            "\n\n        " +
            r.output +
            " = " +
            s +
            ";\n      }\n    ";
        },
        Aa = function (t, e, n) {
          this.variableNames = ["real", "imag"];
          var r = e[1];
          this.outputShape = e;
          var i = n ? "2.0 * " + Math.PI : "-2.0 * " + Math.PI,
            a = n ? r + ".0" : "1.0";
          this.userCode =
            "\n      const float exponentMultiplier = " +
            i +
            ";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        " +
            t +
            "\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(" +
            r +
            ");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < " +
            r +
            "; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / " +
            a +
            ";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ";
        },
        Ta = (function () {
          function t(t, e) {
            (this.outputShape = []),
              (this.variableNames = ["x"]),
              (this.outputShape = t),
              (this.userCode =
                "\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    ");
          }
          return (
            (t.prototype.getCustomSetupFunc = function (t) {
              var e = this;
              return function (n, r) {
                null == e.valueLoc &&
                  (e.valueLoc = n.getUniformLocationNoThrow(r, "value")),
                  n.gl.uniform1f(e.valueLoc, t);
              };
            }),
            t
          );
        })(),
        Ra = function (t, e, n) {
          this.variableNames = ["A", "indices"];
          var r = t.slice();
          (r[n] = e), (this.outputShape = r), (this.rank = r.length);
          var i = Wi(this.rank),
            a = (function (t, e) {
              var n = t.length;
              if (n > 4)
                throw Error("Gather for rank " + n + " is not yet supported");
              if (1 === n) return "int(getIndices(resRC))";
              for (
                var r = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"],
                  i = [],
                  a = 0;
                a < t.length;
                a++
              )
                a === e
                  ? i.push("int(getIndices(" + r[a] + "))")
                  : i.push("" + r[a]);
              return i.join();
            })(t, n);
          this.userCode =
            "\n      void main() {\n        " +
            i +
            " resRC = getOutputCoords();\n        setOutput(getA(" +
            a +
            "));\n      }\n    ";
        },
        Da = function (t, e, n) {
          (this.sliceDim = t),
            (this.strides = e),
            (this.variableNames = ["x", "indices"]),
            (this.outputShape = n);
          var r = Wi(e.length),
            i = Wi(n.length),
            a = this.sliceDim > 1 ? "strides[j]" : "strides";
          this.userCode =
            "\n        " +
            r +
            " strides = " +
            r +
            "(" +
            this.strides +
            ");\n         void main() {\n          " +
            i +
            " coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < " +
            this.sliceDim +
            "; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * " +
            a +
            ";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      ";
        };
      function Fa(t, e) {
        var n = Ai();
        return ee(
          t,
          e,
          n.version +
            "\n    precision highp float;\n    " +
            n.attribute +
            " vec3 clipSpacePos;\n    " +
            n.attribute +
            " vec2 uv;\n    " +
            n.varyingVs +
            " vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"
        );
      }
      function Ma(t, e) {
        return ce(
          t,
          e,
          new Float32Array([
            -1,
            1,
            0,
            0,
            1,
            -1,
            -1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            -1,
            0,
            1,
            0,
          ])
        );
      }
      function ja(t, e) {
        return le(t, e, new Uint16Array([0, 1, 2, 2, 1, 3]));
      }
      function Pa(t, e, n, r, i, a, o) {
        he(n, r);
        var s = pe(t, e),
          u = t.TEXTURE_2D;
        return (
          Jt(t, e, function () {
            return t.bindTexture(u, s);
          }),
          Jt(t, e, function () {
            return t.texParameteri(u, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE);
          }),
          Jt(t, e, function () {
            return t.texParameteri(u, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE);
          }),
          Jt(t, e, function () {
            return t.texParameteri(u, t.TEXTURE_MIN_FILTER, t.NEAREST);
          }),
          Jt(t, e, function () {
            return t.texParameteri(u, t.TEXTURE_MAG_FILTER, t.NEAREST);
          }),
          Jt(t, e, function () {
            return t.texImage2D(u, 0, i, n, r, 0, a, o, null);
          }),
          Jt(t, e, function () {
            return t.bindTexture(t.TEXTURE_2D, null);
          }),
          s
        );
      }
      function za(t, e, n, r, i) {
        var a = Kt(n, r);
        return Pa(
          t,
          e,
          a[0],
          a[1],
          i.internalFormatFloat,
          i.textureFormatFloat,
          t.FLOAT
        );
      }
      function La(t, e, n, r, i) {
        var a = Kt(n, r);
        return Pa(
          t,
          e,
          a[0],
          a[1],
          i.internalFormatHalfFloat,
          i.textureFormatFloat,
          i.textureTypeHalfFloat
        );
      }
      function Ba(t, e, n, r, i) {
        var a = Kt(n, r);
        return Pa(t, e, a[0], a[1], t.RGBA, t.RGBA, t.UNSIGNED_BYTE);
      }
      function Wa(t, e, n, r, i) {
        var a = Xt(n, r);
        return Pa(
          t,
          e,
          a[0],
          a[1],
          i.internalFormatPackedFloat,
          t.RGBA,
          t.FLOAT
        );
      }
      function Ua(t, e, n, r, i) {
        var a = Xt(n, r);
        return Pa(
          t,
          e,
          a[0],
          a[1],
          i.internalFormatPackedHalfFloat,
          t.RGBA,
          i.textureTypeHalfFloat
        );
      }
      function Va(t, e, n, r) {
        return (
          Jt(t, e, function () {
            return t.bindBuffer(t.ARRAY_BUFFER, r);
          }),
          de(t, e, n, "clipSpacePos", r, 3, 20, 0) &&
            de(t, e, n, "uv", r, 2, 20, 12)
        );
      }
      function Ga(t, e, n, r, i, a, o) {
        var s, u, c;
        Jt(t, e, function () {
          return t.bindTexture(t.TEXTURE_2D, n);
        }),
          a instanceof Uint8Array
            ? ((s = new Uint8Array(r * i * 4)),
              (u = t.UNSIGNED_BYTE),
              (c = t.RGBA))
            : ((s = new Float32Array(r * i * 4)),
              (u = t.FLOAT),
              (c = o.internalFormatPackedFloat)),
          s.set(a),
          Jt(t, e, function () {
            return t.texImage2D(t.TEXTURE_2D, 0, c, r, i, 0, t.RGBA, u, s);
          }),
          Jt(t, e, function () {
            return t.bindTexture(t.TEXTURE_2D, null);
          });
      }
      function Ha(t, e, n, r) {
        Jt(t, e, function () {
          return t.bindTexture(t.TEXTURE_2D, n);
        }),
          r.data instanceof Uint8Array
            ? Jt(t, e, function () {
                return t.texImage2D(
                  t.TEXTURE_2D,
                  0,
                  t.RGBA,
                  r.width,
                  r.height,
                  0,
                  t.RGBA,
                  t.UNSIGNED_BYTE,
                  r.data
                );
              })
            : Jt(t, e, function () {
                return t.texImage2D(
                  t.TEXTURE_2D,
                  0,
                  t.RGBA,
                  t.RGBA,
                  t.UNSIGNED_BYTE,
                  r
                );
              }),
          Jt(t, e, function () {
            return t.bindTexture(t.TEXTURE_2D, null);
          });
      }
      function qa(t, e, n, r, i) {
        var a = t.createBuffer();
        Jt(t, e, function () {
          return t.bindBuffer(t.PIXEL_PACK_BUFFER, a);
        });
        var o = 16 * n * r;
        return (
          Jt(t, e, function () {
            return t.bufferData(t.PIXEL_PACK_BUFFER, o, t.STREAM_READ);
          }),
          Jt(t, e, function () {
            return t.readPixels(0, 0, r, n, t.RGBA, t.FLOAT, 0);
          }),
          Jt(t, e, function () {
            return t.bindBuffer(t.PIXEL_PACK_BUFFER, null);
          }),
          a
        );
      }
      function Ka(t, e, n) {
        var r = t,
          i = new Float32Array(n);
        return (
          r.bindBuffer(r.PIXEL_PACK_BUFFER, e),
          r.getBufferSubData(r.PIXEL_PACK_BUFFER, 0, i),
          r.bindBuffer(r.PIXEL_PACK_BUFFER, null),
          i
        );
      }
      function Za(t, e, n, r, i) {
        var a = Kt(n, r),
          o = a[0],
          s = a[1],
          u = new Uint8Array(n * r * 4);
        return (
          Jt(t, e, function () {
            return t.readPixels(
              0,
              0,
              o,
              s,
              i.downloadTextureFormat,
              t.UNSIGNED_BYTE,
              u
            );
          }),
          new Float32Array(u.buffer)
        );
      }
      function Xa(t, e, n, r, i, a, o, s) {
        var u = t,
          c = new Float32Array(
            (function (t, e) {
              var n = Xt(t, e);
              return n[0] * n[1] * 4;
            })(a, o)
          );
        return (
          u.bindBuffer(u.PIXEL_PACK_BUFFER, e),
          u.getBufferSubData(u.PIXEL_PACK_BUFFER, 0, c),
          u.bindBuffer(u.PIXEL_PACK_BUFFER, null),
          c
        );
      }
      function Ya(t, e, n, r) {
        var i = new Float32Array(n * r * 4);
        return (
          Jt(t, e, function () {
            return t.readPixels(0, 0, r, n, t.RGBA, t.FLOAT, i);
          }),
          i
        );
      }
      var Ja = Object.freeze({
          createVertexShader: Fa,
          createVertexBuffer: Ma,
          createIndexBuffer: ja,
          createFloat32MatrixTexture: za,
          createFloat16MatrixTexture: La,
          createUnsignedBytesMatrixTexture: Ba,
          createPackedMatrixTexture: Wa,
          createFloat16PackedMatrixTexture: Ua,
          bindVertexProgramAttributeStreams: Va,
          uploadDenseMatrixToTexture: Ga,
          uploadPixelDataToTexture: Ha,
          createBufferFromOutputTexture: qa,
          downloadFloat32MatrixFromBuffer: Ka,
          downloadByteEncodedFloatMatrixFromOutputTexture: Za,
          downloadPackedMatrixFromBuffer: Xa,
          downloadMatrixFromPackedOutputTexture: Ya,
        }),
        $a = (function () {
          function t(t) {
            (this.outputTexture = null),
              (this.program = null),
              (this.disposed = !1),
              (this.vertexAttrsAreBound = !1),
              (this.itemsToPoll = []);
            var e = h().getNumber("WEBGL_VERSION");
            null != t ? ((this.gl = t), Ht(e, t)) : (this.gl = qt(e));
            var n = "WEBGL_color_buffer_float";
            if (1 === h().getNumber("WEBGL_VERSION")) {
              if (
                ((this.textureFloatExtension = te(
                  this.gl,
                  this.debug,
                  "OES_texture_float"
                )),
                Fe(this.gl, "OES_texture_half_float"))
              )
                this.textureHalfFloatExtension = te(
                  this.gl,
                  this.debug,
                  "OES_texture_half_float"
                );
              else if (h().get("WEBGL_FORCE_F16_TEXTURES"))
                throw new Error(
                  "GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true."
                );
              if (
                ((this.colorBufferFloatExtension = this.gl.getExtension(n)),
                Fe(this.gl, "EXT_color_buffer_half_float"))
              )
                this.colorBufferHalfFloatExtension = te(
                  this.gl,
                  this.debug,
                  "EXT_color_buffer_half_float"
                );
              else if (h().get("WEBGL_FORCE_F16_TEXTURES"))
                throw new Error(
                  "GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true."
                );
            } else if (((n = "EXT_color_buffer_float"), Fe(this.gl, n)))
              this.colorBufferFloatExtension = this.gl.getExtension(n);
            else {
              if (!Fe(this.gl, "EXT_color_buffer_half_float"))
                throw new Error(
                  "GL context does not support color renderable floats"
                );
              this.colorBufferHalfFloatExtension = this.gl.getExtension(
                "EXT_color_buffer_half_float"
              );
            }
            (this.vertexBuffer = Ma(this.gl, this.debug)),
              (this.indexBuffer = ja(this.gl, this.debug)),
              (this.framebuffer = fe(this.gl, this.debug)),
              (this.textureConfig = Yt(
                this.gl,
                this.textureHalfFloatExtension
              ));
          }
          return (
            Object.defineProperty(t.prototype, "debug", {
              get: function () {
                return h().getBool("DEBUG");
              },
              enumerable: !0,
              configurable: !0,
            }),
            (t.prototype.dispose = function () {
              var t = this;
              if (!this.disposed) {
                null != this.program &&
                  console.warn(
                    "Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."
                  ),
                  null != this.outputTexture &&
                    console.warn(
                      "Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing."
                    );
                var e = this.gl;
                Jt(e, this.debug, function () {
                  return e.finish();
                }),
                  Jt(e, this.debug, function () {
                    return e.bindFramebuffer(e.FRAMEBUFFER, null);
                  }),
                  Jt(e, this.debug, function () {
                    return e.deleteFramebuffer(t.framebuffer);
                  }),
                  Jt(e, this.debug, function () {
                    return e.bindBuffer(e.ARRAY_BUFFER, null);
                  }),
                  Jt(e, this.debug, function () {
                    return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null);
                  }),
                  Jt(e, this.debug, function () {
                    return e.deleteBuffer(t.indexBuffer);
                  }),
                  (this.disposed = !0);
              }
            }),
            (t.prototype.createFloat32MatrixTexture = function (t, e) {
              return (
                this.throwIfDisposed(),
                za(this.gl, this.debug, t, e, this.textureConfig)
              );
            }),
            (t.prototype.createFloat16MatrixTexture = function (t, e) {
              return (
                this.throwIfDisposed(),
                La(this.gl, this.debug, t, e, this.textureConfig)
              );
            }),
            (t.prototype.createUnsignedBytesMatrixTexture = function (t, e) {
              return (
                this.throwIfDisposed(),
                Ba(this.gl, this.debug, t, e, this.textureConfig)
              );
            }),
            (t.prototype.uploadPixelDataToTexture = function (t, e) {
              this.throwIfDisposed(), Ha(this.gl, this.debug, t, e);
            }),
            (t.prototype.uploadDenseMatrixToTexture = function (t, e, n, r) {
              this.throwIfDisposed(),
                Ga(this.gl, this.debug, t, e, n, r, this.textureConfig);
            }),
            (t.prototype.createFloat16PackedMatrixTexture = function (t, e) {
              return (
                this.throwIfDisposed(),
                Ua(this.gl, this.debug, t, e, this.textureConfig)
              );
            }),
            (t.prototype.createPackedMatrixTexture = function (t, e) {
              return (
                this.throwIfDisposed(),
                Wa(this.gl, this.debug, t, e, this.textureConfig)
              );
            }),
            (t.prototype.deleteMatrixTexture = function (t) {
              var e = this;
              this.throwIfDisposed(),
                this.outputTexture === t &&
                  (we(this.gl, this.debug, this.framebuffer),
                  (this.outputTexture = null)),
                Jt(this.gl, this.debug, function () {
                  return e.gl.deleteTexture(t);
                });
            }),
            (t.prototype.downloadByteEncodedFloatMatrixFromOutputTexture = function (
              t,
              e,
              n
            ) {
              var r = this;
              return this.downloadMatrixDriver(t, function () {
                return Za(r.gl, r.debug, e, n, r.textureConfig);
              });
            }),
            (t.prototype.downloadPackedMatrixFromBuffer = function (
              t,
              e,
              n,
              r,
              i,
              a
            ) {
              return Xa(this.gl, t, 0, 0, 0, i, a, this.textureConfig);
            }),
            (t.prototype.downloadFloat32MatrixFromBuffer = function (t, e) {
              return Ka(this.gl, t, e);
            }),
            (t.prototype.createBufferFromTexture = function (t, e, n) {
              this.bindTextureToFrameBuffer(t);
              var r = qa(this.gl, this.debug, e, n, this.textureConfig);
              return this.unbindTextureToFrameBuffer(), r;
            }),
            (t.prototype.createAndWaitForFence = function () {
              var t = this.createFence(this.gl);
              return this.pollFence(t);
            }),
            (t.prototype.createFence = function (t) {
              var e,
                n,
                r = this;
              if (h().getBool("WEBGL_FENCE_API_ENABLED")) {
                var i = t,
                  a = i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE, 0);
                t.flush(),
                  (n = function () {
                    var t = i.clientWaitSync(a, 0, 0);
                    return (
                      t === i.ALREADY_SIGNALED || t === i.CONDITION_SATISFIED
                    );
                  }),
                  (e = a);
              } else
                h().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") >
                0
                  ? ((e = this.beginQuery()),
                    this.endQuery(),
                    (n = function () {
                      return r.isQueryAvailable(
                        e,
                        h().getNumber(
                          "WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"
                        )
                      );
                    }))
                  : (n = function () {
                      return !0;
                    });
              return { query: e, isFencePassed: n };
            }),
            (t.prototype.downloadMatrixFromPackedTexture = function (t, e, n) {
              var r = this;
              return this.downloadMatrixDriver(t, function () {
                return Ya(r.gl, r.debug, e, n);
              });
            }),
            (t.prototype.createProgram = function (t) {
              this.throwIfDisposed();
              var e = this.gl,
                n = ne(e, this.debug, t),
                r = Fa(e, this.debug),
                i = oe(e, this.debug);
              return (
                Jt(e, this.debug, function () {
                  return e.attachShader(i, r);
                }),
                Jt(e, this.debug, function () {
                  return e.attachShader(i, n);
                }),
                se(e, this.debug, i),
                this.debug && ue(e, this.debug, i),
                this.vertexAttrsAreBound ||
                  (this.setProgram(i),
                  (this.vertexAttrsAreBound = Va(
                    e,
                    this.debug,
                    this.program,
                    this.vertexBuffer
                  ))),
                i
              );
            }),
            (t.prototype.deleteProgram = function (t) {
              var e = this;
              this.throwIfDisposed(),
                t === this.program && (this.program = null),
                null != t &&
                  Jt(this.gl, this.debug, function () {
                    return e.gl.deleteProgram(t);
                  });
            }),
            (t.prototype.setProgram = function (t) {
              var e = this;
              this.throwIfDisposed(),
                (this.program = t),
                null != this.program &&
                  this.debug &&
                  ue(this.gl, this.debug, this.program),
                Jt(this.gl, this.debug, function () {
                  return e.gl.useProgram(t);
                });
            }),
            (t.prototype.getUniformLocation = function (t, e, n) {
              return (
                void 0 === n && (n = !0),
                this.throwIfDisposed(),
                n ? ve(this.gl, this.debug, t, e) : ge(this.gl, t, e)
              );
            }),
            (t.prototype.getAttributeLocation = function (t, e) {
              var n = this;
              return (
                this.throwIfDisposed(),
                Jt(this.gl, this.debug, function () {
                  return n.gl.getAttribLocation(t, e);
                })
              );
            }),
            (t.prototype.getUniformLocationNoThrow = function (t, e) {
              return this.throwIfDisposed(), this.gl.getUniformLocation(t, e);
            }),
            (t.prototype.setInputMatrixTexture = function (t, e, n) {
              this.throwIfDisposed(),
                this.throwIfNoProgram(),
                ye(this.gl, this.debug, this.program, t, e, n);
            }),
            (t.prototype.setOutputMatrixTexture = function (t, e, n) {
              this.setOutputMatrixTextureDriver(t, n, e);
            }),
            (t.prototype.setOutputPackedMatrixTexture = function (t, e, n) {
              this.throwIfDisposed();
              var r = Xt(e, n),
                i = r[0],
                a = r[1];
              this.setOutputMatrixTextureDriver(t, i, a);
            }),
            (t.prototype.setOutputMatrixWriteRegion = function (t, e, n, r) {
              this.setOutputMatrixWriteRegionDriver(n, t, r, e);
            }),
            (t.prototype.setOutputPackedMatrixWriteRegion = function (
              t,
              e,
              n,
              r
            ) {
              throw new Error(
                "setOutputPackedMatrixWriteRegion not implemented."
              );
            }),
            (t.prototype.debugValidate = function () {
              null != this.program && ue(this.gl, this.debug, this.program),
                xe(this.gl);
            }),
            (t.prototype.executeProgram = function () {
              this.throwIfDisposed(), this.throwIfNoProgram();
              var t = this.gl;
              this.debug && this.debugValidate(),
                Jt(t, this.debug, function () {
                  return t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0);
                });
            }),
            (t.prototype.blockUntilAllProgramsCompleted = function () {
              var t = this;
              this.throwIfDisposed(),
                Jt(this.gl, this.debug, function () {
                  return t.gl.finish();
                });
            }),
            (t.prototype.getQueryTimerExtension = function () {
              return (
                null == this.disjointQueryTimerExtension &&
                  (this.disjointQueryTimerExtension = te(
                    this.gl,
                    this.debug,
                    2 ===
                      h().getNumber(
                        "WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"
                      )
                      ? "EXT_disjoint_timer_query_webgl2"
                      : "EXT_disjoint_timer_query"
                  )),
                this.disjointQueryTimerExtension
              );
            }),
            (t.prototype.getQueryTimerExtensionWebGL2 = function () {
              return this.getQueryTimerExtension();
            }),
            (t.prototype.getQueryTimerExtensionWebGL1 = function () {
              return this.getQueryTimerExtension();
            }),
            (t.prototype.beginQuery = function () {
              if (
                2 ===
                h().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")
              ) {
                var t = this.gl,
                  e = this.getQueryTimerExtensionWebGL2(),
                  n = t.createQuery();
                return t.beginQuery(e.TIME_ELAPSED_EXT, n), n;
              }
              var r = this.getQueryTimerExtensionWebGL1(),
                i = r.createQueryEXT();
              return r.beginQueryEXT(r.TIME_ELAPSED_EXT, i), i;
            }),
            (t.prototype.endQuery = function () {
              if (
                2 !==
                h().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")
              ) {
                var t = this.getQueryTimerExtensionWebGL1();
                t.endQueryEXT(t.TIME_ELAPSED_EXT);
              } else {
                var e = this.gl,
                  n = this.getQueryTimerExtensionWebGL2();
                e.endQuery(n.TIME_ELAPSED_EXT);
              }
            }),
            (t.prototype.waitForQueryAndGetTime = function (t) {
              return u(this, void 0, void 0, function () {
                var e = this;
                return c(this, function (n) {
                  switch (n.label) {
                    case 0:
                      return [
                        4,
                        M(function () {
                          return (
                            e.disposed ||
                            e.isQueryAvailable(
                              t,
                              h().getNumber(
                                "WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"
                              )
                            )
                          );
                        }),
                      ];
                    case 1:
                      return (
                        n.sent(),
                        [
                          2,
                          this.getQueryTime(
                            t,
                            h().getNumber(
                              "WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"
                            )
                          ),
                        ]
                      );
                  }
                });
              });
            }),
            (t.prototype.getQueryTime = function (t, e) {
              if (0 === e) return null;
              if (2 === e) {
                var n = this.gl;
                return n.getQueryParameter(t, n.QUERY_RESULT) / 1e6;
              }
              var r = this.getQueryTimerExtensionWebGL1();
              return r.getQueryObjectEXT(t, r.QUERY_RESULT_EXT) / 1e6;
            }),
            (t.prototype.isQueryAvailable = function (t, e) {
              if (0 === e) return !0;
              if (2 === e) {
                var n = this.gl,
                  r = this.getQueryTimerExtensionWebGL2(),
                  i = n.getQueryParameter(t, n.QUERY_RESULT_AVAILABLE);
                return (
                  null == this.disjoint &&
                    (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)),
                  i && !this.disjoint
                );
              }
              return (
                (i = (r = this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(
                  t,
                  r.QUERY_RESULT_AVAILABLE_EXT
                )),
                null == this.disjoint &&
                  (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)),
                i && !this.disjoint
              );
            }),
            (t.prototype.pollFence = function (t) {
              var e = this;
              return new Promise(function (n) {
                e.addItemToPoll(
                  function () {
                    return t.isFencePassed();
                  },
                  function () {
                    return n();
                  }
                );
              });
            }),
            (t.prototype.pollItems = function () {
              for (
                var t = (function (t) {
                    for (var e = 0; e < t.length && t[e](); ++e);
                    return e - 1;
                  })(
                    this.itemsToPoll.map(function (t) {
                      return t.isDoneFn;
                    })
                  ),
                  e = 0;
                e <= t;
                ++e
              )
                (0, this.itemsToPoll[e].resolveFn)();
              this.itemsToPoll = this.itemsToPoll.slice(t + 1);
            }),
            (t.prototype.addItemToPoll = function (t, e) {
              var n = this;
              this.itemsToPoll.push({ isDoneFn: t, resolveFn: e }),
                this.itemsToPoll.length > 1 ||
                  M(function () {
                    return n.pollItems(), 0 === n.itemsToPoll.length;
                  });
            }),
            (t.prototype.bindTextureToFrameBuffer = function (t) {
              this.throwIfDisposed(),
                be(this.gl, this.debug, t, this.framebuffer),
                this.debug && xe(this.gl);
            }),
            (t.prototype.unbindTextureToFrameBuffer = function () {
              null != this.outputTexture
                ? (be(
                    this.gl,
                    this.debug,
                    this.outputTexture,
                    this.framebuffer
                  ),
                  this.debug && xe(this.gl))
                : we(this.gl, this.debug, this.framebuffer);
            }),
            (t.prototype.downloadMatrixDriver = function (t, e) {
              this.bindTextureToFrameBuffer(t);
              var n = e();
              return this.unbindTextureToFrameBuffer(), n;
            }),
            (t.prototype.setOutputMatrixTextureDriver = function (t, e, n) {
              this.throwIfDisposed();
              var r = this.gl;
              be(r, this.debug, t, this.framebuffer),
                this.debug && xe(r),
                (this.outputTexture = t),
                Jt(r, this.debug, function () {
                  return r.viewport(0, 0, e, n);
                }),
                Jt(r, this.debug, function () {
                  return r.scissor(0, 0, e, n);
                });
            }),
            (t.prototype.setOutputMatrixWriteRegionDriver = function (
              t,
              e,
              n,
              r
            ) {
              var i = this;
              this.throwIfDisposed(),
                Jt(this.gl, this.debug, function () {
                  return i.gl.scissor(t, e, n, r);
                });
            }),
            (t.prototype.throwIfDisposed = function () {
              if (this.disposed)
                throw new Error("Attempted to use disposed GPGPUContext.");
            }),
            (t.prototype.throwIfNoProgram = function () {
              if (null == this.program)
                throw new Error("No GPU program is currently set.");
            }),
            t
          );
        })();
      function Qa(t, e) {
        if (t.length !== e.length)
          throw Error(
            "Binary was compiled with " +
              t.length +
              " inputs, but was executed with " +
              e.length +
              " inputs"
          );
        t.forEach(function (t, n) {
          var r = t.logicalShape,
            i = e[n],
            a = i.shape;
          if (!A(r, a))
            throw Error(
              "Binary was compiled with different shapes than the current args. Shapes " +
                r +
                " and " +
                a +
                " must match"
            );
          if (!t.isUniform || !i.isUniform) {
            var o = t.texShape,
              s = i.isUniform ? null : i.texData.texShape;
            if (!A(o, s))
              throw Error(
                "Binary was compiled with different texture shapes than the current args. Shape " +
                  o +
                  " and " +
                  s +
                  " must match"
              );
          }
        });
      }
      var to = function (t, e, n) {
          (this.variableNames = ["A"]),
            (this.packedInputs = !0),
            (this.packedOutput = !0),
            (this.outputShape = t);
          for (
            var r = n.filterWidth,
              i = n.inChannels,
              a = n.strideWidth,
              o = n.strideHeight,
              s = n.padInfo,
              u = n.outWidth,
              c = n.dilationWidth,
              l = n.dilationHeight,
              p = n.dataFormat,
              h = s.left,
              f = s.top,
              d = i * r,
              m = Ai(),
              v = "channelsLast" === p,
              g = v ? 0 : 1,
              y = v ? 1 : 2,
              b = "",
              w = 0;
            w <= 1;
            w++
          )
            for (var x = 0; x <= 1; x++)
              b +=
                "\n          blockIndex = rc.y + " +
                x +
                ";\n          pos = rc.x + " +
                w +
                ";\n\n          if(blockIndex < " +
                t[1] +
                " && pos < " +
                t[0] +
                ") {\n            offsetY = int(blockIndex / (" +
                u +
                ")) * " +
                o +
                " - " +
                f +
                ";\n            d0 = offsetY + " +
                l +
                " * (pos / " +
                d +
                ");\n\n            if(d0 < " +
                e[g] +
                " && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), " +
                u +
                ".) * " +
                a +
                ". - " +
                h +
                ".);\n              d1 = offsetX + " +
                c +
                " * (int(mod(float(pos), " +
                d +
                ".) / " +
                i +
                ".));\n\n              if(d1 < " +
                e[y] +
                " && d1 >= 0) {\n\n                ch = int(mod(float(pos), " +
                i +
                ".));\n\n                if (" +
                v +
                ") {\n                  innerDims = vec2(d1, ch);\n                  result[" +
                (2 * w + x) +
                "] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[" +
                (2 * w + x) +
                "] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ";
          this.userCode =
            "\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        " +
            b +
            "\n\n        " +
            m.output +
            " = result;\n      }\n    ";
        },
        eo = function (t, e, n, r, i) {
          (this.variableNames = ["x"]), (this.outputShape = []);
          var a,
            o = e,
            s = t[3] - 1;
          this.outputShape = t;
          var u = "float(" + n + ") + float(" + r + ") * sum";
          (a =
            0.5 === i
              ? "inversesqrt(" + u + ")"
              : 1 === i
              ? "1.0/(" + u + ")"
              : "exp(log(" + u + ") * float(-" + i + "));"),
            (this.userCode =
              "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -" +
              o +
              "; j <= " +
              o +
              "; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  " +
              s +
              ") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * " +
              a +
              ";\n        setOutput(val);\n      }\n    ");
        },
        no = function (t, e, n, r, i) {
          (this.variableNames = ["inputImage", "outputImage", "dy"]),
            (this.outputShape = []),
            (this.outputShape = t),
            (this.depth = t[3]),
            (this.depthRadius = e),
            (this.bias = n),
            (this.alpha = r),
            (this.beta = i),
            (this.userCode =
              "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < " +
              this.depth +
              "; ++d) {\n          int depthBegin = int(max(0.0, float(d - " +
              e +
              ")));\n          int depthEnd = int(min(float(" +
              this.depth +
              "),\n              float(d + " +
              e +
              " + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = " +
              this.depth +
              ";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(" +
              r +
              ") * norm + float(" +
              n +
              ");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(" +
              r +
              ")\n                * float(" +
              i +
              ")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * " +
              i +
              ");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ");
        },
        ro = function (t, e, n, r, i) {
          (this.variableNames = ["x"]),
            (this.outputShape = []),
            (this.packedInputs = !0),
            (this.packedOutput = !0);
          var a,
            o = e,
            s = t[3] - 1;
          this.outputShape = t;
          var u = "float(" + n + ") + float(" + r + ") * sum";
          (a =
            0.5 === i
              ? "inversesqrt(" + u + ")"
              : 1 === i
              ? "1.0/(" + u + ")"
              : "exp(log(" + u + ") * float(-" + i + "));"),
            (this.userCode =
              "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < " +
              this.outputShape[3] +
              ";\n        bool hasNextRow = c < " +
              this.outputShape[2] +
              ";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - " +
              o +
              ";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - " +
              o +
              "; j <= " +
              o +
              "; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(" +
              s +
              "));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * " +
              a +
              ";\n        setOutput(result);\n      }\n    ");
        },
        io = function (t) {
          (this.variableNames = ["dy", "maxPos"]),
            (this.outputShape = t.inShape);
          var e = t.strideHeight,
            n = t.strideWidth,
            r = t.dilationHeight,
            i = t.effectiveFilterHeight,
            a = t.effectiveFilterWidth,
            o = i - 1 - t.padInfo.top,
            s = a - 1 - t.padInfo.left,
            u = i * a - 1;
          this.userCode =
            "\n      const ivec2 pads = ivec2(" +
            o +
            ", " +
            s +
            ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " +
            i +
            ";\n          wR += " +
            r +
            ") {\n          float dyR = float(dyRCorner + wR) / " +
            e +
            ".0;\n\n          if (dyR < 0.0 || dyR >= " +
            t.outHeight +
            ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " +
            a +
            "; wC++) {\n            float dyC = float(dyCCorner + wC) / " +
            n +
            ".0;\n\n            if (dyC < 0.0 || dyC >= " +
            t.outWidth +
            ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = " +
            u +
            " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " +
            a +
            " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
        },
        ao = function (t) {
          (this.variableNames = ["dy", "maxPos"]),
            (this.outputShape = t.inShape);
          var e = t.strideDepth,
            n = t.strideHeight,
            r = t.strideWidth,
            i = t.dilationDepth,
            a = t.dilationHeight,
            o = t.dilationWidth,
            s = t.effectiveFilterDepth,
            u = t.effectiveFilterHeight,
            c = t.effectiveFilterWidth,
            l = s - 1 - t.padInfo.front,
            p = u - 1 - t.padInfo.top,
            h = c - 1 - t.padInfo.left,
            f = s * u * c - 1;
          this.userCode =
            "\n      const ivec3 pads = ivec3(" +
            l +
            ", " +
            p +
            ", " +
            h +
            ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " +
            s +
            ";\n           wD += " +
            i +
            ") {\n          float dyD = float(dyDCorner + wD) / " +
            e +
            ".0;\n\n          if (dyD < 0.0 || dyD >= " +
            t.outDepth +
            ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " +
            u +
            ";\n              wR += " +
            a +
            ") {\n            float dyR = float(dyRCorner + wR) / " +
            n +
            ".0;\n\n            if (dyR < 0.0 || dyR >= " +
            t.outHeight +
            ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " +
            c +
            ";\n                wC += " +
            o +
            ") {\n              float dyC = float(dyCCorner + wC) / " +
            r +
            ".0;\n\n              if (dyC < 0.0 || dyC >= " +
            t.outWidth +
            ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = " +
            f +
            " -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * " +
            u +
            " * " +
            c +
            " +\n                  wR * " +
            c +
            " + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
        },
        oo = function (t, e, n, r, i, a, o) {
          void 0 === n && (n = !1),
            void 0 === r && (r = !1),
            void 0 === i && (i = !1),
            void 0 === a && (a = null),
            void 0 === o && (o = !1),
            (this.variableNames = ["matrixA", "matrixB"]),
            (this.packedInputs = !0),
            (this.packedOutput = !0),
            (this.outputShape = e);
          var s = n ? t[1] : t[2],
            u = Math.ceil(s / 2),
            c = n ? "i * 2, rc.y" : "rc.y, i * 2",
            l = r ? "rc.z, i * 2" : "i * 2, rc.z",
            p = n ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"],
            h = r ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"],
            f = "",
            d = "";
          a &&
            ((f = o
              ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " +
                a +
                "\n        }"
              : "vec4 activation(vec4 x) {\n          " + a + "\n        }"),
            (d = "result = activation(result);"));
          var m = i ? "result += getBiasAtOutCoords();" : "";
          i && this.variableNames.push("bias"),
            o && this.variableNames.push("preluActivationWeights"),
            (this.userCode =
              "\n      " +
              f +
              "\n\n      const float sharedDimension = " +
              u +
              ".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < " +
              u +
              "; i++) {\n          vec4 a = getMatrixA(rc.x, " +
              c +
              ");\n          vec4 b = getMatrixB(rc.x, " +
              l +
              ");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (" +
              p[0] +
              " * " +
              h[0] +
              ");\n          result += (" +
              p[1] +
              " * " +
              h[1] +
              ");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        " +
              m +
              "\n\n        " +
              d +
              "\n\n        setOutput(result);\n      }\n    ");
        },
        so = (function () {
          function t(t, e, n) {
            (this.variableNames = ["probs"]),
              (this.outputShape = [t, n]),
              (this.userCode =
                "\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " +
                (e - 1) +
                "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" +
                (e - 1) +
                "));\n      }\n    ");
          }
          return (
            (t.prototype.getCustomSetupFunc = function (t) {
              var e = this;
              return function (n, r) {
                null == e.seedLoc &&
                  (e.seedLoc = n.getUniformLocation(r, "seed")),
                  n.gl.uniform1f(e.seedLoc, t);
              };
            }),
            t
          );
        })(),
        uo = function (t, e, n, r) {
          (this.variableNames = ["indices"]),
            (this.outputShape = [t, e]),
            (this.userCode =
              "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" +
              r +
              "), float(" +
              n +
              "),\n                      float(index == coords.y)));\n      }\n    ");
        },
        co = function (t) {
          (this.variableNames = ["A"]),
            (this.packedInputs = !1),
            (this.packedOutput = !0),
            (this.outputShape = t);
          var e = t.length;
          if (0 === e)
            this.userCode =
              "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";
          else {
            var n = _i("rc", e),
              r = Wi(e),
              i = (function (t, e, n) {
                if (1 === t) return "rc > " + e[0];
                for (var r = "", i = t - 2; i < t; i++)
                  (r += n[i] + " >= " + e[i]), i < t - 1 && (r += "||");
                return r;
              })(e, t, n),
              a = (function (t, e, n, r) {
                if (1 === t) return "";
                var i = r.slice(-2);
                return (
                  "\n    int r = " +
                  i[0] +
                  ";\n    int c = " +
                  i[1] +
                  ";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= " +
                  e +
                  ";\n    bool rEdge = rp1 >= " +
                  n +
                  ";\n  "
                );
              })(e, t[t.length - 1], t[t.length - 2], n),
              o = (function (t, e) {
                var n = t.length,
                  r = (function (t, e) {
                    for (var n = [], r = 0; r <= 1; r++)
                      for (var i = 0; i <= 1; i++) {
                        for (
                          var a =
                              (0 === r ? "r" : "rp1") +
                              ", " +
                              (0 === i ? "c" : "cp1"),
                            o = 2;
                          o < t;
                          o++
                        )
                          a = e[e.length - 1 - o] + "," + a;
                        n.push(a);
                      }
                    return n;
                  })(n, e);
                return 1 === n
                  ? "getA(rc),\n            rc + 1 >= " +
                      t[0] +
                      " ? 0. : getA(rc + 1),\n            0, 0"
                  : "getA(" +
                      r[0] +
                      "),\n          cEdge ? 0. : getA(" +
                      r[1] +
                      "),\n          rEdge ? 0. : getA(" +
                      r[2] +
                      "),\n          rEdge || cEdge ? 0. : getA(" +
                      r[3] +
                      ")";
              })(t, n);
            this.userCode =
              "\n        void main() {\n          " +
              r +
              " rc = getOutputCoords();\n\n          if(" +
              i +
              ") {\n            setOutput(vec4(0));\n          } else {\n            " +
              a +
              "\n\n            setOutput(vec4(" +
              o +
              "));\n          }\n        }\n      ";
          }
        },
        lo = function (t, e, n) {
          (this.variableNames = ["x"]),
            (this.outputShape = e.map(function (e, n) {
              return e[0] + t[n] + e[1];
            }));
          var r = t.length,
            i = Wi(r),
            a = e
              .map(function (t) {
                return t[0];
              })
              .join(","),
            o = e
              .map(function (e, n) {
                return e[0] + t[n];
              })
              .join(","),
            s = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(
              0,
              r
            );
          this.userCode =
            1 !== r
              ? "\n      " +
                i +
                " start = " +
                i +
                "(" +
                a +
                ");\n      " +
                i +
                " end = " +
                i +
                "(" +
                o +
                ");\n\n      void main() {\n        " +
                i +
                " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(" +
                n +
                "));\n        } else {\n          " +
                i +
                " coords = outC - start;\n          setOutput(getX(" +
                s +
                "));\n        }\n      }\n    "
              : "\n        int start = " +
                a +
                ";\n        int end = " +
                o +
                ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(" +
                n +
                "));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ";
        },
        po = function (t, e, n) {
          (this.variableNames = ["x"]),
            (this.packedInputs = !0),
            (this.packedOutput = !0),
            (this.outputShape = e.map(function (e, n) {
              return e[0] + t[n] + e[1];
            }));
          for (
            var r = t.length,
              i = Wi(r),
              a = e
                .map(function (t) {
                  return t[0];
                })
                .join(","),
              o = e
                .map(function (e, n) {
                  return e[0] + t[n];
                })
                .join(","),
              s = _i("rc", r),
              u = _i("source", r),
              c = s[r - 1] + " < " + this.outputShape[r - 1],
              l = 1 === r ? "source" : "vec2(" + u.slice(-2).join() + ")",
              p = [
                i + " rc = outputLoc;",
                s[r - 1] + " += 1;\n       if(" + c + ") {\n      ",
                1 === r
                  ? ""
                  : "}\n       rc = outputLoc;\n       " +
                    s[r - 2] +
                    " += 1;\n       if(" +
                    s[r - 2] +
                    " < " +
                    this.outputShape[r - 2] +
                    ") {",
                1 === r
                  ? ""
                  : "  " + s[r - 1] + " += 1;\n         if(" + c + ") {",
              ],
              h =
                1 === r
                  ? "rc < start || rc >= end"
                  : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",
              f = "",
              d = 0,
              m = 1 === r ? 2 : 4;
            d < m;
            d++
          )
            f +=
              "\n        " +
              p[d] +
              "\n        if (" +
              h +
              ") {\n          result[" +
              d +
              "] = float(" +
              n +
              ");\n        } else {\n          " +
              i +
              " source = rc - start;\n          result[" +
              d +
              "] = getChannel(getX(" +
              u.join() +
              "), " +
              l +
              ");\n        }\n      ";
          (f += 1 === r ? "} " : "}}"),
            (this.userCode =
              "\n      const " +
              i +
              " start = " +
              i +
              "(" +
              a +
              ");\n      const " +
              i +
              " end = " +
              i +
              "(" +
              o +
              ");\n\n      void main() {\n        " +
              i +
              " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        " +
              f +
              "\n        setOutput(result);\n      }\n    ");
        },
        ho = function (t, e, n) {
          if (((this.variableNames = ["x"]), "avg" === e && n))
            throw new Error("Cannot compute positions for average pool.");
          var r = t.filterWidth,
            i = t.strideHeight,
            a = t.strideWidth,
            o = t.dilationHeight,
            s = t.dilationWidth,
            u = t.effectiveFilterHeight,
            c = t.effectiveFilterWidth,
            l = t.padInfo.top,
            p = t.padInfo.left;
          this.outputShape = t.outShape;
          var h = "avg" === e,
            f = "0.0";
          if ((h || (f = "-1.0 / 1e-20"), n))
            this.userCode =
              "\n        const ivec2 strides = ivec2(" +
              i +
              ", " +
              a +
              ");\n        const ivec2 pads = ivec2(" +
              l +
              ", " +
              p +
              ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " +
              u +
              ";\n              wR += " +
              o +
              ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " +
              t.inHeight +
              ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " +
              c +
              ";\n                wC += " +
              s +
              ") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " +
              t.inWidth +
              ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * " +
              c +
              " + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
          else {
            var d =
              e +
              "(" +
              e +
              "(" +
              e +
              "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
            "avg" === e && (d = "avgValue / count");
            var m = 4 * Math.floor(r / 4),
              v = r % 4,
              g =
                "\n      if (" +
                h +
                ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
            this.userCode =
              "\n      const ivec2 strides = ivec2(" +
              i +
              ", " +
              a +
              ");\n      const ivec2 pads = ivec2(" +
              l +
              ", " +
              p +
              ");\n      const float initializationValue = " +
              f +
              ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= " +
              t.inWidth +
              ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" +
              f +
              ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < " +
              u +
              ";\n            wR += " +
              o +
              ") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " +
              t.inHeight +
              ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " +
              m +
              "; wC += 4) {\n            int xC = xCCorner + wC * " +
              s +
              ";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " +
              s +
              ", d),\n              getValue(batch, xR, xC + 2 * " +
              s +
              ", d),\n              getValue(batch, xR, xC + 3 * " +
              s +
              ", d)\n            );\n\n            " +
              g +
              "\n          }\n\n          int xC = xCCorner + " +
              m +
              ";\n          if (" +
              (1 === v) +
              ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            " +
              g +
              "\n          } else if (" +
              (2 === v) +
              ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " +
              s +
              ", d),\n              initializationValue,\n              initializationValue\n            );\n\n            " +
              g +
              "\n          } else if (" +
              (3 === v) +
              ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " +
              s +
              ", d),\n              getValue(batch, xR, xC + 2 * " +
              s +
              ", d),\n              initializationValue\n            );\n\n            " +
              g +
              "\n          }\n        }\n        setOutput(" +
              d +
              ");\n      }\n    ";
          }
        },
        fo = function (t, e, n) {
          if (((this.variableNames = ["x"]), "avg" === e && n))
            throw new Error("Cannot compute positions for average pool.");
          var r = t.filterWidth,
            i = t.strideDepth,
            a = t.strideHeight,
            o = t.strideWidth,
            s = t.dilationDepth,
            u = t.dilationHeight,
            c = t.dilationWidth,
            l = t.effectiveFilterDepth,
            p = t.effectiveFilterHeight,
            h = t.effectiveFilterWidth,
            f = t.padInfo.front,
            d = t.padInfo.top,
            m = t.padInfo.left;
          this.outputShape = t.outShape;
          var v = "avg" === e,
            g = "0.0";
          if ((v || (g = "-1.0 / 1e-20"), n))
            this.userCode =
              "\n        const ivec3 strides =\n            ivec3(" +
              i +
              ", " +
              a +
              ", " +
              o +
              ");\n        const ivec3 pads = ivec3(" +
              f +
              ", " +
              d +
              ", " +
              m +
              ");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < " +
              l +
              ";\n              wD += " +
              s +
              ") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= " +
              t.inDepth +
              ") {\n              continue;\n            }\n\n            for (int wR = 0; wR < " +
              p +
              ";\n                wR += " +
              u +
              ") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= " +
              t.inHeight +
              ") {\n                continue;\n              }\n\n              for (int wC = 0; wC < " +
              h +
              ";\n                  wC += " +
              c +
              ") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= " +
              t.inWidth +
              ") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition =\n                      wD * " +
              p +
              " * " +
              h +
              " +\n                      wR * " +
              h +
              " + wC;;\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
          else {
            var y =
              e +
              "(" +
              e +
              "(" +
              e +
              "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
            "avg" === e && (y = "avgValue / count");
            var b = 4 * Math.floor(r / 4),
              w = r % 4,
              x =
                "\n      if (" +
                v +
                ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
            this.userCode =
              "\n      const ivec3 strides =\n        ivec3(" +
              i +
              ", " +
              a +
              ", " +
              o +
              ");\n      const ivec3 pads = ivec3(" +
              f +
              ", " +
              d +
              ", " +
              m +
              ");\n      const float initializationValue = " +
              g +
              ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= " +
              t.inWidth +
              ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" +
              g +
              ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < " +
              l +
              ";\n            wD += " +
              s +
              ") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= " +
              t.inDepth +
              ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " +
              p +
              ";\n            wR += " +
              u +
              ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " +
              t.inHeight +
              ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " +
              b +
              "; wC += 4) {\n              int xC = xCCorner + wC * " +
              c +
              ";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " +
              c +
              ", ch),\n                getValue(batch, xD, xR, xC + 2 * " +
              c +
              ", ch),\n                getValue(batch, xD, xR, xC + 3 * " +
              c +
              ", ch)\n              );\n\n              " +
              x +
              "\n            }\n\n            int xC = xCCorner + " +
              b +
              ";\n            if (" +
              (1 === w) +
              ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              " +
              x +
              "\n            } else if (" +
              (2 === w) +
              ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " +
              c +
              ", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              " +
              x +
              "\n            } else if (" +
              (3 === w) +
              ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " +
              c +
              ", ch),\n                getValue(batch, xD, xR, xC + 2 * " +
              c +
              ", ch),\n                initializationValue\n              );\n\n              " +
              x +
              "\n            }\n          }\n          setOutput(" +
              y +
              ");\n        }\n      }\n    ";
          }
        },
        mo = function (t, e) {
          this.variableNames = ["x"];
          var n = t.windowSize,
            r = t.batchSize,
            i = t.inSize,
            a = Math.ceil(i / n);
          this.outputShape = [r, a];
          var o = "0.0",
            s = "";
          "prod" === e
            ? (o = "1.0")
            : "min" === e
            ? ((o = "1.0 / 1e-20"), (s = "min"))
            : "max" === e && ((o = "-1.0 / 1e-20"), (s = "max"));
          var u =
            e +
            "(" +
            e +
            "(" +
            e +
            "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
          "sum" === e
            ? (u = "sumValue")
            : "prod" === e
            ? (u = "prodValue")
            : "all" === e
            ? (u = "allValue")
            : "any" === e && (u = "anyValue");
          var c = 4 * Math.floor(n / 4),
            l = n % 4,
            p =
              "\n      if (" +
              ("sum" === e) +
              ") {\n        sumValue += dot(values, ones);\n      } else if (" +
              ("prod" === e) +
              ") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = " +
              s +
              "(values, minMaxValue);\n      }\n    ",
            h = "vec4";
          "all" === e
            ? ((o = "1.0"),
              (p =
                "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      "),
              (h = "bvec4"))
            : "any" === e &&
              ((o = "0.0"),
              (p =
                "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      "),
              (h = "bvec4"));
          var f = "";
          i % n > 0 &&
            (f =
              "\n        if (inIdx < 0 || inIdx >= " +
              i +
              ") {\n          return initializationValue;\n        }\n      "),
            (this.userCode =
              "\n      const float initializationValue = " +
              o +
              ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " +
              f +
              "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " +
              n +
              ";\n\n        vec4 minMaxValue = vec4(" +
              o +
              ");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < " +
              c +
              "; i += 4) {\n          int inIdx = inOffset + i;\n          " +
              h +
              " values = " +
              h +
              "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " +
              p +
              "\n        }\n\n        int inIdx = inOffset + " +
              c +
              ";\n        if (" +
              (1 === l) +
              ") {\n          " +
              h +
              " values = " +
              h +
              "(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          " +
              p +
              "\n        } else if (" +
              (2 === l) +
              ") {\n          " +
              h +
              " values = " +
              h +
              "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          " +
              p +
              "\n        } else if (" +
              (3 === l) +
              ") {\n          " +
              h +
              " values = " +
              h +
              "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          " +
              p +
              "\n        }\n        setOutput(" +
              u +
              ");\n      }\n    ");
        },
        vo = function (t, e) {
          (this.variableNames = ["A"]),
            (this.packedInputs = !0),
            (this.packedOutput = !0),
            (this.outputShape = t);
          for (var n = "", r = 0; r < 4; r++) {
            var i = "thisRC = rc;";
            r % 2 == 1 && (i += "thisRC.z += 1;"),
              r > 1 && (i += "thisRC.y += 1;"),
              (n +=
                "\n        " +
                i +
                "\n        " +
                (r > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : "") +
                "\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[" +
                r +
                "] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        " +
                (r > 0 ? "}" : "") +
                "\n      ");
          }
          this.userCode =
            "\n      \n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      " +
            Ti(["r", "c", "d"], e) +
            "\n      return ivec3(r, c, d);\n    }\n  \n      " +
            Ri(t) +
            "\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = " +
            t[1] +
            ";\n        int cols = " +
            t[2] +
            ";\n\n        " +
            n +
            "\n\n        setOutput(result);\n      }\n    ";
        },
        go = function (t, e, n) {
          (this.variableNames = ["dy"]),
            (this.outputShape = []),
            (this.outputShape = e.shape);
          var r = e.shape,
            i = r[1],
            a = r[2],
            o = t.shape,
            s = o[1],
            u = o[2],
            c = [n && s > 1 ? i - 1 : i, n && u > 1 ? a - 1 : a],
            l = [n && s > 1 ? s - 1 : s, n && u > 1 ? u - 1 : u],
            p = c[0] / l[0],
            h = c[1] / l[1],
            f = 1 / p,
            d = 1 / h,
            m = 2 * Math.ceil(f) + 2,
            v = 2 * Math.ceil(d) + 2;
          this.userCode =
            "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" +
            p +
            ");\n        const float widthScale = float(" +
            h +
            ");\n\n        const float invHeightScale = float(" +
            f +
            ");\n        const float invWidthScale = float(" +
            d +
            ");\n\n        const int winHeight = int(" +
            m +
            ");\n        const int winWidth = int(" +
            v +
            ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " +
            s +
            ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " +
            u +
            ") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), " +
            (i - 1) +
            ".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), " +
            (a - 1) +
            ".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
        },
        yo = function (t, e, n, r) {
          (this.variableNames = ["A"]), (this.outputShape = []);
          var i = t[0],
            a = t[1],
            o = t[2],
            s = t[3];
          this.outputShape = [i, e, n, s];
          var u = [r && e > 1 ? a - 1 : a, r && n > 1 ? o - 1 : o],
            c = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n];
          this.userCode =
            "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " +
            u[0] / c[0] +
            ",\n          " +
            u[1] / c[1] +
            ");\n      const vec2 inputShapeRC = vec2(" +
            a +
            ".0, " +
            o +
            ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ";
        },
        bo = function (t, e, n, r) {
          (this.variableNames = ["A"]),
            (this.packedInputs = !0),
            (this.packedOutput = !0),
            (this.outputShape = []);
          var i = t[0],
            a = t[1],
            o = t[2],
            s = t[3];
          this.outputShape = [i, e, n, s];
          var u = [r && e > 1 ? a - 1 : a, r && n > 1 ? o - 1 : o],
            c = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n];
          this.userCode =
            "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          " +
            u[0] / c[0] +
            ",\n          " +
            u[1] / c[1] +
            ",\n          " +
            u[1] / c[1] +
            ");\n      const vec3 inputShapeRC = vec3(" +
            a +
            ".0, " +
            o +
            ".0,\n                                     " +
            o +
            ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < " +
            (s - 1) +
            ";\n        bool hasNextRow = coords.z < " +
            (n - 1) +
            ";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ";
        },
        wo = function (t, e, n) {
          (this.variableNames = ["dy"]),
            (this.outputShape = []),
            (this.outputShape = e.shape);
          var r = e.shape,
            i = r[1],
            a = r[2],
            o = t.shape,
            s = o[1],
            u = o[2],
            c = [n && s > 1 ? i - 1 : i, n && u > 1 ? a - 1 : a],
            l = [n && s > 1 ? s - 1 : s, n && u > 1 ? u - 1 : u],
            p = c[0] / l[0],
            h = c[1] / l[1],
            f = 1 / p,
            d = 1 / h,
            m = 2 * Math.ceil(f) + 2,
            v = 2 * Math.ceil(d) + 2;
          this.userCode =
            "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" +
            p +
            ");\n        const float widthScale = float(" +
            h +
            ");\n\n        const float invHeightScale = float(" +
            f +
            ");\n        const float invWidthScale = float(" +
            d +
            ");\n\n        const int winHeight = int(" +
            m +
            ");\n        const int winWidth = int(" +
            v +
            ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " +
            s +
            ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " +
            u +
            ") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(" +
            c[0] +
            ") *\n                (float(dyR) / float(" +
            l[0] +
            "));\n\n            float sourceFracCol =\n                float(" +
            c[1] +
            ") *\n                  (float(dyC) / float(" +
            l[1] +
            "));\n\n            int sourceNearestRow = int(min(\n                float(int(" +
            i +
            ") - 1),\n                " +
            n +
            " ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(" +
            a +
            ") - 1),\n                " +
            n +
            " ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
        },
        xo = function (t, e, n, r) {
          (this.variableNames = ["A"]), (this.outputShape = []);
          var i = t[0],
            a = t[1],
            o = t[2],
            s = t[3];
          this.outputShape = [i, e, n, s];
          var u = [r && e > 1 ? a - 1 : a, r && n > 1 ? o - 1 : o],
            c = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n],
            l = r ? "0.5" : "0.0";
          this.userCode =
            "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " +
            u[0] / c[0] +
            ",\n          " +
            u[1] / c[1] +
            ");\n      const vec2 inputShapeRC = vec2(" +
            a +
            ".0, " +
            o +
            ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + " +
            l +
            ")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ";
        },
        Co = function (t, e) {
          this.variableNames = ["x"];
          var n = t.length;
          if (n > 4)
            throw new Error(
              "WebGL backend: Reverse of rank-" +
                n +
                " tensor is not yet supported"
            );
          if (((this.outputShape = t), 1 !== n)) {
            var r = t
                .map(function (n, r) {
                  return (function (n) {
                    return -1 !== e.indexOf(n) && 1 !== t[n]
                      ? t[n] + " - coords[" + n + "] - 1"
                      : "coords[" + n + "]";
                  })(r);
                })
                .join(","),
              i = Wi(n);
            this.userCode =
              "\n      void main() {\n        " +
              i +
              " coords = getOutputCoords();\n        setOutput(getX(" +
              r +
              "));\n      }\n    ";
          } else
            this.userCode =
              "\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(" +
              t[0] +
              " - coord - 1));\n        }\n      ";
        },
        Oo = function (t, e) {
          (this.variableNames = ["x"]),
            (this.packedInputs = !0),
            (this.packedOutput = !0);
          var n = t.length;
          if (n > 4)
            throw new Error(
              "WebGL backend: Reverse of rank-" +
                n +
                " tensor is not yet supported"
            );
          this.outputShape = t;
          var r = _i("rc", n),
            i = r[n - 1] + " + 1 < " + this.outputShape[n - 1],
            a = r[n - 2] + " + 1 < " + this.outputShape[n - 2],
            o = Wi(n);
          function s(n) {
            var r = t.map(function (r, i) {
              return (function (n, r) {
                return -1 !== e.indexOf(n) && 1 !== t[n]
                  ? t[n] + " - " + r[n] + " - 1"
                  : "" + r[n];
              })(i, n);
            });
            return (
              "getChannel(getX(" +
              r.join(",") +
              "), vec2(" +
              r.slice(-2).join(",") +
              "))"
            );
          }
          this.userCode =
            1 === n
              ? "\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(" +
                t[0] +
                " - rc - 1),\n            " +
                t[0] +
                " - rc - 1);\n          if(" +
                i +
                "){\n              result.g = getChannel(getX(" +
                t[0] +
                " - (rc  + 1) - 1),\n                " +
                t[0] +
                " - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      "
              : "\n        void main() {\n          " +
                o +
                " rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = " +
                (function (t) {
                  return s(t);
                })(r.slice()) +
                ";\n          if(" +
                i +
                "){\n            result.g = " +
                (function (t) {
                  return (t[n - 1] = "(" + t[n - 1] + " + 1)"), s(t);
                })(r.slice()) +
                ";\n          }\n          if(" +
                a +
                ") {\n            result.b = " +
                (function (t) {
                  return (t[n - 2] = "(" + t[n - 2] + " + 1)"), s(t);
                })(r.slice()) +
                ";\n            if(" +
                i +
                ") {\n              result.a = " +
                (function (t) {
                  return (
                    (t[n - 1] = "(" + t[n - 1] + " + 1)"),
                    (t[n - 2] = "(" + t[n - 2] + " + 1)"),
                    s(t)
                  );
                })(r.slice()) +
                ";\n            }\n          }\n          setOutput(result);\n        }\n    ";
        },
        Eo = function (t, e, n, r, i, a, o) {
          void 0 === o && (o = !0),
            (this.variableNames = ["updates", "indices", "defaultValue"]),
            (this.outputShape = a);
          var s = Wi(i.length),
            u = Wi(a.length),
            c = "";
          1 === n ? (c = "i") : 2 === n && (c = "i, j");
          var l = "getIndices(" + c + ")",
            p = "";
          1 === r ? (p = "i") : 2 === r && (p = "i, coords[1]");
          var h = "getUpdates(" + p + ")",
            f = e > 1 ? "strides[j]" : "strides";
          this.userCode =
            "\n        " +
            s +
            " strides = " +
            s +
            "(" +
            i +
            ");\n\n        void main() {\n          " +
            u +
            " coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < " +
            t +
            "; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < " +
            e +
            "; j++) {\n              int index = round(" +
            l +
            ");\n              flattenedIndex += index * " +
            f +
            ";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += " +
            h +
            ";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      ";
        },
        So = function (t, e) {
          this.variableNames = ["x", "segmentIds"];
          var n = t.windowSize,
            r = t.batchSize,
            i = t.inSize,
            a = t.numSegments,
            o = a * Math.ceil(i / n);
          this.outputShape = [r, o];
          var s = 4 * Math.floor(n / 4),
            u = n % 4,
            c = "\n        sumValue += dot(values, segFilter);\n    ",
            l = "";
          i % n > 0 &&
            (l =
              "\n        if (inIdx < 0 || inIdx >= " +
              i +
              ") {\n          return initializationValue;\n        }\n      ");
          var p = "";
          i % n > 0 &&
            (p =
              "\n        if (inIdx < 0 || inIdx >= " +
              i +
              ") {\n          return -1.0;\n        }\n      "),
            (this.userCode =
              "\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        " +
              l +
              "\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        " +
              p +
              "\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          " +
              a +
              ")) * float(" +
              n +
              "));\n        int currentSeg = int(mod(float(outIdx), float(" +
              a +
              ")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " +
              s +
              "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          " +
              c +
              "\n        }\n\n        int inIdx = inOffset + " +
              s +
              ";\n        if (" +
              (1 === u) +
              ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          " +
              c +
              "\n        } else if (" +
              (2 === u) +
              ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          " +
              c +
              "\n        } else if (" +
              (3 === u) +
              ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          " +
              c +
              "\n        }\n        setOutput(sumValue);\n      }\n    ");
        },
        No = function (t, e, n) {
          var r, i;
          if (
            ((this.variableNames = ["c", "a", "b"]),
            (this.outputShape = e),
            n > 4)
          )
            throw Error("Where for rank " + n + " is not yet supported");
          if (1 === n) (i = "resRC"), (r = "resRC");
          else {
            for (
              var a = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"],
                o = [],
                s = [],
                u = 0;
              u < e.length;
              u++
            )
              s.push("" + a[u]), u < t && o.push("" + a[u]);
            (r = o.join()), (i = s.join());
          }
          var c = Wi(n);
          this.userCode =
            "\n      void main() {\n        " +
            c +
            " resRC = getOutputCoords();\n        float cVal = getC(" +
            r +
            ");\n        if (cVal >= 1.0) {\n          setOutput(getA(" +
            i +
            "));\n        } else {\n          setOutput(getB(" +
            i +
            "));\n        }\n      }\n    ";
        },
        Io = (function () {
          function t(t) {
            (this.variableNames = ["source"]),
              (this.outputShape = t),
              (this.rank = t.length);
            var e,
              n = Wi(this.rank),
              r = "uniform int start[" + this.rank + "];",
              i = (function (t) {
                if (1 === t) return "sourceLoc";
                if (t <= 6)
                  return ko
                    .slice(0, t)
                    .map(function (t) {
                      return "sourceLoc." + t;
                    })
                    .join(",");
                throw Error("Slicing for rank " + t + " is not yet supported");
              })(this.rank);
            (e =
              "\n        " +
              n +
              " sourceLoc;\n        " +
              n +
              " coords = getOutputCoords();\n        " +
              t
                .map(function (t, e) {
                  return (
                    "sourceLoc." +
                    ko[e] +
                    " = start[" +
                    e +
                    "] + coords." +
                    ko[e] +
                    ";"
                  );
                })
                .join("\n") +
              "\n      "),
              (this.userCode =
                "\n      " +
                r +
                "\n      void main() {\n        " +
                e +
                "\n        setOutput(getSource(" +
                i +
                "));\n      }\n    ");
          }
          return (
            (t.prototype.getCustomSetupFunc = function (t) {
              var e = this;
              if (t.length !== this.rank)
                throw Error(
                  "The rank (" +
                    this.rank +
                    ") of the program must match the length of start (" +
                    t.length +
                    ")"
                );
              return function (n, r) {
                (null == e.startLoc &&
                  ((e.startLoc = n.getUniformLocationNoThrow(r, "start")),
                  null == e.startLoc)) ||
                  n.gl.uniform1iv(e.startLoc, t);
              };
            }),
            t
          );
        })(),
        ko = ["x", "y", "z", "w", "u", "v"],
        _o = (function () {
          function t(t) {
            (this.variableNames = ["source"]),
              (this.packedInputs = !0),
              (this.packedOutput = !0),
              (this.outputShape = t),
              (this.rank = t.length);
            var e = Wi(this.rank),
              n = _i("coords", this.rank),
              r = _i("sourceLoc", this.rank),
              i =
                1 === this.rank
                  ? "sourceLoc"
                  : "vec2(" + r.slice(-2).join() + ")",
              a = "getChannel(getSource(" + r.join() + "), " + i + ")",
              o =
                "\n      result.x = " +
                a +
                ";\n      if (++" +
                n[this.rank - 1] +
                " < " +
                t[this.rank - 1] +
                ") {\n        ++" +
                r[this.rank - 1] +
                ";\n        result.y = " +
                a +
                ";\n        --" +
                r[this.rank - 1] +
                ";\n      }\n    ",
              s =
                1 === this.rank
                  ? ""
                  : "\n      --" +
                    n[this.rank - 1] +
                    ";\n      if (++" +
                    n[this.rank - 2] +
                    " < " +
                    t[this.rank - 2] +
                    ") {\n        ++" +
                    r[this.rank - 2] +
                    ";\n        result.z = " +
                    a +
                    ";\n        if (++" +
                    n[this.rank - 1] +
                    " < " +
                    t[this.rank - 1] +
                    ") {\n          ++" +
                    r[this.rank - 1] +
                    ";\n          result.w = " +
                    a +
                    ";\n        }\n      }\n    ",
              u =
                this.rank <= 4
                  ? "sourceLoc = coords +\n            " +
                    e +
                    "(" +
                    t
                      .map(function (t, e) {
                        return "start[" + e + "]";
                      })
                      .join() +
                    ");"
                  : t
                      .map(function (t, e) {
                        return r[e] + " = " + n[e] + " + start[" + e + "];";
                      })
                      .join("\n");
            this.userCode =
              "\n      uniform int start[" +
              this.rank +
              "];\n      void main() {\n        " +
              e +
              " coords = getOutputCoords();\n        " +
              e +
              " sourceLoc;\n        " +
              u +
              "\n        vec4 result = vec4(0.);\n        " +
              o +
              "\n        " +
              s +
              "\n        setOutput(result);\n      }\n    ";
          }
          return (
            (t.prototype.getCustomSetupFunc = function (t) {
              var e = this;
              if (t.length !== this.rank)
                throw Error(
                  "The rank (" +
                    this.rank +
                    ") of the program must match the length of start (" +
                    t.length +
                    ")"
                );
              return function (n, r) {
                (null == e.startLoc &&
                  ((e.startLoc = n.getUniformLocationNoThrow(r, "start")),
                  null == e.startLoc)) ||
                  n.gl.uniform1iv(e.startLoc, t);
              };
            }),
            t
          );
        })(),
        Ao = function (t, e, n) {
          (this.variableNames = ["x"]), (this.outputShape = n);
          var r = n.length,
            i = Wi(n.length),
            a = Wi(n.length),
            o = "";
          if (1 === r) o = "coords * strides + begin";
          else {
            var s = 0;
            o = n
              .map(function (t, e) {
                return (
                  s++,
                  1 === n.length
                    ? "coords * strides[" + e + "] + begin[" + e + "]"
                    : "coords[" +
                      (s - 1) +
                      "] * strides[" +
                      e +
                      "] + begin[" +
                      e +
                      "]"
                );
              })
              .join(",");
          }
          this.userCode =
            "\n      " +
            i +
            " begin = " +
            i +
            "(" +
            t +
            ");\n      " +
            i +
            " strides = " +
            i +
            "(" +
            e +
            ");\n\n      void main() {\n        " +
            a +
            " coords = getOutputCoords();\n        setOutput(getX(" +
            o +
            "));\n      }\n    ";
        },
        To = (function () {
          function t(t) {
            (this.gpgpu = t),
              (this.numUsedTextures = 0),
              (this.numFreeTextures = 0),
              (this.freeTextures = {}),
              (this.logEnabled = !1),
              (this.usedTextures = {});
          }
          return (
            (t.prototype.acquireTexture = function (t, e, n) {
              var r,
                i = Ro(e, n),
                a = Do(t, i, n);
              if (
                (a in this.freeTextures || (this.freeTextures[a] = []),
                a in this.usedTextures || (this.usedTextures[a] = []),
                this.freeTextures[a].length > 0)
              ) {
                this.numFreeTextures--, this.numUsedTextures++, this.log();
                var o = this.freeTextures[a].shift();
                return this.usedTextures[a].push(o), o;
              }
              return (
                this.numUsedTextures++,
                this.log(),
                i === Ut.PACKED_2X2_FLOAT32
                  ? (r = this.gpgpu.createPackedMatrixTexture(t[0], t[1]))
                  : i === Ut.PACKED_2X2_FLOAT16
                  ? (r = this.gpgpu.createFloat16PackedMatrixTexture(
                      t[0],
                      t[1]
                    ))
                  : i === Ut.UNPACKED_FLOAT32
                  ? (r = this.gpgpu.createFloat32MatrixTexture(t[0], t[1]))
                  : i === Ut.UNPACKED_FLOAT16
                  ? (r = this.gpgpu.createFloat16MatrixTexture(t[0], t[1]))
                  : i === Ut.PACKED_4X1_UNSIGNED_BYTE &&
                    (r = this.gpgpu.createUnsignedBytesMatrixTexture(
                      t[0],
                      t[1]
                    )),
                this.usedTextures[a].push(r),
                r
              );
            }),
            (t.prototype.releaseTexture = function (t, e, n, r) {
              if (null != this.freeTextures) {
                var i = Do(e, Ro(n, r), r);
                i in this.freeTextures || (this.freeTextures[i] = []),
                  this.freeTextures[i].push(t),
                  this.numFreeTextures++,
                  this.numUsedTextures--;
                var a = this.usedTextures[i],
                  o = a.indexOf(t);
                if (o < 0)
                  throw new Error(
                    "Cannot release a texture that was never provided by this texture manager"
                  );
                a.splice(o, 1), this.log();
              }
            }),
            (t.prototype.log = function () {
              if (this.logEnabled) {
                var t = this.numFreeTextures + this.numUsedTextures;
                console.log(
                  "Free/Used",
                  this.numFreeTextures + " / " + this.numUsedTextures,
                  "(" + t + ")"
                );
              }
            }),
            (t.prototype.getNumUsedTextures = function () {
              return this.numUsedTextures;
            }),
            (t.prototype.getNumFreeTextures = function () {
              return this.numFreeTextures;
            }),
            (t.prototype.dispose = function () {
              var t = this;
              if (null != this.freeTextures) {
                for (var e in this.freeTextures)
                  this.freeTextures[e].forEach(function (e) {
                    t.gpgpu.deleteMatrixTexture(e);
                  });
                for (var e in this.usedTextures)
                  this.usedTextures[e].forEach(function (e) {
                    t.gpgpu.deleteMatrixTexture(e);
                  });
                (this.freeTextures = null),
                  (this.usedTextures = null),
                  (this.numUsedTextures = 0),
                  (this.numFreeTextures = 0);
              }
            }),
            t
          );
        })();
      function Ro(t, e) {
        if (t === Wt.UPLOAD) return Ut.PACKED_2X2_FLOAT32;
        if (t === Wt.RENDER || null == t)
          return (function (t) {
            return h().getBool("WEBGL_RENDER_FLOAT32_ENABLED")
              ? t
                ? Ut.PACKED_2X2_FLOAT32
                : Ut.UNPACKED_FLOAT32
              : t
              ? Ut.PACKED_2X2_FLOAT16
              : Ut.UNPACKED_FLOAT16;
          })(e);
        if (t === Wt.DOWNLOAD || t === Wt.PIXELS)
          return Ut.PACKED_4X1_UNSIGNED_BYTE;
        throw new Error("Unknown logical texture type " + t);
      }
      function Do(t, e, n) {
        return t[0] + "_" + t[1] + "_" + e + "_" + n;
      }
      var Fo = function (t, e) {
          this.variableNames = ["A"];
          for (var n = new Array(t.length), r = 0; r < n.length; r++)
            n[r] = t[r] * e[r];
          (this.outputShape = n), (this.rank = n.length);
          var i = Wi(this.rank),
            a = (function (t) {
              var e = t.length;
              if (e > 5)
                throw Error("Tile for rank " + e + " is not yet supported");
              if (1 === e) return "imod(resRC, " + t[0] + ")";
              for (
                var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"],
                  r = [],
                  i = 0;
                i < t.length;
                i++
              )
                r.push("imod(" + n[i] + ", " + t[i] + ")");
              return r.join();
            })(t);
          this.userCode =
            "\n      void main() {\n        " +
            i +
            " resRC = getOutputCoords();\n        setOutput(getA(" +
            a +
            "));\n      }\n    ";
        },
        Mo = function (t, e) {
          this.variableNames = ["A"];
          for (var n = new Array(t.length), r = 0; r < n.length; r++)
            n[r] = t[e[r]];
          (this.outputShape = n), (this.rank = n.length);
          var i = Wi(this.rank),
            a = (function (t) {
              var e = t.length;
              if (e > 6)
                throw Error(
                  "Transpose for rank " + e + " is not yet supported"
                );
              for (
                var n = [
                    "resRC.x",
                    "resRC.y",
                    "resRC.z",
                    "resRC.w",
                    "resRC.u",
                    "resRC.v",
                  ],
                  r = new Array(e),
                  i = 0;
                i < t.length;
                i++
              )
                r[t[i]] = n[i];
              return r.join();
            })(e);
          this.userCode =
            "\n    void main() {\n      " +
            i +
            " resRC = getOutputCoords();\n      setOutput(getA(" +
            a +
            "));\n    }\n    ";
        },
        jo = function (t, e) {
          (this.variableNames = ["A"]),
            (this.packedInputs = !0),
            (this.packedOutput = !0);
          for (var n = new Array(t.length), r = 0; r < n.length; r++)
            n[r] = t[e[r]];
          if (((this.outputShape = n), (this.rank = n.length), this.rank > 6))
            throw Error(
              "Packed transpose for rank " +
                this.rank +
                " is not yet supported."
            );
          var i = Wi(this.rank),
            a = ki("rc", this.rank),
            o = new Array(this.rank);
          for (r = 0; r < e.length; r++) o[e[r]] = a[r];
          var s = "vec2(" + o.slice(-2).join() + ")",
            u = "++" + a[this.rank - 1] + " < " + n[this.rank - 1],
            c = "getChannel(getA(" + o.join() + "), " + s + ")";
          this.userCode =
            "\n    void main() {\n      " +
            i +
            " rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = " +
            c +
            ";\n      if(" +
            u +
            ") {\n        result[1] = " +
            c +
            ";\n      }\n      --" +
            a[this.rank - 1] +
            ";\n      if(++" +
            a[this.rank - 2] +
            " < " +
            n[this.rank - 2] +
            ") {\n        result[2] = " +
            c +
            ";\n        if(" +
            u +
            ") {\n          result[3] = " +
            c +
            ";\n        }\n      }\n      setOutput(result);\n    }\n    ";
        },
        Po = 1.7580993408473768,
        zo = 1.0507009873554805,
        Lo = function (t, e) {
          (this.variableNames = ["A"]),
            (this.outputShape = t),
            (this.userCode =
              "\n      float unaryOperation(float x) {\n        " +
              e +
              "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ");
        },
        Bo = "if (isnan(x)) return x;",
        Wo = "return abs(x);",
        Uo = Bo + "\n  return (x < 0.0) ? 0.0 : x;\n",
        Vo = Bo + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",
        Go = "return (x >= 0.0) ? x : (exp(x) - 1.0);",
        Ho = "return -x;",
        qo = "return ceil(x);",
        Ko = "return floor(x);",
        Zo = "return exp(x);",
        Xo = "return exp(x) - 1.0;",
        Yo = "return x;",
        Jo =
          "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
        $o =
          "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
        Qo =
          "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",
        ts = function (t, e) {
          (this.variableNames = ["A"]),
            (this.packedInputs = !0),
            (this.packedOutput = !0),
            (this.outputShape = t),
            (this.userCode =
              "\n      vec4 unaryOperation(vec4 x) {\n        " +
              e +
              "\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ");
        },
        es = function (t) {
          (this.variableNames = ["A"]),
            (this.packedInputs = !0),
            (this.packedOutput = !1),
            (this.outputShape = t);
          var e = t.length,
            n = _i("rc", e),
            r = Wi(e),
            i = (function (t, e) {
              if (1 === t) return "rc";
              for (var n = "", r = 0; r < t; r++)
                (n += e[r]), r < t - 1 && (n += ",");
              return n;
            })(e, n),
            a = n.slice(-2),
            o = e <= 1 ? "rc" : "vec2(" + a.join(",") + ")";
          this.userCode =
            "\n      void main() {\n        " +
            r +
            " rc = getOutputCoords();\n        vec4 packedInput = getA(" +
            i +
            ");\n\n        setOutput(getChannel(packedInput, " +
            o +
            "));\n      }\n    ";
        },
        ns = {};
      function rs(t, e) {
        if ((void 0 === e && (e = !1), "linear" === t)) return "return x;";
        if ("relu" === t) return e ? Jo : Uo;
        if ("elu" === t) return e ? Qo : Go;
        if ("relu6" === t) return e ? $o : Vo;
        if ("prelu" === t) return e ? ea : Qi;
        throw new Error(
          "Activation " + t + " has not been implemented for the WebGL backend."
        );
      }
      var is = (function (t) {
        function e(e) {
          var n,
            r = t.call(this) || this;
          if (
            ((r.pendingRead = new WeakMap()),
            (r.pendingDisposal = new WeakSet()),
            (r.dataRefCount = new WeakMap()),
            (r.numBytesInGPU = 0),
            (r.uploadWaitMs = 0),
            (r.downloadWaitMs = 0),
            (r.warnedAboutMemory = !1),
            (r.pendingDeletes = 0),
            (r.disposed = !1),
            !h().getBool("HAS_WEBGL"))
          )
            throw new Error("WebGL is not supported on this device");
          if (null == e) {
            var i = qt(h().getNumber("WEBGL_VERSION"));
            (r.binaryCache =
              ((n = h().getNumber("WEBGL_VERSION")) in ns || (ns[n] = {}),
              ns[n])),
              (r.gpgpu = new $a(i)),
              (r.canvas = i.canvas),
              (r.gpgpuCreatedLocally = !0);
          } else
            (r.gpgpu = e),
              (r.binaryCache = {}),
              (r.gpgpuCreatedLocally = !1),
              (r.canvas = e.gl.canvas);
          return (
            (r.textureManager = new To(r.gpgpu)),
            (r.numMBBeforeWarning =
              null == h().global.screen
                ? 1024
                : (h().global.screen.height *
                    h().global.screen.width *
                    window.devicePixelRatio *
                    600) /
                  1024 /
                  1024),
            (r.texData = new Ur(r, Pt)),
            r
          );
        }
        return (
          s(e, t),
          (e.prototype.numDataIds = function () {
            return (
              this.texData.numDataIds() +
              (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) -
              this.pendingDeletes
            );
          }),
          (e.prototype.write = function (t, e, n) {
            if (
              (h().getBool("DEBUG") && this.checkNumericalProblems(t),
              "complex64" === n && null != t)
            )
              throw new Error(
                "Cannot write to a complex64 dtype. Please use tf.complex(real, imag)."
              );
            var r = {};
            return (
              this.texData.set(r, {
                shape: e,
                dtype: n,
                values: t,
                usage: Wt.UPLOAD,
              }),
              r
            );
          }),
          (e.prototype.move = function (t, e, n, r) {
            if (
              (h().getBool("DEBUG") && this.checkNumericalProblems(e),
              "complex64" === r)
            )
              throw new Error(
                "Cannot write to a complex64 dtype. Please use tf.complex(real, imag)."
              );
            this.texData.set(t, {
              shape: n,
              dtype: r,
              values: e,
              usage: Wt.UPLOAD,
            });
          }),
          (e.prototype.readSync = function (t) {
            var e = this.texData.get(t),
              n = e.values,
              r = e.dtype,
              i = e.complexTensors,
              a = e.slice,
              o = e.shape,
              s = e.isPacked;
            if (null != a) {
              var u;
              u = s ? new ts(o, Yo) : new Lo(o, Yo);
              var c = this.runWebGLProgram(
                  u,
                  [{ dataId: t, shape: o, dtype: r }],
                  r
                ),
                l = this.readSync(c.dataId);
              return this.disposeData(c.dataId), l;
            }
            if (null != n) return this.convertAndCacheOnCPU(t);
            if ("string" === r) return n;
            var p,
              h,
              f = null != this.activeTimers;
            return (
              f && (p = it()),
              (h =
                "complex64" === r
                  ? ci(i.real.dataSync(), i.imag.dataSync())
                  : this.getValuesFromTexture(t)),
              f && (this.downloadWaitMs += it() - p),
              this.convertAndCacheOnCPU(t, h)
            );
          }),
          (e.prototype.read = function (t) {
            return u(this, void 0, void 0, function () {
              var e,
                n,
                r,
                i,
                a,
                o,
                s,
                u,
                l,
                p,
                f,
                d,
                m,
                v,
                g,
                y,
                b,
                w,
                x,
                C,
                O,
                E;
              return c(this, function (c) {
                switch (c.label) {
                  case 0:
                    if (this.pendingRead.has(t))
                      return (
                        (e = this.pendingRead.get(t)),
                        [
                          2,
                          new Promise(function (t) {
                            return e.push(t);
                          }),
                        ]
                      );
                    if (
                      ((n = this.texData.get(t)),
                      (r = n.values),
                      (i = n.shape),
                      (a = n.slice),
                      (o = n.dtype),
                      (s = n.complexTensors),
                      (u = n.isPacked),
                      null != a)
                    )
                      return (
                        void 0,
                        (l = u ? new ts(i, Yo) : new Lo(i, Yo)),
                        (p = this.runWebGLProgram(
                          l,
                          [{ dataId: t, shape: i, dtype: o }],
                          o
                        )),
                        (f = this.read(p.dataId)),
                        this.disposeData(p.dataId),
                        [2, f]
                      );
                    if (null != r) return [2, this.convertAndCacheOnCPU(t)];
                    if (
                      !h().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") &&
                      2 === h().getNumber("WEBGL_VERSION")
                    )
                      throw new Error(
                        "tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported."
                      );
                    return (
                      (d = null),
                      "complex64" !== o &&
                        h().get("WEBGL_BUFFER_SUPPORTED") &&
                        ((m = this.decode(t)),
                        (v = this.texData.get(m.dataId)),
                        (d = (E = this.gpgpu).createBufferFromTexture.apply(
                          E,
                          [v.texture].concat(Zt(i))
                        ))),
                      this.pendingRead.set(t, []),
                      "complex64" === o
                        ? [3, 2]
                        : [4, this.gpgpu.createAndWaitForFence()]
                    );
                  case 1:
                    c.sent(), (c.label = 2);
                  case 2:
                    return "complex64" !== o
                      ? [3, 4]
                      : [4, Promise.all([s.real.data(), s.imag.data()])];
                  case 3:
                    return (
                      (y = c.sent()),
                      (b = y[0]),
                      (w = y[1]),
                      (g = ci(b, w)),
                      [3, 5]
                    );
                  case 4:
                    null == d
                      ? (g = this.getValuesFromTexture(t))
                      : ((x = _(i)),
                        (g = this.gpgpu.downloadFloat32MatrixFromBuffer(d, x))),
                      (c.label = 5);
                  case 5:
                    return (
                      null != m && this.disposeData(m.dataId),
                      (C = this.convertAndCacheOnCPU(t, g)),
                      (O = this.pendingRead.get(t)),
                      this.pendingRead.delete(t),
                      O.forEach(function (t) {
                        return t(C);
                      }),
                      this.pendingDisposal.has(t) &&
                        (this.pendingDisposal.delete(t),
                        this.disposeData(t),
                        this.pendingDeletes--),
                      [2, C]
                    );
                }
              });
            });
          }),
          (e.prototype.checkNumericalProblems = function (t) {
            if (null != t)
              for (var e = 0; e < t.length; e++) {
                var n = t[e];
                if (!$t(n)) {
                  if (h().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))
                    throw Error(
                      "The value " +
                        n +
                        " cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'"
                    );
                  throw Error(
                    "The value " + n + " cannot be represented on this device."
                  );
                }
              }
          }),
          (e.prototype.getValuesFromTexture = function (t) {
            var e,
              n = this.texData.get(t),
              r = n.shape,
              i = n.dtype,
              a = n.isPacked,
              o = _(r);
            if (h().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
              var s = this.decode(t),
                u = this.texData.get(s.dataId),
                c = (e = this.gpgpu).downloadMatrixFromPackedTexture
                  .apply(e, [u.texture].concat(Zt(r)))
                  .subarray(0, o);
              return this.disposeData(s.dataId), c;
            }
            var l = h().getBool("WEBGL_PACK") && !0 === a,
              p = l ? Ie(r) : r,
              f = l ? new Ia(p) : new Na(p),
              d = this.runWebGLProgram(
                f,
                [{ shape: p, dtype: i, dataId: t }],
                "float32"
              ),
              m = this.texData.get(d.dataId),
              v = this.gpgpu
                .downloadByteEncodedFloatMatrixFromOutputTexture(
                  m.texture,
                  m.texShape[0],
                  m.texShape[1]
                )
                .subarray(0, o);
            return this.disposeData(d.dataId), v;
          }),
          (e.prototype.time = function (t) {
            return u(this, void 0, void 0, function () {
              var e, n, r, i, a, o, s;
              return c(this, function (u) {
                switch (u.label) {
                  case 0:
                    return (
                      (e = this.activeTimers),
                      (n = []),
                      (r = !1),
                      null == this.programTimersStack
                        ? ((this.programTimersStack = n), (r = !0))
                        : this.activeTimers.push(n),
                      (this.activeTimers = n),
                      t(),
                      (i = k(
                        this.activeTimers.map(function (t) {
                          return t.query;
                        })
                      ).filter(function (t) {
                        return null != t;
                      })),
                      (a = k(
                        this.activeTimers.map(function (t) {
                          return t.name;
                        })
                      ).filter(function (t) {
                        return null != t;
                      })),
                      (this.activeTimers = e),
                      r && (this.programTimersStack = null),
                      (o = {
                        uploadWaitMs: this.uploadWaitMs,
                        downloadWaitMs: this.downloadWaitMs,
                        kernelMs: null,
                        wallMs: null,
                      }),
                      h().getNumber(
                        "WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE"
                      ) > 0
                        ? [4, Promise.all(i)]
                        : [3, 2]
                    );
                  case 1:
                    return (
                      (s = u.sent()),
                      (o.kernelMs = E(s)),
                      (o.getExtraProfileInfo = function () {
                        return s
                          .map(function (t, e) {
                            return { name: a[e], ms: t };
                          })
                          .map(function (t) {
                            return t.name + ": " + t.ms;
                          })
                          .join(", ");
                      }),
                      [3, 3]
                    );
                  case 2:
                    (o.kernelMs = {
                      error:
                        "WebGL query timers are not supported in this environment.",
                    }),
                      (u.label = 3);
                  case 3:
                    return (
                      (this.uploadWaitMs = 0), (this.downloadWaitMs = 0), [2, o]
                    );
                }
              });
            });
          }),
          (e.prototype.memory = function () {
            return { unreliable: !1, numBytesInGPU: this.numBytesInGPU };
          }),
          (e.prototype.startTimer = function () {
            return h().getNumber(
              "WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE"
            ) > 0
              ? this.gpgpu.beginQuery()
              : { startMs: it(), endMs: null };
          }),
          (e.prototype.endTimer = function (t) {
            return h().getNumber(
              "WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE"
            ) > 0
              ? (this.gpgpu.endQuery(), t)
              : ((t.endMs = it()), t);
          }),
          (e.prototype.getQueryTime = function (t) {
            return u(this, void 0, void 0, function () {
              var e;
              return c(this, function (n) {
                return h().getNumber(
                  "WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE"
                ) > 0
                  ? [2, this.gpgpu.waitForQueryAndGetTime(t)]
                  : [2, (e = t).endMs - e.startMs];
              });
            });
          }),
          (e.prototype.disposeData = function (t) {
            if (!this.pendingDisposal.has(t)) {
              if (this.pendingRead.has(t))
                return this.pendingDisposal.add(t), void this.pendingDeletes++;
              if (this.texData.has(t)) {
                this.releaseGPUData(t);
                var e = this.texData.get(t).complexTensors;
                null != e && (e.real.dispose(), e.imag.dispose()),
                  this.texData.delete(t);
              }
            }
          }),
          (e.prototype.releaseGPUData = function (t) {
            var e = this.texData.get(t),
              n = e.texture,
              r = e.dtype,
              i = e.texShape,
              a = e.usage,
              o = e.isPacked,
              s = e.slice,
              u = (s && s.origDataId) || t,
              c = this.dataRefCount.get(u);
            c > 1
              ? this.dataRefCount.set(u, c - 1)
              : (this.dataRefCount.delete(u),
                null != n &&
                  ((this.numBytesInGPU -= this.computeBytes(i, r)),
                  this.textureManager.releaseTexture(n, i, a, o)));
            var l = this.texData.get(t);
            (l.texture = null),
              (l.texShape = null),
              (l.isPacked = !1),
              (l.slice = null);
          }),
          (e.prototype.getTexture = function (t) {
            return this.uploadToGPU(t), this.texData.get(t).texture;
          }),
          (e.prototype.getDataInfo = function (t) {
            return this.texData.get(t);
          }),
          (e.prototype.getCPUBackend = function () {
            return h().getBool("WEBGL_CPU_FORWARD")
              ? (null == this.cpuBackend &&
                  (this.cpuBackend = Pt.findBackend("cpu")),
                this.cpuBackend)
              : null;
          }),
          (e.prototype.shouldExecuteOnCPU = function (t, e) {
            var n = this;
            return (
              void 0 === e && (e = 128),
              null != this.getCPUBackend() &&
                t.every(function (t) {
                  return null == n.texData.get(t.dataId).texture && t.size < e;
                })
            );
          }),
          (e.prototype.getGPGPUContext = function () {
            return this.gpgpu;
          }),
          (e.prototype.complex = function (t, e) {
            var n = this.makeOutput(t.shape, "complex64");
            return (
              (this.texData.get(n.dataId).complexTensors = {
                real: Pt.keep(t.clone()),
                imag: Pt.keep(e.clone()),
              }),
              n
            );
          }),
          (e.prototype.real = function (t) {
            return this.texData.get(t.dataId).complexTensors.real.clone();
          }),
          (e.prototype.imag = function (t) {
            return this.texData.get(t.dataId).complexTensors.imag.clone();
          }),
          (e.prototype.slice = function (t, e, n) {
            if (this.shouldExecuteOnCPU([t]))
              return this.cpuBackend.slice(t, e, n);
            if (0 === _(n)) return mn([], n, t.dtype);
            var r = this.texData.get(t.dataId).isPacked,
              i = Pr(t.shape, e, n);
            if (r || !i) {
              var a = h().getBool("WEBGL_PACK_ARRAY_OPERATIONS")
                  ? new _o(n)
                  : new Io(n),
                o = a.getCustomSetupFunc(e);
              return this.compileAndRun(a, [t], null, o);
            }
            return this.uploadToGPU(t.dataId), this.shallowSlice(t, e, n);
          }),
          (e.prototype.shallowSlice = function (t, e, n) {
            var r = this.texData.get(t.dataId),
              i = this.makeOutput(n, t.dtype),
              a = this.texData.get(i.dataId);
            Object.assign(a, r), (a.shape = n), (a.dtype = t.dtype);
            var o = zr(e, t.strides);
            r.slice && (o += r.slice.flatOffset),
              (a.slice = {
                flatOffset: o,
                origDataId: (r.slice && r.slice.origDataId) || t.dataId,
              });
            var s = this.dataRefCount.get(a.slice.origDataId) || 1;
            return this.dataRefCount.set(a.slice.origDataId, s + 1), i;
          }),
          (e.prototype.stridedSlice = function (t, e, n, r) {
            if (this.shouldExecuteOnCPU([t]))
              return this.cpuBackend.stridedSlice(t, e, n, r);
            var i = Fr(e, n, r);
            if (
              i.some(function (t) {
                return 0 === t;
              })
            )
              return mn([], i);
            var a = new Ao(e, r, i);
            return this.compileAndRun(a, [t]);
          }),
          (e.prototype.reverse = function (t, e) {
            var n = h().getBool("WEBGL_PACK_ARRAY_OPERATIONS")
              ? new Oo(t.shape, e)
              : new Co(t.shape, e);
            return this.compileAndRun(n, [t]);
          }),
          (e.prototype.concat = function (t, e) {
            if ("complex64" === t[0].dtype) {
              var n = t.map(function (t) {
                  return fn(t);
                }),
                r = t.map(function (t) {
                  return dn(t);
                });
              return hn(this.concat(n, e), this.concat(r, e));
            }
            if (this.shouldExecuteOnCPU(t)) return this.cpuBackend.concat(t, e);
            if (1 === t.length) return t[0];
            if (t.length > h().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
              var i = Math.floor(t.length / 2),
                a = this.concat(t.slice(0, i), e),
                o = this.concat(t.slice(i), e);
              return this.concat([a, o], e);
            }
            if (h().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && t[0].rank > 1) {
              var s = new sa(
                t.map(function (t) {
                  return t.shape;
                }),
                e
              );
              return this.compileAndRun(s, t);
            }
            var u = ln(
                t.map(function (t) {
                  return t.shape;
                }),
                e
              ),
              c = t.map(function (t) {
                return t.as2D(-1, _(t.shape.slice(e)));
              }),
              l = new oa(
                c.map(function (t) {
                  return t.shape;
                })
              );
            return this.compileAndRun(l, c).reshape(u);
          }),
          (e.prototype.neg = function (t) {
            if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.neg(t);
            if (h().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
              return this.packedUnaryOp(t, Ho, t.dtype);
            var e = new Lo(t.shape, Ho);
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.batchMatMul = function (t, e, n, r) {
            var i = n ? t.shape[2] : t.shape[1],
              a = r ? e.shape[1] : e.shape[2],
              o = n ? t.shape[1] : t.shape[2],
              s = t.shape[0];
            if ((1 === i || 1 === a) && o > 1e3) {
              n && (t = t.transpose([0, 2, 1])),
                r && (e = e.transpose([0, 2, 1]));
              var u = 1 === a ? t : t.as3D(s, o, 1),
                c = 1 === a ? 2 : 1,
                l = 1 === a ? e.as3D(s, 1, o) : e;
              return this.multiply(u, l).sum(c, !0);
            }
            var p = kt(t.dtype, e.dtype),
              h = new oo(t.shape, [s, i, a], n, r);
            return this.compileAndRun(h, [t, e], p);
          }),
          (e.prototype.fusedBatchMatMul = function (t) {
            var e = t.a,
              n = t.b,
              r = t.transposeA,
              i = t.transposeB,
              a = t.bias,
              o = t.activation,
              s = t.preluActivationWeights,
              u = r ? e.shape[2] : e.shape[1],
              c = i ? n.shape[1] : n.shape[2],
              l = e.shape[0],
              p = kt(e.dtype, n.dtype),
              h = null != a,
              f = null != s,
              d = o ? rs(o, !0) : null,
              m = new oo(e.shape, [l, u, c], r, i, h, d, f),
              v = [e, n];
            return a && v.push(a), s && v.push(s), this.compileAndRun(m, v, p);
          }),
          (e.prototype.multiply = function (t, e) {
            if ("complex64" === t.dtype) {
              var n = this.texData.get(t.dataId),
                r = this.texData.get(e.dataId),
                i = new Xi(
                  "return areal * breal - aimag * bimag;",
                  t.shape,
                  e.shape
                ),
                a = new Xi(
                  "return areal * bimag + aimag * breal;",
                  t.shape,
                  e.shape
                ),
                o = [
                  this.makeComplexComponentTensorInfo(t, n.complexTensors.real),
                  this.makeComplexComponentTensorInfo(t, n.complexTensors.imag),
                  this.makeComplexComponentTensorInfo(e, r.complexTensors.real),
                  this.makeComplexComponentTensorInfo(e, r.complexTensors.imag),
                ],
                s = this.compileAndRun(i, o),
                u = this.compileAndRun(a, o),
                c = this.complex(s, u);
              return s.dispose(), u.dispose(), c;
            }
            if (this.shouldExecuteOnCPU([t, e]))
              return this.cpuBackend.multiply(t, e);
            if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
              return this.packedBinaryOp(t, e, $i, t.dtype);
            var l = new ta($i, t.shape, e.shape);
            return this.compileAndRun(l, [t, e], t.dtype);
          }),
          (e.prototype.batchNormalization = function (t, e, n, r, i, a) {
            var o = [t, e, n],
              s = null;
            null != a && ((s = a.shape), o.push(a));
            var u = null;
            if (
              (null != i && ((u = i.shape), o.push(i)),
              h().getBool("WEBGL_PACK_NORMALIZATION"))
            ) {
              var c = new Zi(t.shape, e.shape, n.shape, s, u, r);
              return this.compileAndRun(c, o);
            }
            var l = new Ki(t.shape, e.shape, n.shape, s, u, r);
            return this.compileAndRun(l, o);
          }),
          (e.prototype.localResponseNormalization4D = function (t, e, n, r, i) {
            var a = h().getBool("WEBGL_PACK_NORMALIZATION")
              ? new ro(t.shape, e, n, r, i)
              : new eo(t.shape, e, n, r, i);
            return this.compileAndRun(a, [t]);
          }),
          (e.prototype.LRNGrad = function (t, e, n, r, i, a, o) {
            var s = new no(e.shape, r, i, a, o);
            return this.compileAndRun(s, [e, n, t]);
          }),
          (e.prototype.tile = function (t, e) {
            if ("string" === t.dtype) {
              var n = this.readSync(t.dataId).map(function (t) {
                return st(t);
              });
              return Ci(Zn(t.shape, t.dtype, n), e);
            }
            var r = new Fo(t.shape, e);
            return this.compileAndRun(r, [t]);
          }),
          (e.prototype.pad = function (t, e, n) {
            var r = h().getBool("WEBGL_PACK_ARRAY_OPERATIONS")
              ? new po(t.shape, e, n)
              : new lo(t.shape, e, n);
            return this.compileAndRun(r, [t]);
          }),
          (e.prototype.transpose = function (t, e) {
            if (this.shouldExecuteOnCPU([t]))
              return this.cpuBackend.transpose(t, e);
            var n = h().getBool("WEBGL_PACK_ARRAY_OPERATIONS")
              ? new jo(t.shape, e)
              : new Mo(t.shape, e);
            return this.compileAndRun(n, [t]);
          }),
          (e.prototype.gather = function (t, e, n) {
            if (this.shouldExecuteOnCPU([t, e]))
              return this.cpuBackend.gather(t, e, n);
            var r = new Ra(t.shape, e.size, n);
            return this.compileAndRun(r, [t, e]);
          }),
          (e.prototype.batchToSpaceND = function (t, e, n) {
            S(t.rank <= 4, function () {
              return "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet";
            });
            var r = e.reduce(function (t, e) {
                return t * e;
              }),
              i = Cr(t.shape, e, r),
              a = Or(i.length, e.length),
              o = Er(t.shape, e, r),
              s = Sr(n, e.length),
              u = Nr(o, n, e.length);
            return t.reshape(i).transpose(a).reshape(o).slice(s, u);
          }),
          (e.prototype.spaceToBatchND = function (t, e, n) {
            S(t.rank <= 4, function () {
              return "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet";
            });
            var r = e.reduce(function (t, e) {
                return t * e;
              }),
              i = [[0, 0]];
            i.push.apply(i, n);
            for (var a = 1 + e.length; a < t.shape.length; ++a) i.push([0, 0]);
            var o = t.pad(i),
              s = Cr(o.shape, e, r, !1),
              u = Or(s.length, e.length, !1),
              c = Er(o.shape, e, r, !1);
            return o.reshape(s).transpose(u).reshape(c);
          }),
          (e.prototype.reduce = function (t, e, n) {
            var r = t.shape[0],
              i = t.shape[1],
              a = kr(i),
              o = new mo({ windowSize: a, inSize: i, batchSize: r }, e),
              s = this.compileAndRun(o, [t], n);
            return 1 === s.shape[1] ? s : this.reduce(s, e, n);
          }),
          (e.prototype.argReduce = function (t, e, n) {
            void 0 === n && (n = null);
            var r = t.shape[0],
              i = t.shape[1];
            null != n && ((r = n.shape[0]), (i = n.shape[1]));
            var a = kr(i),
              o = new Ii(
                { windowSize: a, inSize: i, batchSize: r },
                e,
                null == n
              ),
              s = [t];
            null != n && s.push(n);
            var u = this.compileAndRun(o, s, "int32");
            return 1 === u.shape[1] ? u : this.argReduce(t, e, u);
          }),
          (e.prototype.argReducePacked = function (t, e, n) {
            void 0 === n && (n = null);
            var r = null != n ? n.shape : t.shape,
              i = kr(r[r.length - 1]),
              a = new Gi(r, i, e, null == n),
              o = null == n ? [t] : [t, n],
              s = this.compileAndRun(a, o, "int32");
            return s.rank === t.rank ? this.argReducePacked(t, e, s) : s;
          }),
          (e.prototype.sum = function (t, e) {
            an("sum", e, t.rank);
            var n = nn(t.shape, e),
              r = n[0],
              i = _(n[1]),
              a = t.as2D(-1, i),
              o = _t(t.dtype);
            return this.reduce(a, "sum", o).reshape(r);
          }),
          (e.prototype.prod = function (t, e) {
            if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.prod(t, e);
            var n = nn(t.shape, e),
              r = n[0],
              i = _(n[1]),
              a = t.as2D(-1, i),
              o = _t(t.dtype);
            return this.reduce(a, "prod", o).reshape(r);
          }),
          (e.prototype.unsortedSegmentSum = function (t, e, n) {
            var r = 0,
              i = on([r], t.rank),
              a = t;
            null != i && ((a = t.transpose(i)), (r = un(1, t.rank)[0]));
            var o = (function (t, e, n) {
                for (var r = [], i = t.length, a = 0; a < i; a++)
                  a !== e ? r.push(t[a]) : r.push(n);
                return r;
              })(a.shape, r, n),
              s = _([a.shape[r]]),
              u = a.as2D(-1, s),
              c = _t(t.dtype),
              l = this.segOpCompute(u, "unsortedSegmentSum", e, c, n).reshape(
                o
              );
            return null != i && (l = l.transpose(sn(i))), l;
          }),
          (e.prototype.segOpCompute = function (t, e, n, r, i) {
            var a = t.shape[0],
              o = t.shape[1],
              s = (function (t, e) {
                var n,
                  r = !1;
                for (
                  t <= 30
                    ? ((n = t), (r = !0))
                    : (n = $(t, Math.floor(Math.sqrt(t))));
                  !r;

                )
                  n > e || n === t ? (r = !0) : (n = $(t, n + 1));
                return n;
              })(o, i),
              u = new So(
                { windowSize: s, inSize: o, batchSize: a, numSegments: i },
                e
              ),
              c = this.compileAndRun(u, [t, n], r);
            return c.shape[1] === i
              ? c
              : ((n = In(0, i).tile([o / s])),
                this.segOpCompute(c, e, n, r, i));
          }),
          (e.prototype.argMinMaxReduce = function (t, e, n) {
            var r = [e];
            if (
              (an("arg" + n.charAt(0).toUpperCase() + n.slice(1), r, t.rank),
              !h().getBool("WEBGL_PACK_REDUCE") || t.rank <= 2)
            ) {
              var i = nn(t.shape, r),
                a = i[0],
                o = _(i[1]),
                s = t.as2D(-1, o);
              return this.argReduce(s, n).reshape(a);
            }
            return this.argReducePacked(t, n);
          }),
          (e.prototype.argMin = function (t, e) {
            return this.argMinMaxReduce(t, e, "min");
          }),
          (e.prototype.argMax = function (t, e) {
            return this.argMinMaxReduce(t, e, "max");
          }),
          (e.prototype.cumsum = function (t, e, n, r) {
            if (e !== t.rank - 1)
              throw new Error(
                "WebGL cumsum shader expects an inner-most axis=" +
                  (t.rank - 1) +
                  " but got axis=" +
                  e
              );
            var i = new wa(t.shape, n, r);
            return this.compileAndRun(i, [t]);
          }),
          (e.prototype.equal = function (t, e) {
            if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
              return this.packedBinaryOp(
                t,
                e,
                "\n  return vec4(equal(a, b));\n",
                "bool"
              );
            var n = new ta("return float(a == b);", t.shape, e.shape);
            return this.compileAndRun(n, [t, e], "bool");
          }),
          (e.prototype.notEqual = function (t, e) {
            if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
              return this.packedBinaryOp(
                t,
                e,
                "\n  return vec4(notEqual(a, b));\n",
                "bool"
              );
            var n = new ta("return float(a != b);", t.shape, e.shape);
            return this.compileAndRun(n, [t, e], "bool");
          }),
          (e.prototype.less = function (t, e) {
            if (this.shouldExecuteOnCPU([t, e]))
              return this.cpuBackend.less(t, e);
            if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
              return this.packedBinaryOp(
                t,
                e,
                "\n  return vec4(lessThan(a, b));\n",
                "bool"
              );
            var n = new ta("return float(a < b);", t.shape, e.shape);
            return this.compileAndRun(n, [t, e], "bool");
          }),
          (e.prototype.lessEqual = function (t, e) {
            if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
              return this.packedBinaryOp(
                t,
                e,
                "\n  return vec4(lessThanEqual(a, b));\n",
                "bool"
              );
            var n = new ta("return float(a <= b);", t.shape, e.shape);
            return this.compileAndRun(n, [t, e], "bool");
          }),
          (e.prototype.greater = function (t, e) {
            if (this.shouldExecuteOnCPU([t, e]))
              return this.cpuBackend.greater(t, e);
            if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
              return this.packedBinaryOp(
                t,
                e,
                "\n  return vec4(greaterThan(a, b));\n",
                "bool"
              );
            var n = new ta("return float(a > b);", t.shape, e.shape);
            return this.compileAndRun(n, [t, e], "bool");
          }),
          (e.prototype.greaterEqual = function (t, e) {
            if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
              return this.packedBinaryOp(
                t,
                e,
                "\n  return vec4(greaterThanEqual(a, b));\n",
                "bool"
              );
            var n = new ta("return float(a >= b);", t.shape, e.shape);
            return this.compileAndRun(n, [t, e], "bool");
          }),
          (e.prototype.logicalNot = function (t) {
            var e = new Lo(t.shape, "return float(!(x >= 1.0));");
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.logicalAnd = function (t, e) {
            if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
              return this.packedBinaryOp(
                t,
                e,
                "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",
                "bool"
              );
            var n = new ta(
              "return float(a >= 1.0 && b >= 1.0);",
              t.shape,
              e.shape
            );
            return this.compileAndRun(n, [t, e], "bool");
          }),
          (e.prototype.logicalOr = function (t, e) {
            if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
              return this.packedBinaryOp(
                t,
                e,
                "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",
                "bool"
              );
            var n = new ta(
              "return float(a >= 1.0 || b >= 1.0);",
              t.shape,
              e.shape
            );
            return this.compileAndRun(n, [t, e], "bool");
          }),
          (e.prototype.select = function (t, e, n) {
            var r = new No(t.rank, e.shape, e.rank);
            return this.compileAndRun(r, [t, e, n], kt(e.dtype, n.dtype));
          }),
          (e.prototype.where = function (t) {
            Xe(
              "tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead"
            );
            var e = t.dataSync();
            return Ei(t.shape, e);
          }),
          (e.prototype.topk = function (t, e, n) {
            return Oi(t.dataSync(), t.shape, t.dtype, e);
          }),
          (e.prototype.min = function (t, e) {
            an("min", e, t.rank);
            var n = nn(t.shape, e),
              r = n[0],
              i = _(n[1]),
              a = t.as2D(-1, i);
            return this.reduce(a, "min", a.dtype).reshape(r);
          }),
          (e.prototype.minimum = function (t, e) {
            if (this.shouldExecuteOnCPU([t, e]))
              return this.cpuBackend.minimum(t, e);
            var n = h().getBool("WEBGL_PACK_BINARY_OPERATIONS")
              ? new na(
                  "\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",
                  t.shape,
                  e.shape
                )
              : new ta(
                  "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",
                  t.shape,
                  e.shape
                );
            return this.compileAndRun(n, [t, e]);
          }),
          (e.prototype.mod = function (t, e) {
            var n = h().getBool("WEBGL_PACK_BINARY_OPERATIONS")
              ? new na(
                  "\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",
                  t.shape,
                  e.shape
                )
              : new ta(
                  "if (b == 0.0) return NAN;\n  return mod(a, b);",
                  t.shape,
                  e.shape
                );
            return this.compileAndRun(n, [t, e]);
          }),
          (e.prototype.max = function (t, e) {
            if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.max(t, e);
            an("max", e, t.rank);
            var n = nn(t.shape, e),
              r = n[0],
              i = _(n[1]),
              a = t.as2D(-1, i);
            return this.reduce(a, "max", a.dtype).reshape(r);
          }),
          (e.prototype.maximum = function (t, e) {
            if (this.shouldExecuteOnCPU([t, e]))
              return this.cpuBackend.maximum(t, e);
            var n = h().getBool("WEBGL_PACK_BINARY_OPERATIONS")
              ? new na(
                  "\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",
                  t.shape,
                  e.shape
                )
              : new ta(
                  "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",
                  t.shape,
                  e.shape
                );
            return this.compileAndRun(n, [t, e]);
          }),
          (e.prototype.all = function (t, e) {
            an("all", e, t.rank);
            var n = nn(t.shape, e),
              r = n[0],
              i = _(n[1]),
              a = t.as2D(-1, i);
            return this.reduce(a, "all", a.dtype).reshape(r);
          }),
          (e.prototype.any = function (t, e) {
            an("any", e, t.rank);
            var n = nn(t.shape, e),
              r = n[0],
              i = _(n[1]),
              a = t.as2D(-1, i);
            return this.reduce(a, "any", a.dtype).reshape(r);
          }),
          (e.prototype.realDivide = function (t, e) {
            if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
              return this.packedBinaryOp(
                t,
                e,
                "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",
                "float32",
                !0
              );
            var n = new ta(
              "\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",
              t.shape,
              e.shape
            );
            return this.compileAndRun(n, [t, e], "float32");
          }),
          (e.prototype.floorDiv = function (t, e) {
            if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
              return this.packedBinaryOp(
                t,
                e,
                "\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",
                "int32"
              );
            var n = new ta(
              "\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",
              t.shape,
              e.shape
            );
            return this.compileAndRun(n, [t, e], "int32");
          }),
          (e.prototype.add = function (t, e) {
            if ("complex64" === t.dtype && "complex64" === e.dtype)
              return this.complexSeparableBinaryOp(t, e, Yi);
            if (this.shouldExecuteOnCPU([t, e]))
              return this.cpuBackend.add(t, e);
            var n = kt(t.dtype, e.dtype);
            if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
              return this.packedBinaryOp(t, e, Yi, n);
            var r = new ta(Yi, t.shape, e.shape);
            return this.compileAndRun(r, [t, e], n);
          }),
          (e.prototype.packedUnaryOp = function (t, e, n) {
            var r = new ts(t.shape, e);
            return this.compileAndRun(r, [t], n);
          }),
          (e.prototype.packedBinaryOp = function (t, e, n, r, i) {
            void 0 === i && (i = !1);
            var a = new na(n, t.shape, e.shape, i);
            return this.compileAndRun(a, [t, e], r);
          }),
          (e.prototype.complexSeparableBinaryOp = function (t, e, n) {
            var r = this,
              i = this.texData.get(t.dataId),
              a = this.texData.get(e.dataId),
              o = [
                [i.complexTensors.real, a.complexTensors.real],
                [i.complexTensors.imag, a.complexTensors.imag],
              ].map(function (i) {
                var a = i[0],
                  o = i[1],
                  s = r.makeComplexComponentTensorInfo(t, a),
                  u = r.makeComplexComponentTensorInfo(e, o),
                  c = new ta(n, t.shape, e.shape);
                return r.compileAndRun(c, [s, u], kt(a.dtype, o.dtype));
              }),
              s = o[0],
              u = o[1],
              c = this.complex(s, u);
            return s.dispose(), u.dispose(), c;
          }),
          (e.prototype.makeComplexComponentTensorInfo = function (t, e) {
            return { dataId: e.dataId, dtype: e.dtype, shape: t.shape };
          }),
          (e.prototype.addN = function (t) {
            if (1 === t.length) return t[0];
            if (t.length > h().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
              var e = Math.floor(t.length / 2),
                n = this.addN(t.slice(0, e)),
                r = this.addN(t.slice(e));
              return this.addN([n, r]);
            }
            var i = t
                .map(function (t) {
                  return t.dtype;
                })
                .reduce(function (t, e) {
                  return kt(t, e);
                }),
              a = t.map(function (t) {
                return t.shape;
              }),
              o = h().getBool("WEBGL_PACK")
                ? new Ni(t[0].shape, a)
                : new Si(t[0].shape, a);
            return this.compileAndRun(o, t, i);
          }),
          (e.prototype.subtract = function (t, e) {
            if ("complex64" === t.dtype && "complex64" === e.dtype)
              return this.complexSeparableBinaryOp(t, e, Ji);
            if (this.shouldExecuteOnCPU([t, e]))
              return this.cpuBackend.subtract(t, e);
            var n = kt(t.dtype, e.dtype);
            if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
              return this.packedBinaryOp(t, e, Ji, t.dtype);
            var r = new ta(Ji, t.shape, e.shape);
            return this.compileAndRun(r, [t, e], n);
          }),
          (e.prototype.pow = function (t, e) {
            var n = h().getBool("WEBGL_PACK_BINARY_OPERATIONS")
                ? new na(
                    "\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",
                    t.shape,
                    e.shape
                  )
                : new ta(
                    "\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",
                    t.shape,
                    e.shape
                  ),
              r = kt(t.dtype, e.dtype);
            return this.compileAndRun(n, [t, e], r);
          }),
          (e.prototype.ceil = function (t) {
            if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.ceil(t);
            if (h().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
              return this.packedUnaryOp(t, qo, t.dtype);
            var e = new Lo(t.shape, qo);
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.floor = function (t) {
            if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.floor(t);
            if (h().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
              return this.packedUnaryOp(t, Ko, t.dtype);
            var e = new Lo(t.shape, Ko);
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.sign = function (t) {
            var e = new Lo(
              t.shape,
              "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"
            );
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.isNaN = function (t) {
            var e = new Lo(t.shape, "return float(isnan(x));");
            return this.compileAndRun(e, [t], "bool");
          }),
          (e.prototype.isInf = function (t) {
            var e = new Lo(t.shape, "return float(isinf(x));");
            return this.compileAndRun(e, [t], "bool");
          }),
          (e.prototype.isFinite = function (t) {
            var e = new Lo(t.shape, "return float(!isnan(x) && !isinf(x));");
            return this.compileAndRun(e, [t], "bool");
          }),
          (e.prototype.round = function (t) {
            var e = new Lo(
              t.shape,
              "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"
            );
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.exp = function (t) {
            if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.exp(t);
            if (h().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
              return this.packedUnaryOp(t, Zo, t.dtype);
            var e = new Lo(t.shape, Zo);
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.expm1 = function (t) {
            if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.expm1(t);
            if (h().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
              return this.packedUnaryOp(t, Xo, t.dtype);
            var e = new Lo(t.shape, Xo);
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.softmax = function (t, e) {
            var n = P([e], t.shape),
              r = this.max(t, n),
              i = rn(r.shape, n),
              a = this.subtract(t, r.reshape(i)),
              o = this.exp(a),
              s = this.sum(o, n).reshape(i);
            return this.realDivide(o, s);
          }),
          (e.prototype.log = function (t) {
            if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.log(t);
            if (h().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
              return this.packedUnaryOp(
                t,
                "\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",
                t.dtype
              );
            var e = new Lo(
              t.shape,
              "if (x < 0.0) return NAN;\n  return log(x);"
            );
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.log1p = function (t) {
            var e = new Lo(t.shape, "return log(1.0 + x);");
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.sqrt = function (t) {
            var e = new Lo(t.shape, "return sqrt(x);");
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.rsqrt = function (t) {
            if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.rsqrt(t);
            var e = new Lo(t.shape, "return inversesqrt(x);");
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.reciprocal = function (t) {
            var e = new Lo(t.shape, "return 1.0 / x;");
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.relu = function (t) {
            var e;
            return (
              (e = h().getBool("WEBGL_PACK")
                ? new ts(t.shape, Jo)
                : new Lo(t.shape, Uo)),
              this.compileAndRun(e, [t])
            );
          }),
          (e.prototype.relu6 = function (t) {
            var e;
            return (
              (e = h().getBool("WEBGL_PACK")
                ? new ts(t.shape, $o)
                : new Lo(t.shape, Vo)),
              this.compileAndRun(e, [t])
            );
          }),
          (e.prototype.prelu = function (t, e) {
            var n = h().getBool("WEBGL_PACK_BINARY_OPERATIONS")
              ? new na(ea, t.shape, e.shape)
              : new ta(Qi, t.shape, e.shape);
            return this.compileAndRun(n, [t, e]);
          }),
          (e.prototype.elu = function (t) {
            if (h().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
              return this.packedUnaryOp(t, Qo, t.dtype);
            var e = new Lo(t.shape, Go);
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.eluDer = function (t, e) {
            var n = h().getBool("WEBGL_PACK_BINARY_OPERATIONS")
              ? new na(
                  "\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",
                  t.shape,
                  e.shape
                )
              : new ta(
                  "return (b >= 1.0) ? a : a * (b + 1.0);",
                  t.shape,
                  e.shape
                );
            return this.compileAndRun(n, [t, e]);
          }),
          (e.prototype.selu = function (t) {
            var e = new Lo(
              t.shape,
              "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = 1.7580993408473768;\n  float scale = 1.0507009873554805;\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n"
            );
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.int = function (t) {
            var e = new Lo(t.shape, "return float(int(x));");
            return this.compileAndRun(e, [t], "int32");
          }),
          (e.prototype.clip = function (t, e, n) {
            var r,
              i = (r = h().getBool("WEBGL_PACK_CLIP")
                ? new ia(t.shape)
                : new ra(t.shape)).getCustomSetupFunc(e, n);
            return this.compileAndRun(r, [t], null, i);
          }),
          (e.prototype.abs = function (t) {
            if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.abs(t);
            if (h().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
              return this.packedUnaryOp(t, Wo, t.dtype);
            var e = new Lo(t.shape, Wo);
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.complexAbs = function (t) {
            var e = this.texData.get(t.dataId),
              n = new aa(t.shape),
              r = [
                this.makeComplexComponentTensorInfo(t, e.complexTensors.real),
                this.makeComplexComponentTensorInfo(t, e.complexTensors.imag),
              ];
            return this.compileAndRun(n, r);
          }),
          (e.prototype.sigmoid = function (t) {
            var e = new Lo(t.shape, "return 1.0 / (1.0 + exp(-1.0 * x));");
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.softplus = function (t) {
            var e = new Lo(
              t.shape,
              "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"
            );
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.sin = function (t) {
            var e = new Lo(
              t.shape,
              "if (isnan(x)) return x;\n  return sin(x);\n"
            );
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.cos = function (t) {
            var e = new Lo(
              t.shape,
              "if (isnan(x)) return x;\n  return cos(x);\n"
            );
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.tan = function (t) {
            var e = new Lo(t.shape, "return tan(x);");
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.asin = function (t) {
            var e = new Lo(
              t.shape,
              "if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"
            );
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.acos = function (t) {
            var e = new Lo(
              t.shape,
              "if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"
            );
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.atan = function (t) {
            var e = new Lo(
              t.shape,
              "if (isnan(x)) return x;\n  return atan(x);\n"
            );
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.atan2 = function (t, e) {
            var n = h().getBool("WEBGL_PACK_BINARY_OPERATIONS")
              ? new na(
                  "\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",
                  t.shape,
                  e.shape
                )
              : new ta(
                  "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",
                  t.shape,
                  e.shape
                );
            return this.compileAndRun(n, [t, e]);
          }),
          (e.prototype.sinh = function (t) {
            var e = new Lo(
              t.shape,
              "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"
            );
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.cosh = function (t) {
            var e = new Lo(
              t.shape,
              "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"
            );
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.tanh = function (t) {
            var e = new Lo(
              t.shape,
              "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"
            );
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.asinh = function (t) {
            var e = new Lo(
              t.shape,
              "if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"
            );
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.acosh = function (t) {
            var e = new Lo(
              t.shape,
              "if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));"
            );
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.atanh = function (t) {
            var e = new Lo(
              t.shape,
              "if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;"
            );
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.erf = function (t) {
            var e = new Lo(
              t.shape,
              '\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n'
            );
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.step = function (t, e) {
            var n = new Lo(
              t.shape,
              (function (t) {
                return (
                  void 0 === t && (t = 0),
                  Bo + "\n    return x > 0.0 ? 1.0 : float(" + t + ");\n  "
                );
              })(e)
            );
            return this.compileAndRun(n, [t]);
          }),
          (e.prototype.conv2dByMatMul = function (t, e, n, r, i, a) {
            var o = t.shape,
              s = this.texData.get(t.dataId),
              u = n.inChannels,
              c = o[0] * o[1] * o[2],
              l = n.outChannels,
              p = "channelsLast" === n.dataFormat,
              f = (1 === c || 1 === l) && u > 1e3,
              d = o[2] % 2 != 0 && !!s.isPacked;
            if (
              f ||
              !h().getBool("WEBGL_LAZILY_UNPACK") ||
              !h().getBool("WEBGL_PACK_BINARY_OPERATIONS") ||
              !d
            ) {
              var m = p ? o[0] * o[1] * o[2] : o[0] * o[2] * o[3],
                v = this.reshape(t, [1, m, n.inChannels]),
                g = this.reshape(e, [1, n.inChannels, n.outChannels]);
              return this.reshape(
                this.fusedBatchMatMul({
                  a: v,
                  b: g,
                  transposeA: !1,
                  transposeB: !1,
                  bias: r,
                  activation: i,
                  preluActivationWeights: a,
                }),
                n.outShape
              );
            }
            var y = p ? o[0] * o[1] * (o[2] + 1) : o[0] * o[2] * (o[3] + 1),
              b = {
                dataId: t.dataId,
                shape: [1, y, n.inChannels],
                dtype: t.dtype,
              },
              w = s.shape;
            (s.shape = s.shape.slice()),
              s.shape[s.shape.length - 2]++,
              S(Ae(s.shape, b.shape), function () {
                return (
                  "packed reshape " + s.shape + " to " + b.shape + " isn't free"
                );
              });
            var x = this.reshape(e, [1, n.inChannels, n.outChannels]),
              C = this.fusedBatchMatMul({
                a: b,
                b: x,
                transposeA: !1,
                transposeB: !1,
                bias: r,
                activation: i,
                preluActivationWeights: a,
              }),
              O = this.texData.get(C.dataId);
            return (
              S(O.isPacked, function () {
                return "batchMatMul result is expected to be packed";
              }),
              (s.shape = w),
              (O.shape = n.outShape),
              Pt.makeTensorFromDataId(C.dataId, n.outShape, C.dtype)
            );
          }),
          (e.prototype.conv2dWithIm2Row = function (t, e, n, r, i, a) {
            var o = n.filterWidth,
              s = n.filterHeight,
              u = n.inChannels,
              c = n.outWidth,
              l = n.outHeight,
              p = "channelsLast" === n.dataFormat,
              h = o * s * u,
              f = l * c,
              d = [h, f],
              m = t.squeeze([0]),
              v = e.reshape([1, h, -1]),
              g = new to(d, m.shape, n),
              y = this.compileAndRun(g, [m]).reshape([1, d[0], d[1]]),
              b = null != r,
              w = null != a,
              x = i ? rs(i, !0) : null,
              C = new oo(y.shape, [1, f, n.outChannels], !0, !1, b, x, w),
              O = [y, v];
            r && O.push(r), w && O.push(a);
            var E = this.compileAndRun(C, O);
            return p
              ? E.reshape([1, l, c, n.outChannels])
              : E.reshape([1, n.outChannels, l, c]);
          }),
          (e.prototype.fusedConv2d = function (t) {
            var e = t.input,
              n = t.filter,
              r = t.convInfo,
              i = t.bias,
              a = t.activation,
              o = t.preluActivationWeights;
            if (
              1 === r.filterHeight &&
              1 === r.filterWidth &&
              1 === r.dilationHeight &&
              1 === r.dilationWidth &&
              1 === r.strideHeight &&
              1 === r.strideWidth &&
              ("SAME" === r.padInfo.type || "VALID" === r.padInfo.type)
            )
              return this.conv2dByMatMul(e, n, r, i, a, o);
            if (h().getBool("WEBGL_CONV_IM2COL") && 1 === e.shape[0])
              return this.conv2dWithIm2Row(e, n, r, i, a, o);
            var s = null != i,
              u = null != o,
              c = a ? rs(a, !1) : null,
              l = new ma(r, s, c, u),
              p = [e, n];
            return i && p.push(i), o && p.push(o), this.compileAndRun(l, p);
          }),
          (e.prototype.conv2d = function (t, e, n) {
            if (
              1 === n.filterHeight &&
              1 === n.filterWidth &&
              1 === n.dilationHeight &&
              1 === n.dilationWidth &&
              1 === n.strideHeight &&
              1 === n.strideWidth &&
              ("SAME" === n.padInfo.type || "VALID" === n.padInfo.type)
            )
              return this.conv2dByMatMul(t, e, n);
            if (h().getBool("WEBGL_CONV_IM2COL") && 1 === t.shape[0])
              return this.conv2dWithIm2Row(t, e, n);
            var r = new ma(n);
            return this.compileAndRun(r, [t, e]);
          }),
          (e.prototype.conv2dDerInput = function (t, e, n) {
            var r = new la(n);
            return this.compileAndRun(r, [t, e]);
          }),
          (e.prototype.conv2dDerFilter = function (t, e, n) {
            var r = new ca(n);
            return this.compileAndRun(r, [t, e]);
          }),
          (e.prototype.fusedDepthwiseConv2D = function (t) {
            var e,
              n = t.input,
              r = t.filter,
              i = t.convInfo,
              a = t.bias,
              o = t.activation,
              s = t.preluActivationWeights,
              u =
                h().getBool("WEBGL_PACK_DEPTHWISECONV") &&
                i.strideWidth <= 2 &&
                i.outChannels / i.inChannels == 1,
              c = o ? rs(o, u) : null,
              l = [n, r],
              p = null != a,
              f = null != s;
            return (
              p && l.push(a),
              f && l.push(s),
              u
                ? ((e = new ya(i, p, c, f)), this.compileAndRun(e, l))
                : ((e = new ga(i, p, c, f)), this.compileAndRun(e, l))
            );
          }),
          (e.prototype.depthwiseConv2D = function (t, e, n) {
            var r;
            return h().getBool("WEBGL_PACK_DEPTHWISECONV") &&
              n.strideWidth <= 2 &&
              n.outChannels / n.inChannels == 1
              ? ((r = new ya(n)), this.compileAndRun(r, [t, e]))
              : ((r = new ga(n)), this.compileAndRun(r, [t, e]));
          }),
          (e.prototype.depthwiseConv2DDerInput = function (t, e, n) {
            var r = new da(n);
            return this.compileAndRun(r, [t, e]);
          }),
          (e.prototype.depthwiseConv2DDerFilter = function (t, e, n) {
            var r = new fa(n);
            return this.compileAndRun(r, [t, e]);
          }),
          (e.prototype.conv3d = function (t, e, n) {
            var r = new va(n);
            return this.compileAndRun(r, [t, e]);
          }),
          (e.prototype.conv3dDerInput = function (t, e, n) {
            var r = new ha(n);
            return this.compileAndRun(r, [t, e]);
          }),
          (e.prototype.conv3dDerFilter = function (t, e, n) {
            var r = new pa(n);
            return this.compileAndRun(r, [t, e]);
          }),
          (e.prototype.maxPool = function (t, e) {
            var n = new ho(e, "max", !1);
            return this.compileAndRun(n, [t]);
          }),
          (e.prototype.avgPool = function (t, e) {
            var n = new ho(e, "avg", !1);
            return this.compileAndRun(n, [t], "float32");
          }),
          (e.prototype.maxPoolBackprop = function (t, e, n, r) {
            var i = new ho(r, "max", !0),
              a = this.compileAndRun(i, [e]),
              o = new io(r),
              s = this.compileAndRun(o, [t, a], e.dtype);
            return a.dispose(), s;
          }),
          (e.prototype.avgPoolBackprop = function (t, e, n) {
            var r = new Hi(n);
            return this.compileAndRun(r, [t], e.dtype);
          }),
          (e.prototype.cast = function (t, e) {
            return oi(t, e, this);
          }),
          (e.prototype.unstack = function (t, e) {
            for (
              var n = t.shape[e], r = new Array(t.rank - 1), i = 0, a = 0;
              a < t.rank;
              a++
            )
              a !== e && (r[i++] = t.shape[a]);
            var o = new Array(t.rank).fill(0),
              s = t.shape.slice();
            s[e] = 1;
            var u = new Array(n);
            for (a = 0; a < u.length; a++)
              (o[e] = a), (u[a] = this.slice(t, o, s).reshape(r));
            return u;
          }),
          (e.prototype.avgPool3d = function (t, e) {
            var n = new fo(e, "avg", !1);
            return this.compileAndRun(n, [t], "float32");
          }),
          (e.prototype.avgPool3dBackprop = function (t, e, n) {
            var r = new qi(n);
            return this.compileAndRun(r, [t], e.dtype);
          }),
          (e.prototype.maxPool3d = function (t, e) {
            var n = new fo(e, "max", !1);
            return this.compileAndRun(n, [t], "float32");
          }),
          (e.prototype.maxPool3dBackprop = function (t, e, n, r) {
            var i = new fo(r, "max", !0),
              a = this.compileAndRun(i, [e]),
              o = new ao(r),
              s = this.compileAndRun(o, [t, a], e.dtype);
            return a.dispose(), s;
          }),
          (e.prototype.reshape = function (t, e) {
            var n = this.texData.get(t.dataId);
            if (
              n.isPacked &&
              !Ae(t.shape, e) &&
              (null === n.texture || !Ae(n.shape, e))
            ) {
              var r = this.packedReshape(t, e);
              return Pt.makeTensorFromDataId(r.dataId, r.shape, r.dtype);
            }
            return si(t, e);
          }),
          (e.prototype.resizeBilinear = function (t, e, n, r) {
            var i = h().getBool("WEBGL_PACK_IMAGE_OPERATIONS")
              ? new bo(t.shape, e, n, r)
              : new yo(t.shape, e, n, r);
            return this.compileAndRun(i, [t], "float32");
          }),
          (e.prototype.resizeBilinearBackprop = function (t, e, n) {
            var r = new go(t, e, n);
            return this.compileAndRun(r, [t]);
          }),
          (e.prototype.resizeNearestNeighbor = function (t, e, n, r) {
            var i = new xo(t.shape, e, n, r);
            return this.compileAndRun(i, [t]);
          }),
          (e.prototype.resizeNearestNeighborBackprop = function (t, e, n) {
            var r = new wo(t, e, n);
            return this.compileAndRun(r, [t]);
          }),
          (e.prototype.multinomial = function (t, e, n, r) {
            var i = e ? t : Br(t),
              a = i.shape[0],
              o = i.shape[1],
              s = new so(a, o, n),
              u = s.getCustomSetupFunc(r);
            return this.compileAndRun(s, [i], "int32", u);
          }),
          (e.prototype.oneHot = function (t, e, n, r) {
            var i = new uo(t.size, e, n, r);
            return this.compileAndRun(i, [t]);
          }),
          (e.prototype.diag = function (t) {
            var e = new Sa(t.size);
            return this.compileAndRun(e, [t]);
          }),
          (e.prototype.nonMaxSuppression = function (t, e, n, r, i) {
            return (
              Xe(
                "tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"
              ),
              mi(t.dataSync(), e.dataSync(), n, r, i)
            );
          }),
          (e.prototype.cropAndResize = function (t, e, n, r, i, a) {
            var o = new ba(t.shape, e.shape, r, i, a);
            return this.compileAndRun(o, [t, e, n], "float32");
          }),
          (e.prototype.depthToSpace = function (t, e, n) {
            S(e > 1, function () {
              return "blockSize should be > 1 for depthToSpace, but was: " + e;
            });
            var r = t.shape[0],
              i = "NHWC" === n ? t.shape[1] : t.shape[2],
              a = "NHWC" === n ? t.shape[2] : t.shape[3],
              o = "NHWC" === n ? t.shape[3] : t.shape[1],
              s = i * e,
              u = a * e,
              c = o / (e * e),
              l = new Ea("NHWC" === n ? [r, s, u, c] : [r, c, s, u], e, n);
            return this.compileAndRun(l, [t]);
          }),
          (e.prototype.split = function (t, e, n) {
            return xi(t, e, n);
          }),
          (e.prototype.scatterND = function (t, e, n) {
            var r = Tr(0, t, n),
              i = r.sliceRank,
              a = r.numUpdates,
              o = r.sliceSize,
              s = r.strides,
              u = r.outputSize,
              c = [u / o, o],
              l = t.reshape([a, i]),
              p = e.reshape([a, o]);
            if (0 === u) return si(mn([]), n);
            var h = gn(0),
              f = new Eo(a, i, l.rank, p.rank, s, c);
            return this.compileAndRun(f, [p, l, h]).reshape(n);
          }),
          (e.prototype.sparseToDense = function (t, e, n, r) {
            var i = Tr(0, t, n),
              a = i.sliceRank,
              o = i.numUpdates,
              s = i.strides,
              u = i.outputSize,
              c = new Eo(o, a, t.rank, e.rank, s, [u, 1], !1);
            return this.compileAndRun(c, [e, t, r]).reshape(n);
          }),
          (e.prototype.fft = function (t) {
            return this.fftImpl(t, !1);
          }),
          (e.prototype.ifft = function (t) {
            return this.fftImpl(t, !0);
          }),
          (e.prototype.fftImpl = function (t, e) {
            var n = this.texData.get(t.dataId),
              r = new Aa("return real * expR - imag * expI;", t.shape, e),
              i = new Aa("return real * expI + imag * expR;", t.shape, e),
              a = [
                this.makeComplexComponentTensorInfo(t, n.complexTensors.real),
                this.makeComplexComponentTensorInfo(t, n.complexTensors.imag),
              ],
              o = this.compileAndRun(r, a),
              s = this.compileAndRun(i, a),
              u = this.complex(o, s).as2D(t.shape[0], t.shape[1]);
            return o.dispose(), s.dispose(), u;
          }),
          (e.prototype.gatherND = function (t, e) {
            var n = e.shape,
              r = n[n.length - 1],
              i = Ir(t, e),
              a = i[0],
              o = i[1],
              s = i[2],
              u = i[3],
              c = e.reshape([o, r]),
              l = t.reshape([t.size / s, s]),
              p = new Da(r, u, [o, s]);
            return this.compileAndRun(p, [l, c]).reshape(a);
          }),
          (e.prototype.fill = function (t, e, n) {
            if ("string" === (n = n || Y(e))) {
              var r = B(n, _(t));
              return r.fill(e), Pt.makeTensor(r, t, n, this);
            }
            var i = new Ta(t, e),
              a = i.getCustomSetupFunc(e);
            return this.compileAndRun(i, [], n, a);
          }),
          (e.prototype.onesLike = function (t) {
            if ("string" === t.dtype)
              throw new Error("onesLike is not supported under string dtype");
            return this.fill(t.shape, 1, t.dtype);
          }),
          (e.prototype.zerosLike = function (t) {
            return this.fill(t.shape, "string" === t.dtype ? "" : 0, t.dtype);
          }),
          (e.prototype.linspace = function (t, e, n) {
            return ui(t, e, n);
          }),
          (e.prototype.makeTensorInfo = function (t, e) {
            var n = this.write(null, t, e);
            return (
              (this.texData.get(n).usage = null),
              { dataId: n, shape: t, dtype: e }
            );
          }),
          (e.prototype.makeOutput = function (t, e) {
            var n = this.makeTensorInfo(t, e).dataId;
            return Pt.makeTensorFromDataId(n, t, e, this);
          }),
          (e.prototype.unpackTensor = function (t) {
            var e = new es(t.shape);
            return this.runWebGLProgram(e, [t], t.dtype);
          }),
          (e.prototype.packTensor = function (t) {
            var e = new co(t.shape);
            return this.runWebGLProgram(e, [t], t.dtype, null, !0);
          }),
          (e.prototype.packedReshape = function (t, e) {
            var n = [Se(t.shape)].concat(Ne(t.shape)),
              r = { dtype: t.dtype, shape: n, dataId: t.dataId },
              i = [Se(e)].concat(Ne(e)),
              a = new vo(i, n),
              o = this.runWebGLProgram(a, [r], t.dtype, null, !0);
            return { dataId: o.dataId, shape: e, dtype: o.dtype };
          }),
          (e.prototype.decode = function (t) {
            var e,
              n = this.texData.get(t),
              r = n.isPacked,
              i = n.shape,
              a = n.dtype,
              o = Ie(i);
            return (
              (e = r ? new Oa(o) : new Ca(o)),
              {
                dtype: a,
                shape: i,
                dataId: this.runWebGLProgram(
                  e,
                  [{ shape: o, dtype: a, dataId: t }],
                  a,
                  null,
                  !0
                ).dataId,
              }
            );
          }),
          (e.prototype.runWebGLProgram = function (t, e, n, r, i) {
            var a = this;
            void 0 === i && (i = !1);
            var o = this.makeTensorInfo(t.outputShape, n),
              s = this.texData.get(o.dataId);
            if (
              (t.packedOutput && (s.isPacked = !0),
              t.outPackingScheme === Bt.DENSE)
            ) {
              var u = Zt(t.outputShape);
              s.texShape = u.map(function (t) {
                return 2 * t;
              });
            }
            if (
              (null != t.outTexUsage && (s.usage = t.outTexUsage),
              0 === _(o.shape))
            )
              return (s.values = L(o.dtype, 0)), o;
            var c = [],
              l = e.map(function (e) {
                if ("complex64" === e.dtype)
                  throw new Error(
                    "GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts."
                  );
                var n = a.texData.get(e.dataId);
                if (null == n.texture) {
                  if (
                    !t.packedInputs &&
                    _(e.shape) <= h().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")
                  )
                    return {
                      shape: e.shape,
                      texData: null,
                      isUniform: !0,
                      uniformValues: n.values,
                    };
                  t.packedInputs && ((n.isPacked = !0), (n.shape = e.shape));
                } else if (!!n.isPacked != !!t.packedInputs)
                  (e = n.isPacked ? a.unpackTensor(e) : a.packTensor(e)),
                    c.push(e),
                    (n = a.texData.get(e.dataId));
                else if (n.isPacked && !Ae(n.shape, e.shape)) {
                  var r = e,
                    i = e.shape;
                  (e.shape = n.shape),
                    (e = a.packedReshape(e, i)),
                    c.push(e),
                    (n = a.texData.get(e.dataId)),
                    (r.shape = i);
                }
                return (
                  a.uploadToGPU(e.dataId),
                  { shape: e.shape, texData: n, isUniform: !1 }
                );
              });
            this.uploadToGPU(o.dataId);
            var p,
              f = { shape: o.shape, texData: s, isUniform: !1 },
              d = (function (t, e, n) {
                var r = "";
                e.concat(n).forEach(function (t) {
                  var e =
                      null != t.texData &&
                      null != t.texData.slice &&
                      t.texData.slice.flatOffset > 0,
                    n = t.isUniform ? "uniform" : t.texData.texShape;
                  r += t.shape + "_" + n + "_" + e;
                });
                var i = t.userCode;
                return t.constructor.name + "_" + r + "_" + i;
              })(t, l, f),
              m = this.getAndSaveBinary(d, function () {
                return (function (t, e, n, r) {
                  var i = e.userCode,
                    a = n.map(function (t, n) {
                      var r = {
                        logicalShape: t.shape,
                        texShape: t.isUniform ? null : t.texData.texShape,
                        isUniform: t.isUniform,
                        isPacked: !t.isUniform && t.texData.isPacked,
                        flatOffset: null,
                      };
                      return (
                        null != t.texData &&
                          null != t.texData.slice &&
                          t.texData.slice.flatOffset > 0 &&
                          (r.flatOffset = t.texData.slice.flatOffset),
                        { name: e.variableNames[n], shapeInfo: r }
                      );
                    }),
                    o = a.map(function (t) {
                      return t.shapeInfo;
                    }),
                    s = {
                      logicalShape: r.shape,
                      texShape: r.texData.texShape,
                      isUniform: !1,
                      isPacked: r.texData.isPacked,
                      flatOffset: null,
                    },
                    u = Fi(a, s, i, e.packedInputs),
                    c = t.createProgram(u),
                    l = null,
                    p = t.getUniformLocation(c, "NAN", !1);
                  1 === h().getNumber("WEBGL_VERSION") &&
                    (l = t.getUniformLocation(c, "INFINITY", !1));
                  for (var f = {}, d = 0; d < e.variableNames.length; d++) {
                    var m = e.variableNames[d];
                    (f[m] = t.getUniformLocation(c, m, !1)),
                      (f["offset" + m] = t.getUniformLocation(
                        c,
                        "offset" + m,
                        !1
                      ));
                  }
                  return {
                    program: e,
                    source: u,
                    webGLProgram: c,
                    uniformLocations: f,
                    inShapeInfos: o,
                    outShapeInfo: s,
                    infLoc: l,
                    nanLoc: p,
                  };
                })(a.gpgpu, t, l, f);
              }),
              v = null != this.activeTimers;
            if (
              (v && (p = this.startTimer()),
              (function (t, e, n, r, i) {
                Qa(e.inShapeInfos, n), Qa([e.outShapeInfo], [r]);
                var a = r.texData.texture,
                  o = r.texData.texShape;
                r.texData.isPacked
                  ? t.setOutputPackedMatrixTexture(a, o[0], o[1])
                  : t.setOutputMatrixTexture(a, o[0], o[1]),
                  t.setProgram(e.webGLProgram),
                  1 === h().getNumber("WEBGL_VERSION") &&
                    null !== e.infLoc &&
                    t.gl.uniform1f(e.infLoc, 1 / 0),
                  null !== e.nanLoc && t.gl.uniform1f(e.nanLoc, NaN),
                  n.forEach(function (n, r) {
                    var i = e.program.variableNames[r],
                      a = e.uniformLocations[i],
                      o = e.uniformLocations["offset" + i];
                    if (null != a)
                      if (n.isUniform)
                        if (_(n.shape) < 2)
                          t.gl.uniform1f(a, n.uniformValues[0]);
                        else {
                          var s = n.uniformValues;
                          s instanceof Float32Array ||
                            (s = new Float32Array(s)),
                            t.gl.uniform1fv(a, s);
                        }
                      else
                        null != n.texData.slice &&
                          null != o &&
                          t.gl.uniform1i(o, n.texData.slice.flatOffset),
                          t.setInputMatrixTexture(n.texData.texture, a, r);
                  }),
                  null != i && i(t, e.webGLProgram),
                  t.executeProgram();
              })(this.gpgpu, m, l, f, r),
              c.forEach(function (t) {
                return a.disposeData(t.dataId);
              }),
              v &&
                ((p = this.endTimer(p)),
                this.activeTimers.push({
                  name: t.constructor.name,
                  query: this.getQueryTime(p),
                })),
              !h().getBool("WEBGL_LAZILY_UNPACK") && s.isPacked && !1 === i)
            ) {
              var g = this.unpackTensor(o);
              return this.disposeData(o.dataId), g;
            }
            return o;
          }),
          (e.prototype.compileAndRun = function (t, e, n, r, i) {
            void 0 === i && (i = !1), (n = n || e[0].dtype);
            var a = this.runWebGLProgram(t, e, n, r, i);
            return Pt.makeTensorFromDataId(a.dataId, a.shape, a.dtype);
          }),
          (e.prototype.getAndSaveBinary = function (t, e) {
            return (
              t in this.binaryCache || (this.binaryCache[t] = e()),
              this.binaryCache[t]
            );
          }),
          (e.prototype.getTextureManager = function () {
            return this.textureManager;
          }),
          (e.prototype.dispose = function () {
            var t = this;
            this.disposed ||
              (h().getBool("IS_TEST") ||
                Object.keys(this.binaryCache).forEach(function (e) {
                  t.gpgpu.deleteProgram(t.binaryCache[e].webGLProgram),
                    delete t.binaryCache[e];
                }),
              this.textureManager.dispose(),
              null != this.canvas &&
              "undefined" != typeof HTMLCanvasElement &&
              this.canvas instanceof HTMLCanvasElement
                ? this.canvas.remove()
                : (this.canvas = null),
              this.gpgpuCreatedLocally &&
                ((this.gpgpu.program = null), this.gpgpu.dispose()),
              (this.disposed = !0));
          }),
          (e.prototype.floatPrecision = function () {
            var t = this;
            return (
              null == this.floatPrecisionValue &&
                (this.floatPrecisionValue = He(function () {
                  if (!h().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
                    var e = h().getBool("DEBUG");
                    h().set("DEBUG", !1);
                    var n = t.abs(gn(1e-8)).dataSync()[0];
                    if ((h().set("DEBUG", e), n > 0)) return 32;
                  }
                  return 16;
                })),
              this.floatPrecisionValue
            );
          }),
          (e.prototype.epsilon = function () {
            return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
          }),
          (e.prototype.uploadToGPU = function (t) {
            var e,
              n = this.texData.get(t),
              r = n.shape,
              i = n.dtype,
              a = n.values,
              o = n.texture,
              s = n.usage,
              u = n.isPacked;
            if (null == o) {
              var c,
                l = null != this.activeTimers;
              l && (c = it());
              var p = n.texShape;
              if (
                (null == p && ((p = ke(r, u)), (n.texShape = p)), null != a)
              ) {
                var h = Ie(r),
                  f = void 0,
                  d = p[1],
                  m = p[0],
                  v = a instanceof Uint8Array;
                u
                  ? ((d = (e = Xt(p[0], p[1]))[0]),
                    (m = e[1]),
                    (f = new _a(h, [m, d], v)))
                  : (f = new ka(h, [m, d], v));
                var g = this.makeTensorInfo([m, d], i);
                (this.texData.get(g.dataId).usage = v ? Wt.PIXELS : Wt.UPLOAD),
                  this.gpgpu.uploadDenseMatrixToTexture(
                    this.getTexture(g.dataId),
                    d,
                    m,
                    a
                  );
                var y = this.runWebGLProgram(f, [g], i, null, !0),
                  b = this.texData.get(y.dataId);
                (n.texture = b.texture),
                  (n.texShape = b.texShape),
                  (n.isPacked = b.isPacked),
                  (n.usage = b.usage),
                  this.disposeData(g.dataId),
                  this.texData.delete(y.dataId),
                  (n.values = null),
                  l && (this.uploadWaitMs += it() - c);
              } else {
                var w = this.acquireTexture(p, s, i, u);
                n.texture = w;
              }
            }
          }),
          (e.prototype.convertAndCacheOnCPU = function (t, e) {
            var n = this.texData.get(t),
              r = n.dtype;
            return (
              this.releaseGPUData(t),
              null != e &&
                (n.values = (function (t, e) {
                  if ("float32" === e || "complex64" === e) return t;
                  if ("int32" === e || "bool" === e) {
                    for (
                      var n =
                          "int32" === e
                            ? new Int32Array(t.length)
                            : new Uint8Array(t.length),
                        r = 0;
                      r < n.length;
                      ++r
                    )
                      n[r] = Math.round(t[r]);
                    return n;
                  }
                  throw new Error("Unknown dtype " + e);
                })(e, r)),
              n.values
            );
          }),
          (e.prototype.acquireTexture = function (t, e, n, r) {
            if (
              ((this.numBytesInGPU += this.computeBytes(t, n)),
              !this.warnedAboutMemory &&
                this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024)
            ) {
              var i = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
              (this.warnedAboutMemory = !0),
                console.warn(
                  "High memory usage in GPU: " +
                    i +
                    " MB, most likely due to a memory leak"
                );
            }
            return this.textureManager.acquireTexture(t, e, r);
          }),
          (e.prototype.computeBytes = function (t, e) {
            return t[0] * t[1] * H(e);
          }),
          e
        );
      })(Vr);
      zt() &&
        Pt.registerBackend(
          "webgl",
          function () {
            return new is();
          },
          2
        );
      var as = pn({
          square_: function (t) {
            var e = $e(t, "x", "square"),
              n = [e];
            return Pt.runKernelFunc(
              function (t, n) {
                return n([e]), t.square(e);
              },
              { x: e },
              null,
              "Square",
              {},
              n,
              []
            );
          },
        }),
        os = "SquaredDifference",
        ss = pn({
          squaredDifference_: function (t, e) {
            var n,
              r = $e(t, "a", "squaredDifference"),
              i = $e(e, "b", "squaredDifference");
            (n = At(r, i)), (r = n[0]), (i = n[1]), Kr(r.shape, i.shape);
            var a = { a: r, b: i },
              o = [r, i];
            return Pt.runKernelFunc(
              function (t, e) {
                var n = t.squaredDifference(r, i);
                return e([r, i]), n;
              },
              a,
              function (t, e) {
                var n = e[0],
                  r = e[1],
                  i = gn(2);
                return {
                  a: function () {
                    return t.mul(n.sub(r).mul(i));
                  },
                  b: function () {
                    return t.mul(r.sub(n).mul(i));
                  },
                };
              },
              os,
              {},
              o,
              []
            );
          },
        }),
        us = pn({
          abs_: function (t) {
            var e = $e(t, "x", "abs");
            return "complex64" === e.dtype
              ? Pt.runKernelFunc(
                  function (t) {
                    return t.complexAbs(e);
                  },
                  { $x: e }
                )
              : Pt.runKernelFunc(
                  function (t, n) {
                    var r = t.abs(e);
                    return n([e]), r;
                  },
                  { x: e },
                  function (t, e) {
                    var n = e[0];
                    return {
                      x: function () {
                        return t.mul(n.toFloat().step(-1));
                      },
                    };
                  },
                  "Abs"
                );
          },
        }),
        cs = pn({
          acos_: function (t) {
            var e = $e(t, "x", "acos");
            return Pt.runKernelFunc(
              function (t, n) {
                var r = t.acos(e);
                return n([e]), r;
              },
              { $x: e },
              function (t, e) {
                var n = e[0];
                return {
                  $x: function () {
                    return t
                      .divStrict(gn(1).sub(n.toFloat().square()).sqrt())
                      .neg();
                  },
                };
              }
            );
          },
        }),
        ls = pn({
          acosh_: function (t) {
            var e = $e(t, "x", "acosh");
            return Pt.runKernelFunc(
              function (t, n) {
                var r = t.acosh(e);
                return n([e]), r;
              },
              { $x: e },
              function (t, e) {
                var n = e[0];
                return {
                  $x: function () {
                    return t.divStrict(n.toFloat().square().sub(1).sqrt());
                  },
                };
              }
            );
          },
        }),
        ps = pn({
          asin_: function (t) {
            var e = $e(t, "x", "asin");
            return Pt.runKernelFunc(
              function (t, n) {
                var r = t.asin(e);
                return n([e]), r;
              },
              { $x: e },
              function (t, e) {
                var n = e[0];
                return {
                  $x: function () {
                    return t.divStrict(gn(1).sub(n.toFloat().square()).sqrt());
                  },
                };
              }
            );
          },
        }),
        hs = pn({
          asinh_: function (t) {
            var e = $e(t, "x", "asinh");
            return Pt.runKernelFunc(
              function (t, n) {
                var r = t.asinh(e);
                return n([e]), r;
              },
              { $x: e },
              function (t, e) {
                var n = e[0];
                return {
                  $x: function () {
                    return t.divStrict(gn(1).add(n.toFloat().square()).sqrt());
                  },
                };
              }
            );
          },
        }),
        fs = pn({
          atan_: function (t) {
            var e = $e(t, "x", "atan");
            return Pt.runKernelFunc(
              function (t, n) {
                var r = t.atan(e);
                return n([e]), r;
              },
              { $x: e },
              function (t, e) {
                var n = e[0];
                return {
                  $x: function () {
                    return t.div(n.toFloat().square().add(1));
                  },
                };
              }
            );
          },
        }),
        ds = pn({
          atanh_: function (t) {
            var e = $e(t, "x", "atanh");
            return Pt.runKernelFunc(
              function (t, n) {
                var r = t.atanh(e);
                return n([e]), r;
              },
              { $x: e },
              function (t, e) {
                var n = e[0];
                return {
                  $x: function () {
                    return t.div(gn(1).sub(n.toFloat().square()));
                  },
                };
              }
            );
          },
        }),
        ms = pn({
          ceil_: function (t) {
            var e = $e(t, "x", "ceil");
            return Pt.runKernelFunc(
              function (t) {
                return t.ceil(e);
              },
              { $x: e },
              function (t) {
                return {
                  $x: function () {
                    return _n(t);
                  },
                };
              }
            );
          },
        }),
        vs = pn({
          clipByValue_: function (t, e, n) {
            var r = $e(t, "x", "clipByValue");
            S(e <= n, function () {
              return (
                "Error in clip: min (" +
                e +
                ") must be less than or equal to max (" +
                n +
                ")."
              );
            });
            var i = [r],
              a = { min: e, max: n };
            return Pt.runKernelFunc(
              function (t, i) {
                var a = t.clip(r, e, n);
                return i([r]), a;
              },
              { x: r },
              function (t, r) {
                var i = r[0];
                return {
                  x: function () {
                    return t.where(
                      i.greaterEqual(e).logicalAnd(i.lessEqual(n)),
                      _n(t)
                    );
                  },
                };
              },
              "ClipByValue",
              a,
              i
            );
          },
        }),
        gs = pn({
          cos_: function (t) {
            var e = $e(t, "x", "cos"),
              n = [e];
            return Pt.runKernelFunc(
              function (t, n) {
                var r = t.cos(e);
                return n([e]), r;
              },
              { x: e },
              function (t, e) {
                var n = e[0];
                return {
                  x: function () {
                    return n.toFloat().sin().neg().mul(t);
                  },
                };
              },
              "Cos",
              {},
              n
            );
          },
        }),
        ys = pn({
          cosh_: function (t) {
            var e = $e(t, "x", "cosh");
            return Pt.runKernelFunc(
              function (t, n) {
                var r = t.cosh(e);
                return n([e]), r;
              },
              { $x: e },
              function (t, e) {
                var n = e[0];
                return {
                  $x: function () {
                    return n.toFloat().sinh().mulStrict(t);
                  },
                };
              }
            );
          },
        }),
        bs = pn({
          erf_: function (t) {
            var e = $e(t, "x", "erf");
            return (
              S("int32" === e.dtype || "float32" === e.dtype, function () {
                return "Input dtype must be `int32` or `float32`.";
              }),
              "int32" === e.dtype && (e = e.toFloat()),
              Pt.runKernelFunc(
                function (t, n) {
                  var r = t.erf(e);
                  return n([e]), r;
                },
                { $x: e },
                function (t, e) {
                  var n = e[0];
                  return {
                    $x: function () {
                      return t.mul(
                        n
                          .square()
                          .neg()
                          .exp()
                          .mul(2 / Math.sqrt(Math.PI))
                      );
                    },
                  };
                }
              )
            );
          },
        }),
        ws = pn({
          exp_: function (t) {
            var e = $e(t, "x", "exp");
            return Pt.runKernelFunc(
              function (t, n) {
                var r = t.exp(e);
                return n([r]), r;
              },
              { x: e },
              function (t, e) {
                return {
                  x: function () {
                    return t.mulStrict(e[0]);
                  },
                };
              },
              "Exp",
              {},
              [],
              [!0]
            );
          },
        }),
        xs = pn({
          expm1_: function (t) {
            var e = $e(t, "x", "expm1");
            return Pt.runKernelFunc(
              function (t, n) {
                var r = t.expm1(e);
                return n([e]), r;
              },
              { $x: e },
              function (t, e) {
                var n = e[0];
                return {
                  $x: function () {
                    return t.mul(n.exp());
                  },
                };
              }
            );
          },
        }),
        Cs = pn({
          floor_: function (t) {
            var e = $e(t, "x", "floor");
            return Pt.runKernelFunc(
              function (t) {
                return t.floor(e);
              },
              { $x: e },
              function (t) {
                return {
                  $x: function () {
                    return _n(t);
                  },
                };
              }
            );
          },
        }),
        Os = pn({
          log_: function (t) {
            var e = $e(t, "x", "log"),
              n = [e];
            return Pt.runKernelFunc(
              function (t, n) {
                var r = t.log(e);
                return n([e]), r;
              },
              { x: e },
              function (t, e) {
                var n = e[0];
                return {
                  x: function () {
                    return t.div(n.toFloat());
                  },
                };
              },
              "Log",
              {},
              n
            );
          },
        }),
        Es = pn({
          log1p_: function (t) {
            var e = $e(t, "x", "log1p");
            return Pt.runKernelFunc(
              function (t, n) {
                var r = t.log1p(e);
                return n([e]), r;
              },
              { $x: e },
              function (t, e) {
                var n = e[0];
                return {
                  $x: function () {
                    return t.div(n.add(1));
                  },
                };
              }
            );
          },
        }),
        Ss = pn({
          logSigmoid_: function (t) {
            var e = $e(t, "x", "logSigmoid");
            return Pt.runKernelFunc(
              function (t, n) {
                var r = t.softplus(e.neg()).neg();
                return n([e]), r;
              },
              { $x: e },
              function (t, e) {
                var n = e[0];
                return {
                  $x: function () {
                    return t.mul(n.neg().sigmoid());
                  },
                };
              }
            );
          },
        }),
        Ns = pn({
          neg_: function (t) {
            var e = $e(t, "x", "neg"),
              n = [e];
            return Pt.runKernelFunc(
              function (t) {
                return t.neg(e);
              },
              { x: e },
              function (t) {
                return {
                  x: function () {
                    return t.neg();
                  },
                };
              },
              "Neg",
              {},
              n
            );
          },
        }),
        Is = pn({
          reciprocal_: function (t) {
            var e = $e(t, "x", "reciprocal");
            return Pt.runKernelFunc(
              function (t, n) {
                var r = t.reciprocal(e);
                return n([e]), r;
              },
              { $x: e },
              function (t, e) {
                var n = e[0];
                return {
                  $x: function () {
                    return t.div(n.square().neg());
                  },
                };
              }
            );
          },
        }),
        ks = pn({
          round_: function (t) {
            var e = $e(t, "x", "round");
            return Pt.runKernelFunc(
              function (t) {
                return t.round(e);
              },
              { $x: e },
              function (t) {
                return {
                  $x: function () {
                    return _n(t);
                  },
                };
              }
            );
          },
        }),
        _s = pn({
          rsqrt_: function (t) {
            var e = $e(t, "x", "rsqrt"),
              n = [e];
            return Pt.runKernelFunc(
              function (t, n) {
                var r = t.rsqrt(e);
                return n([e]), r;
              },
              { x: e },
              function (t, e) {
                var n = e[0];
                return {
                  x: function () {
                    return t.div(n.pow(1.5).mul(2)).neg();
                  },
                };
              },
              "Rsqrt",
              {},
              n
            );
          },
        }),
        As = pn({
          sigmoid_: function (t) {
            var e = $e(t, "x", "sigmoid");
            return Pt.runKernelFunc(
              function (t, n) {
                var r = t.sigmoid(e);
                return n([r]), r;
              },
              { x: e },
              function (t, e) {
                var n = e[0];
                return {
                  x: function () {
                    return t.mul(n.mul(gn(1).sub(n)));
                  },
                };
              },
              "Sigmoid"
            );
          },
        }),
        Ts = pn({
          sign_: function (t) {
            var e = $e(t, "x", "sign");
            return Pt.runKernelFunc(
              function (t) {
                return t.sign(e);
              },
              { $x: e },
              function (t) {
                return {
                  $x: function () {
                    return _n(t);
                  },
                };
              }
            );
          },
        }),
        Rs = pn({
          isNaN_: function (t) {
            var e = $e(t, "x", "isNaN");
            return Pt.runKernelFunc(
              function (t) {
                return t.isNaN(e);
              },
              { $x: e },
              function (t) {
                return {
                  $x: function () {
                    return _n(t);
                  },
                };
              }
            );
          },
        }),
        Ds = pn({
          isInf_: function (t) {
            var e = $e(t, "x", "isInf");
            return Pt.runKernelFunc(
              function (t) {
                return t.isInf(e);
              },
              { $x: e },
              function (t) {
                return {
                  $x: function () {
                    return _n(t);
                  },
                };
              }
            );
          },
        }),
        Fs = pn({
          isFinite_: function (t) {
            var e = $e(t, "x", "isFinite");
            return Pt.runKernelFunc(
              function (t) {
                return t.isFinite(e);
              },
              { $x: e },
              function (t) {
                return {
                  $x: function () {
                    return _n(t);
                  },
                };
              }
            );
          },
        }),
        Ms = pn({
          sin_: function (t) {
            var e = $e(t, "x", "sin"),
              n = [e];
            return Pt.runKernelFunc(
              function (t, n) {
                var r = t.sin(e);
                return n([e]), r;
              },
              { x: e },
              function (t, e) {
                var n = e[0];
                return {
                  x: function () {
                    return n.toFloat().cos().mul(t);
                  },
                };
              },
              "Sin",
              {},
              n
            );
          },
        }),
        js = pn({
          sinh_: function (t) {
            var e = $e(t, "x", "sinh");
            return Pt.runKernelFunc(
              function (t, n) {
                var r = t.sinh(e);
                return n([e]), r;
              },
              { $x: e },
              function (t, e) {
                var n = e[0];
                return {
                  $x: function () {
                    return n.toFloat().cosh().mulStrict(t);
                  },
                };
              }
            );
          },
        }),
        Ps = pn({
          softplus_: function (t) {
            var e = $e(t, "x", "softplus");
            return Pt.runKernelFunc(
              function (t, n) {
                var r = t.softplus(e);
                return n([e]), r;
              },
              { $x: e },
              function (t, e) {
                var n = e[0];
                return {
                  $x: function () {
                    return t.mul(n.sigmoid());
                  },
                };
              }
            );
          },
        }),
        zs = pn({
          sqrt_: function (t) {
            var e = $e(t, "x", "sqrt");
            return Pt.runKernelFunc(
              function (t, n) {
                var r = t.sqrt(e);
                return n([e]), r;
              },
              { $x: e },
              function (t, e) {
                var n = e[0];
                return {
                  $x: function () {
                    return t.div(n.toFloat().sqrt().mul(2));
                  },
                };
              }
            );
          },
        }),
        Ls = pn({
          step_: function (t, e) {
            void 0 === e && (e = 0);
            var n = $e(t, "x", "step");
            return Pt.runKernelFunc(
              function (t) {
                return t.step(n, e);
              },
              { $x: n },
              function (t) {
                return {
                  $x: function () {
                    return _n(t);
                  },
                };
              }
            );
          },
        }),
        Bs = pn({
          tan_: function (t) {
            var e = $e(t, "x", "tan");
            return Pt.runKernelFunc(
              function (t, n) {
                var r = t.tan(e);
                return n([e]), r;
              },
              { $x: e },
              function (t, e) {
                var n = e[0];
                return {
                  $x: function () {
                    return t.div(n.cos().square());
                  },
                };
              }
            );
          },
        }),
        Ws = pn({
          tanh_: function (t) {
            var e = $e(t, "x", "tanh");
            return Pt.runKernelFunc(
              function (t, n) {
                var r = t.tanh(e);
                return n([r]), r;
              },
              { x: e },
              function (t, e) {
                var n = e[0];
                return {
                  x: function () {
                    return gn(1).sub(n.square()).mulStrict(t);
                  },
                };
              },
              "Tanh",
              {},
              null,
              [!0]
            );
          },
        });
      function Us(t, e, n, r, i, a) {
        var o,
          s,
          u = $e(t, "x", "batchNorm"),
          c = $e(e, "mean", "batchNorm"),
          l = $e(n, "variance", "batchNorm");
        return (
          null != i && (o = $e(i, "scale", "batchNorm")),
          null != r && (s = $e(r, "offset", "batchNorm")),
          S(2 === u.rank, function () {
            return (
              "Error in batchNorm3D: x must be rank 3 but got rank " +
              u.rank +
              "."
            );
          }),
          S(2 === c.rank || 1 === c.rank, function () {
            return (
              "Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank " +
              c.rank +
              "."
            );
          }),
          S(2 === l.rank || 1 === l.rank, function () {
            return (
              "Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank " +
              l.rank +
              "."
            );
          }),
          null != o &&
            S(2 === o.rank || 1 === o.rank, function () {
              return (
                "Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank " +
                o.rank +
                "."
              );
            }),
          null != s &&
            S(2 === s.rank || 1 === s.rank, function () {
              return (
                "Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank " +
                s.rank +
                "."
              );
            }),
          Hs(u, c, l, s, o, a)
        );
      }
      function Vs(t, e, n, r, i, a) {
        var o,
          s,
          u = $e(t, "x", "batchNorm"),
          c = $e(e, "mean", "batchNorm"),
          l = $e(n, "variance", "batchNorm");
        return (
          null != i && (o = $e(i, "scale", "batchNorm")),
          null != r && (s = $e(r, "offset", "batchNorm")),
          S(3 === u.rank, function () {
            return (
              "Error in batchNorm3D: x must be rank 3 but got rank " +
              u.rank +
              "."
            );
          }),
          S(3 === c.rank || 1 === c.rank, function () {
            return (
              "Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank " +
              c.rank +
              "."
            );
          }),
          S(3 === l.rank || 1 === l.rank, function () {
            return (
              "Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank " +
              l.rank +
              "."
            );
          }),
          null != o &&
            S(3 === o.rank || 1 === o.rank, function () {
              return (
                "Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank " +
                o.rank +
                "."
              );
            }),
          null != s &&
            S(3 === s.rank || 1 === s.rank, function () {
              return (
                "Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank " +
                s.rank +
                "."
              );
            }),
          Hs(u, c, l, s, o, a)
        );
      }
      function Gs(t, e, n, r, i, a) {
        var o,
          s,
          u = $e(t, "x", "batchNorm"),
          c = $e(e, "mean", "batchNorm"),
          l = $e(n, "variance", "batchNorm");
        return (
          null != i && (o = $e(i, "scale", "batchNorm")),
          null != r && (s = $e(r, "offset", "batchNorm")),
          S(4 === u.rank, function () {
            return (
              "Error in batchNorm4D: x must be rank 4 but got rank " +
              u.rank +
              "."
            );
          }),
          S(4 === c.rank || 1 === c.rank, function () {
            return (
              "Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank " +
              c.rank +
              "."
            );
          }),
          S(4 === l.rank || 1 === l.rank, function () {
            return (
              "Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank " +
              l.rank +
              "."
            );
          }),
          null != o &&
            S(4 === o.rank || 1 === o.rank, function () {
              return (
                "Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank " +
                o.rank +
                "."
              );
            }),
          null != s &&
            S(4 === s.rank || 1 === s.rank, function () {
              return (
                "Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank " +
                s.rank +
                "."
              );
            }),
          Hs(u, c, l, s, o, a)
        );
      }
      function Hs(t, e, n, r, i, a) {
        null == a && (a = 0.001);
        var o,
          s,
          u,
          c = $e(t, "x", "batchNorm"),
          l = $e(e, "mean", "batchNorm"),
          p = $e(n, "variance", "batchNorm");
        null != i && (o = $e(i, "scale", "batchNorm")),
          null != r && (s = $e(r, "offset", "batchNorm")),
          S(l.rank === p.rank, function () {
            return "Batch normalization gradient requires mean and variance to have equal ranks.";
          }),
          S(null == s || l.rank === s.rank, function () {
            return "Batch normalization gradient requires mean and offset to have equal ranks.";
          }),
          S(null == o || l.rank === o.rank, function () {
            return "Batch normalization gradient requires mean and scale to have equal ranks.";
          }),
          (u =
            0 === c.rank || 1 === c.rank
              ? c.as4D(1, 1, 1, c.size)
              : 2 === c.rank
              ? c.as4D(1, 1, c.shape[0], c.shape[1])
              : 3 === c.rank
              ? c.as4D(1, c.shape[0], c.shape[1], c.shape[2])
              : c);
        var h = [c, l, p, o];
        return Pt.runKernelFunc(
          function (t, e) {
            var n = t.batchNormalization(u, qs(l), qs(p), a, qs(o), qs(s));
            return e([c, l, p, o]), n;
          },
          { x: c, mean: l, variance: p, scale: o, offset: s },
          function (t, e) {
            var n = e,
              r = n[0],
              i = n[1],
              o = n[2],
              s = n[3],
              c = null == s ? gn(1) : s,
              l = qr(i.shape, u.shape),
              p = [];
            if (1 === i.rank) {
              for (var h = 0; h < u.shape.length - 1; ++h) p.push(u.shape[h]);
              p.push(1);
            }
            var f = r.sub(i),
              d = t.mul(c),
              m = _s(o.add(gn(a))),
              v = m.mul(m).mul(m).mul(gn(-0.5));
            return {
              x: function () {
                return 1 === i.rank
                  ? t
                      .mul(yr(m.as4D(1, 1, 1, i.shape[0]), p))
                      .mul(c)
                      .reshape(r.shape)
                  : t.mul(m).mul(c).reshape(r.shape);
              },
              mean: function () {
                var t = m.mul(gn(-1)).mul(d);
                return 1 === i.rank && (t = t.sum(l)), t.reshape(i.shape);
              },
              variance: function () {
                var t = v.mul(f).mul(d);
                return 1 === i.rank && (t = t.sum(l)), t.reshape(i.shape);
              },
              scale: function () {
                var e = f.mul(m),
                  n = t.mul(e);
                return 1 === i.rank && (n = n.sum(l)), n.reshape(i.shape);
              },
              offset: function () {
                var e = t;
                return 1 === i.rank && (e = e.sum(l)), e.reshape(i.shape);
              },
            };
          },
          "BatchNormalization",
          { varianceEpsilon: a },
          h
        ).reshape(c.shape);
      }
      function qs(t) {
        return null == t
          ? null
          : 0 === t.rank
          ? t.as1D()
          : 1 === t.rank
          ? t
          : 2 === t.rank
          ? t.as4D(1, 1, t.shape[0], t.shape[1])
          : 3 === t.rank
          ? t.as4D(1, t.shape[0], t.shape[1], t.shape[2])
          : t;
      }
      function Ks() {
        Ve(
          "tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"
        );
      }
      var Zs = pn({
          batchNormalization2d_: function (t, e, n, r, i, a) {
            return void 0 === r && (r = 0.001), Ks(), Us(t, e, n, a, i, r);
          },
        }),
        Xs = pn({
          batchNormalization3d_: function (t, e, n, r, i, a) {
            return void 0 === r && (r = 0.001), Ks(), Vs(t, e, n, a, i, r);
          },
        }),
        Ys = pn({
          batchNormalization4d_: function (t, e, n, r, i, a) {
            return void 0 === r && (r = 0.001), Ks(), Gs(t, e, n, a, i, r);
          },
        }),
        Js = pn({
          batchNormalization_: function (t, e, n, r, i, a) {
            return void 0 === r && (r = 0.001), Ks(), Hs(t, e, n, a, i, r);
          },
        }),
        $s = pn({ batchNorm_: Hs }),
        Qs = pn({ batchNorm2d_: Us }),
        tu = pn({ batchNorm3d_: Vs }),
        eu = pn({ batchNorm4d_: Gs }),
        nu = pn({
          logicalAnd_: function (t, e) {
            var n = $e(t, "a", "logicalAnd", "bool"),
              r = $e(e, "b", "logicalAnd", "bool");
            return (
              Kr(n.shape, r.shape),
              Pt.runKernelFunc(
                function (t) {
                  return t.logicalAnd(n, r);
                },
                { a: n, b: r },
                null,
                "LogicalAnd"
              )
            );
          },
        }),
        ru = pn({
          logicalNot_: function (t) {
            var e = $e(t, "x", "logicalNot", "bool");
            return Pt.runKernelFunc(
              function (t) {
                return t.logicalNot(e);
              },
              { $x: e }
            );
          },
        }),
        iu = pn({
          logicalOr_: function (t, e) {
            var n = $e(t, "a", "logicalOr", "bool"),
              r = $e(e, "b", "logicalOr", "bool");
            return (
              Kr(n.shape, r.shape),
              Pt.runKernelFunc(
                function (t) {
                  return t.logicalOr(n, r);
                },
                { $a: n, $b: r }
              )
            );
          },
        }),
        au = pn({
          logicalXor_: function (t, e) {
            var n = $e(t, "a", "logicalXor", "bool"),
              r = $e(e, "b", "logicalXor", "bool");
            return (
              Kr(n.shape, r.shape), iu(t, e).logicalAnd(nu(t, e).logicalNot())
            );
          },
        }),
        ou = pn({
          where_: function (t, e, n) {
            var r = $e(e, "a", "where"),
              i = $e(n, "b", "where"),
              a = $e(t, "condition", "where", "bool");
            return (
              N(r.shape, i.shape, "Error in where: "),
              1 === a.rank
                ? S(a.shape[0] === r.shape[0], function () {
                    return "The first dimension of `a` must match the size of `condition`.";
                  })
                : N(a.shape, i.shape, "Error in where: "),
              Pt.runKernelFunc(
                function (t, e) {
                  var n = t.select(a, r, i);
                  return e([a]), n;
                },
                { $condition: a, $a: r, $b: i },
                function (t, e) {
                  var n = e[0];
                  return {
                    $condition: function () {
                      return _n(n).toFloat();
                    },
                    $a: function () {
                      return t.mul(n.cast(t.dtype));
                    },
                    $b: function () {
                      return t.mul(n.logicalNot().cast(t.dtype));
                    },
                  };
                }
              )
            );
          },
        }),
        su = function (t) {
          return u(this, void 0, void 0, function () {
            var e, n, r;
            return c(this, function (i) {
              switch (i.label) {
                case 0:
                  return [
                    4,
                    (e = $e(t, "condition", "whereAsync", "bool")).data(),
                  ];
                case 1:
                  return (
                    (n = i.sent()),
                    (r = Ei(e.shape, n)),
                    t !== e && e.dispose(),
                    [2, r]
                  );
              }
            });
          });
        },
        uu = pn({
          add_: function (t, e) {
            var n,
              r = $e(t, "a", "add"),
              i = $e(e, "b", "add");
            (n = At(r, i)), (r = n[0]), (i = n[1]);
            var a = Kr(r.shape, i.shape);
            return Pt.runKernelFunc(
              function (t) {
                return t.add(r, i);
              },
              { a: r, b: i },
              function (t) {
                return {
                  a: function () {
                    var e = t,
                      n = qr(r.shape, a);
                    return n.length > 0 && (e = e.sum(n)), e.reshape(r.shape);
                  },
                  b: function () {
                    var e = t,
                      n = qr(i.shape, a);
                    return n.length > 0 && (e = e.sum(n)), e.reshape(i.shape);
                  },
                };
              },
              "Add"
            );
          },
        }),
        cu = pn({
          addN_: function (t) {
            S(Array.isArray(t), function () {
              return "The argument passed to tf.addN() must be a list of tensors";
            }),
              S(t.length >= 1, function () {
                return (
                  "Must pass at least one tensor to tf.addN(), but got " +
                  t.length
                );
              });
            var e = t.map(function (t, e) {
                return $e(t, "tensors" + e, "addN");
              }),
              n = e[0];
            e.forEach(function (t) {
              if (t.dtype !== n.dtype)
                throw new Error(
                  "All tensors passed to tf.addN() must have the same dtype"
                );
            }),
              e.forEach(function (t) {
                if (!A(t.shape, n.shape))
                  throw new Error(
                    "All tensors passed to tf.addN() must have the same shape"
                  );
              });
            var r = e;
            return Pt.runKernelFunc(
              function (t) {
                return t.addN(e);
              },
              r,
              function (t) {
                var n = {};
                return (
                  e.forEach(function (e, r) {
                    n[r] = function () {
                      return t.clone();
                    };
                  }),
                  n
                );
              },
              "AddN"
            );
          },
        }),
        lu = pn({
          addStrict_: function (t, e) {
            var n = $e(t, "a", "addStrict"),
              r = $e(e, "b", "addStrict");
            return N(n.shape, r.shape, "Error in addStrict: "), n.add(r);
          },
        }),
        pu = pn({
          atan2_: function (t, e) {
            var n,
              r = $e(t, "a", "atan2"),
              i = $e(e, "b", "atan2");
            (n = At(r, i)), (r = n[0]), (i = n[1]);
            var a = Kr(r.shape, i.shape);
            return Pt.runKernelFunc(
              function (t, e) {
                var n = t.atan2(r, i);
                return e([r, i]), n;
              },
              { $a: r, $b: i },
              function (t, e) {
                var n = e[0],
                  r = e[1];
                return {
                  $a: function () {
                    var e = uu(n.square(), r.square()),
                      i = t.mul(r.div(e)),
                      o = qr(n.shape, a);
                    return o.length > 0 && (i = i.sum(o)), i.reshape(n.shape);
                  },
                  $b: function () {
                    var e = uu(n.square(), r.square()),
                      i = Ns(t.mul(n.div(e))),
                      o = qr(r.shape, a);
                    return o.length > 0 && (i = i.sum(o)), i.reshape(r.shape);
                  },
                };
              }
            );
          },
        }),
        hu = pn({
          div_: function (t, e) {
            var n,
              r = $e(t, "a", "div"),
              i = $e(e, "b", "div");
            if (
              ((n = At(r, i)),
              (r = n[0]),
              (i = n[1]),
              "int32" === r.dtype && "int32" === i.dtype)
            )
              return mu(r, i);
            var a = Kr(r.shape, i.shape);
            return Pt.runKernelFunc(
              function (t, e) {
                var n = t.realDivide(r, i);
                return e([r, i]), n;
              },
              { a: r, b: i },
              function (t, e) {
                var n = e[0],
                  r = e[1];
                return {
                  a: function () {
                    var e = t.div(r.toFloat()),
                      i = qr(n.shape, a);
                    return i.length > 0 ? e.sum(i).reshape(n.shape) : e;
                  },
                  b: function () {
                    var e = t.mul(n.toFloat()),
                      i = qr(r.shape, a);
                    i.length > 0 && (e = e.sum(i).reshape(r.shape));
                    var o = r.square();
                    return e.div(o.toFloat()).neg();
                  },
                };
              },
              "Div"
            );
          },
        }),
        fu = pn({
          divNoNan_: function (t, e) {
            var n,
              r = $e(t, "a", "div"),
              i = $e(e, "b", "div");
            (r = (n = At(r, i))[0]), (i = n[1]);
            var a = hu(r, i),
              o = _n(a),
              s = i.equal(o);
            return ou(s, o, a);
          },
        }),
        du = pn({
          divStrict_: function (t, e) {
            var n = $e(t, "a", "div"),
              r = $e(e, "b", "div");
            return N(n.shape, r.shape, "Error in divideStrict: "), n.div(r);
          },
        }),
        mu = pn({
          floorDiv_: function (t, e) {
            var n,
              r = $e(t, "a", "floorDiv"),
              i = $e(e, "b", "floorDiv");
            (n = At(r, i)), (r = n[0]), (i = n[1]);
            var a = Kr(r.shape, i.shape);
            return Pt.runKernelFunc(
              function (t, e) {
                var n = t.floorDiv(r, i);
                return e([r, i]), n;
              },
              { a: r, b: i },
              function (t, e) {
                var n = e[0],
                  r = e[1];
                return {
                  a: function () {
                    var e = t.div(r.toFloat()),
                      i = qr(n.shape, a);
                    return i.length > 0 ? e.sum(i).reshape(n.shape) : e;
                  },
                  b: function () {
                    var e = t.mul(n.toFloat()),
                      i = qr(r.shape, a);
                    i.length > 0 && (e = e.sum(i).reshape(r.shape));
                    var o = r.square();
                    return e.div(o.toFloat()).neg();
                  },
                };
              },
              "FloorDiv"
            );
          },
        }),
        vu = pn({
          maximum_: function (t, e) {
            var n,
              r = $e(t, "a", "maximum"),
              i = $e(e, "b", "maximum");
            return (
              (n = At(r, i)),
              (r = n[0]),
              (i = n[1]),
              "bool" === r.dtype && ((r = r.toInt()), (i = i.toInt())),
              Kr(r.shape, i.shape),
              Pt.runKernelFunc(
                function (t, e) {
                  var n = t.maximum(r, i);
                  return e([r, i]), n;
                },
                { a: r, b: i },
                function (t, e) {
                  var n = e[0],
                    r = e[1];
                  return {
                    a: function () {
                      return t.mul(n.greaterEqual(r).toFloat());
                    },
                    b: function () {
                      return t.mul(n.less(r).toFloat());
                    },
                  };
                },
                "Maximum"
              )
            );
          },
        }),
        gu = pn({
          maximumStrict_: function (t, e) {
            var n = $e(t, "a", "maximumStrict"),
              r = $e(e, "b", "maximumStrict");
            return (
              N(n.shape, r.shape, "Error in maximumStrict: "), n.maximum(r)
            );
          },
        }),
        yu = pn({
          minimum_: function (t, e) {
            var n,
              r = $e(t, "a", "minimum"),
              i = $e(e, "b", "minimum");
            return (
              (n = At(r, i)),
              (r = n[0]),
              (i = n[1]),
              "bool" === r.dtype && ((r = r.toInt()), (i = i.toInt())),
              Kr(r.shape, i.shape),
              Pt.runKernelFunc(
                function (t, e) {
                  var n = t.minimum(r, i);
                  return e([r, i]), n;
                },
                { a: r, b: i },
                function (t, e) {
                  var n = e[0],
                    r = e[1];
                  return {
                    a: function () {
                      return t.mul(n.lessEqual(r).toFloat());
                    },
                    b: function () {
                      return t.mul(n.greater(r).toFloat());
                    },
                  };
                },
                "Minimum"
              )
            );
          },
        }),
        bu = pn({
          minimumStrict_: function (t, e) {
            var n = $e(t, "a", "minimumStrict"),
              r = $e(e, "b", "minimumStrict");
            return (
              N(n.shape, r.shape, "Error in minimumStrict: "), n.minimum(r)
            );
          },
        }),
        wu = pn({
          mod_: function (t, e) {
            var n,
              r = $e(t, "a", "mod"),
              i = $e(e, "b", "mod");
            (n = At(r, i)), (r = n[0]), (i = n[1]);
            var a = Kr(r.shape, i.shape);
            return Pt.runKernelFunc(
              function (t, e) {
                var n = t.mod(r, i);
                return e([r, i]), n;
              },
              { $a: r, $b: i },
              function (t, e) {
                var n = e[0],
                  r = e[1];
                return {
                  $a: function () {
                    var e = qr(n.shape, a);
                    return e.length > 0 ? t.sum(e).reshape(n.shape) : t;
                  },
                  $b: function () {
                    var e = t.mul(n.div(r).floor().neg()),
                      i = qr(r.shape, a);
                    return i.length > 0 ? e.sum(i).reshape(r.shape) : e;
                  },
                };
              }
            );
          },
        }),
        xu = pn({
          modStrict_: function (t, e) {
            var n = $e(t, "a", "modStrict"),
              r = $e(e, "b", "modStrict");
            return N(n.shape, r.shape, "Error in modStrict: "), n.mod(r);
          },
        }),
        Cu = pn({
          mul_: function (t, e) {
            var n,
              r = $e(t, "a", "mul"),
              i = $e(e, "b", "mul");
            (n = At(r, i)), (r = n[0]), (i = n[1]);
            var a = Kr(r.shape, i.shape);
            return Pt.runKernelFunc(
              function (t, e) {
                var n = t.multiply(r, i);
                return e([r, i]), n;
              },
              { a: r, b: i },
              function (t, e) {
                var n = e[0],
                  r = e[1];
                return {
                  a: function () {
                    var e = t.mul(r.toFloat()),
                      i = qr(n.shape, a);
                    return i.length > 0 ? e.sum(i).reshape(n.shape) : e;
                  },
                  b: function () {
                    var e = t.mul(n.toFloat()),
                      i = qr(r.shape, a);
                    return i.length > 0 ? e.sum(i).reshape(r.shape) : e;
                  },
                };
              },
              "Mul"
            );
          },
        }),
        Ou = pn({
          mulStrict_: function (t, e) {
            var n = $e(t, "a", "mul"),
              r = $e(e, "b", "mul");
            return N(n.shape, r.shape, "Error in multiplyStrict: "), n.mul(r);
          },
        }),
        Eu = pn({
          pow_: function (t, e) {
            var n,
              r = $e(t, "base", "pow"),
              i = $e(e, "exp", "pow");
            (n = At(r, i)), (r = n[0]), (i = n[1]);
            var a = Kr(r.shape, i.shape),
              o = [r, i];
            return Pt.runKernelFunc(
              function (t, e) {
                var n = t.pow(r, i);
                return e([r, i, n]), n;
              },
              { a: r, b: i },
              function (t, e) {
                var n = e[0],
                  r = e[1],
                  i = e[2];
                return {
                  a: function () {
                    var e = r.toFloat(),
                      i = t.mul(e.mul(n.pow(e.sub(gn(1))))),
                      o = qr(n.shape, a);
                    return o.length > 0 && (i = i.sum(o)), i.reshape(n.shape);
                  },
                  b: function () {
                    var e = n.greater(0),
                      o = n.log().where(e, _n(n)),
                      s = t.mul(i.mul(o)),
                      u = qr(r.shape, a);
                    return u.length > 0 && (s = s.sum(u)), s.reshape(r.shape);
                  },
                };
              },
              "Pow",
              {},
              o,
              [!0]
            );
          },
        }),
        Su = pn({
          powStrict_: function (t, e) {
            return N(t.shape, e.shape, "Error in powStrict: "), t.pow(e);
          },
        }),
        Nu = pn({
          squaredDifferenceStrict_: function (t, e) {
            var n = $e(t, "a", "squaredDifferenceStrict"),
              r = $e(e, "b", "squaredDifferenceStrict");
            return (
              N(n.shape, r.shape, "Error in squaredDifferenceStrict: "),
              n.squaredDifference(r)
            );
          },
        }),
        Iu = pn({
          sub_: function (t, e) {
            var n,
              r = $e(t, "a", "sub"),
              i = $e(e, "b", "sub");
            (n = At(r, i)), (r = n[0]), (i = n[1]);
            var a = Kr(r.shape, i.shape);
            return Pt.runKernelFunc(
              function (t) {
                return t.subtract(r, i);
              },
              { a: r, b: i },
              function (t) {
                return {
                  a: function () {
                    var e = t,
                      n = qr(r.shape, a);
                    return n.length > 0 && (e = e.sum(n)), e.reshape(r.shape);
                  },
                  b: function () {
                    var e = t,
                      n = qr(i.shape, a);
                    return (
                      n.length > 0 && (e = e.sum(n)), e.neg().reshape(i.shape)
                    );
                  },
                };
              },
              "Sub"
            );
          },
        }),
        ku = pn({
          subStrict_: function (t, e) {
            var n = $e(t, "a", "subStrict"),
              r = $e(e, "b", "subStrict");
            return N(n.shape, r.shape, "Error in subStrict: "), n.sub(r);
          },
        }),
        _u = pn({
          equal_: function (t, e) {
            var n,
              r = $e(t, "a", "equal"),
              i = $e(e, "b", "equal");
            return (
              (n = At(r, i)),
              (r = n[0]),
              (i = n[1]),
              Kr(r.shape, i.shape),
              Pt.runKernelFunc(
                function (t) {
                  return t.equal(r, i);
                },
                { $a: r, $b: i }
              )
            );
          },
        }),
        Au = pn({
          equalStrict_: function (t, e) {
            var n = $e(t, "a", "equalStrict"),
              r = $e(e, "b", "equalStrict");
            return N(n.shape, r.shape, "Error in equalStrict: "), n.equal(r);
          },
        }),
        Tu = pn({
          greater_: function (t, e) {
            var n,
              r = $e(t, "a", "greater"),
              i = $e(e, "b", "greater");
            return (
              (n = At(r, i)),
              (r = n[0]),
              (i = n[1]),
              Kr(r.shape, i.shape),
              Pt.runKernelFunc(
                function (t) {
                  return t.greater(r, i);
                },
                { a: r, b: i },
                null,
                "Greater"
              )
            );
          },
        }),
        Ru = pn({
          greaterEqual_: function (t, e) {
            var n,
              r = $e(t, "a", "greaterEqual"),
              i = $e(e, "b", "greaterEqual");
            return (
              (n = At(r, i)),
              (r = n[0]),
              (i = n[1]),
              Kr(r.shape, i.shape),
              Pt.runKernelFunc(
                function (t, e) {
                  var n = t.greaterEqual(r, i);
                  return e([r, i]), n;
                },
                { a: r, b: i },
                function (t, e) {
                  var n = e[0],
                    r = e[1];
                  return {
                    a: function () {
                      return _n(n);
                    },
                    b: function () {
                      return _n(r);
                    },
                  };
                },
                "GreaterEqual"
              )
            );
          },
        }),
        Du = pn({
          greaterEqualStrict_: function (t, e) {
            var n = $e(t, "a", "greaterEqualStrict"),
              r = $e(e, "b", "greaterEqualStrict");
            return (
              N(n.shape, r.shape, "Error in greaterEqualStrict: "),
              n.greaterEqual(r)
            );
          },
        }),
        Fu = pn({
          greaterStrict_: function (t, e) {
            var n = $e(t, "a", "greaterStrict"),
              r = $e(e, "b", "greaterStrict");
            return (
              N(n.shape, r.shape, "Error in greaterStrict: "), n.greater(r)
            );
          },
        }),
        Mu = pn({
          less_: function (t, e) {
            var n,
              r = $e(t, "a", "less"),
              i = $e(e, "b", "less");
            return (
              (n = At(r, i)),
              (r = n[0]),
              (i = n[1]),
              Kr(r.shape, i.shape),
              Pt.runKernelFunc(
                function (t) {
                  return t.less(r, i);
                },
                { a: r, b: i },
                null,
                "Less"
              )
            );
          },
        }),
        ju = pn({
          lessEqual_: function (t, e) {
            var n,
              r = $e(t, "a", "lessEqual"),
              i = $e(e, "b", "lessEqual");
            return (
              (n = At(r, i)),
              (r = n[0]),
              (i = n[1]),
              Kr(r.shape, i.shape),
              Pt.runKernelFunc(
                function (t, e) {
                  var n = t.lessEqual(r, i);
                  return e([r, i]), n;
                },
                { a: r, b: i },
                null,
                "LessEqual"
              )
            );
          },
        }),
        Pu = pn({
          lessEqualStrict_: function (t, e) {
            var n = $e(t, "a", "lessEqualStrict"),
              r = $e(e, "b", "lessEqualStrict");
            return (
              N(n.shape, r.shape, "Error in lessEqualStrict: "), n.lessEqual(r)
            );
          },
        }),
        zu = pn({
          lessStrict_: function (t, e) {
            var n = $e(t, "a", "lessStrict"),
              r = $e(e, "b", "lessStrict");
            return N(n.shape, r.shape, "Error in lessStrict: "), n.less(r);
          },
        }),
        Lu = pn({
          notEqual_: function (t, e) {
            var n,
              r = $e(t, "a", "notEqual"),
              i = $e(e, "b", "notEqual");
            return (
              (n = At(r, i)),
              (r = n[0]),
              (i = n[1]),
              Kr(r.shape, i.shape),
              Pt.runKernelFunc(
                function (t) {
                  return t.notEqual(r, i);
                },
                { a: r, b: i },
                null,
                "NotEqual"
              )
            );
          },
        }),
        Bu = pn({
          notEqualStrict_: function (t, e) {
            var n = $e(t, "a", "notEqualStrict"),
              r = $e(e, "b", "notEqualStrict");
            return (
              N(n.shape, r.shape, "Error in notEqualStrict: "), n.notEqual(r)
            );
          },
        });
      function Wu(t, e) {
        for (var n = [], r = t; r < e; ++r) n.push(r);
        return n;
      }
      function Uu(t) {
        for (var e = [], n = 0; n < t.length; ++n)
          for (var r = 0; r < t[n].length; ++r) e.push(t[n][r]);
        return e;
      }
      var Vu = pn({
          gather_: function (t, e, n) {
            void 0 === n && (n = 0);
            var r = $e(t, "x", "gather"),
              i = $e(e, "indices", "gather", "int32");
            n = P(n, r.shape)[0];
            var a = (function (t, e, n) {
              for (var r = t.shape[n], i = [], a = 1, o = 1, s = 0; s < n; s++)
                i.push(t.shape[s]), (a *= t.shape[s]);
              for (s = 0; s < e.rank; s++) i.push(e.shape[s]);
              for (s = n + 1; s < t.rank; s++)
                i.push(t.shape[s]), (o *= t.shape[s]);
              return { batchSize: a, sliceSize: o, dimSize: r, outputShape: i };
            })(r, i, n);
            return Pt.runKernelFunc(
              function (t, e) {
                var a = t.gather(r, i.flatten(), n);
                return e([i]), a;
              },
              { x: r, indices: i },
              function (t, e) {
                var i = e[0];
                return {
                  x: function () {
                    var e = r.shape,
                      a = i.size,
                      o = e.slice(0, n),
                      s = o.length,
                      u = e.slice(n, e.length).slice(1),
                      c = u.length,
                      l = Wu(0, s),
                      p = Wu(s + 1, s + 1 + c),
                      h = Uu([o, [a], u]),
                      f = t.reshape(h),
                      d = i.reshape([a]),
                      m = Uu([[s], l, p]),
                      v = f.transpose(m),
                      g = Gu(v, d, r.shape[n]),
                      y = sn(m);
                    return g.transpose(y);
                  },
                  indices: function () {
                    return i;
                  },
                };
              },
              "Gather",
              { axis: n }
            ).reshape(a.outputShape);
          },
        }),
        Gu = pn({
          unsortedSegmentSum_: function (t, e, n) {
            var r = $e(t, "x", "unsortedSegmentSum"),
              i = $e(e, "segmentIds", "unsortedSegmentSum", "int32");
            return (
              S(T(n), function () {
                return "numSegments must be of dtype int";
              }),
              Pt.runKernelFunc(
                function (t, e) {
                  var a = t.unsortedSegmentSum(r, i, n);
                  return e([i]), a;
                },
                { $x: r },
                function (t, e) {
                  var n = e[0];
                  return {
                    $x: function () {
                      return (function (t, e) {
                        for (
                          var n = vu(e, _n(e)),
                            r = Vu(t, n),
                            i = Ru(e, gn(0, "int32")),
                            a = r.rank - i.rank,
                            o = 0;
                          o < a;
                          ++o
                        )
                          i = er(i, o + 1);
                        i = nu(i, On(r.shape, "bool"));
                        var s = _n(r);
                        return ou(i, r, s);
                      })(t, n);
                    },
                  };
                }
              )
            );
          },
        });
      function Hu(t, e, n, r, i, a, o) {
        void 0 === a && (a = "NHWC"),
          S(t.length === e.rank, function () {
            return (
              "Length of inShape (" +
              t.length +
              ") and rank of dy (" +
              e.rank +
              ") must match"
            );
          });
        var s = t,
          u = e,
          c = !1;
        3 === e.rank &&
          ((c = !0),
          (u = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])),
          (s = [1, t[0], t[1], t[2]])),
          S(4 === s.length, function () {
            return (
              "Error in conv2dDerInput: inShape must be length 4, but got length " +
              s.length +
              "."
            );
          }),
          S(4 === u.rank, function () {
            return (
              "Error in conv2dDerInput: dy must be rank 4, but got rank " +
              u.rank
            );
          }),
          S(4 === n.rank, function () {
            return (
              "Error in conv2dDerInput: filter must be rank 4, but got rank " +
              n.rank
            );
          });
        var l = "NHWC" === a ? s[3] : s[1],
          p = "NHWC" === a ? u.shape[3] : u.shape[1];
        S(l === n.shape[2], function () {
          return (
            "Error in conv2dDerInput: depth of input (" +
            l +
            ") must match input depth for filter " +
            n.shape[2] +
            "."
          );
        }),
          S(p === n.shape[3], function () {
            return (
              "Error in conv2dDerInput: depth of output (" +
              p +
              ") must match output depth for filter " +
              n.shape[3] +
              "."
            );
          }),
          null != o &&
            S(T(i), function () {
              return (
                "Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode " +
                o +
                " but got pad " +
                i +
                "."
              );
            });
        var h = ai(a),
          f = Yr(s, n.shape, r, 1, i, o, !1, h),
          d = Pt.runKernelFunc(
            function (t, e) {
              var r = t.conv2dDerInput(u, n, f);
              return e([n, u]), r;
            },
            { dy4D: u, filter: n },
            function (t, e) {
              var n = e[0],
                s = e[1];
              return {
                dy4D: function () {
                  return Xu(t, n, r, i, a, 1, o);
                },
                filter: function () {
                  return Ju(t, s, n.shape, r, i, a, o);
                },
              };
            }
          );
        return c ? d.as3D(d.shape[1], d.shape[2], d.shape[3]) : d;
      }
      function qu(t) {
        var e = (function (t) {
            return "number" == typeof t
              ? [t, t, t]
              : 2 === t.length
              ? [t[0], t[1], 1]
              : t;
          })(t),
          n = e[0],
          r = e[1],
          i = e[2];
        return 1 === n && 1 === r && 1 === i;
      }
      function Ku(t, e, n, r, i) {
        S(t.length === e.rank, function () {
          return (
            "Length of inShape (" +
            t.length +
            ") and rank of dy (" +
            e.rank +
            ") must match"
          );
        });
        var a = t,
          o = e,
          s = !1;
        4 === e.rank &&
          ((s = !0),
          (o = e.as5D(1, e.shape[0], e.shape[1], e.shape[2], e.shape[3])),
          (a = [1, t[0], t[1], t[2], t[3]]));
        var u = a[4],
          c = o.shape[4];
        S(5 === a.length, function () {
          return (
            "Error in conv3dDerInput: inShape must be length 5, but got length " +
            a.length +
            "."
          );
        }),
          S(5 === o.rank, function () {
            return (
              "Error in conv3dDerInput: dy must be rank 5, but got rank " +
              o.rank
            );
          }),
          S(5 === n.rank, function () {
            return (
              "Error in conv3dDerInput: filter must be rank 5, but got rank " +
              n.rank
            );
          }),
          S(u === n.shape[3], function () {
            return (
              "Error in conv3dDerInput: depth of input (" +
              u +
              ") must match input depth for filter " +
              n.shape[3] +
              "."
            );
          }),
          S(c === n.shape[4], function () {
            return (
              "Error in conv3dDerInput: depth of output (" +
              c +
              ") must match output depth for filter " +
              n.shape[4] +
              "."
            );
          });
        var l = Jr(a, n.shape, r, 1, i),
          p = Pt.runKernelFunc(
            function (t) {
              return t.conv3dDerInput(o, n, l);
            },
            { dy5D: o }
          );
        return s ? p.as4D(p.shape[1], p.shape[2], p.shape[3], p.shape[4]) : p;
      }
      var Zu = pn({
          conv1d_: function (t, e, n, r, i, a, o) {
            void 0 === i && (i = "NWC"), void 0 === a && (a = 1);
            var s = $e(t, "x", "conv1d"),
              u = $e(e, "filter", "conv1d"),
              c = s,
              l = !1;
            2 === s.rank && ((l = !0), (c = s.as3D(1, s.shape[0], s.shape[1]))),
              S(3 === c.rank, function () {
                return (
                  "Error in conv1d: input must be rank 3, but got rank " +
                  c.rank +
                  "."
                );
              }),
              S(3 === u.rank, function () {
                return (
                  "Error in conv1d: filter must be rank 3, but got rank " +
                  u.rank +
                  "."
                );
              }),
              null != o &&
                S(T(r), function () {
                  return (
                    "Error in conv1d: pad must be an integer when using, dimRoundingMode " +
                    o +
                    " but got pad " +
                    r +
                    "."
                  );
                }),
              S(c.shape[2] === u.shape[1], function () {
                return (
                  "Error in conv1d: depth of input (" +
                  c.shape[2] +
                  ") must match input depth for filter " +
                  u.shape[1] +
                  "."
                );
              }),
              S(ii(n, a), function () {
                return (
                  "Error in conv1D: Either stride or dilation must be 1. Got stride " +
                  n +
                  " and dilation '" +
                  a +
                  "'"
                );
              }),
              S("NWC" === i, function () {
                return (
                  "Error in conv1d: got dataFormat of " +
                  i +
                  " but only NWC is currently supported."
                );
              });
            var p = u.as4D(1, u.shape[0], u.shape[1], u.shape[2]),
              h = c.as4D(c.shape[0], 1, c.shape[1], c.shape[2]),
              f = Xu(h, p, [1, n], r, "NHWC", [1, a], o);
            return l
              ? f.as2D(f.shape[2], f.shape[3])
              : f.as3D(f.shape[0], f.shape[2], f.shape[3]);
          },
        }),
        Xu = pn({
          conv2d_: function (t, e, n, r, i, a, o) {
            void 0 === i && (i = "NHWC"), void 0 === a && (a = [1, 1]);
            var s = $e(t, "x", "conv2d"),
              u = $e(e, "filter", "conv2d"),
              c = s,
              l = !1;
            3 === s.rank &&
              ((l = !0), (c = s.as4D(1, s.shape[0], s.shape[1], s.shape[2]))),
              S(4 === c.rank, function () {
                return (
                  "Error in conv2d: input must be rank 4, but got rank " +
                  c.rank +
                  "."
                );
              }),
              S(4 === u.rank, function () {
                return (
                  "Error in conv2d: filter must be rank 4, but got rank " +
                  u.rank +
                  "."
                );
              }),
              null != o &&
                S(T(r), function () {
                  return (
                    "Error in conv2d: pad must be an integer when using, dimRoundingMode " +
                    o +
                    " but got pad " +
                    r +
                    "."
                  );
                });
            var p = "NHWC" === i ? c.shape[3] : c.shape[1];
            S(p === u.shape[2], function () {
              return (
                "Error in conv2d: depth of input (" +
                p +
                ") must match input depth for filter " +
                u.shape[2] +
                "."
              );
            }),
              S(ii(n, a), function () {
                return (
                  "Error in conv2D: Either strides or dilations must be 1. Got strides " +
                  n +
                  " and dilations '" +
                  a +
                  "'"
                );
              });
            var h = ai(i),
              f = Yr(c.shape, u.shape, n, a, r, o, !1, h),
              d = [u, c],
              m = Pt.runKernelFunc(
                function (t, e) {
                  var n = t.conv2d(c, u, f);
                  return e([u, c]), n;
                },
                { x: c, filter: u },
                function (t, e) {
                  var o = e,
                    s = o[0],
                    u = o[1];
                  return (
                    S(ri(a), function () {
                      return (
                        "Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" +
                        a +
                        "'"
                      );
                    }),
                    {
                      x: function () {
                        return $u(u.shape, t, s, n, r, i);
                      },
                      filter: function () {
                        return Ju(u, t, s.shape, n, r, i);
                      },
                    }
                  );
                },
                "Conv2D",
                f,
                d
              );
            return l ? m.as3D(m.shape[1], m.shape[2], m.shape[3]) : m;
          },
        }),
        Yu = pn({
          conv3d_: function (t, e, n, r, i, a) {
            void 0 === i && (i = "NDHWC"), void 0 === a && (a = [1, 1, 1]);
            var o = $e(t, "x", "conv3d"),
              s = $e(e, "filter", "conv3d"),
              u = o,
              c = !1;
            4 === o.rank &&
              ((c = !0),
              (u = o.as5D(1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]))),
              S(5 === u.rank, function () {
                return (
                  "Error in conv3d: input must be rank 5, but got rank " +
                  u.rank +
                  "."
                );
              }),
              S(5 === s.rank, function () {
                return (
                  "Error in conv3d: filter must be rank 5, but got rank " +
                  s.rank +
                  "."
                );
              }),
              S(u.shape[4] === s.shape[3], function () {
                return (
                  "Error in conv3d: depth of input (" +
                  u.shape[4] +
                  ") must match input depth for filter " +
                  s.shape[3] +
                  "."
                );
              }),
              S(
                (function (t, e) {
                  return qu(t) || qu(e);
                })(n, a),
                function () {
                  return (
                    "Error in conv3D: Either strides or dilations must be 1. Got strides " +
                    n +
                    " and dilations '" +
                    a +
                    "'"
                  );
                }
              ),
              S("NDHWC" === i, function () {
                return (
                  "Error in conv3d: got dataFormat of " +
                  i +
                  " but only NDHWC is currently supported."
                );
              });
            var l = Jr(u.shape, s.shape, n, a, r),
              p = Pt.runKernelFunc(
                function (t, e) {
                  var n = t.conv3d(u, s, l);
                  return e([u, s]), n;
                },
                { x: u, $filter: s },
                function (t, e) {
                  S(qu(a), function () {
                    return (
                      "Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" +
                      a +
                      "'"
                    );
                  });
                  var i = e[0],
                    o = e[1];
                  return {
                    x: function () {
                      return Ku(i.shape, t, o, n, r);
                    },
                    $filter: function () {
                      return (function (t, e, n, r, i) {
                        var a = t;
                        4 === t.rank &&
                          (a = t.as5D(
                            1,
                            t.shape[0],
                            t.shape[1],
                            t.shape[2],
                            t.shape[3]
                          ));
                        var o = e;
                        4 === o.rank &&
                          (o = e.as5D(
                            1,
                            e.shape[0],
                            e.shape[1],
                            e.shape[2],
                            e.shape[3]
                          )),
                          S(5 === a.rank, function () {
                            return (
                              "Error in conv3dDerFilter: input must be rank 5, but got shape " +
                              a.shape +
                              "."
                            );
                          }),
                          S(5 === o.rank, function () {
                            return (
                              "Error in conv3dDerFilter: dy must be rank 5, but got shape " +
                              o.shape +
                              "."
                            );
                          }),
                          S(5 === n.length, function () {
                            return (
                              "Error in conv3dDerFilter: filterShape must be length 5, but got " +
                              n +
                              "."
                            );
                          }),
                          S(a.shape[4] === n[3], function () {
                            return (
                              "Error in conv3dDerFilter: depth of input " +
                              a.shape[4] +
                              ") must match input depth in filter (" +
                              n[3] +
                              "."
                            );
                          }),
                          S(o.shape[4] === n[4], function () {
                            return (
                              "Error in conv3dDerFilter: depth of dy (" +
                              o.shape[4] +
                              ") must match output depth for filter (" +
                              n[4] +
                              ")."
                            );
                          });
                        var s = Jr(a.shape, n, r, 1, i);
                        return Pt.runKernelFunc(
                          function (t) {
                            return t.conv3dDerFilter(a, o, s);
                          },
                          { x5D: a, dy5D: o }
                        );
                      })(i, t, o.shape, n, r);
                    },
                  };
                }
              );
            return c
              ? p.as4D(p.shape[1], p.shape[2], p.shape[3], p.shape[4])
              : p;
          },
        }),
        Ju = pn({
          conv2dDerFilter_: function (t, e, n, r, i, a, o) {
            void 0 === a && (a = "NHWC");
            var s = t;
            3 === t.rank && (s = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]));
            var u = e;
            3 === u.rank && (u = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])),
              S(4 === s.rank, function () {
                return (
                  "Error in conv2dDerFilter: input must be rank 4, but got shape " +
                  s.shape +
                  "."
                );
              }),
              S(4 === u.rank, function () {
                return (
                  "Error in conv2dDerFilter: dy must be rank 4, but got shape " +
                  u.shape +
                  "."
                );
              }),
              S(4 === n.length, function () {
                return (
                  "Error in conv2dDerFilter: filterShape must be length 4, but got " +
                  n +
                  "."
                );
              });
            var c = "NHWC" === a ? s.shape[3] : s.shape[1],
              l = "NHWC" === a ? u.shape[3] : u.shape[1];
            S(c === n[2], function () {
              return (
                "Error in conv2dDerFilter: depth of input " +
                c +
                ") must match input depth in filter (" +
                n[2] +
                "."
              );
            }),
              S(l === n[3], function () {
                return (
                  "Error in conv2dDerFilter: depth of dy (" +
                  l +
                  ") must match output depth for filter (" +
                  n[3] +
                  ")."
                );
              }),
              null != o &&
                S(T(i), function () {
                  return (
                    "Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode " +
                    o +
                    " but got pad " +
                    i +
                    "."
                  );
                });
            var p = ai(a),
              h = Yr(s.shape, n, r, 1, i, o, !1, p);
            return Pt.runKernelFunc(
              function (t) {
                return t.conv2dDerFilter(s, u, h);
              },
              { x4D: s, dy4D: u }
            );
          },
        }),
        $u = pn({ conv2dDerInput_: Hu }),
        Qu = pn({
          depthwiseConv2d_: function (t, e, n, r, i, a, o) {
            void 0 === i && (i = "NHWC"), void 0 === a && (a = [1, 1]);
            var s = $e(t, "x", "depthwiseConv2d"),
              u = $e(e, "filter", "depthwiseConv2d"),
              c = s,
              l = !1;
            3 === s.rank &&
              ((l = !0), (c = s.as4D(1, s.shape[0], s.shape[1], s.shape[2]))),
              S(4 === c.rank, function () {
                return (
                  "Error in depthwiseConv2d: input must be rank 4, but got rank " +
                  c.rank +
                  "."
                );
              }),
              S(4 === u.rank, function () {
                return (
                  "Error in depthwiseConv2d: filter must be rank 4, but got rank " +
                  u.rank +
                  "."
                );
              }),
              S(c.shape[3] === u.shape[2], function () {
                return (
                  "Error in depthwiseConv2d: number of input channels (" +
                  c.shape[3] +
                  ") must match the inChannels dimension in filter " +
                  u.shape[2] +
                  "."
                );
              }),
              null == a && (a = [1, 1]),
              S(ii(n, a), function () {
                return (
                  "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides " +
                  n +
                  " and dilations '" +
                  a +
                  "'"
                );
              }),
              null != o &&
                S(T(r), function () {
                  return (
                    "Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode " +
                    o +
                    " but got pad " +
                    r +
                    "."
                  );
                });
            var p = Yr(c.shape, u.shape, n, a, r, o, !0),
              h = [c, u],
              f = Pt.runKernelFunc(
                function (t, e) {
                  var n = t.depthwiseConv2D(c, u, p);
                  return e([c, u]), n;
                },
                { x: c, filter: u },
                function (t, e) {
                  S(ri(a), function () {
                    return (
                      "Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" +
                      a +
                      "'"
                    );
                  });
                  var n = e[0],
                    r = e[1];
                  return {
                    x: function () {
                      return tc(n.shape, t, r, p);
                    },
                    filter: function () {
                      return ec(n, t, r.shape, p);
                    },
                  };
                },
                "DepthwiseConv2dNative",
                p,
                h
              );
            return l ? f.as3D(f.shape[1], f.shape[2], f.shape[3]) : f;
          },
        }),
        tc = pn({
          depthwiseConv2dDerInput_: function (t, e, n, r) {
            var i = e,
              a = !1;
            3 === e.rank &&
              ((a = !0), (i = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])));
            var o = Pt.runKernelFunc(
              function (t) {
                return t.depthwiseConv2DDerInput(i, n, r);
              },
              { dy4D: i }
            );
            return a ? o.as3D(o.shape[1], o.shape[2], o.shape[3]) : o;
          },
        }),
        ec = pn({
          depthwiseConv2dDerFilter_: function (t, e, n, r) {
            var i = t;
            3 === t.rank && (i = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]));
            var a = e;
            return (
              3 === a.rank &&
                (a = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])),
              Pt.runKernelFunc(
                function (t) {
                  return t.depthwiseConv2DDerFilter(i, a, r);
                },
                { x4D: i, dy4D: a }
              )
            );
          },
        }),
        nc = pn({
          separableConv2d_: function (t, e, n, r, i, a, o) {
            void 0 === a && (a = [1, 1]), void 0 === o && (o = "NHWC");
            var s = $e(t, "x", "separableConv2d"),
              u = $e(e, "depthwiseFilter", "separableConv2d"),
              c = $e(n, "pointwiseFilter", "separableConv2d"),
              l = s,
              p = !1;
            if (
              (3 === s.rank &&
                ((p = !0), (l = s.as4D(1, s.shape[0], s.shape[1], s.shape[2]))),
              "NCHW" === o)
            )
              throw new Error(
                "separableConv2d currently does not support dataFormat NCHW; only NHWC is supported"
              );
            S(4 === l.rank, function () {
              return (
                "Error in separableConv2d: input must be rank 4, but got rank " +
                l.rank +
                "."
              );
            }),
              S(4 === u.rank, function () {
                return (
                  "Error in separableConv2d: depthwise filter must be rank 4, but got rank " +
                  u.rank +
                  "."
                );
              }),
              S(4 === c.rank, function () {
                return (
                  "Error in separableConv2d: pointwise filter must be rank 4, but got rank " +
                  u.rank +
                  "."
                );
              }),
              S(1 === c.shape[0], function () {
                return (
                  "Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got " +
                  c.shape[0] +
                  "."
                );
              }),
              S(1 === c.shape[1], function () {
                return (
                  "Error in separableConv2d: the second dimension of pointwise filter must be 1, but got " +
                  c.shape[1] +
                  "."
                );
              });
            var h = u.shape[2],
              f = u.shape[3];
            S(c.shape[2] === h * f, function () {
              return (
                "Error in separableConv2d: the third dimension of pointwise filter must be " +
                h * f +
                ", but got " +
                c.shape[2] +
                "."
              );
            });
            var d = Qu(l, u, r, i, o, a),
              m = Xu(d, c, 1, "valid", o);
            return p ? m.as3D(m.shape[1], m.shape[2], m.shape[3]) : m;
          },
        }),
        rc = pn({
          conv2dTranspose_: function (t, e, n, r, i, a) {
            return Hu(
              n,
              $e(t, "x", "conv2dTranspose"),
              $e(e, "filter", "conv2dTranspose"),
              r,
              i,
              "NHWC",
              a
            );
          },
        }),
        ic = pn({
          conv3dTranspose_: function (t, e, n, r, i) {
            return Ku(
              n,
              $e(t, "x", "conv3dTranspose"),
              $e(e, "filter", "conv3dTranspose"),
              r,
              i
            );
          },
        }),
        ac = pn({
          matMul_: function (t, e, n, r) {
            var i;
            void 0 === n && (n = !1), void 0 === r && (r = !1);
            var a = $e(t, "a", "matMul"),
              o = $e(e, "b", "matMul");
            (i = At(a, o)), (a = i[0]), (o = i[1]);
            var s = n ? a.shape[a.rank - 2] : a.shape[a.rank - 1],
              u = r ? o.shape[o.rank - 1] : o.shape[o.rank - 2],
              c = n ? a.shape[a.rank - 1] : a.shape[a.rank - 2],
              l = r ? o.shape[o.rank - 2] : o.shape[o.rank - 1],
              p = a.shape.slice(0, -2),
              h = o.shape.slice(0, -2),
              f = _(p),
              d = _(h);
            S(a.rank >= 2 && o.rank >= 2 && a.rank === o.rank, function () {
              return (
                "Error in matMul: inputs must have the same rank of at least 2, got ranks " +
                a.rank +
                " and " +
                o.rank +
                "."
              );
            }),
              S(A(p, h), function () {
                return (
                  "Error in matMul: outer dimensions (" +
                  p +
                  ") and (" +
                  h +
                  ") of Tensors with shapes " +
                  a.shape +
                  " and " +
                  o.shape +
                  " must match."
                );
              }),
              S(s === u, function () {
                return (
                  "Error in matMul: inner shapes (" +
                  s +
                  ") and (" +
                  u +
                  ") of Tensors with shapes " +
                  a.shape +
                  " and " +
                  o.shape +
                  " and transposeA=" +
                  n +
                  " and transposeB=" +
                  r +
                  " must match."
                );
              });
            var m = a.shape.slice(0, -2).concat([c, l]),
              v = n ? a.as3D(f, s, c) : a.as3D(f, c, s),
              g = r ? o.as3D(d, l, u) : o.as3D(d, u, l),
              y = { transposeA: n, transposeB: r };
            return Pt.runKernelFunc(
              function (t, e) {
                var i = t.batchMatMul(v, g, n, r);
                return e([v, g]), i;
              },
              { a: v, b: g },
              function (t, e) {
                var i = e,
                  a = i[0],
                  o = i[1];
                return n || r
                  ? !n && r
                    ? {
                        a: function () {
                          return t.matMul(o, !1, !1);
                        },
                        b: function () {
                          return t.matMul(a, !0, !1);
                        },
                      }
                    : n && !r
                    ? {
                        a: function () {
                          return o.matMul(t, !1, !0);
                        },
                        b: function () {
                          return a.matMul(t, !1, !1);
                        },
                      }
                    : {
                        a: function () {
                          return o.matMul(t, !0, !0);
                        },
                        b: function () {
                          return t.matMul(a, !0, !0);
                        },
                      }
                  : {
                      a: function () {
                        return t.matMul(o, !1, !0);
                      },
                      b: function () {
                        return a.matMul(t, !0, !1);
                      },
                    };
              },
              "BatchMatMul",
              y
            ).reshape(m);
          },
        }),
        oc = pn({
          dot_: function (t, e) {
            var n = $e(t, "t1", "dot"),
              r = $e(e, "t2", "dot");
            S(
              !(
                (1 !== n.rank && 2 !== n.rank) ||
                (1 !== r.rank && 2 !== r.rank)
              ),
              function () {
                return (
                  "Error in dot: inputs must all be rank 1 or 2, but got ranks " +
                  n.rank +
                  " and " +
                  r.rank +
                  "."
                );
              }
            );
            var i = 1 === n.rank ? n.size : n.shape[1],
              a = 1 === r.rank ? r.size : r.shape[0];
            return (
              S(i === a, function () {
                return (
                  "Error in dot: inner dimensions of inputs must match, but got " +
                  i +
                  " and " +
                  a +
                  "."
                );
              }),
              1 === n.rank && 1 === r.rank
                ? n.as2D(1, -1).matMul(r.as2D(-1, 1)).asScalar()
                : 1 === n.rank && 2 === r.rank
                ? n.as2D(1, -1).matMul(r.as2D(r.shape[0], r.shape[1])).as1D()
                : 2 === n.rank && 1 === r.rank
                ? n.matMul(r.as2D(-1, 1)).as1D()
                : n.matMul(r.as2D(r.shape[0], r.shape[1]))
            );
          },
        }),
        sc = pn({
          outerProduct_: function (t, e) {
            var n = $e(t, "v1", "outerProduct"),
              r = $e(e, "v2", "outerProduct");
            return (
              S(1 === n.rank && 1 === r.rank, function () {
                return (
                  "Error in outerProduct: inputs must be rank 1, but got ranks " +
                  n.rank +
                  " and " +
                  r.rank +
                  "."
                );
              }),
              n.as2D(-1, 1).matMul(r.as2D(1, -1))
            );
          },
        }),
        uc = pn({
          reverse_: function (t, e) {
            var n = $e(t, "x", "reverse");
            if (0 === n.rank) return n.clone();
            var r = P(e, n.shape);
            return Pt.runKernelFunc(
              function (t) {
                return t.reverse(n, r);
              },
              { $x: n },
              function (t) {
                return {
                  $x: function () {
                    return t.reverse(r);
                  },
                };
              }
            ).reshapeAs(n);
          },
        }),
        cc = pn({
          reverse1d_: function (t) {
            var e = $e(t, "x", "reverse");
            return (
              S(1 === e.rank, function () {
                return (
                  "Error in reverse1D: x must be rank 1 but got rank " +
                  e.rank +
                  "."
                );
              }),
              uc(e, 0)
            );
          },
        }),
        lc = pn({
          reverse2d_: function (t, e) {
            var n = $e(t, "x", "reverse");
            return (
              S(2 === n.rank, function () {
                return (
                  "Error in reverse2D: x must be rank 2 but got rank " +
                  n.rank +
                  "."
                );
              }),
              uc(n, e)
            );
          },
        }),
        pc = pn({
          reverse3d_: function (t, e) {
            var n = $e(t, "x", "reverse");
            return (
              S(3 === n.rank, function () {
                return (
                  "Error in reverse3D: x must be rank 3 but got rank " +
                  n.rank +
                  "."
                );
              }),
              uc(n, e)
            );
          },
        }),
        hc = pn({
          reverse4d_: function (t, e) {
            var n = $e(t, "x", "reverse");
            return (
              S(4 === n.rank, function () {
                return (
                  "Error in reverse4D: x must be rank 4 but got rank " +
                  n.rank +
                  "."
                );
              }),
              uc(n, e)
            );
          },
        });
      function fc(t, e, n, r, i, a) {
        var o = $e(t, "x", "maxPool"),
          s = o,
          u = !1;
        3 === o.rank &&
          ((u = !0), (s = o.as4D(1, o.shape[0], o.shape[1], o.shape[2]))),
          null == r && (r = [1, 1]),
          S(4 === s.rank, function () {
            return (
              "Error in maxPool: input must be rank 4 but got rank " +
              s.rank +
              "."
            );
          }),
          S(ii(n, r), function () {
            return (
              "Error in maxPool: Either strides or dilations must be 1. Got strides " +
              n +
              " and dilations '" +
              r +
              "'"
            );
          }),
          null != a &&
            S(T(i), function () {
              return (
                "Error in maxPool: pad must be an integer when using, dimRoundingMode " +
                a +
                " but got pad " +
                i +
                "."
              );
            });
        var c = Zr(s.shape, e, n, r, i, a);
        if (
          1 === c.filterWidth &&
          1 === c.filterHeight &&
          A(c.inShape, c.outShape)
        )
          return o.clone();
        var l = [s],
          p = Pt.runKernelFunc(
            function (t, e) {
              var n = t.maxPool(s, c);
              return e([s, n]), n;
            },
            { x: s },
            function (t, a) {
              var o = a[0],
                s = a[1];
              return {
                x: function () {
                  return (function (t, e, n, r, i, a, o, s) {
                    var u = $e(t, "dy", "maxPoolBackprop"),
                      c = $e(e, "input", "maxPoolBackprop"),
                      l = $e(n, "output", "maxPoolBackprop");
                    S(c.rank === u.rank, function () {
                      return (
                        "Rank of input (" +
                        c.rank +
                        ") does not match rank of dy (" +
                        u.rank +
                        ")"
                      );
                    }),
                      null == a && (a = [1, 1]),
                      S(ii(i, a), function () {
                        return (
                          "Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides " +
                          i +
                          " and dilations '" +
                          a +
                          "'"
                        );
                      }),
                      S(4 === u.rank, function () {
                        return (
                          "Error in maxPoolBackprop: dy must be rank 4 but got rank " +
                          u.rank +
                          "."
                        );
                      }),
                      S(4 === c.rank, function () {
                        return (
                          "Error in maxPoolBackprop: input must be rank 4 but got rank " +
                          c.rank +
                          "."
                        );
                      });
                    var p = Zr(c.shape, r, i, a, o, s);
                    return Pt.runKernelFunc(
                      function (t) {
                        return t.maxPoolBackprop(u, c, l, p);
                      },
                      { $dy: u, $input: c }
                    );
                  })(t, o, s, e, n, r, i);
                },
              };
            },
            "MaxPool",
            c,
            l
          );
        return u ? p.as3D(p.shape[1], p.shape[2], p.shape[3]) : p;
      }
      function dc(t, e, n, r, i, a) {
        var o = $e(t, "x", "avgPool", "float32");
        null == r && (r = [1, 1]),
          S(ii(n, r), function () {
            return (
              "Error in avgPool: Either strides or dilations must be 1. Got strides " +
              n +
              " and dilations '" +
              r +
              "'"
            );
          });
        var s = o,
          u = !1;
        3 === o.rank &&
          ((u = !0), (s = o.as4D(1, o.shape[0], o.shape[1], o.shape[2]))),
          S(4 === s.rank, function () {
            return (
              "Error in avgPool: x must be rank 4 but got rank " + s.rank + "."
            );
          }),
          null != a &&
            S(T(i), function () {
              return (
                "Error in avgPool: pad must be an integer when using, dimRoundingMode " +
                a +
                " but got pad " +
                i +
                "."
              );
            });
        var c = Zr(s.shape, e, n, r, i, a);
        if (
          1 === c.filterWidth &&
          1 === c.filterHeight &&
          A(c.inShape, c.outShape)
        )
          return o.clone();
        var l = Pt.runKernelFunc(
          function (t) {
            return t.avgPool(s, c);
          },
          { x: s },
          function (t) {
            return {
              x: function () {
                return (function (t, e, n, r, i, a) {
                  var o = $e(t, "dy", "avgPoolBackprop"),
                    s = $e(e, "input", "avgPoolBackprop");
                  S(s.rank === o.rank, function () {
                    return (
                      "Rank of input (" +
                      s.rank +
                      ") does not match rank of dy (" +
                      o.rank +
                      ")"
                    );
                  }),
                    null == i && (i = [1, 1]),
                    S(ii(r, i), function () {
                      return (
                        "Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides " +
                        r +
                        " and dilations '" +
                        i +
                        "'"
                      );
                    });
                  var u = s,
                    c = o,
                    l = !1;
                  3 === s.rank &&
                    ((l = !0),
                    (u = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])),
                    (c = o.as4D(1, o.shape[0], o.shape[1], o.shape[2]))),
                    S(4 === c.rank, function () {
                      return (
                        "Error in avgPoolBackprop: dy must be rank 4 but got rank " +
                        c.rank +
                        "."
                      );
                    }),
                    S(4 === u.rank, function () {
                      return (
                        "Error in avgPoolBackprop: input must be rank 4 but got rank " +
                        u.rank +
                        "."
                      );
                    });
                  var p = Zr(u.shape, n, r, i, a),
                    h = Pt.runKernelFunc(
                      function (t) {
                        return t.avgPoolBackprop(c, u, p);
                      },
                      { dy4D: c, input4D: u }
                    );
                  return l ? h.as3D(h.shape[1], h.shape[2], h.shape[3]) : h;
                })(t, s, e, n, r, i);
              },
            };
          },
          "AvgPool",
          c
        );
        return (
          (l = l.cast(o.dtype)),
          u ? l.as3D(l.shape[1], l.shape[2], l.shape[3]) : l
        );
      }
      var mc = pn({
          maxPool_: function (t, e, n, r, i) {
            return fc(t, e, n, 1, r, i);
          },
        }),
        vc = pn({
          avgPool_: function (t, e, n, r, i) {
            return dc(t, e, n, 1, r, i);
          },
        }),
        gc = pn({
          pool_: function (t, e, n, r, i, a) {
            null == i && (i = [1, 1]),
              null == a && (a = 1),
              0 === r && (r = "valid");
            var o = $e(t, "x", "maxPool"),
              s = o,
              u = !1;
            3 === o.rank &&
              ((u = !0), (s = o.as4D(1, o.shape[0], o.shape[1], o.shape[2]))),
              S(ii(a, i), function () {
                return (
                  "Error in pool: Either strides or dilations must be 1. Got strides " +
                  a +
                  " and dilations '" +
                  i +
                  "'"
                );
              });
            var c,
              l = Zr(s.shape, e, a, i, r),
              p = [l.dilationHeight, l.dilationWidth];
            c =
              "same" === r
                ? (function (t, e) {
                    var n = t
                        .map(function (t, n) {
                          return t + (t - 1) * (e[n] - 1);
                        })
                        .map(function (t) {
                          return t - 1;
                        }),
                      r = n.map(function (t) {
                        return Math.floor(t / 2);
                      }),
                      i = n.map(function (t, e) {
                        return t - r[e];
                      });
                    return n.map(function (t, e) {
                      return [r[e], i[e]];
                    });
                  })([l.filterHeight, l.filterWidth], p)
                : [
                    [0, 0],
                    [0, 0],
                  ];
            var h = 1 === p[0] && 1 === p[1],
              f = (function (t, e, n) {
                var r = n.map(function (t) {
                    return t[0];
                  }),
                  i = n.map(function (t) {
                    return t[1];
                  }),
                  a = t.concat(r, i),
                  o = e.map(function (t, e) {
                    return (t - (a[e] % t)) % t;
                  }),
                  s = i.map(function (t, e) {
                    return t + o[e];
                  });
                return [
                  e.map(function (t, e) {
                    return [r[e], s[e]];
                  }),
                  e.map(function (t, e) {
                    return [0, o[e]];
                  }),
                ];
              })([l.inHeight, l.inWidth], p, c),
              d = f[0],
              m = f[1],
              v = h ? r : "valid",
              g = h ? s : mr(s, p, d),
              y = ("avg" === n
                ? function () {
                    return dc(g, e, a, 1, v);
                  }
                : function () {
                    return fc(g, e, a, 1, v);
                  })(),
              b = h ? y : Xn(y, p, m);
            return u ? b.as3D(b.shape[1], b.shape[2], b.shape[3]) : b;
          },
        }),
        yc = pn({
          maxPool3d_: function (t, e, n, r, i, a, o) {
            void 0 === a && (a = "NDHWC");
            var s = $e(t, "x", "maxPool3d"),
              u = s,
              c = !1;
            4 === s.rank &&
              ((c = !0),
              (u = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3]))),
              null == o && (o = [1, 1, 1]),
              S(5 === u.rank, function () {
                return (
                  "Error in maxPool3d: x must be rank 5 but got rank " +
                  u.rank +
                  "."
                );
              }),
              S("NDHWC" === a, function () {
                return (
                  "Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of " +
                  a
                );
              }),
              S(ii(n, o), function () {
                return (
                  "Error in maxPool3d: Either strides or dilations must be 1. Got strides " +
                  n +
                  " and dilations '" +
                  o +
                  "'"
                );
              }),
              null != i &&
                S(T(r), function () {
                  return (
                    "Error in maxPool3d: pad must be an integer when using, dimRoundingMode " +
                    i +
                    " but got pad " +
                    r +
                    "."
                  );
                });
            var l = Xr(u.shape, e, n, o, r, i, a),
              p = Pt.runKernelFunc(
                function (t, e) {
                  var n = t.maxPool3d(u, l);
                  return e([u, n]), n;
                },
                { x: u },
                function (t, a) {
                  var s = a[0],
                    u = a[1];
                  return {
                    x: function () {
                      return (function (t, e, n, r, i, a, o, s) {
                        var u = $e(t, "dy", "maxPool3dBackprop"),
                          c = $e(e, "input", "maxPool3dBackprop"),
                          l = $e(n, "output", "maxPool3dBackprop"),
                          p = u,
                          h = c,
                          f = l,
                          d = !1;
                        4 === c.rank &&
                          ((d = !0),
                          (p = u.as5D(
                            1,
                            u.shape[0],
                            u.shape[1],
                            u.shape[2],
                            u.shape[3]
                          )),
                          (h = c.as5D(
                            1,
                            c.shape[0],
                            c.shape[1],
                            c.shape[2],
                            c.shape[3]
                          )),
                          (f = l.as5D(
                            1,
                            l.shape[0],
                            l.shape[1],
                            l.shape[2],
                            l.shape[3]
                          ))),
                          S(5 === p.rank, function () {
                            return (
                              "Error in maxPool3dBackprop: dy must be rank 5 but got rank " +
                              p.rank +
                              "."
                            );
                          }),
                          S(5 === h.rank, function () {
                            return (
                              "Error in maxPool3dBackprop: input must be rank 5 but got rank " +
                              h.rank +
                              "."
                            );
                          }),
                          S(5 === f.rank, function () {
                            return (
                              "Error in maxPool3dBackprop: output must be rank 5 but got rank " +
                              f.rank +
                              "."
                            );
                          }),
                          null == a && (a = [1, 1, 1]),
                          S(ii(i, a), function () {
                            return (
                              "Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides " +
                              i +
                              " and dilations '" +
                              a +
                              "'"
                            );
                          }),
                          null != s &&
                            S(T(o), function () {
                              return (
                                "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " +
                                s +
                                " but got pad " +
                                o +
                                "."
                              );
                            });
                        var m = Xr(h.shape, r, i, a, o, s),
                          v = Pt.runKernelFunc(
                            function (t) {
                              return t.maxPool3dBackprop(p, h, f, m);
                            },
                            { dy5D: p, input5D: h }
                          );
                        return d
                          ? v.as4D(
                              v.shape[1],
                              v.shape[2],
                              v.shape[3],
                              v.shape[4]
                            )
                          : v;
                      })(t, s, u, e, n, o, r, i);
                    },
                  };
                }
              );
            return c
              ? p.as4D(p.shape[1], p.shape[2], p.shape[3], p.shape[4])
              : p;
          },
        }),
        bc = pn({
          avgPool3d_: function (t, e, n, r, i, a, o) {
            void 0 === a && (a = "NDHWC");
            var s = $e(t, "x", "avgPool3d", "float32"),
              u = s,
              c = !1;
            4 === s.rank &&
              ((c = !0),
              (u = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3]))),
              null == o && (o = [1, 1, 1]),
              S(5 === u.rank, function () {
                return (
                  "Error in avgPool3d: x must be rank 5 but got rank " +
                  u.rank +
                  "."
                );
              }),
              S("NDHWC" === a, function () {
                return (
                  "Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of " +
                  a
                );
              }),
              S(ii(n, o), function () {
                return (
                  "Error in avgPool3d: Either strides or dilations must be 1. Got strides " +
                  n +
                  " and dilations '" +
                  o +
                  "'"
                );
              }),
              null != i &&
                S(T(r), function () {
                  return (
                    "Error in avgPool3d: pad must be an integer when using, dimRoundingMode " +
                    i +
                    " but got pad " +
                    r +
                    "."
                  );
                });
            var l = Xr(u.shape, e, n, o, r, i, a),
              p = Pt.runKernelFunc(
                function (t) {
                  return t.avgPool3d(u, l);
                },
                { x: u },
                function (t) {
                  return {
                    x: function () {
                      return (function (t, e, n, r, i, a, o) {
                        var s = $e(t, "dy", "avgPool3dBackprop"),
                          u = $e(e, "input", "avgPool3dBackprop"),
                          c = s,
                          l = u,
                          p = !1;
                        4 === u.rank &&
                          ((p = !0),
                          (c = s.as5D(
                            1,
                            s.shape[0],
                            s.shape[1],
                            s.shape[2],
                            s.shape[3]
                          )),
                          (l = u.as5D(
                            1,
                            u.shape[0],
                            u.shape[1],
                            u.shape[2],
                            u.shape[3]
                          ))),
                          S(5 === c.rank, function () {
                            return (
                              "Error in avgPool3dBackprop: dy must be rank 5 but got rank " +
                              c.rank +
                              "."
                            );
                          }),
                          S(5 === l.rank, function () {
                            return (
                              "Error in avgPool3dBackprop: input must be rank 5 but got rank " +
                              l.rank +
                              "."
                            );
                          }),
                          null == i && (i = [1, 1, 1]),
                          S(ii(r, i), function () {
                            return (
                              "Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides " +
                              r +
                              " and dilations '" +
                              i +
                              "'"
                            );
                          }),
                          null != o &&
                            S(T(a), function () {
                              return (
                                "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " +
                                o +
                                " but got pad " +
                                a +
                                "."
                              );
                            });
                        var h = Xr(l.shape, n, r, i, a, o),
                          f = Pt.runKernelFunc(
                            function (t) {
                              return t.avgPool3dBackprop(c, l, h);
                            },
                            { dy5D: c, input5D: l }
                          );
                        return p
                          ? f.as4D(
                              f.shape[1],
                              f.shape[2],
                              f.shape[3],
                              f.shape[4]
                            )
                          : f;
                      })(t, u, e, n, o, r, i);
                    },
                  };
                }
              );
            return (
              (p = p.cast(u.dtype)),
              c ? p.as4D(p.shape[1], p.shape[2], p.shape[3], p.shape[4]) : p
            );
          },
        }),
        wc = pn({
          slice_: function (t, e, n) {
            var r,
              i,
              a = $e(t, "x", "slice");
            if (0 === a.rank) throw new Error("Slicing scalar is not possible");
            (r =
              "number" == typeof e
                ? [e].concat(new Array(a.rank - 1).fill(0))
                : e.length < a.rank
                ? e.concat(new Array(a.rank - e.length).fill(0))
                : e.slice()).forEach(function (t) {
              S(-1 !== t, function () {
                return "slice() does not support negative begin indexing.";
              });
            }),
              (i = (i =
                null == n
                  ? new Array(a.rank).fill(-1)
                  : "number" == typeof n
                  ? [n].concat(new Array(a.rank - 1).fill(-1))
                  : n.length < a.rank
                  ? n.concat(new Array(a.rank - n.length).fill(-1))
                  : n).map(function (t, e) {
                return t >= 0
                  ? t
                  : (S(-1 === t, function () {
                      return (
                        "Negative size values should be exactly -1 but got " +
                        t +
                        " for the slice() size at index " +
                        e +
                        "."
                      );
                    }),
                    a.shape[e] - r[e]);
              })),
              Rr(a, r, i);
            var o = a.shape,
              s = { begin: r, size: i };
            return Pt.runKernelFunc(
              function (t) {
                return t.slice(a, r, i);
              },
              { x: a },
              function (t) {
                for (var e = [], n = 0; n < t.rank; n++)
                  e.push([r[n], o[n] - r[n] - i[n]]);
                return {
                  x: function () {
                    return t.pad(e);
                  },
                };
              },
              "Slice",
              s
            );
          },
        }),
        xc = pn({
          slice1d_: function (t, e, n) {
            var r = $e(t, "x", "slice1d");
            return (
              S(1 === r.rank, function () {
                return (
                  "slice1d expects a rank-1 tensor, but got a rank-" +
                  r.rank +
                  " tensor"
                );
              }),
              wc(r, [e], [n])
            );
          },
        }),
        Cc = pn({
          slice2d_: function (t, e, n) {
            var r = $e(t, "x", "slice2d");
            return (
              S(2 === r.rank, function () {
                return (
                  "slice2d expects a rank-2 tensor, but got a rank-" +
                  r.rank +
                  " tensor"
                );
              }),
              wc(r, e, n)
            );
          },
        }),
        Oc = pn({
          slice3d_: function (t, e, n) {
            var r = $e(t, "x", "slice3d");
            return (
              S(3 === r.rank, function () {
                return (
                  "slice3d expects a rank-3 tensor, but got a rank-" +
                  r.rank +
                  " tensor"
                );
              }),
              wc(r, e, n)
            );
          },
        }),
        Ec = pn({
          slice4d_: function (t, e, n) {
            var r = $e(t, "x", "slice4d");
            return (
              S(4 === r.rank, function () {
                return (
                  "slice4d expects a rank-4 tensor, but got a rank-" +
                  r.rank +
                  " tensor"
                );
              }),
              wc(r, e, n)
            );
          },
        });
      function Sc(t, e, n, r, i) {
        return (
          e.rank < n.rank && (e = e.reshape(rn(e.shape, r))),
          t.rank < n.rank && (t = t.reshape(rn(t.shape, r))),
          {
            x: function () {
              var r = t.mul(n.equal(e).cast(t.dtype));
              return null == i ? r : r.transpose(i);
            },
          }
        );
      }
      var Nc = pn({
          all_: function (t, e, n) {
            void 0 === e && (e = null), void 0 === n && (n = !1);
            var r = $e(t, "x", "all", "bool"),
              i = P(e, r.shape),
              a = i,
              o = on(a, r.rank);
            null != o && ((r = r.transpose(o)), (a = un(a.length, r.rank)));
            var s = Pt.runKernelFunc(
              function (t) {
                return t.all(r, a);
              },
              { $x: r }
            );
            if (n) {
              var u = rn(s.shape, i);
              return s.reshape(u);
            }
            return s;
          },
        }),
        Ic = pn({
          any_: function (t, e, n) {
            void 0 === e && (e = null), void 0 === n && (n = !1);
            var r = $e(t, "x", "any", "bool"),
              i = P(e, r.shape),
              a = i,
              o = on(a, r.rank);
            null != o && ((r = r.transpose(o)), (a = un(a.length, r.rank)));
            var s = Pt.runKernelFunc(
              function (t) {
                return t.any(r, a);
              },
              { $x: r }
            );
            if (n) {
              var u = rn(s.shape, i);
              return s.reshape(u);
            }
            return s;
          },
        }),
        kc = pn({
          argMax_: function (t, e) {
            void 0 === e && (e = 0);
            var n = $e(t, "x", "argMax");
            null == e && (e = 0);
            var r = P(e, n.shape),
              i = on(r, n.rank);
            null != i && ((n = n.transpose(i)), (r = un(r.length, n.rank)));
            var a = { axis: r[0] },
              o = [n];
            return Pt.runKernelFunc(
              function (t, e) {
                var i = t.argMax(n, r[0]);
                return e([n]), i;
              },
              { x: n },
              function (t, e) {
                var n = e[0];
                return {
                  x: function () {
                    return _n(n);
                  },
                };
              },
              "ArgMax",
              a,
              o
            );
          },
        }),
        _c = pn({
          argMin_: function (t, e) {
            void 0 === e && (e = 0);
            var n = $e(t, "x", "argMin");
            null == e && (e = 0);
            var r = P(e, n.shape),
              i = on(r, n.rank);
            return (
              null != i && ((n = n.transpose(i)), (r = un(r.length, n.rank))),
              Pt.runKernelFunc(
                function (t, e) {
                  var i = t.argMin(n, r[0]);
                  return e([n]), i;
                },
                { $x: n },
                function (t, e) {
                  var n = e[0];
                  return {
                    $x: function () {
                      return _n(n);
                    },
                  };
                }
              )
            );
          },
        }),
        Ac = pn({
          logSumExp_: function (t, e, n) {
            void 0 === e && (e = null), void 0 === n && (n = !1);
            var r = $e(t, "x", "logSumExp"),
              i = P(e, r.shape),
              a = r.max(i, !0),
              o = r.sub(a).exp().sum(i).log(),
              s = a.reshape(o.shape).add(o);
            if (n) {
              var u = rn(s.shape, i);
              return s.reshape(u);
            }
            return s;
          },
        }),
        Tc = pn({
          max_: function (t, e, n) {
            void 0 === e && (e = null), void 0 === n && (n = !1);
            var r = $e(t, "x", "max"),
              i = r,
              a = P(e, r.shape),
              o = a,
              s = on(o, r.rank);
            null != s && ((r = r.transpose(s)), (o = un(o.length, r.rank)));
            var u = [r],
              c = Pt.runKernelFunc(
                function (t, e) {
                  var n = t.max(r, o);
                  return e([i, n]), n;
                },
                { x: r },
                function (t, e) {
                  return Sc(t, e[1], e[0], a, s);
                },
                "Max",
                { axes: o },
                u,
                [!0]
              );
            if (n) {
              var l = rn(c.shape, a);
              c = c.reshape(l);
            }
            return c;
          },
        }),
        Rc = pn({
          mean_: function (t, e, n) {
            void 0 === e && (e = null), void 0 === n && (n = !1);
            var r = $e(t, "x", "mean"),
              i = P(e, r.shape),
              a = _(nn(r.shape, i)[1]);
            return Lr(function (t) {
              var r = gn(a);
              return {
                value: (r.dtype === t.dtype ? t : t.cast(r.dtype))
                  .div(r)
                  .sum(e, n),
                gradFunc: function (e) {
                  var n = t.shape.slice();
                  return (
                    i.forEach(function (t) {
                      n[t] = 1;
                    }),
                    e.reshape(n).mul(On(t.shape, "float32")).div(a)
                  );
                },
              };
            })(r);
          },
        }),
        Dc = pn({
          min_: function (t, e, n) {
            void 0 === e && (e = null), void 0 === n && (n = !1);
            var r = $e(t, "x", "min"),
              i = r,
              a = P(e, r.shape),
              o = a,
              s = on(o, r.rank);
            null != s && ((r = r.transpose(s)), (o = un(o.length, r.rank)));
            var u = [r],
              c = Pt.runKernelFunc(
                function (t, e) {
                  var n = t.min(r, o);
                  return e([i, n]), n;
                },
                { x: r },
                function (t, e) {
                  return Sc(t, e[1], e[0], a, s);
                },
                "Min",
                { axes: o },
                u,
                [!0]
              );
            if (n) {
              var l = rn(c.shape, a);
              c = c.reshape(l);
            }
            return c;
          },
        }),
        Fc = pn({
          moments_: function (t, e, n) {
            void 0 === e && (e = null), void 0 === n && (n = !1);
            var r = P(e, (t = $e(t, "x", "moments")).shape),
              i = t.mean(r, n),
              a = i.shape;
            n || (a = rn(i.shape, r));
            var o = t.toFloat().sub(i.reshape(a)).square();
            return { mean: i, variance: o.mean(r, n) };
          },
        }),
        Mc = pn({
          sum_: function (t, e, n) {
            void 0 === e && (e = null), void 0 === n && (n = !1);
            var r = $e(t, "x", "sum");
            "bool" === r.dtype && (r = r.toInt());
            var i = P(e, r.shape);
            return Lr(function (t) {
              var e = on(i, t.rank),
                r = i,
                a = t;
              null != e && ((a = t.transpose(e)), (r = un(r.length, t.rank)));
              var o = function (e) {
                  var n = t.shape.slice();
                  return (
                    i.forEach(function (t) {
                      n[t] = 1;
                    }),
                    e.reshape(n).mul(On(t.shape, "float32"))
                  );
                },
                s = { axes: r },
                u = Pt.runKernelFunc(
                  function (t) {
                    return t.sum(a, r);
                  },
                  { x: a },
                  function (t) {
                    return {
                      x: function () {
                        return o(t);
                      },
                    };
                  },
                  "Sum",
                  s
                );
              if (n) {
                var c = rn(u.shape, i);
                u = u.reshape(c);
              }
              return { value: u, gradFunc: o };
            })(r);
          },
        }),
        jc = pn({
          prod_: function (t, e, n) {
            void 0 === e && (e = null), void 0 === n && (n = !1);
            var r = $e(t, "x", "prod");
            "bool" === r.dtype && (r = r.toInt());
            var i = P(e, r.shape),
              a = on(i, r.rank),
              o = i,
              s = r;
            null != a && ((s = r.transpose(a)), (o = un(o.length, r.rank)));
            var u = Pt.runKernelFunc(
              function (t) {
                return t.prod(s, o);
              },
              { permutedX: s }
            );
            if (n) {
              var c = rn(u.shape, i);
              u = u.reshape(c);
            }
            return u;
          },
        }),
        Pc = pn({
          elu_: function (t) {
            var e = $e(t, "x", "elu");
            return Pt.runKernelFunc(
              function (t, n) {
                var r = t.elu(e);
                return n([r]), r;
              },
              { $x: e },
              function (t, e) {
                var n = e[0];
                return {
                  $x: function () {
                    return Pt.runKernelFunc(
                      function (e) {
                        return e.eluDer(t, n);
                      },
                      { dy: t, y: n }
                    );
                  },
                };
              }
            );
          },
        }),
        zc = pn({
          leakyRelu_: function (t, e) {
            void 0 === e && (e = 0.2);
            var n = $e(t, "x", "leakyRelu");
            return vu(gn(e).mul(n), n);
          },
        }),
        Lc = pn({
          prelu_: function (t, e) {
            var n = $e(t, "x", "prelu"),
              r = $e(e, "alpha", "prelu");
            return Pt.runKernelFunc(
              function (t, e) {
                var i = t.prelu(n, r);
                return e([n, r]), i;
              },
              { x: n, alpha: r },
              function (t, e) {
                var n = e[0],
                  r = e[1],
                  i = n.greater(0);
                return {
                  x: function () {
                    return ou(i, t, t.mul(r));
                  },
                  alpha: function () {
                    var e = ou(i, _n(t), t.mul(n)),
                      a = qr(r.shape, t.shape);
                    return a.length > 0 && (e = e.sum(a)), e.reshape(r.shape);
                  },
                };
              },
              "Prelu"
            );
          },
        }),
        Bc = pn({
          relu_: function (t) {
            var e = $e(t, "x", "relu");
            return "bool" === e.dtype
              ? e.toInt()
              : Pt.runKernelFunc(
                  function (t, n) {
                    var r = t.relu(e);
                    return n([e]), r;
                  },
                  { x: e },
                  function (t, e) {
                    var n = e[0];
                    return {
                      x: function () {
                        return t.mulStrict(n.step().toFloat());
                      },
                    };
                  },
                  "Relu"
                );
          },
        }),
        Wc = pn({
          relu6_: function (t) {
            var e = $e(t, "x", "relu6");
            return "bool" === e.dtype
              ? e.toInt()
              : Pt.runKernelFunc(
                  function (t, n) {
                    var r = t.relu6(e);
                    return n([e]), r;
                  },
                  { x: e },
                  function (t, e) {
                    var n = e[0],
                      r = n.lessEqual(6).mul(n.step());
                    return {
                      x: function () {
                        return t.mulStrict(r.toFloat());
                      },
                    };
                  },
                  "Relu6"
                );
          },
        }),
        Uc = pn({
          selu_: function (t) {
            var e = $e(t, "x", "selu");
            return Pt.runKernelFunc(
              function (t, n) {
                var r = t.selu(e);
                return n([e]), r;
              },
              { $x: e },
              function (t, e) {
                var n = e[0];
                return {
                  $x: function () {
                    var e = n.greater(gn(0)),
                      r = gn(Po),
                      i = gn(zo),
                      a = t.mul(i),
                      o = t.mul(r).mul(n.toFloat().exp());
                    return ou(e, a, o);
                  },
                };
              }
            );
          },
        }),
        Vc = pn({
          transpose_: function (t, e) {
            var n = $e(t, "x", "transpose");
            if (
              (null == e &&
                (e = n.shape
                  .map(function (t, e) {
                    return e;
                  })
                  .reverse()),
              S(n.rank === e.length, function () {
                return (
                  "Error in transpose: rank of input " +
                  n.rank +
                  " must match length of perm " +
                  e +
                  "."
                );
              }),
              e.forEach(function (t) {
                S(t >= 0 && t < n.rank, function () {
                  return (
                    "All entries in 'perm' must be between 0 and " +
                    (n.rank - 1) +
                    " but got " +
                    e
                  );
                });
              }),
              n.rank <= 1)
            )
              return n.clone();
            var r = { perm: e };
            return Pt.runKernelFunc(
              function (t) {
                return t.transpose(n, e);
              },
              { x: n },
              function (t) {
                var n = sn(e);
                return {
                  x: function () {
                    return t.transpose(n);
                  },
                };
              },
              "Transpose",
              r
            );
          },
        }),
        Gc = pn({
          localResponseNormalization_: function (t, e, n, r, i) {
            void 0 === e && (e = 5),
              void 0 === n && (n = 1),
              void 0 === r && (r = 1),
              void 0 === i && (i = 0.5);
            var a = $e(t, "x", "localResponseNormalization");
            S(4 === a.rank || 3 === a.rank, function () {
              return (
                "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank " +
                a.rank +
                "."
              );
            }),
              S(T(e), function () {
                return (
                  "Error in localResponseNormalization: depthRadius must be an integer but got depthRadius " +
                  e +
                  "."
                );
              });
            var o = a,
              s = !1;
            3 === a.rank &&
              ((s = !0), (o = a.as4D(1, a.shape[0], a.shape[1], a.shape[2])));
            var u = Pt.runKernelFunc(
              function (t, a) {
                var s = t.localResponseNormalization4D(o, e, n, r, i);
                return a([o, s]), s;
              },
              { x4D: o },
              function (t, a) {
                var o = a[0],
                  s = a[1];
                return {
                  x4D: function () {
                    return Pt.runKernelFunc(function (a) {
                      return a.LRNGrad(t, o, s, e, n, r, i);
                    }, {});
                  },
                };
              }
            );
            return s ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;
          },
        }),
        Hc = pn({
          norm_: function (t, e, n, r) {
            void 0 === e && (e = "euclidean"),
              void 0 === n && (n = null),
              void 0 === r && (r = !1);
            var i = (function t(e, n, r) {
                if ((void 0 === r && (r = null), 0 === e.rank)) return e.abs();
                if (1 !== e.rank && null === r) return t(e.reshape([-1]), n, r);
                if (
                  1 === e.rank ||
                  "number" == typeof r ||
                  (Array.isArray(r) && 1 === r.length)
                ) {
                  if (1 === n) return e.abs().sum(r);
                  if (n === 1 / 0) return e.abs().max(r);
                  if (n === -1 / 0) return e.abs().min(r);
                  if ("euclidean" === n || 2 === n)
                    return e.abs().pow(gn(2, "int32")).sum(r).sqrt();
                  throw new Error("Error in norm: invalid ord value: " + n);
                }
                if (Array.isArray(r) && 2 === r.length) {
                  if (1 === n)
                    return e
                      .abs()
                      .sum(r[0])
                      .max(r[1] - 1);
                  if (n === 1 / 0) return e.abs().sum(r[1]).max(r[0]);
                  if (n === -1 / 0) return e.abs().sum(r[1]).min(r[0]);
                  if ("fro" === n || "euclidean" === n)
                    return e.square().sum(r).sqrt();
                  throw new Error("Error in norm: invalid ord value: " + n);
                }
                throw new Error("Error in norm: invalid axis: " + r);
              })((t = $e(t, "x", "norm")), e, n),
              a = i.shape;
            if (r) {
              var o = P(n, t.shape);
              a = rn(i.shape, o);
            }
            return i.reshape(a);
          },
        }),
        qc = pn({
          basicLSTMCell_: function (t, e, n, r, i, a) {
            var o = $e(t, "forgetBias", "basicLSTMCell"),
              s = $e(e, "lstmKernel", "basicLSTMCell"),
              u = $e(n, "lstmBias", "basicLSTMCell"),
              c = $e(r, "data", "basicLSTMCell"),
              l = $e(i, "c", "basicLSTMCell"),
              p = $e(a, "h", "basicLSTMCell"),
              h = c.concat(p, 1).matMul(s).add(u),
              f = h.shape[0],
              d = h.shape[1] / 4,
              m = [f, d],
              v = h.slice([0, 0], m),
              g = h.slice([0, d], m),
              y = h.slice([0, 2 * d], m),
              b = h.slice([0, 3 * d], m),
              w = v
                .sigmoid()
                .mulStrict(g.tanh())
                .addStrict(l.mulStrict(o.add(y).sigmoid())),
              x = w.tanh().mulStrict(b.sigmoid());
            return [w, x];
          },
        }),
        Kc = pn({
          multiRNNCell_: function (t, e, n, r) {
            for (
              var i = $e(e, "data", "multiRNNCell"),
                a = Qe(n, "c", "multiRNNCell"),
                o = Qe(r, "h", "multiRNNCell"),
                s = i,
                u = [],
                c = 0;
              c < t.length;
              c++
            ) {
              var l = t[c](s, a[c], o[c]);
              u.push(l[0]), u.push(l[1]), (s = l[1]);
            }
            var p = [],
              h = [];
            for (c = 0; c < u.length; c += 2) p.push(u[c]), h.push(u[c + 1]);
            return [p, h];
          },
        }),
        Zc = pn({
          movingAverage_: function (t, e, n, r, i) {
            void 0 === i && (i = !0);
            var a = $e(t, "v", "movingAverage"),
              o = $e(e, "x", "movingAverage"),
              s = $e(n, "decay", "movingAverage");
            Tt(a, o),
              S(A(a.shape, o.shape), function () {
                return "Shape mismatch in v and x";
              });
            var u = gn(1),
              c = u.sub(s),
              l = o.sub(a).mul(c);
            if (i) {
              S(null != r, function () {
                return "When using zeroDebias: true, step is required.";
              });
              var p = $e(r, "step", "movingAverage");
              l = l.div(u.sub(Eu(s, p)));
            }
            return a.add(l);
          },
        }),
        Xc = pn({
          stridedSlice_: function (t, e, n, r, i, a, o, s, u) {
            if (
              (void 0 === i && (i = 0),
              void 0 === a && (a = 0),
              void 0 === o && (o = 0),
              void 0 === s && (s = 0),
              void 0 === u && (u = 0),
              null == r && (r = new Array(e.length)),
              0 !== o)
            )
              throw new Error("ellipsis mask is not yet supported");
            var c = $e(t, "x", "stridedSlice"),
              l = Dr(s),
              p = c.shape.slice();
            l.forEach(function (t) {
              (e[t] = 0), (n[t] = 1), p.splice(t, 0, 1);
            }),
              (c = c.reshape(p));
            for (var h = 0; h < c.rank; h++)
              (e[h] = Mr(i, e, r, c.shape, h)),
                (n[h] = jr(a, n, r, c.shape, h)),
                (r[h] = r[h] || 1);
            var f = Dr(u);
            f.forEach(function (t) {
              (n[t] = e[t] + 1), (r[t] = 1);
            });
            var d = Fr(e, n, r),
              m = d.filter(function (t, e) {
                return -1 === f.indexOf(e);
              });
            return r.every(function (t) {
              return 1 === t;
            })
              ? wc(c, e, d).reshape(m)
              : Pt.runKernelFunc(
                  function (t) {
                    return t.stridedSlice(c, e, n, r);
                  },
                  { $x: c }
                ).reshape(m);
          },
        }),
        Yc = pn({
          topk_: function (t, e, n) {
            void 0 === e && (e = 1), void 0 === n && (n = !0);
            var r = $e(t, "x", "topk");
            if (0 === r.rank)
              throw new Error(
                "topk() expects the input to be of rank 1 or higher"
              );
            var i = r.shape[r.shape.length - 1];
            if (e > i)
              throw new Error(
                "'k' passed to topk() must be <= the last dimension (" +
                  i +
                  ") but got " +
                  e
              );
            var a = Pt.runKernelFunc(
              function (t) {
                return t.topk(r, e, n);
              },
              { $x: r }
            );
            return { values: a[0], indices: a[1] };
          },
        }),
        Jc = pn({
          scatterND_: function (t, e, n) {
            var r = $e(t, "indices", "scatterND", "int32"),
              i = $e(e, "updates", "scatterND");
            return (
              Ar(i, r, n),
              Pt.runKernelFunc(
                function (t) {
                  return t.scatterND(r, i, n);
                },
                { indices: r, updates: i },
                null,
                "ScatterNd",
                { shape: n }
              )
            );
          },
        }),
        $c = pn({
          fft_: function (t) {
            S("complex64" === t.dtype, function () {
              return (
                "The dtype for tf.spectral.fft() must be complex64 but got " +
                t.dtype +
                "."
              );
            });
            var e = t.shape[t.shape.length - 1],
              n = t.size / e,
              r = t.as2D(n, e);
            return Pt.runKernelFunc(
              function (t) {
                return t.fft(r);
              },
              { input: t }
            ).reshape(t.shape);
          },
        }),
        Qc = pn({
          ifft_: function (t) {
            S("complex64" === t.dtype, function () {
              return (
                "The dtype for tf.spectral.ifft() must be complex64 but got " +
                t.dtype +
                "."
              );
            });
            var e = t.shape[t.shape.length - 1],
              n = t.size / e,
              r = t.as2D(n, e);
            return Pt.runKernelFunc(
              function (t) {
                return t.ifft(r);
              },
              { input: t }
            ).reshape(t.shape);
          },
        }),
        tl = pn({
          rfft_: function (t, e) {
            S("float32" === t.dtype, function () {
              return (
                "The dtype for rfft() must be real value but got " + t.dtype
              );
            });
            var n,
              r = t.shape[t.shape.length - 1],
              i = t.size / r;
            if (null != e && e < r) {
              var a = t.shape.map(function (t) {
                  return 0;
                }),
                o = t.shape.map(function (t) {
                  return t;
                });
              (o[t.shape.length - 1] = e), (n = t.slice(a, o)), (r = e);
            } else if (null != e && e > r) {
              var s = t.shape.map(function (t) {
                return t;
              });
              (s[t.shape.length - 1] = e - r),
                (n = t.concat(En(s), t.shape.length - 1)),
                (r = e);
            } else n = t;
            var u = n.zerosLike(),
              c = hn(n, u).as2D(i, r),
              l = $c(c),
              p = Math.floor(r / 2) + 1,
              h = fn(l),
              f = dn(l),
              d = h.split([p, r - p], h.shape.length - 1),
              m = f.split([p, r - p], f.shape.length - 1),
              v = n.shape.slice();
            return (v[n.shape.length - 1] = p), hn(d[0], m[0]).reshape(v);
          },
        }),
        el = pn({
          irfft_: function (t) {
            var e = t.shape[t.shape.length - 1],
              n = t.size / e;
            if (e <= 2) {
              var r = t.as2D(n, e),
                i = Qc(r);
              return fn(i);
            }
            var a = [n, 2 * (e - 1)],
              o = fn(t).as2D(n, e),
              s = dn(t).as2D(n, e),
              u = o.slice([0, 1], [n, e - 2]).reverse(1),
              c = s
                .slice([0, 1], [n, e - 2])
                .reverse(1)
                .mul(gn(-1)),
              l = o.concat(u, 1),
              p = s.concat(c, 1);
            return (r = hn(l, p).as2D(a[0], a[1])), (i = Qc(r)), fn(i);
          },
        }),
        nl = Object.freeze({ fft: $c, ifft: Qc, rfft: tl, irfft: el }),
        rl = pn({
          sparseToDense_: function (t, e, n, r) {
            void 0 === r && (r = 0);
            var i = $e(t, "sparseIndices", "sparseToDense", "int32"),
              a = $e(e, "sparseValues", "sparseToDense"),
              o = $e(r, "defaultValue", "sparseToDense", a.dtype);
            return (
              (function (t, e, n, r) {
                if ("int32" !== t.dtype)
                  throw new Error(
                    "tf.sparseToDense() expects the indices to be int32 type, but the dtype was " +
                      t.dtype +
                      "."
                  );
                if (t.rank > 2)
                  throw new Error(
                    "sparseIndices should be a scalar, vector, or matrix, but got shape " +
                      t.shape +
                      "."
                  );
                var i = t.rank > 0 ? t.shape[0] : 1,
                  a = t.rank > 1 ? t.shape[1] : 1;
                if (n.length !== a)
                  throw new Error(
                    "outputShape has incorrect number of elements:, " +
                      n.length +
                      ", should be: " +
                      a +
                      "."
                  );
                var o = e.size;
                if (0 !== e.rank && (1 !== e.rank || o !== i))
                  throw new Error(
                    "sparseValues has incorrect shape " +
                      e.shape +
                      ", should be [] or [" +
                      i +
                      "]"
                  );
                if (e.dtype !== r.dtype)
                  throw new Error(
                    "sparseValues.dtype must match defaultValues.dtype"
                  );
              })(i, a, n, o),
              Pt.runKernelFunc(
                function (t) {
                  return t.sparseToDense(i, a, n, o);
                },
                { $sparseIndices: i, $sparseValues: a, $defaultValue: o }
              )
            );
          },
        }),
        il = pn({
          gatherND_: function (t, e) {
            var n = $e(e, "indices", "gatherND", "int32"),
              r = $e(t, "x", "gatherND");
            return Pt.runKernelFunc(
              function (t) {
                return t.gatherND(r, n);
              },
              { x: r, indices: n },
              null,
              "GatherNd"
            );
          },
        }),
        al = pn({
          diag_: function (t) {
            var e = $e(t, "x", "diag").flatten(),
              n = t.shape.concat(t.shape);
            return Pt.runKernelFunc(
              function (t) {
                return t.diag(e);
              },
              { $x: e }
            ).reshape(n);
          },
        }),
        ol = pn({
          dropout_: function (t, e, n, r) {
            var i = $e(t, "x", "dropout");
            if (
              (S("float32" === i.dtype, function () {
                return (
                  "x has to be a floating point tensor since it's going to be scaled, but got a " +
                  i.dtype +
                  " tensor instead."
                );
              }),
              S(e >= 0 && e < 1, function () {
                return (
                  "rate must be a float in the range [0, 1), but got " + e + "."
                );
              }),
              0 === e)
            )
              return t instanceof wt ? i.clone() : i;
            var a = (function (t, e) {
                if (null == e) return t.shape.slice();
                if (A(t.shape, e)) return e;
                if (t.shape.length === e.length) {
                  for (var n = [], r = 0; r < t.shape.length; r++)
                    null == e[r] && null != t.shape[r]
                      ? n.push(t.shape[r])
                      : n.push(e[r]);
                  return n;
                }
                return e;
              })(i, n),
              o = 1 - e,
              s = fr(a, 0, 1, "float32", r).add(o).floor().div(o);
            return i.mul(s);
          },
        });
      function sl(t, e, n) {
        for (var r = 1 - (t % 2), i = new Float32Array(t), a = 0; a < t; ++a) {
          var o = (2 * Math.PI * a) / (t + r - 1);
          i[a] = e - n * Math.cos(o);
        }
        return yn(i, "float32");
      }
      var ul,
        cl = pn({
          hannWindow_: function (t) {
            return sl(t, 0.5, 0.5);
          },
        }),
        ll = pn({
          hammingWindow_: function (t) {
            return sl(t, 0.54, 0.46);
          },
        }),
        pl = pn({
          frame_: function (t, e, n, r, i) {
            void 0 === r && (r = !1), void 0 === i && (i = 0);
            for (var a = 0, o = []; a + e <= t.size; )
              o.push(wc(t, a, e)), (a += n);
            if (r)
              for (; a < t.size; ) {
                var s = a + e - t.size,
                  u = An([wc(t, a, e - s), Sn([s], i)]);
                o.push(u), (a += n);
              }
            return 0 === o.length ? bn([], [0, e]) : An(o).as2D(o.length, e);
          },
        }),
        hl = pn({
          stft_: function (t, e, n, r, i) {
            var a;
            void 0 === i && (i = cl),
              null == r &&
                ((a = e),
                (r = Math.floor(
                  Math.pow(2, Math.ceil(Math.log(a) / Math.log(2)))
                )));
            for (
              var o = pl(t, e, n), s = Cu(o, i(e)), u = [], c = 0;
              c < o.shape[0];
              c++
            )
              u.push(tl(s.slice([c, 0], [1, e]), r));
            return An(u);
          },
        }),
        fl = Object.freeze({
          hannWindow: cl,
          hammingWindow: ll,
          frame: pl,
          stft: hl,
        });
      !(function (t) {
        (t[(t.NONE = 0)] = "NONE"),
          (t[(t.MEAN = 1)] = "MEAN"),
          (t[(t.SUM = 2)] = "SUM"),
          (t[(t.SUM_BY_NONZERO_WEIGHTS = 3)] = "SUM_BY_NONZERO_WEIGHTS");
      })(ul || (ul = {}));
      var dl = pn({
          absoluteDifference_: function (t, e, n, r) {
            void 0 === r && (r = ul.SUM_BY_NONZERO_WEIGHTS);
            var i = $e(t, "labels", "absoluteDifference"),
              a = $e(e, "predictions", "absoluteDifference"),
              o = null;
            null != n && (o = $e(n, "weights", "absoluteDifference")),
              N(i.shape, a.shape, "Error in absoluteDifference: ");
            var s = i.sub(a).abs();
            return ml(s, o, r);
          },
        }),
        ml = pn({
          computeWeightedLoss_: function (t, e, n) {
            void 0 === n && (n = ul.SUM_BY_NONZERO_WEIGHTS);
            var r = $e(t, "losses", "computeWeightedLoss"),
              i = null;
            null != e && (i = $e(e, "weights", "computeWeightedLoss"));
            var a = null == i ? r : r.mul(i);
            if (n === ul.NONE) return a;
            if (n === ul.SUM) return a.sum();
            if (n === ul.MEAN) {
              if (null == i) return a.mean();
              var o = r.size / i.size,
                s = a.sum().div(i.sum());
              return o > 1 ? s.div(gn(o)) : s;
            }
            if (n === ul.SUM_BY_NONZERO_WEIGHTS) {
              if (null == i) return a.sum().div(gn(r.size));
              var u = i.mul(On(r.shape)).notEqual(gn(0)).sum().toFloat();
              return a.sum().div(u);
            }
            throw Error("Unknown reduction: " + n);
          },
        }),
        vl = pn({
          cosineDistance_: function (t, e, n, r, i) {
            void 0 === i && (i = ul.SUM_BY_NONZERO_WEIGHTS);
            var a = $e(t, "labels", "cosineDistance"),
              o = $e(e, "predictions", "cosineDistance"),
              s = null;
            null != r && (s = $e(r, "weights", "cosineDistance")),
              N(a.shape, o.shape, "Error in cosineDistance: ");
            var u = gn(1).sub(a.mul(o).sum(n, !0));
            return ml(u, s, i);
          },
        }),
        gl = pn({
          hingeLoss_: function (t, e, n, r) {
            void 0 === r && (r = ul.SUM_BY_NONZERO_WEIGHTS);
            var i = $e(t, "labels", "hingeLoss"),
              a = $e(e, "predictions", "hingeLoss"),
              o = null;
            null != n && (o = $e(n, "weights", "hingeLoss")),
              N(i.shape, a.shape, "Error in hingeLoss: ");
            var s = gn(1);
            i = gn(2).mul(i).sub(s);
            var u = s.sub(i.mul(a)).relu();
            return ml(u, o, r);
          },
        }),
        yl = pn({
          huberLoss_: function (t, e, n, r, i) {
            void 0 === r && (r = 1),
              void 0 === i && (i = ul.SUM_BY_NONZERO_WEIGHTS);
            var a = $e(t, "labels", "huberLoss"),
              o = $e(e, "predictions", "huberLoss"),
              s = null;
            null != n && (s = $e(n, "weights", "huberLoss")),
              N(a.shape, o.shape, "Error in huberLoss: ");
            var u = gn(r),
              c = o.sub(a).abs(),
              l = yu(c, u),
              p = c.sub(l),
              h = gn(0.5).mul(l.square()).add(u.mul(p));
            return ml(h, s, i);
          },
        }),
        bl = pn({
          logLoss_: function (t, e, n, r, i) {
            void 0 === r && (r = 1e-7),
              void 0 === i && (i = ul.SUM_BY_NONZERO_WEIGHTS);
            var a = $e(t, "labels", "logLoss"),
              o = $e(e, "predictions", "logLoss"),
              s = null;
            null != n && (s = $e(n, "weights", "logLoss")),
              N(a.shape, o.shape, "Error in logLoss: ");
            var u = gn(1),
              c = gn(r),
              l = a
                .mul(o.add(c).log())
                .neg()
                .sub(u.sub(a).mul(u.sub(o).add(c).log()));
            return ml(l, s, i);
          },
        }),
        wl = pn({
          meanSquaredError_: function (t, e, n, r) {
            void 0 === r && (r = ul.SUM_BY_NONZERO_WEIGHTS);
            var i = $e(t, "labels", "meanSquaredError"),
              a = $e(e, "predictions", "meanSquaredError"),
              o = null;
            null != n && (o = $e(n, "weights", "meanSquaredError")),
              N(i.shape, a.shape, "Error in meanSquaredError: ");
            var s = i.squaredDifference(a);
            return ml(s, o, r);
          },
        }),
        xl = pn({
          sigmoidCrossEntropy_: function (t, e, n, r, i) {
            void 0 === r && (r = 0),
              void 0 === i && (i = ul.SUM_BY_NONZERO_WEIGHTS);
            var a = $e(t, "multiClassLabels", "sigmoidCrossEntropy"),
              o = $e(e, "logits", "sigmoidCrossEntropy"),
              s = null;
            if (
              (null != n && (s = $e(n, "weights", "sigmoidCrossEntropy")),
              N(a.shape, o.shape, "Error in sigmoidCrossEntropy: "),
              r > 0)
            ) {
              var u = gn(r),
                c = gn(1),
                l = gn(0.5);
              a = a.mul(c.sub(u)).add(l.mul(u));
            }
            var p = (function (t, e) {
              var n = $e(t, "labels", "sigmoidCrossEntropyWithLogits"),
                r = $e(e, "logits", "sigmoidCrossEntropyWithLogits");
              N(n.shape, r.shape, "Error in sigmoidCrossEntropyWithLogits: ");
              var i = r.relu(),
                a = r.mul(n),
                o = r.abs().neg().exp().log1p();
              return i.sub(a).add(o);
            })(a, o);
            return ml(p, s, i);
          },
        }),
        Cl = pn({
          softmaxCrossEntropy_: function (t, e, n, r, i) {
            void 0 === r && (r = 0),
              void 0 === i && (i = ul.SUM_BY_NONZERO_WEIGHTS);
            var a = $e(t, "onehotLabels", "softmaxCrossEntropy"),
              o = $e(e, "logits", "softmaxCrossEntropy"),
              s = null;
            if (
              (null != n && (s = $e(n, "weights", "softmaxCrossEntropy")),
              N(a.shape, o.shape, "Error in softmaxCrossEntropy: "),
              r > 0)
            ) {
              var u = gn(r),
                c = gn(1),
                l = gn(a.shape[1]);
              a = a.mul(c.sub(u)).add(u.div(l));
            }
            var p = (function (t, e, n) {
              if (
                (void 0 === n && (n = -1),
                -1 === n && (n = e.rank - 1),
                n !== e.rank - 1)
              )
                throw Error(
                  "Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank " +
                    e.rank +
                    " and dim was " +
                    n
                );
              return Lr(function (t, e, r) {
                var i = e.logSumExp([n], !0),
                  a = e.toFloat().sub(i);
                return (
                  r([t, a]),
                  {
                    value: a.mul(t).neg().sum([n]),
                    gradFunc: function (t, e) {
                      var r = e[0],
                        i = e[1],
                        a = rn(t.shape, [n]);
                      return [
                        t.reshape(a).mul(r.toFloat().sub(i.exp())),
                        t.reshape(a).mul(i.exp().sub(r.toFloat())),
                      ];
                    },
                  }
                );
              })(t, e);
            })(a, o);
            return ml(p, s, i);
          },
        }),
        Ol = Object.freeze({
          get Reduction() {
            return ul;
          },
          absoluteDifference: dl,
          computeWeightedLoss: ml,
          cosineDistance: vl,
          hingeLoss: gl,
          huberLoss: yl,
          logLoss: bl,
          meanSquaredError: wl,
          sigmoidCrossEntropy: xl,
          softmaxCrossEntropy: Cl,
        });
      function El(t, e) {
        return (
          void 0 === e && (e = !1),
          Pt.tidy(function () {
            if (2 !== t.shape.length)
              throw new Error(
                "qr2d() requires a 2D Tensor, but got a " +
                  t.shape.length +
                  "D Tensor."
              );
            for (
              var n = t.shape[0],
                r = t.shape[1],
                i = nr(n),
                a = t.clone(),
                o = bn([[1]], [1, 1]),
                s = o.clone(),
                u = n >= r ? r : n,
                c = function (t) {
                  var e,
                    u = a,
                    c = s,
                    l = i;
                  (e = Pt.tidy(function () {
                    var e = a.slice([t, t], [n - t, 1]),
                      u = e.norm(),
                      c = a.slice([t, t], [1, 1]),
                      l = bn([[-1]]).where(c.greater(0), bn([[1]])),
                      p = c.sub(l.mul(u)),
                      h = e.div(p);
                    s =
                      1 === h.shape[0]
                        ? o.clone()
                        : o.concat(
                            h.slice([1, 0], [h.shape[0] - 1, h.shape[1]]),
                            0
                          );
                    var f = l.matMul(p).div(u).neg(),
                      d = a.slice([t, 0], [n - t, r]),
                      m = f.mul(s);
                    if (0 === t) a = d.sub(m.matMul(s.transpose().matMul(d)));
                    else {
                      var v = d.sub(m.matMul(s.transpose().matMul(d)));
                      a = a.slice([0, 0], [t, r]).concat(v, 0);
                    }
                    var g = i.slice([0, t], [n, i.shape[1] - t]);
                    if (0 === t) i = g.sub(g.matMul(s).matMul(m.transpose()));
                    else {
                      var y = g.sub(g.matMul(s).matMul(m.transpose()));
                      i = i.slice([0, 0], [n, t]).concat(y, 1);
                    }
                    return [s, a, i];
                  })),
                    (s = e[0]),
                    (a = e[1]),
                    (i = e[2]),
                    qe([u, c, l]);
                },
                l = 0;
              l < u;
              ++l
            )
              c(l);
            return (
              !e &&
                n > r &&
                ((i = i.slice([0, 0], [n, r])), (a = a.slice([0, 0], [r, r]))),
              [i, a]
            );
          })
        );
      }
      var Sl = pn({
          bandPart_: function (t, e, n) {
            if (e % 1 != 0)
              throw new Error(
                "bandPart(): numLower must be an integer, got " + e + "."
              );
            if (n % 1 != 0)
              throw new Error(
                "bandPart(): numUpper must be an integer, got " + n + "."
              );
            var r = $e(t, "a", "bandPart");
            if (r.rank < 2)
              throw new Error(
                "bandPart(): Rank must be at least 2, got " + r.rank + "."
              );
            var i = r.shape,
              a = r.shape.slice(-2),
              o = a[0],
              s = a[1];
            if (!(e <= o))
              throw new Error(
                "bandPart(): numLower (" +
                  e +
                  ") must not be greater than the number of rows (" +
                  o +
                  ")."
              );
            if (!(n <= s))
              throw new Error(
                "bandPart(): numUpper (" +
                  n +
                  ") must not be greater than the number of columns (" +
                  s +
                  ")."
              );
            e < 0 && (e = o), n < 0 && (n = s);
            var u = In(0, o, 1, "int32").reshape([-1, 1]),
              c = In(0, s, 1, "int32"),
              l = Iu(u, c),
              p = nu(
                l.lessEqual(gn(+e, "int32")),
                l.greaterEqual(gn(-n, "int32"))
              ),
              h = En([o, s], r.dtype);
            return gr(
              wr(r.reshape([-1, o, s])).map(function (t) {
                return ou(p, t, h);
              })
            ).reshape(i);
          },
        }),
        Nl = pn({
          gramSchmidt_: function (t) {
            var e;
            if (Array.isArray(t)) {
              (e = !1),
                S(null != t && t.length > 0, function () {
                  return "Gram-Schmidt process: input must not be null, undefined, or empty";
                });
              for (
                var n = t[0].shape[0],
                  r = function (e) {
                    S(t[e].shape[0] === n, function () {
                      return (
                        "Gram-Schmidt: Non-unique lengths found in the input vectors: (" +
                        t[e].shape[0] +
                        " vs. " +
                        n +
                        ")"
                      );
                    });
                  },
                  i = 1;
                i < t.length;
                ++i
              )
                r(i);
            } else
              (e = !0),
                (t = Mn(t, t.shape[0], 0).map(function (t) {
                  return vr(t, [0]);
                }));
            S(t.length <= t[0].shape[0], function () {
              return (
                "Gram-Schmidt: Number of vectors (" +
                t.length +
                ") exceeds number of dimensions (" +
                t[0].shape[0] +
                ")."
              );
            });
            var a = [],
              o = t,
              s = function (t) {
                a.push(
                  Pt.tidy(function () {
                    var e = o[t];
                    if (t > 0)
                      for (var n = 0; n < t; ++n) {
                        var r = Mc(a[n].mulStrict(e)).mul(a[n]);
                        e = e.sub(r);
                      }
                    return e.div(Hc(e, "euclidean"));
                  })
                );
              };
            for (i = 0; i < t.length; ++i) s(i);
            return e ? gr(a, 0) : a;
          },
        }),
        Il = pn({
          qr_: function (t, e) {
            if ((void 0 === e && (e = !1), t.rank < 2))
              throw new Error(
                "qr() requires input tensor to have a rank >= 2, but got rank " +
                  t.rank
              );
            if (2 === t.rank) return El(t, e);
            var n = t.shape
                .slice(0, t.shape.length - 2)
                .reduce(function (t, e) {
                  return t * e;
                }),
              r = wr(
                t.reshape([
                  n,
                  t.shape[t.shape.length - 2],
                  t.shape[t.shape.length - 1],
                ]),
                0
              ),
              i = [],
              a = [];
            return (
              r.forEach(function (t) {
                var n = El(t, e),
                  r = n[0],
                  o = n[1];
                i.push(r), a.push(o);
              }),
              [gr(i, 0).reshape(t.shape), gr(a, 0).reshape(t.shape)]
            );
          },
        }),
        kl = Object.freeze({ bandPart: Sl, gramSchmidt: Nl, qr: Il });
      function _l(t, e, n, r, i, a) {
        null == r && (r = 0.5),
          null == i && (i = Number.NEGATIVE_INFINITY),
          null == a && (a = 0);
        var o = t.shape[0];
        return (
          (n = Math.min(n, o)),
          S(0 <= r && r <= 1, function () {
            return "iouThreshold must be in [0, 1], but was '" + r + "'";
          }),
          S(2 === t.rank, function () {
            return (
              "boxes must be a 2D tensor, but was of rank '" + t.rank + "'"
            );
          }),
          S(4 === t.shape[1], function () {
            return (
              "boxes must have 4 columns, but 2nd dimension was " + t.shape[1]
            );
          }),
          S(1 === e.rank, function () {
            return "scores must be a 1D tensor";
          }),
          S(e.shape[0] === o, function () {
            return (
              "scores has incompatible shape with boxes. Expected " +
              o +
              ", but was " +
              e.shape[0]
            );
          }),
          S(0 <= a && a <= 1, function () {
            return "softNmsSigma must be in [0, 1], but was '" + a + "'";
          }),
          {
            maxOutputSize: n,
            iouThreshold: r,
            scoreThreshold: i,
            softNmsSigma: a,
          }
        );
      }
      var Al = pn({
          resizeBilinear_: function (t, e, n) {
            void 0 === n && (n = !1);
            var r = $e(t, "images", "resizeBilinear");
            S(3 === r.rank || 4 === r.rank, function () {
              return (
                "Error in resizeBilinear: x must be rank 3 or 4, but got rank " +
                r.rank +
                "."
              );
            }),
              S(2 === e.length, function () {
                return (
                  "Error in resizeBilinear: new shape must 2D, but got shape " +
                  e +
                  "."
                );
              });
            var i = r,
              a = !1;
            3 === r.rank &&
              ((a = !0), (i = r.as4D(1, r.shape[0], r.shape[1], r.shape[2])));
            var o = e[0],
              s = e[1],
              u = Pt.runKernelFunc(
                function (t, e) {
                  return e([i]), t.resizeBilinear(i, o, s, n);
                },
                { x: i },
                function (t, e) {
                  return {
                    x: function () {
                      return Pt.runKernelFunc(function (r) {
                        return r.resizeBilinearBackprop(t, e[0], n);
                      }, {});
                    },
                  };
                },
                "ResizeBilinear",
                { alignCorners: n, newHeight: o, newWidth: s }
              );
            return a ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;
          },
        }),
        Tl = pn({
          resizeNearestNeighbor_: function (t, e, n) {
            void 0 === n && (n = !1);
            var r = $e(t, "images", "resizeNearestNeighbor");
            S(3 === r.rank || 4 === r.rank, function () {
              return (
                "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank " +
                r.rank +
                "."
              );
            }),
              S(2 === e.length, function () {
                return (
                  "Error in resizeNearestNeighbor: new shape must 2D, but got shape " +
                  e +
                  "."
                );
              }),
              S("float32" === r.dtype || "int32" === r.dtype, function () {
                return "`images` must have `int32` or `float32` as dtype";
              });
            var i = r,
              a = !1;
            3 === r.rank &&
              ((a = !0), (i = r.as4D(1, r.shape[0], r.shape[1], r.shape[2])));
            var o = e[0],
              s = e[1],
              u = Pt.runKernelFunc(
                function (t, e) {
                  return e([i]), t.resizeNearestNeighbor(i, o, s, n);
                },
                { batchImages: i },
                function (t, e) {
                  return {
                    batchImages: function () {
                      return Pt.runKernelFunc(function (r) {
                        return r.resizeNearestNeighborBackprop(t, e[0], n);
                      }, {});
                    },
                  };
                }
              );
            return a ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;
          },
        }),
        Rl = pn({
          nonMaxSuppression_: function (t, e, n, r, i) {
            void 0 === r && (r = 0.5),
              void 0 === i && (i = Number.NEGATIVE_INFINITY);
            var a = $e(t, "boxes", "nonMaxSuppression"),
              o = $e(e, "scores", "nonMaxSuppression"),
              s = _l(a, o, n, r, i);
            (n = s.maxOutputSize), (r = s.iouThreshold), (i = s.scoreThreshold);
            var u = { maxOutputSize: n, iouThreshold: r, scoreThreshold: i };
            return Pt.runKernelFunc(
              function (t) {
                return t.nonMaxSuppression(a, o, n, r, i);
              },
              { boxes: a, scores: o },
              null,
              "NonMaxSuppressionV3",
              u
            );
          },
        }),
        Dl = pn({
          nonMaxSuppressionWithScore_: function (t, e, n, r, i, a) {
            void 0 === r && (r = 0.5),
              void 0 === i && (i = Number.NEGATIVE_INFINITY),
              void 0 === a && (a = 0);
            var o = $e(t, "boxes", "nonMaxSuppression"),
              s = $e(e, "scores", "nonMaxSuppression"),
              u = _l(o, s, n, r, i, a),
              c = {
                maxOutputSize: (n = u.maxOutputSize),
                iouThreshold: (r = u.iouThreshold),
                scoreThreshold: (i = u.scoreThreshold),
                softNmsSigma: (a = u.softNmsSigma),
              },
              l = Pt.runKernel(
                "NonMaxSuppressionV5",
                { boxes: o, scores: s },
                c
              );
            return { selectedIndices: l[0], selectedScores: l[1] };
          },
        }),
        Fl = pn({
          cropAndResize_: function (t, e, n, r, i, a) {
            var o = $e(t, "image", "cropAndResize"),
              s = $e(e, "boxes", "cropAndResize", "float32"),
              u = $e(n, "boxInd", "cropAndResize", "int32");
            (i = i || "bilinear"), (a = a || 0);
            var c = s.shape[0];
            return (
              S(4 === o.rank, function () {
                return (
                  "Error in cropAndResize: image must be rank 4,but got rank " +
                  o.rank +
                  "."
                );
              }),
              S(2 === s.rank && 4 === s.shape[1], function () {
                return (
                  "Error in cropAndResize: boxes must be have size [" +
                  c +
                  ",4] but had shape " +
                  s.shape +
                  "."
                );
              }),
              S(1 === u.rank && u.shape[0] === c, function () {
                return (
                  "Error in cropAndResize: boxInd must be have size [" +
                  c +
                  "] but had shape " +
                  s.shape +
                  "."
                );
              }),
              S(2 === r.length, function () {
                return (
                  "Error in cropAndResize: cropSize must be of length 2, but got length " +
                  r.length +
                  "."
                );
              }),
              S(r[0] >= 1 && r[1] >= 1, function () {
                return "cropSize must be atleast [1,1], but was " + r;
              }),
              S("bilinear" === i || "nearest" === i, function () {
                return "method must be bilinear or nearest, but was " + i;
              }),
              Pt.runKernelFunc(
                function (t, e) {
                  return t.cropAndResize(o, s, u, r, i, a);
                },
                { images: o, boxes: s, boxInd: u },
                null,
                "CropAndResize",
                { method: i, extrapolationValue: a, cropSize: r }
              )
            );
          },
        }),
        Ml = Object.freeze({
          resizeBilinear: Al,
          resizeNearestNeighbor: Tl,
          nonMaxSuppression: Rl,
          nonMaxSuppressionAsync: function (t, e, n, r, i) {
            return (
              void 0 === r && (r = 0.5),
              void 0 === i && (i = Number.NEGATIVE_INFINITY),
              u(this, void 0, void 0, function () {
                var a, o, s, u, l, p, h;
                return c(this, function (c) {
                  switch (c.label) {
                    case 0:
                      return (
                        (a = $e(t, "boxes", "nonMaxSuppressionAsync")),
                        (o = $e(e, "scores", "nonMaxSuppressionAsync")),
                        (s = _l(a, o, n, r, i)),
                        (n = s.maxOutputSize),
                        (r = s.iouThreshold),
                        (i = s.scoreThreshold),
                        [4, Promise.all([a.data(), o.data()])]
                      );
                    case 1:
                      return (
                        (u = c.sent()),
                        (l = u[0]),
                        (p = u[1]),
                        (h = mi(l, p, n, r, i)),
                        a !== t && a.dispose(),
                        o !== e && o.dispose(),
                        [2, h]
                      );
                  }
                });
              })
            );
          },
          nonMaxSuppressionWithScore: Dl,
          nonMaxSuppressionWithScoreAsync: function (t, e, n, r, i, a) {
            return (
              void 0 === r && (r = 0.5),
              void 0 === i && (i = Number.NEGATIVE_INFINITY),
              void 0 === a && (a = 0),
              u(this, void 0, void 0, function () {
                var o, s, u, l, p, h, f;
                return c(this, function (c) {
                  switch (c.label) {
                    case 0:
                      return (
                        (o = $e(t, "boxes", "nonMaxSuppressionAsync")),
                        (s = $e(e, "scores", "nonMaxSuppressionAsync")),
                        (u = _l(o, s, n, r, i, a)),
                        (n = u.maxOutputSize),
                        (r = u.iouThreshold),
                        (i = u.scoreThreshold),
                        (a = u.softNmsSigma),
                        [4, Promise.all([o.data(), s.data()])]
                      );
                    case 1:
                      return (
                        (l = c.sent()),
                        (p = l[0]),
                        (h = l[1]),
                        (f = vi(p, h, n, r, i, a)),
                        o !== t && o.dispose(),
                        s !== e && s.dispose(),
                        [2, f]
                      );
                  }
                });
              })
            );
          },
          cropAndResize: Fl,
        }),
        jl = function (t, e) {
          return !(t > 0) || "linear" === e;
        },
        Pl = function (t, e, n) {
          if (null == n || "linear" === n) return t;
          if ("relu" === n) return t.mul(e.step());
          throw new Error(
            "Gradient for activation " + n + " has not been implemented yet."
          );
        },
        zl = function (t, e) {
          var n = e,
            r = qr(t.shape, e.shape);
          return r.length > 0 && (n = n.sum(r)), n.reshape(t.shape);
        },
        Ll = function (t, e, n) {
          if ("linear" === e) return t;
          if ("relu" === e) return Bc(t);
          if ("elu" === e) return Pc(t);
          if ("relu6" === e) return Wc(t);
          if ("prelu" === e) return Lc(t, n);
          throw new Error("Unknown fused activation " + e + ".");
        },
        Bl = pn({
          fusedMatMul_: function (t) {
            var e,
              n = t.a,
              r = t.b,
              i = t.transposeA,
              a = void 0 !== i && i,
              o = t.transposeB,
              s = void 0 !== o && o,
              u = t.bias,
              c = t.activation,
              l = void 0 === c ? "linear" : c,
              p = t.preluActivationWeights;
            if (!1 === jl(Pt.state.gradientDepth, l)) {
              var h = ac(n, r, a, s);
              return null != u && (h = uu(h, u)), Ll(h, l, p);
            }
            var f = $e(n, "a", "fused matMul"),
              d = $e(r, "b", "fused matMul");
            (e = At(f, d)), (f = e[0]), (d = e[1]);
            var m = a ? f.shape[f.rank - 2] : f.shape[f.rank - 1],
              v = s ? d.shape[d.rank - 1] : d.shape[d.rank - 2],
              g = a ? f.shape[f.rank - 1] : f.shape[f.rank - 2],
              y = s ? d.shape[d.rank - 2] : d.shape[d.rank - 1],
              b = f.shape.slice(0, -2),
              w = d.shape.slice(0, -2),
              x = _(b),
              C = _(w);
            S(f.rank >= 2 && d.rank >= 2 && f.rank === d.rank, function () {
              return (
                "Error in fused matMul: inputs must have the same rank of at least 2, got ranks " +
                f.rank +
                " and " +
                d.rank +
                "."
              );
            }),
              S(A(b, w), function () {
                return (
                  "Error in fused matMul: outer dimensions (" +
                  b +
                  ") and (" +
                  w +
                  ") of Tensors with shapes " +
                  f.shape +
                  " and " +
                  d.shape +
                  " must match."
                );
              }),
              S(m === v, function () {
                return (
                  "Error in fused matMul: inner shapes (" +
                  m +
                  ") and (" +
                  v +
                  ") of Tensors with shapes " +
                  f.shape +
                  " and " +
                  d.shape +
                  " and transposeA=" +
                  a +
                  " and transposeB=" +
                  s +
                  " must match."
                );
              });
            var O,
              E,
              N = f.shape.slice(0, -2).concat([g, y]),
              I = a ? f.as3D(x, m, g) : f.as3D(x, g, m),
              k = s ? d.as3D(C, y, v) : d.as3D(C, v, y);
            null != u &&
              Kr(N, (O = At((O = $e(u, "bias", "fused matMul")), f)[0]).shape),
              null != p && (E = $e(p, "prelu weights", "fused matMul"));
            var T = { a: I, b: k };
            null != u && (T.bias = O),
              null != p && (T.preluActivationWeights = E);
            var R = [I, k];
            return Pt.runKernelFunc(
              function (t, e) {
                var n = t.fusedBatchMatMul({
                  a: I,
                  b: k,
                  transposeA: a,
                  transposeB: s,
                  bias: O,
                  activation: l,
                  preluActivationWeights: E,
                });
                return e([I, k, n]), n;
              },
              T,
              function (t, e) {
                var n = e[0],
                  r = e[1],
                  i = e[2],
                  o = Pl(t, i, l),
                  c = {};
                return (
                  null != u &&
                    (c = {
                      bias: function () {
                        return zl(O, o);
                      },
                    }),
                  a || s
                    ? !a && s
                      ? Object.assign(
                          {
                            a: function () {
                              return o.matMul(r, !1, !1);
                            },
                            b: function () {
                              return o.matMul(n, !0, !1);
                            },
                          },
                          c
                        )
                      : a && !s
                      ? Object.assign(
                          {
                            a: function () {
                              return r.matMul(o, !1, !0);
                            },
                            b: function () {
                              return n.matMul(o, !1, !1);
                            },
                          },
                          c
                        )
                      : Object.assign(
                          {
                            a: function () {
                              return r.matMul(o, !0, !0);
                            },
                            b: function () {
                              return o.matMul(n, !0, !0);
                            },
                          },
                          c
                        )
                    : Object.assign(
                        {
                          a: function () {
                            return o.matMul(r, !1, !0);
                          },
                          b: function () {
                            return n.matMul(o, !0, !1);
                          },
                        },
                        c
                      )
                );
              },
              "_FusedMatMul",
              { transposeA: a, transposeB: s, activation: l },
              R,
              [!0]
            ).reshape(N);
          },
        }),
        Wl = pn({
          fusedConv2d_: function (t) {
            var e = t.x,
              n = t.filter,
              r = t.strides,
              i = t.pad,
              a = t.dataFormat,
              o = void 0 === a ? "NHWC" : a,
              s = t.dilations,
              u = void 0 === s ? [1, 1] : s,
              c = t.dimRoundingMode,
              l = t.bias,
              p = t.activation,
              h = void 0 === p ? "linear" : p,
              f = t.preluActivationWeights;
            if (((h = h || "linear"), !1 === jl(Pt.state.gradientDepth, h))) {
              var d = Xu(e, n, r, i, o, u, c);
              return null != l && (d = uu(d, l)), Ll(d, h, f);
            }
            var m = $e(e, "x", "conv2d"),
              v = $e(n, "filter", "conv2d"),
              g = m,
              y = !1;
            3 === m.rank &&
              ((y = !0), (g = m.as4D(1, m.shape[0], m.shape[1], m.shape[2]))),
              S(4 === g.rank, function () {
                return (
                  "Error in fused conv2d: input must be rank 4, but got rank " +
                  g.rank +
                  "."
                );
              }),
              S(4 === v.rank, function () {
                return (
                  "Error in fused conv2d: filter must be rank 4, but got rank " +
                  v.rank +
                  "."
                );
              }),
              null != c &&
                S(T(i), function () {
                  return (
                    "Error in fused conv2d: pad must be an integer when using, dimRoundingMode " +
                    c +
                    " but got pad " +
                    i +
                    "."
                  );
                }),
              S(g.shape[3] === v.shape[2], function () {
                return (
                  "Error in conv2d: depth of input (" +
                  g.shape[3] +
                  ") must match input depth for filter " +
                  v.shape[2] +
                  "."
                );
              }),
              S(ii(r, u), function () {
                return (
                  "Error in conv2D: Either strides or dilations must be 1. Got strides " +
                  r +
                  " and dilations '" +
                  u +
                  "'"
                );
              }),
              S("NHWC" === o, function () {
                return (
                  "Error in conv2d: got dataFormat of " +
                  o +
                  " but only NHWC is currently supported."
                );
              });
            var b,
              w,
              x = Yr(g.shape, v.shape, r, u, i, c);
            null != l &&
              ((b = At((b = $e(l, "bias", "fused conv2d")), m)[0]),
              Kr(x.outShape, b.shape)),
              null != f && (w = $e(f, "prelu weights", "fused conv2d"));
            var C = { x: g, filter: v };
            null != l && (C.bias = b),
              null != f && (C.preluActivationWeights = w);
            var O = [v, g],
              E = Pt.runKernelFunc(
                function (t, e) {
                  var n = t.fusedConv2d({
                    input: g,
                    filter: v,
                    convInfo: x,
                    bias: b,
                    activation: h,
                    preluActivationWeights: w,
                  });
                  return e([v, g, n]), n;
                },
                C,
                function (t, e) {
                  var n = e,
                    a = n[0],
                    o = n[1],
                    s = n[2],
                    c = Pl(t, s, h);
                  S(ri(u), function () {
                    return (
                      "Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" +
                      u +
                      "'"
                    );
                  });
                  var p = {};
                  return (
                    null != l &&
                      (p = {
                        bias: function () {
                          return zl(b, c);
                        },
                      }),
                    Object.assign(
                      {
                        x: function () {
                          return $u(o.shape, c, a, r, i);
                        },
                        filter: function () {
                          return Ju(o, c, a.shape, r, i);
                        },
                      },
                      p
                    )
                  );
                },
                "FusedConv2D",
                { convInfo: x, activation: h },
                O,
                [!0]
              );
            return y ? E.as3D(E.shape[1], E.shape[2], E.shape[3]) : E;
          },
        }),
        Ul = pn({
          fusedDepthwiseConv2d_: function (t) {
            var e = t.x,
              n = t.filter,
              r = t.strides,
              i = t.pad,
              a = t.dataFormat,
              o = void 0 === a ? "NHWC" : a,
              s = t.dilations,
              u = void 0 === s ? [1, 1] : s,
              c = t.dimRoundingMode,
              l = t.bias,
              p = t.activation,
              h = void 0 === p ? "linear" : p,
              f = t.preluActivationWeights;
            if (!1 === jl(Pt.state.gradientDepth, h)) {
              var d = Qu(e, n, r, i, o, u, c);
              return null != l && (d = uu(d, l)), Ll(d, h, f);
            }
            var m = $e(e, "x", "depthwiseConv2d"),
              v = $e(n, "filter", "depthwiseConv2d"),
              g = m,
              y = !1;
            3 === m.rank &&
              ((y = !0), (g = m.as4D(1, m.shape[0], m.shape[1], m.shape[2]))),
              S(4 === g.rank, function () {
                return (
                  "Error in fused depthwiseConv2d: input must be rank 4, but got rank " +
                  g.rank +
                  "."
                );
              }),
              S(4 === v.rank, function () {
                return (
                  "Error in fused depthwiseConv2d: filter must be rank 4, but got rank " +
                  v.rank +
                  "."
                );
              }),
              S(g.shape[3] === v.shape[2], function () {
                return (
                  "Error in fused depthwiseConv2d: number of input channels (" +
                  g.shape[3] +
                  ") must match the inChannels dimension in filter " +
                  v.shape[2] +
                  "."
                );
              }),
              null == u && (u = [1, 1]),
              S(ii(r, u), function () {
                return (
                  "Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides " +
                  r +
                  " and dilations '" +
                  u +
                  "'"
                );
              }),
              null != c &&
                S(T(i), function () {
                  return (
                    "Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode " +
                    c +
                    " but got pad " +
                    i +
                    "."
                  );
                });
            var b,
              w,
              x = Yr(g.shape, v.shape, r, u, i, c, !0);
            null != l &&
              ((b = At((b = $e(l, "bias", "fused conv2d")), m)[0]),
              Kr(x.outShape, b.shape)),
              null != f &&
                (w = $e(f, "prelu weights", "fused depthwiseConv2d"));
            var C = { x: g, filter: v };
            null != l && (C.bias = b),
              null != f && (C.preluActivationWeights = w);
            var O = [v, g],
              E = Pt.runKernelFunc(
                function (t, e) {
                  var n = t.fusedDepthwiseConv2D({
                    input: g,
                    filter: v,
                    convInfo: x,
                    bias: b,
                    activation: h,
                    preluActivationWeights: w,
                  });
                  return e([v, g, n]), n;
                },
                C,
                function (t, e) {
                  S(ri(u), function () {
                    return (
                      "Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" +
                      u +
                      "'"
                    );
                  });
                  var n = e[0],
                    r = e[1],
                    i = e[2],
                    a = Pl(t, i, h),
                    o = {};
                  return (
                    null != l &&
                      (o = {
                        bias: function () {
                          return zl(b, a);
                        },
                      }),
                    Object.assign(
                      {
                        x: function () {
                          return tc(r.shape, a, n, x);
                        },
                        filter: function () {
                          return ec(r, a, n.shape, x);
                        },
                      },
                      o
                    )
                  );
                },
                "FusedDepthwiseConv2D",
                { convInfo: x, activation: h },
                O,
                [!0]
              );
            return y ? E.as3D(E.shape[1], E.shape[2], E.shape[3]) : E;
          },
        }),
        Vl = Object.freeze({ matMul: Bl, conv2d: Wl, depthwiseConv2d: Ul }),
        Gl = Object.freeze({
          image: Ml,
          linalg: kl,
          losses: Ol,
          spectral: nl,
          fused: Vl,
          signal: fl,
          square: as,
          squaredDifference: ss,
          conv1d: Zu,
          conv2d: Xu,
          conv3d: Yu,
          depthwiseConv2d: Qu,
          separableConv2d: nc,
          conv2dTranspose: rc,
          conv3dTranspose: ic,
          op: pn,
          batchNormalization2d: Zs,
          batchNormalization3d: Xs,
          batchNormalization4d: Ys,
          batchNormalization: Js,
          batchNorm: $s,
          batchNorm2d: Qs,
          batchNorm3d: tu,
          batchNorm4d: eu,
          booleanMaskAsync: function (t, e, n) {
            return u(this, void 0, void 0, function () {
              var r, i, a, o, s, u, l, p, h, f, d, m, v;
              return c(this, function (c) {
                switch (c.label) {
                  case 0:
                    for (
                      r = $e(t, "tensor", "boolMask"),
                        i = $e(e, "mask", "boolMask", "bool"),
                        a = null == n ? 0 : n,
                        o = i.rank,
                        s = r.shape,
                        S(o > 0, function () {
                          return "mask cannot be scalar";
                        }),
                        N(
                          s.slice(a, a + o),
                          i.shape,
                          "mask's shape must match the first K dimensions of tensor's shape,"
                        ),
                        u = 1,
                        l = a;
                      l < a + o;
                      l++
                    )
                      u *= s[l];
                    return (
                      (p = s.slice(0, a).concat([u], s.slice(a + o))),
                      (h = r.reshape(p)),
                      (f = i.reshape([-1])),
                      [4, su(f)]
                    );
                  case 1:
                    return (
                      (d = c.sent()),
                      (m = d.squeeze([1])),
                      (v = Vu(h, m, a)),
                      t !== r && r.dispose(),
                      e !== i && i.dispose(),
                      m.dispose(),
                      h.dispose(),
                      f.dispose(),
                      d.dispose(),
                      [2, v]
                    );
                }
              });
            });
          },
          complex: hn,
          real: fn,
          imag: dn,
          concat: An,
          concat1d: Tn,
          concat2d: Rn,
          concat3d: Dn,
          concat4d: Fn,
          split: Mn,
          matMul: ac,
          dot: oc,
          outerProduct: sc,
          reverse: uc,
          reverse1d: cc,
          reverse2d: lc,
          reverse3d: pc,
          reverse4d: hc,
          maxPool: mc,
          avgPool: vc,
          pool: gc,
          maxPool3d: yc,
          avgPool3d: bc,
          slice: wc,
          slice1d: xc,
          slice2d: Cc,
          slice3d: Oc,
          slice4d: Ec,
          abs: us,
          acos: cs,
          acosh: ls,
          asin: ps,
          asinh: hs,
          atan: fs,
          atanh: ds,
          ceil: ms,
          clipByValue: vs,
          cos: gs,
          cosh: ys,
          erf: bs,
          exp: ws,
          expm1: xs,
          floor: Cs,
          log: Os,
          log1p: Es,
          logSigmoid: Ss,
          neg: Ns,
          reciprocal: Is,
          round: ks,
          rsqrt: _s,
          sigmoid: As,
          sign: Ts,
          isNaN: Rs,
          isInf: Ds,
          isFinite: Fs,
          sin: Ms,
          sinh: js,
          softplus: Ps,
          sqrt: zs,
          step: Ls,
          tan: Bs,
          tanh: Ws,
          all: Nc,
          any: Ic,
          argMax: kc,
          argMin: _c,
          logSumExp: Ac,
          max: Tc,
          mean: Rc,
          min: Dc,
          moments: Fc,
          sum: Mc,
          prod: jc,
          equal: _u,
          equalStrict: Au,
          greater: Tu,
          greaterEqual: Ru,
          greaterEqualStrict: Du,
          greaterStrict: Fu,
          less: Mu,
          lessEqual: ju,
          lessEqualStrict: Pu,
          lessStrict: zu,
          notEqual: Lu,
          notEqualStrict: Bu,
          add: uu,
          addN: cu,
          addStrict: lu,
          atan2: pu,
          div: hu,
          divNoNan: fu,
          divStrict: du,
          floorDiv: mu,
          maximum: vu,
          maximumStrict: gu,
          minimum: yu,
          minimumStrict: bu,
          mod: wu,
          modStrict: xu,
          mul: Cu,
          mulStrict: Ou,
          pow: Eu,
          powStrict: Su,
          squaredDifferenceStrict: Nu,
          sub: Iu,
          subStrict: ku,
          elu: Pc,
          leakyRelu: zc,
          prelu: Lc,
          relu: Bc,
          relu6: Wc,
          selu: Uc,
          logicalAnd: nu,
          logicalNot: ru,
          logicalOr: iu,
          logicalXor: au,
          where: ou,
          whereAsync: su,
          buffer: Zn,
          print: function (t, e) {
            void 0 === e && (e = !1), console.log(t.toString(e));
          },
          batchToSpaceND: Xn,
          broadcastTo: Yn,
          cast: Jn,
          clone: $n,
          cumsum: Qn,
          depthToSpace: tr,
          expandDims: er,
          eye: nr,
          multinomial: rr,
          oneHot: ir,
          pad: ar,
          pad1d: or,
          pad2d: sr,
          pad3d: ur,
          pad4d: cr,
          rand: lr,
          randomNormal: pr,
          randomGamma: hr,
          randomUniform: fr,
          reshape: dr,
          spaceToBatchND: mr,
          squeeze: vr,
          stack: gr,
          tile: yr,
          truncatedNormal: br,
          unstack: wr,
          setdiff1dAsync: xr,
          fill: Sn,
          linspace: Nn,
          ones: On,
          range: In,
          scalar: gn,
          tensor: mn,
          tensor1d: yn,
          tensor2d: bn,
          tensor3d: wn,
          tensor4d: xn,
          tensor5d: function (t, e, n) {
            if ((I(t), null != e && 5 !== e.length))
              throw new Error("tensor5d() requires shape to have five numbers");
            var r = Ye(t, n);
            if (5 !== r.length && 1 !== r.length)
              throw new Error(
                "tensor5d() requires values to be number[][][][][] or flat/TypedArray"
              );
            if (1 === r.length && null == e)
              throw new Error(
                "tensor5d() requires shape to be provided when `values` are a flat array"
              );
            return vn(t, e, r, n);
          },
          tensor6d: function (t, e, n) {
            if ((I(t), null != e && 6 !== e.length))
              throw new Error("tensor6d() requires shape to have six numbers");
            var r = Ye(t, n);
            if (6 !== r.length && 1 !== r.length)
              throw new Error(
                "tensor6d() requires values to be number[][][][][][] or flat/TypedArray"
              );
            if (1 === r.length && null == e)
              throw new Error(
                "tensor6d() requires shape to be provided when `values` are a flat array"
              );
            return vn(t, (e = e || r), r, n);
          },
          variable: Cn,
          zeros: En,
          onesLike: kn,
          zerosLike: _n,
          transpose: Vc,
          softmax: Br,
          logSoftmax: Wr,
          localResponseNormalization: Gc,
          norm: Hc,
          gather: Vu,
          unsortedSegmentSum: Gu,
          basicLSTMCell: qc,
          multiRNNCell: Kc,
          movingAverage: Zc,
          stridedSlice: Xc,
          topk: Yc,
          scatterND: Jc,
          fft: $c,
          ifft: Qc,
          rfft: tl,
          irfft: el,
          sparseToDense: rl,
          gatherND: il,
          diag: al,
          dropout: ol,
          hannWindow: cl,
          hammingWindow: ll,
          frame: pl,
          stft: hl,
          inTopKAsync: function (t, e, n) {
            return (
              void 0 === n && (n = 1),
              u(this, void 0, void 0, function () {
                var r, i, a, o, s, u, l, p, h, f, d, m, v, g;
                return c(this, function (c) {
                  switch (c.label) {
                    case 0:
                      return (
                        (r = $e(t, "predictions", "inTopK")),
                        (i = $e(e, "targets", "inTopK")),
                        S(r.rank > 1, function () {
                          return (
                            "inTopK() expects the predictions to be of rank 2 or higher, but got " +
                            r.rank
                          );
                        }),
                        S(r.rank - 1 === i.rank, function () {
                          return (
                            "predictions rank should be 1 larger than targets rank, but got predictions rank " +
                            r.rank +
                            " and targets rank " +
                            i.rank
                          );
                        }),
                        N(
                          r.shape.slice(0, r.shape.length - 1),
                          i.shape,
                          "predictions's shape should be align with the targets' shape, except the last dimension."
                        ),
                        (a = r.shape[r.shape.length - 1]),
                        S(n > 0 && n <= a, function () {
                          return (
                            "'k' passed to inTopK() must be > 0 && <= the predictions last dimension (" +
                            a +
                            "), but got " +
                            n
                          );
                        }),
                        [4, r.data()]
                      );
                    case 1:
                      return (o = c.sent()), [4, i.data()];
                    case 2:
                      for (
                        s = c.sent(),
                          u = [o.length / a, a],
                          p = u[1],
                          h = L("bool", (l = u[0])),
                          f = 0;
                        f < l;
                        f++
                      ) {
                        for (
                          d = f * p, m = o.subarray(d, d + p), v = [], g = 0;
                          g < m.length;
                          g++
                        )
                          v.push({ value: m[g], index: g });
                        for (
                          v.sort(function (t, e) {
                            return e.value - t.value;
                          }),
                            h[f] = 0,
                            g = 0;
                          g < n;
                          g++
                        )
                          if (v[g].index === s[f]) {
                            h[f] = 1;
                            break;
                          }
                      }
                      return (
                        t !== r && r.dispose(),
                        e !== i && i.dispose(),
                        [2, mn(h, i.shape, "bool")]
                      );
                  }
                });
              })
            );
          },
        });
      function Hl(t, e) {
        Array.isArray(t) || (t = [t]),
          t.forEach(function (t) {
            null != t &&
              S("complex64" !== t.dtype, function () {
                return e + " does not support complex64 tensors.";
              });
          });
      }
      function ql(t, e, n, r) {
        if ("linear" === n) return t.linear(e);
        if ("relu" === n) return t.relu(e);
        if ("elu" === n) return t.elu(e);
        if ("relu6" === n) return t.relu6(e);
        if ("prelu" === n) return t.prelu(e, r);
        throw new Error(
          "Activation " + n + " has not been implemented for the CPU backend."
        );
      }
      var Kl = (function (t) {
        function e() {
          var e = t.call(this) || this;
          return (
            (e.blockSize = 48), (e.firstUse = !0), (e.data = new Ur(e, Pt)), e
          );
        }
        return (
          s(e, t),
          (e.prototype.write = function (t, e, n) {
            this.firstUse &&
              ((this.firstUse = !1),
              h().get("IS_NODE") &&
                Xe(
                  "\n============================\nHi there 👋. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"
                ));
            var r = {};
            return this.data.set(r, { values: t, dtype: n }), r;
          }),
          (e.prototype.move = function (t, e, n, r) {
            this.data.set(t, { values: e, dtype: r });
          }),
          (e.prototype.numDataIds = function () {
            return this.data.numDataIds();
          }),
          (e.prototype.read = function (t) {
            return u(this, void 0, void 0, function () {
              return c(this, function (e) {
                return [2, this.readSync(t)];
              });
            });
          }),
          (e.prototype.readSync = function (t) {
            var e = this.data.get(t),
              n = e.dtype,
              r = e.complexTensors;
            return "complex64" === n
              ? ci(this.readSync(r.real.dataId), this.readSync(r.imag.dataId))
              : this.data.get(t).values;
          }),
          (e.prototype.bufferSync = function (t) {
            var e = this.readSync(t.dataId),
              n = e;
            if ("string" === t.dtype)
              try {
                n = e.map(function (t) {
                  return st(t);
                });
              } catch (t) {
                throw new Error(
                  "Failed to decode encoded string bytes into utf-8"
                );
              }
            return Zn(t.shape, t.dtype, n);
          }),
          (e.prototype.makeOutput = function (t, e, n) {
            var r = this.write(t, e, n);
            return Pt.makeTensorFromDataId(r, e, n, this);
          }),
          (e.prototype.disposeData = function (t) {
            if (this.data.has(t)) {
              var e = this.data.get(t).complexTensors;
              null != e && (e.real.dispose(), e.imag.dispose()),
                this.data.delete(t);
            }
          }),
          (e.prototype.time = function (t) {
            return u(this, void 0, void 0, function () {
              var e;
              return c(this, function (n) {
                return (e = it()), t(), [2, { kernelMs: it() - e }];
              });
            });
          }),
          (e.prototype.memory = function () {
            return {
              unreliable: !0,
              reasons: [
                "The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less.",
              ],
            };
          }),
          (e.prototype.complex = function (t, e) {
            var n = this.makeOutput(null, t.shape, "complex64");
            return (
              (this.data.get(n.dataId).complexTensors = {
                real: Pt.keep(t.clone()),
                imag: Pt.keep(e.clone()),
              }),
              n
            );
          }),
          (e.prototype.real = function (t) {
            return this.data.get(t.dataId).complexTensors.real.clone();
          }),
          (e.prototype.imag = function (t) {
            return this.data.get(t.dataId).complexTensors.imag.clone();
          }),
          (e.prototype.slice = function (t, e, n) {
            if ((Hl(t, "slice"), Pr(t.shape, e, n))) {
              var r = zr(e, t.strides),
                i = _(n);
              return mn(this.readSync(t.dataId).subarray(r, r + i), n, t.dtype);
            }
            for (
              var a = Zn(n, t.dtype), o = this.bufferSync(t), s = 0;
              s < a.size;
              ++s
            ) {
              var u = a.indexToLoc(s).map(function (t, n) {
                return t + e[n];
              });
              a.values[s] = o.get.apply(o, u);
            }
            return a.toTensor();
          }),
          (e.prototype.stridedSlice = function (t, e, n, r) {
            Hl(t, "stridedSlice");
            var i = Fr(e, n, r);
            if (
              i.some(function (t) {
                return 0 === t;
              })
            )
              return mn([], i);
            for (
              var a = Zn(i, t.dtype), o = this.bufferSync(t), s = 0;
              s < a.size;
              s++
            ) {
              for (
                var u = a.indexToLoc(s), c = new Array(u.length), l = 0;
                l < c.length;
                l++
              )
                c[l] = u[l] * r[l] + e[l];
              a.set.apply(a, [o.get.apply(o, c)].concat(u));
            }
            return a.toTensor();
          }),
          (e.prototype.diag = function (t) {
            for (
              var e = this.readSync(t.dataId),
                n = Zn([t.size, t.size], t.dtype),
                r = n.values,
                i = 0;
              i < e.length;
              i++
            )
              r[i * t.size + i] = e[i];
            return n.toTensor();
          }),
          (e.prototype.unstack = function (t, e) {
            for (
              var n = t.shape[e], r = new Array(t.rank - 1), i = 0, a = 0;
              a < t.rank;
              a++
            )
              a !== e && (r[i++] = t.shape[a]);
            var o = new Array(t.rank).fill(0),
              s = t.shape.slice();
            s[e] = 1;
            var u = new Array(n);
            for (a = 0; a < u.length; a++)
              (o[e] = a), (u[a] = this.slice(t, o, s).reshape(r));
            return u;
          }),
          (e.prototype.reverse = function (t, e) {
            Hl(t, "reverse");
            for (
              var n = Zn(t.shape, t.dtype),
                r = this.bufferSync(t),
                i = function (i) {
                  var a = n.indexToLoc(i),
                    o = a.slice();
                  e.forEach(function (e) {
                    return (o[e] = t.shape[e] - 1 - o[e]);
                  }),
                    n.set.apply(n, [r.get.apply(r, o)].concat(a));
                },
                a = 0;
              a < n.size;
              a++
            )
              i(a);
            return n.toTensor();
          }),
          (e.prototype.concat = function (t, e) {
            var n = this;
            if ("complex64" === t[0].dtype) {
              var r = t.map(function (t) {
                  return fn(t);
                }),
                i = t.map(function (t) {
                  return dn(t);
                });
              return hn(this.concat(r, e), this.concat(i, e));
            }
            var a = t.map(function (t) {
                var n = _(t.shape.slice(e));
                return t.as2D(-1, n);
              }),
              o = ln(
                a.map(function (t) {
                  return t.shape;
                }),
                1
              ),
              s = Zn(o, t[0].dtype).values;
            if (1 === a[0].shape[0]) {
              var u = 0;
              a.forEach(function (t) {
                s.set(n.readSync(t.dataId), u), (u += t.size);
              });
            } else {
              var c = 0;
              a.forEach(function (t) {
                for (
                  var e = n.readSync(t.dataId), r = 0, i = 0;
                  i < t.shape[0];
                  ++i
                )
                  for (var a = i * o[1] + c, u = 0; u < t.shape[1]; ++u)
                    s[a + u] = e[r++];
                c += t.shape[1];
              });
            }
            var l = ln(
              t.map(function (t) {
                return t.shape;
              }),
              e
            );
            return mn(s, l, t[0].dtype);
          }),
          (e.prototype.neg = function (t) {
            return Hl(t, "neg"), this.multiply(gn(-1), t);
          }),
          (e.prototype.add = function (t, e) {
            return "complex64" === t.dtype || "complex64" === e.dtype
              ? this.broadcastedBinaryComplexOp(
                  t.cast("complex64"),
                  e.cast("complex64"),
                  function (t, e, n, r) {
                    return { real: t + n, imag: e + r };
                  }
                )
              : this.broadcastedBinaryOp(t, e, kt(t.dtype, e.dtype), function (
                  t,
                  e
                ) {
                  return t + e;
                });
          }),
          (e.prototype.addN = function (t) {
            var e = this;
            Hl(t, "addN");
            for (
              var n = t.map(function (t) {
                  return e.readSync(t.dataId);
                }),
                r = Zn(t[0].shape, t[0].dtype),
                i = r.values,
                a = 0;
              a < t.length;
              a++
            )
              for (var o = n[a], s = 0; s < i.length; s++) i[s] += o[s];
            return r.toTensor();
          }),
          (e.prototype.softmax = function (t, e) {
            var n = P([e], t.shape),
              r = this.max(t, n),
              i = rn(r.shape, n),
              a = this.subtract(t, r.reshape(i)),
              o = this.exp(a),
              s = this.sum(o, n).reshape(i);
            return this.realDivide(o, s);
          }),
          (e.prototype.subtract = function (t, e) {
            return "complex64" === t.dtype || "complex64" === e.dtype
              ? this.broadcastedBinaryComplexOp(
                  t.cast("complex64"),
                  e.cast("complex64"),
                  function (t, e, n, r) {
                    return { real: t - n, imag: e - r };
                  }
                )
              : this.broadcastedBinaryOp(t, e, kt(t.dtype, e.dtype), function (
                  t,
                  e
                ) {
                  return t - e;
                });
          }),
          (e.prototype.pow = function (t, e) {
            return (
              Hl([t, e], "pow"),
              this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
                return Math.pow(t, e);
              })
            );
          }),
          (e.prototype.batchMatMul = function (t, e, n, r) {
            Hl([t, e], "matMul");
            for (
              var i = n ? t.shape[1] : t.shape[2],
                a = n ? t.shape[2] : t.shape[1],
                o = r ? e.shape[1] : e.shape[2],
                s = t.shape[0],
                u = this.readSync(t.dataId),
                c = this.readSync(e.dataId),
                l = n
                  ? [t.strides[0], 1, t.strides[1]]
                  : [t.strides[0], t.strides[1], 1],
                p = l[0],
                h = l[1],
                f = l[2],
                d = r
                  ? [1, e.strides[1], e.strides[0]]
                  : [e.strides[1], 1, e.strides[0]],
                m = d[0],
                v = d[1],
                g = d[2],
                y = a * o,
                b = Zn([s, a, o], t.dtype),
                w = b.values,
                x = this.blockSize,
                C = 0;
              C < s;
              C++
            )
              for (var O = 0; O < a; O += x)
                for (var E = 0; E < o; E += x)
                  for (var S = 0; S < i; S += x)
                    for (
                      var N = Math.min(O + x, a),
                        I = Math.min(E + x, o),
                        k = Math.min(S + x, i),
                        _ = O;
                      _ < N;
                      _++
                    )
                      for (var A = E; A < I; A++) {
                        for (var T = 0, R = S; R < k; R++)
                          T +=
                            u[C * p + _ * h + R * f] * c[R * m + A * v + C * g];
                        w[C * y + (_ * o + A)] += T;
                      }
            return b.toTensor();
          }),
          (e.prototype.fusedBatchMatMul = function (t) {
            var e = t.a,
              n = t.b,
              r = t.transposeA,
              i = t.transposeB,
              a = t.bias,
              o = t.activation,
              s = t.preluActivationWeights,
              u = this.batchMatMul(e, n, r, i);
            return a && (u = this.add(u, a)), o && (u = ql(this, u, o, s)), u;
          }),
          (e.prototype.multiply = function (t, e) {
            return "complex64" === t.dtype || "complex64" === e.dtype
              ? this.broadcastedBinaryComplexOp(
                  t.cast("complex64"),
                  e.cast("complex64"),
                  function (t, e, n, r) {
                    return { real: t * n - e * r, imag: t * r + e * n };
                  }
                )
              : this.broadcastedBinaryOp(t, e, kt(t.dtype, e.dtype), function (
                  t,
                  e
                ) {
                  return t * e;
                });
          }),
          (e.prototype.realDivide = function (t, e) {
            return (
              Hl([t, e], "realDivide"),
              this.broadcastedBinaryOp(t, e, "float32", function (t, e) {
                return t / e;
              })
            );
          }),
          (e.prototype.floorDiv = function (t, e) {
            return (
              Hl([t, e], "floorDiv"),
              this.broadcastedBinaryOp(t, e, "int32", function (t, e) {
                return Math.floor(t / e);
              })
            );
          }),
          (e.prototype.sum = function (t, e) {
            Hl(t, "sum"), an("sum", e, t.rank);
            for (
              var n = nn(t.shape, e),
                r = n[0],
                i = n[1],
                a = En(r, kt(t.dtype, "int32")),
                o = _(i),
                s = this.readSync(a.dataId),
                u = this.readSync(t.dataId),
                c = 0;
              c < s.length;
              ++c
            ) {
              for (var l = c * o, p = 0, h = 0; h < o; ++h) p += u[l + h];
              s[c] = p;
            }
            return a;
          }),
          (e.prototype.prod = function (t, e) {
            Hl(t, "sum");
            for (
              var n = nn(t.shape, e),
                r = n[0],
                i = n[1],
                a = En(r, kt(t.dtype, "int32")),
                o = _(i),
                s = this.readSync(a.dataId),
                u = this.readSync(t.dataId),
                c = 0;
              c < s.length;
              ++c
            ) {
              for (var l = c * o, p = 1, h = 0; h < o; ++h) p *= u[l + h];
              s[c] = p;
            }
            return a;
          }),
          (e.prototype.unsortedSegmentSum = function (t, e, n) {
            Hl(t, "unsortedSegmentSum");
            for (var r = [], i = t.rank - e.rank, a = 0; a < i; ++a)
              e = e.expandDims(a + 1);
            for (a = 0; a < n; ++a) {
              var o = gn(a, "int32"),
                s = _u(o, e).asType("float32").mul(t).sum(0);
              r.push(s);
            }
            return gr(r);
          }),
          (e.prototype.argMin = function (t, e) {
            Hl(t, "argMin");
            var n = [e];
            an("argMin", n, t.rank);
            for (
              var r = nn(t.shape, n),
                i = r[0],
                a = r[1],
                o = En(i, "int32"),
                s = _(a),
                u = this.readSync(o.dataId),
                c = this.readSync(t.dataId),
                l = 0;
              l < u.length;
              ++l
            ) {
              for (var p = l * s, h = c[p], f = 0, d = 0; d < s; ++d) {
                var m = c[p + d];
                m < h && ((h = m), (f = d));
              }
              u[l] = f;
            }
            return o;
          }),
          (e.prototype.argMax = function (t, e) {
            Hl(t, "argMax");
            var n = [e];
            an("argMax", n, t.rank);
            for (
              var r = nn(t.shape, n),
                i = r[0],
                a = r[1],
                o = En(i, "int32"),
                s = _(a),
                u = this.readSync(o.dataId),
                c = this.readSync(t.dataId),
                l = 0;
              l < u.length;
              ++l
            ) {
              for (var p = l * s, h = c[p], f = 0, d = 0; d < s; ++d) {
                var m = c[p + d];
                m > h && ((h = m), (f = d));
              }
              u[l] = f;
            }
            return o;
          }),
          (e.prototype.cumsum = function (t, e, n, r) {
            if ((Hl(t, "cumsum"), e !== t.rank - 1))
              throw new Error(
                "backend.cumsum in CPU expects an inner-most axis=" +
                  (t.rank - 1) +
                  " but got axis=" +
                  e
              );
            for (
              var i = kt(t.dtype, "int32"),
                a = En(t.shape, i),
                o = this.readSync(a.dataId),
                s = this.readSync(t.dataId),
                u = t.shape[t.rank - 1],
                c = r
                  ? function (t, e) {
                      return t + u - e - 1;
                    }
                  : function (t, e) {
                      return t + e;
                    },
                l = 0;
              l < s.length;
              l += u
            )
              for (var p = 0; p < u; p++) {
                var h = c(l, p);
                if (0 === p) o[h] = n ? 0 : s[h];
                else {
                  var f = c(l, p - 1);
                  o[h] = n ? s[f] + o[f] : s[h] + o[f];
                }
              }
            return a;
          }),
          (e.prototype.equal = function (t, e) {
            return (
              Hl([t, e], "equal"),
              this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
                return t === e ? 1 : 0;
              })
            );
          }),
          (e.prototype.notEqual = function (t, e) {
            return (
              Hl([t, e], "notEqual"),
              this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
                return t !== e ? 1 : 0;
              })
            );
          }),
          (e.prototype.less = function (t, e) {
            return (
              Hl([t, e], "less"),
              this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
                return t < e ? 1 : 0;
              })
            );
          }),
          (e.prototype.lessEqual = function (t, e) {
            return (
              Hl([t, e], "lessEqual"),
              this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
                return t <= e ? 1 : 0;
              })
            );
          }),
          (e.prototype.greater = function (t, e) {
            return (
              Hl([t, e], "greater"),
              this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
                return t > e ? 1 : 0;
              })
            );
          }),
          (e.prototype.greaterEqual = function (t, e) {
            return (
              Hl([t, e], "greaterEqual"),
              this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
                return t >= e ? 1 : 0;
              })
            );
          }),
          (e.prototype.logicalNot = function (t) {
            Hl(t, "logicalNot");
            for (
              var e = this.readSync(t.dataId),
                n = new Uint8Array(e.length),
                r = 0;
              r < e.length;
              ++r
            )
              n[r] = e[r] ? 0 : 1;
            return this.makeOutput(n, t.shape, "bool");
          }),
          (e.prototype.logicalAnd = function (t, e) {
            return (
              Hl([t, e], "logicalAnd"),
              this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
                return t && e;
              })
            );
          }),
          (e.prototype.logicalOr = function (t, e) {
            return (
              Hl([t, e], "logicalOr"),
              this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
                return t || e;
              })
            );
          }),
          (e.prototype.select = function (t, e, n) {
            Hl([t, e, n], "select");
            for (
              var r = this.readSync(t.dataId),
                i = this.readSync(e.dataId),
                a = this.readSync(n.dataId),
                o = En(e.shape, kt(e.dtype, n.dtype)),
                s = this.readSync(o.dataId),
                u = 0,
                c =
                  0 === t.rank || t.rank > 1 || 1 === e.rank
                    ? 1
                    : _(e.shape.slice(1)),
                l = 0;
              l < r.length;
              l++
            )
              for (var p = 0; p < c; p++)
                1 === r[l] ? (s[u++] = i[l]) : (s[u++] = a[l]);
            return o;
          }),
          (e.prototype.where = function (t) {
            Hl([t], "where");
            var e = this.readSync(t.dataId);
            return Ei(t.shape, e);
          }),
          (e.prototype.topk = function (t, e, n) {
            return (
              Hl(t, "topk"), Oi(this.readSync(t.dataId), t.shape, t.dtype, e)
            );
          }),
          (e.prototype.min = function (t, e) {
            Hl(t, "min"), an("min", e, t.rank);
            for (
              var n = nn(t.shape, e),
                r = n[0],
                i = n[1],
                a = En(r, t.dtype),
                o = _(i),
                s = this.readSync(a.dataId),
                u = this.readSync(t.dataId),
                c = 0;
              c < s.length;
              ++c
            ) {
              for (var l = c * o, p = u[l], h = 0; h < o; ++h) {
                var f = u[l + h];
                f < p && (p = f);
              }
              s[c] = p;
            }
            return a;
          }),
          (e.prototype.minimum = function (t, e) {
            return (
              Hl([t, e], "minimum"),
              this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
                return Math.min(t, e);
              })
            );
          }),
          (e.prototype.mod = function (t, e) {
            return (
              Hl([t, e], "mod"),
              this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
                var n = t % e;
                return (t < 0 && e < 0) || (t >= 0 && e >= 0) ? n : (n + e) % e;
              })
            );
          }),
          (e.prototype.max = function (t, e) {
            Hl(t, "max"), an("max", e, t.rank);
            for (
              var n = nn(t.shape, e),
                r = n[0],
                i = n[1],
                a = En(r, t.dtype),
                o = _(i),
                s = this.readSync(a.dataId),
                u = this.readSync(t.dataId),
                c = 0;
              c < s.length;
              ++c
            ) {
              for (var l = c * o, p = u[l], h = 0; h < o; ++h) {
                var f = u[l + h];
                f > p && (p = f);
              }
              s[c] = p;
            }
            return a;
          }),
          (e.prototype.maximum = function (t, e) {
            return (
              Hl([t, e], "maximum"),
              this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
                return Math.max(t, e);
              })
            );
          }),
          (e.prototype.all = function (t, e) {
            Hl(t, "all"), an("all", e, t.rank);
            for (
              var n = nn(t.shape, e),
                r = n[0],
                i = n[1],
                a = En(r, t.dtype),
                o = _(i),
                s = this.readSync(a.dataId),
                u = this.readSync(t.dataId),
                c = 0;
              c < s.length;
              ++c
            ) {
              for (var l = c * o, p = u[l], h = 0; h < o; ++h) {
                var f = u[l + h];
                p = p && f;
              }
              s[c] = p;
            }
            return a;
          }),
          (e.prototype.any = function (t, e) {
            Hl(t, "any"), an("any", e, t.rank);
            for (
              var n = nn(t.shape, e),
                r = n[0],
                i = n[1],
                a = En(r, t.dtype),
                o = _(i),
                s = this.readSync(a.dataId),
                u = this.readSync(t.dataId),
                c = 0;
              c < s.length;
              ++c
            ) {
              for (var l = c * o, p = u[l], h = 0; h < o; ++h) {
                var f = u[l + h];
                p = p || f;
              }
              s[c] = p;
            }
            return a;
          }),
          (e.prototype.squaredDifference = function (t, e) {
            return (
              Hl([t, e], "squaredDifference"),
              this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
                var n = t - e;
                return n * n;
              })
            );
          }),
          (e.prototype.ceil = function (t) {
            Hl(t, "ceil");
            for (
              var e = this.readSync(t.dataId),
                n = new Float32Array(e.length),
                r = 0;
              r < e.length;
              ++r
            )
              n[r] = Math.ceil(e[r]);
            return this.makeOutput(n, t.shape, "float32");
          }),
          (e.prototype.floor = function (t) {
            Hl(t, "floor");
            for (
              var e = this.readSync(t.dataId),
                n = new Float32Array(e.length),
                r = 0;
              r < e.length;
              ++r
            )
              n[r] = Math.floor(e[r]);
            return this.makeOutput(n, t.shape, "float32");
          }),
          (e.prototype.sign = function (t) {
            Hl(t, "x");
            for (
              var e = this.readSync(t.dataId),
                n = new Float32Array(e.length),
                r = 0;
              r < e.length;
              ++r
            )
              e[r] < 0 ? (n[r] = -1) : e[r] > 0 ? (n[r] = 1) : (n[r] = 0);
            return this.makeOutput(n, t.shape, "float32");
          }),
          (e.prototype.isNaN = function (t) {
            Hl(t, "x");
            for (
              var e = this.readSync(t.dataId),
                n = new Uint8Array(e.length),
                r = 0;
              r < e.length;
              ++r
            )
              Number.isNaN(e[r]) && (n[r] = 1);
            return this.makeOutput(n, t.shape, "bool");
          }),
          (e.prototype.isInf = function (t) {
            Hl(t, "x");
            for (
              var e = this.readSync(t.dataId),
                n = new Uint8Array(e.length),
                r = 0;
              r < e.length;
              ++r
            )
              Math.abs(e[r]) === 1 / 0 && (n[r] = 1);
            return this.makeOutput(n, t.shape, "bool");
          }),
          (e.prototype.isFinite = function (t) {
            Hl(t, "x");
            for (
              var e = this.readSync(t.dataId),
                n = new Uint8Array(e.length),
                r = 0;
              r < e.length;
              ++r
            )
              Number.isFinite(e[r]) && (n[r] = 1);
            return this.makeOutput(n, t.shape, "bool");
          }),
          (e.prototype.round = function (t) {
            Hl(t, "round");
            for (
              var e = this.readSync(t.dataId),
                n = new Float32Array(e.length),
                r = 0;
              r < e.length;
              ++r
            ) {
              var i = Math.floor(e[r]);
              e[r] - i < 0.5
                ? (n[r] = Math.floor(e[r]))
                : e[r] - i > 0.5
                ? (n[r] = Math.ceil(e[r]))
                : (n[r] = i % 2 == 0 ? i : i + 1);
            }
            return this.makeOutput(n, t.shape, "float32");
          }),
          (e.prototype.exp = function (t) {
            Hl(t, "exp");
            for (
              var e = this.readSync(t.dataId),
                n = new Float32Array(e.length),
                r = 0;
              r < e.length;
              ++r
            )
              n[r] = Math.exp(e[r]);
            return this.makeOutput(n, t.shape, "float32");
          }),
          (e.prototype.expm1 = function (t) {
            Hl(t, "expm1");
            for (
              var e = this.readSync(t.dataId),
                n = new Float32Array(e.length),
                r = 0;
              r < e.length;
              ++r
            )
              n[r] = Math.expm1(e[r]);
            return this.makeOutput(n, t.shape, "float32");
          }),
          (e.prototype.log = function (t) {
            Hl(t, "log");
            for (
              var e = this.readSync(t.dataId),
                n = new Float32Array(e.length),
                r = 0;
              r < e.length;
              ++r
            ) {
              var i = e[r];
              n[r] = Math.log(i);
            }
            return this.makeOutput(n, t.shape, "float32");
          }),
          (e.prototype.log1p = function (t) {
            Hl(t, "log1p");
            for (
              var e = this.readSync(t.dataId),
                n = new Float32Array(e.length),
                r = 0;
              r < e.length;
              ++r
            ) {
              var i = e[r];
              n[r] = Math.log1p(i);
            }
            return this.makeOutput(n, t.shape, "float32");
          }),
          (e.prototype.sqrt = function (t) {
            Hl(t, "sqrt");
            for (
              var e = this.readSync(t.dataId),
                n = new Float32Array(e.length),
                r = 0;
              r < e.length;
              ++r
            ) {
              var i = e[r];
              n[r] = Math.sqrt(i);
            }
            return this.makeOutput(n, t.shape, "float32");
          }),
          (e.prototype.rsqrt = function (t) {
            Hl(t, "rsqrt");
            for (
              var e = this.readSync(t.dataId),
                n = new Float32Array(e.length),
                r = 0;
              r < e.length;
              ++r
            ) {
              var i = e[r];
              n[r] = 1 / Math.sqrt(i);
            }
            return this.makeOutput(n, t.shape, "float32");
          }),
          (e.prototype.reciprocal = function (t) {
            Hl(t, "reciprocal");
            for (
              var e = this.readSync(t.dataId),
                n = new Float32Array(e.length),
                r = 0;
              r < e.length;
              ++r
            )
              n[r] = 1 / e[r];
            return this.makeOutput(n, t.shape, "float32");
          }),
          (e.prototype.linear = function (t) {
            return t;
          }),
          (e.prototype.relu = function (t) {
            Hl(t, "relu");
            for (
              var e = En(t.shape, t.dtype),
                n = this.readSync(e.dataId),
                r = this.readSync(t.dataId),
                i = 0;
              i < r.length;
              ++i
            )
              n[i] = Math.max(0, r[i]);
            return e;
          }),
          (e.prototype.relu6 = function (t) {
            Hl(t, "relu");
            for (
              var e = En(t.shape, t.dtype),
                n = this.readSync(e.dataId),
                r = this.readSync(t.dataId),
                i = 0;
              i < r.length;
              ++i
            )
              n[i] = Math.min(Math.max(0, r[i]), 6);
            return e;
          }),
          (e.prototype.prelu = function (t, e) {
            return (
              Hl([t, e], "prelu"),
              this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
                return t < 0 ? e * t : t;
              })
            );
          }),
          (e.prototype.elu = function (t) {
            Hl(t, "elu");
            for (
              var e = new Float32Array(t.size),
                n = this.readSync(t.dataId),
                r = 0;
              r < n.length;
              ++r
            ) {
              var i = n[r];
              e[r] = i >= 0 ? i : Math.exp(i) - 1;
            }
            return this.makeOutput(e, t.shape, "float32");
          }),
          (e.prototype.eluDer = function (t, e) {
            Hl([t, e], "eluDer");
            for (
              var n = new Float32Array(e.size),
                r = this.readSync(e.dataId),
                i = this.readSync(t.dataId),
                a = 0;
              a < r.length;
              ++a
            ) {
              var o = r[a];
              n[a] = o >= 1 ? i[a] : i[a] * (o + 1);
            }
            return this.makeOutput(n, e.shape, "float32");
          }),
          (e.prototype.selu = function (t) {
            Hl(t, "selu");
            for (
              var e = new Float32Array(t.size),
                n = this.readSync(t.dataId),
                r = 0;
              r < n.length;
              ++r
            ) {
              var i = n[r];
              e[r] =
                i >= 0
                  ? 1.0507009873554805 * i
                  : 1.7580993408473768 * (Math.exp(i) - 1);
            }
            return this.makeOutput(e, t.shape, "float32");
          }),
          (e.prototype.clip = function (t, e, n) {
            Hl(t, "clip");
            for (
              var r = new Float32Array(t.size),
                i = this.readSync(t.dataId),
                a = 0;
              a < i.length;
              ++a
            ) {
              var o = i[a];
              r[a] = o > n ? n : o < e ? e : o;
            }
            return this.makeOutput(r, t.shape, "float32");
          }),
          (e.prototype.abs = function (t) {
            for (
              var e = new Float32Array(t.size),
                n = this.readSync(t.dataId),
                r = 0;
              r < n.length;
              ++r
            )
              e[r] = Math.abs(n[r]);
            return this.makeOutput(e, t.shape, "float32");
          }),
          (e.prototype.complexAbs = function (t) {
            for (
              var e = new Float32Array(t.size),
                n = this.readSync(t.dataId),
                r = 0;
              r < t.size;
              ++r
            ) {
              var i = n[2 * r],
                a = n[2 * r + 1];
              e[r] = Math.hypot(i, a);
            }
            return this.makeOutput(e, t.shape, "float32");
          }),
          (e.prototype.int = function (t) {
            Hl(t, "int");
            for (
              var e = new Int32Array(t.size),
                n = this.readSync(t.dataId),
                r = 0;
              r < n.length;
              ++r
            )
              e[r] = n[r];
            return this.makeOutput(e, t.shape, "int32");
          }),
          (e.prototype.sigmoid = function (t) {
            Hl(t, "sigmoid");
            for (
              var e = new Float32Array(t.size),
                n = this.readSync(t.dataId),
                r = 0;
              r < n.length;
              ++r
            )
              e[r] = 1 / (1 + Math.exp(-n[r]));
            return this.makeOutput(e, t.shape, "float32");
          }),
          (e.prototype.softplus = function (t) {
            Hl(t, "softplus");
            for (
              var e = Math.log(1.1920928955078125e-7) + 2,
                n = new Float32Array(t.size),
                r = this.readSync(t.dataId),
                i = 0;
              i < r.length;
              ++i
            ) {
              var a,
                o = r[i] > -e,
                s = r[i] < e,
                u = Math.exp(r[i]);
              (a = s ? u : o ? r[i] : Math.log(1 + u)), (n[i] = a);
            }
            return this.makeOutput(n, t.shape, "float32");
          }),
          (e.prototype.sin = function (t) {
            Hl(t, "sin");
            for (
              var e = new Float32Array(t.size),
                n = this.readSync(t.dataId),
                r = 0;
              r < n.length;
              ++r
            )
              e[r] = Math.sin(n[r]);
            return this.makeOutput(e, t.shape, "float32");
          }),
          (e.prototype.cos = function (t) {
            Hl(t, "cos");
            for (
              var e = new Float32Array(t.size),
                n = this.readSync(t.dataId),
                r = 0;
              r < n.length;
              ++r
            )
              e[r] = Math.cos(n[r]);
            return this.makeOutput(e, t.shape, "float32");
          }),
          (e.prototype.tan = function (t) {
            Hl(t, "tan");
            for (
              var e = new Float32Array(t.size),
                n = this.readSync(t.dataId),
                r = 0;
              r < n.length;
              ++r
            )
              e[r] = Math.tan(n[r]);
            return this.makeOutput(e, t.shape, "float32");
          }),
          (e.prototype.asin = function (t) {
            Hl(t, "asin");
            for (
              var e = new Float32Array(t.size),
                n = this.readSync(t.dataId),
                r = 0;
              r < n.length;
              ++r
            )
              e[r] = Math.asin(n[r]);
            return this.makeOutput(e, t.shape, "float32");
          }),
          (e.prototype.acos = function (t) {
            Hl(t, "acos");
            for (
              var e = new Float32Array(t.size),
                n = this.readSync(t.dataId),
                r = 0;
              r < n.length;
              ++r
            )
              e[r] = Math.acos(n[r]);
            return this.makeOutput(e, t.shape, "float32");
          }),
          (e.prototype.atan = function (t) {
            Hl(t, "atan");
            for (
              var e = new Float32Array(t.size),
                n = this.readSync(t.dataId),
                r = 0;
              r < n.length;
              ++r
            )
              e[r] = Math.atan(n[r]);
            return this.makeOutput(e, t.shape, "float32");
          }),
          (e.prototype.atan2 = function (t, e) {
            return (
              Hl([t, e], "atan2"),
              this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
                return Math.atan2(t, e);
              })
            );
          }),
          (e.prototype.sinh = function (t) {
            Hl(t, "sinh");
            for (
              var e = new Float32Array(t.size),
                n = this.readSync(t.dataId),
                r = 0;
              r < n.length;
              ++r
            )
              e[r] = Math.sinh(n[r]);
            return this.makeOutput(e, t.shape, "float32");
          }),
          (e.prototype.cosh = function (t) {
            Hl(t, "cosh");
            for (
              var e = new Float32Array(t.size),
                n = this.readSync(t.dataId),
                r = 0;
              r < n.length;
              ++r
            )
              e[r] = Math.cosh(n[r]);
            return this.makeOutput(e, t.shape, "float32");
          }),
          (e.prototype.tanh = function (t) {
            Hl(t, "tanh");
            for (
              var e = new Float32Array(t.size),
                n = this.readSync(t.dataId),
                r = 0;
              r < n.length;
              ++r
            )
              e[r] = R(n[r]);
            return this.makeOutput(e, t.shape, "float32");
          }),
          (e.prototype.asinh = function (t) {
            Hl(t, "asinh");
            for (
              var e = new Float32Array(t.size),
                n = this.readSync(t.dataId),
                r = 0;
              r < n.length;
              ++r
            )
              e[r] = Math.asinh(n[r]);
            return this.makeOutput(e, t.shape, "float32");
          }),
          (e.prototype.acosh = function (t) {
            Hl(t, "acosh");
            for (
              var e = new Float32Array(t.size),
                n = this.readSync(t.dataId),
                r = 0;
              r < n.length;
              ++r
            )
              e[r] = Math.acosh(n[r]);
            return this.makeOutput(e, t.shape, "float32");
          }),
          (e.prototype.atanh = function (t) {
            Hl(t, "atanh");
            for (
              var e = new Float32Array(t.size),
                n = this.readSync(t.dataId),
                r = 0;
              r < n.length;
              ++r
            )
              e[r] = Math.atanh(n[r]);
            return this.makeOutput(e, t.shape, "float32");
          }),
          (e.prototype.erf = function (t) {
            Hl(t, "erf");
            for (
              var e = new Float32Array(t.size),
                n = this.readSync(t.dataId),
                r = 0;
              r < n.length;
              ++r
            ) {
              var i = Math.sign(n[r]),
                a = Math.abs(n[r]),
                o = 1 / (1 + 0.3275911 * a);
              e[r] =
                i *
                (1 -
                  ((((1.061405429 * o - 1.453152027) * o + 1.421413741) * o -
                    0.284496736) *
                    o +
                    0.254829592) *
                    o *
                    Math.exp(-a * a));
            }
            return this.makeOutput(e, t.shape, "float32");
          }),
          (e.prototype.step = function (t, e) {
            void 0 === e && (e = 0), Hl(t, "step");
            for (
              var n = new Float32Array(t.size),
                r = this.readSync(t.dataId),
                i = 0;
              i < r.length;
              ++i
            ) {
              var a = r[i];
              isNaN(a) ? (n[i] = NaN) : (n[i] = a > 0 ? 1 : e);
            }
            return this.makeOutput(n, t.shape, "float32");
          }),
          (e.prototype.fusedConv2d = function (t) {
            var e = t.input,
              n = t.filter,
              r = t.convInfo,
              i = t.bias,
              a = t.activation,
              o = t.preluActivationWeights,
              s = this.conv2d(e, n, r);
            return i && (s = this.add(s, i)), a && (s = ql(this, s, a, o)), s;
          }),
          (e.prototype.conv2d = function (t, e, n) {
            Hl([t, e], "conv2d");
            for (
              var r = n.filterHeight,
                i = n.filterWidth,
                a = n.dilationHeight,
                o = n.dilationWidth,
                s = n.padInfo.left,
                u = n.padInfo.top,
                c = "channelsLast" === n.dataFormat,
                l = Zn(n.outShape, t.dtype),
                p = t.strides[0],
                h = c ? t.strides[1] : t.strides[2],
                f = c ? t.strides[2] : 1,
                d = c ? 1 : t.strides[1],
                m = l.strides[0],
                v = c ? l.strides[1] : l.strides[2],
                g = c ? l.strides[2] : 1,
                y = c ? 1 : l.strides[1],
                b = this.readSync(t.dataId),
                w = this.readSync(e.dataId),
                x = l.values,
                C = 0;
              C < n.batchSize;
              ++C
            )
              for (var O = C * p, E = C * m, S = 0; S < n.outHeight; ++S)
                for (
                  var N = E + S * v, I = S * n.strideHeight - u, k = 0;
                  k < r;
                  k++
                ) {
                  var _ = I + k * a;
                  if (!(_ < 0 || _ >= n.inHeight))
                    for (
                      var A = k * e.strides[0], T = O + _ * h, R = 0;
                      R < n.outWidth;
                      ++R
                    )
                      for (
                        var D = N + R * g, F = R * n.strideWidth - s, M = 0;
                        M < i;
                        M++
                      ) {
                        var j = F + M * o;
                        if (!(j < 0 || j >= n.inWidth))
                          for (
                            var P = T + j * f, z = A + M * e.strides[1], L = 0;
                            L < n.inChannels;
                            ++L
                          ) {
                            for (
                              var B = b[P + L * d], W = 0;
                              W < n.outChannels;
                              ++W
                            )
                              x[D + W * y] += B * w[z + W];
                            z += n.outChannels;
                          }
                      }
                }
            return l.toTensor();
          }),
          (e.prototype.conv3d = function (t, e, n) {
            for (
              var r = n.filterDepth,
                i = n.filterHeight,
                a = n.filterWidth,
                o = n.dilationDepth,
                s = n.dilationHeight,
                u = n.dilationWidth,
                c = n.padInfo.front,
                l = n.padInfo.left,
                p = n.padInfo.top,
                h = Zn(n.outShape, t.dtype),
                f = this.readSync(t.dataId),
                d = this.readSync(e.dataId),
                m = h.values,
                v = 0;
              v < n.batchSize;
              ++v
            )
              for (
                var g = v * t.strides[0], y = v * h.strides[0], b = 0;
                b < n.outDepth;
                ++b
              )
                for (
                  var w = y + b * h.strides[1],
                    x = b * n.strideDepth - c,
                    C = 0;
                  C < r;
                  C++
                ) {
                  var O = x + C * o;
                  if (!(O < 0 || O >= n.inDepth))
                    for (
                      var E = C * e.strides[0], S = g + O * t.strides[1], N = 0;
                      N < n.outHeight;
                      ++N
                    )
                      for (
                        var I = w + N * h.strides[2],
                          k = N * n.strideHeight - p,
                          _ = 0;
                        _ < i;
                        _++
                      ) {
                        var A = k + _ * s;
                        if (!(A < 0 || A >= n.inHeight))
                          for (
                            var T = E + _ * e.strides[1],
                              R = S + A * t.strides[2],
                              D = 0;
                            D < n.outWidth;
                            ++D
                          )
                            for (
                              var F = I + D * n.outChannels,
                                M = D * n.strideWidth - l,
                                j = 0;
                              j < a;
                              j++
                            ) {
                              var P = M + j * u;
                              if (!(P < 0 || P >= n.inWidth))
                                for (
                                  var z = T + j * e.strides[2],
                                    L = R + P * n.inChannels,
                                    B = z,
                                    W = 0;
                                  W < n.inChannels;
                                  ++W
                                ) {
                                  for (
                                    var U = f[L + W], V = 0;
                                    V < n.outChannels;
                                    ++V
                                  )
                                    m[F + V] += U * d[B + V];
                                  B += n.outChannels;
                                }
                            }
                      }
                }
            return h.toTensor();
          }),
          (e.prototype.conv2dDerInput = function (t, e, n) {
            Hl([t, e], "conv2dDerInput");
            for (
              var r = Zn(n.inShape, "float32"),
                i = r.values,
                a = this.readSync(t.dataId),
                o = this.readSync(e.dataId),
                s = e.strides,
                u = s[0],
                c = s[1],
                l = s[2],
                p = n.batchSize,
                h = n.filterHeight,
                f = n.filterWidth,
                d = n.inChannels,
                m = n.inHeight,
                v = n.inWidth,
                g = n.outChannels,
                y = n.outHeight,
                b = n.outWidth,
                w = n.strideHeight,
                x = n.strideWidth,
                C = n.dataFormat,
                O = h - 1 - n.padInfo.top,
                E = f - 1 - n.padInfo.left,
                S = "channelsLast" === C,
                N = r.strides[0],
                I = S ? r.strides[1] : r.strides[2],
                k = S ? r.strides[2] : 1,
                _ = S ? 1 : r.strides[1],
                A = t.strides[0],
                T = S ? t.strides[1] : t.strides[2],
                R = S ? t.strides[2] : 1,
                D = S ? 1 : t.strides[1],
                F = 0;
              F < p;
              ++F
            )
              for (var M = 0; M < d; ++M)
                for (var j = 0; j < m; ++j)
                  for (
                    var P = j - O,
                      z = Math.max(0, Math.ceil(P / w)),
                      L = Math.min(y, (h + P) / w),
                      B = 0;
                    B < v;
                    ++B
                  ) {
                    for (
                      var W = B - E,
                        U = Math.max(0, Math.ceil(W / x)),
                        V = Math.min(b, (f + W) / x),
                        G = 0,
                        H = z;
                      H < L;
                      ++H
                    )
                      for (var q = H * w - P, K = U; K < V; ++K)
                        for (
                          var Z = A * F + T * H + R * K,
                            X =
                              u * (h - 1 - q) +
                              c * (f - 1 - (K * x - W)) +
                              l * M,
                            Y = 0;
                          Y < g;
                          ++Y
                        )
                          G += a[Z + D * Y] * o[X + Y];
                    i[N * F + I * j + k * B + _ * M] = G;
                  }
            return r.toTensor();
          }),
          (e.prototype.conv3dDerInput = function (t, e, n) {
            for (
              var r = Zn(n.inShape, "float32"),
                i = r.values,
                a = r.strides,
                o = a[0],
                s = a[1],
                u = a[2],
                c = a[3],
                l = this.readSync(t.dataId),
                p = t.strides,
                h = p[0],
                f = p[1],
                d = p[2],
                m = p[3],
                v = this.readSync(e.dataId),
                g = e.strides,
                y = g[0],
                b = g[1],
                w = g[2],
                x = g[3],
                C = n.batchSize,
                O = n.filterDepth,
                E = n.filterHeight,
                S = n.filterWidth,
                N = n.inChannels,
                I = n.inDepth,
                k = n.inHeight,
                _ = n.inWidth,
                A = n.outChannels,
                T = n.outDepth,
                R = n.outHeight,
                D = n.outWidth,
                F = n.strideDepth,
                M = n.strideHeight,
                j = n.strideWidth,
                P = O - 1 - n.padInfo.front,
                z = E - 1 - n.padInfo.top,
                L = S - 1 - n.padInfo.left,
                B = 0;
              B < C;
              ++B
            )
              for (var W = 0; W < N; ++W)
                for (var U = 0; U < I; ++U)
                  for (
                    var V = U - P,
                      G = Math.max(0, Math.ceil(V / F)),
                      H = Math.min(T, (O + V) / F),
                      q = 0;
                    q < k;
                    ++q
                  )
                    for (
                      var K = q - z,
                        Z = Math.max(0, Math.ceil(K / M)),
                        X = Math.min(R, (E + K) / M),
                        Y = 0;
                      Y < _;
                      ++Y
                    ) {
                      for (
                        var J = Y - L,
                          $ = Math.max(0, Math.ceil(J / j)),
                          Q = Math.min(D, (S + J) / j),
                          tt = 0,
                          et = G;
                        et < H;
                        ++et
                      )
                        for (var nt = et * F - V, rt = Z; rt < X; ++rt)
                          for (var it = rt * M - K, at = $; at < Q; ++at)
                            for (
                              var ot = h * B + f * et + d * rt + m * at,
                                st =
                                  y * (O - 1 - nt) +
                                  b * (E - 1 - it) +
                                  w * (S - 1 - (at * j - J)) +
                                  x * W,
                                ut = 0;
                              ut < A;
                              ++ut
                            )
                              tt += l[ot + ut] * v[st + ut];
                      i[o * B + s * U + u * q + c * Y + W] = tt;
                    }
            return r.toTensor();
          }),
          (e.prototype.conv2dDerFilter = function (t, e, n) {
            Hl([t, e], "conv2dDerFilter");
            for (
              var r = n.strideHeight,
                i = n.strideWidth,
                a = n.filterHeight,
                o = n.filterWidth,
                s = "channelsLast" === n.dataFormat,
                u = Zn(n.filterShape, "float32"),
                c = n.padInfo.left,
                l = n.padInfo.top,
                p = this.bufferSync(t),
                h = this.bufferSync(e),
                f = 0;
              f < a;
              ++f
            )
              for (
                var d = Math.max(0, Math.ceil((l - f) / r)),
                  m = Math.min(n.outHeight, (n.inHeight + l - f) / r),
                  v = 0;
                v < o;
                ++v
              )
                for (
                  var g = Math.max(0, Math.ceil((c - v) / i)),
                    y = Math.min(n.outWidth, (n.inWidth + c - v) / i),
                    b = 0;
                  b < n.inChannels;
                  ++b
                )
                  for (var w = 0; w < n.outChannels; ++w) {
                    for (var x = 0, C = 0; C < n.batchSize; ++C)
                      for (var O = d; O < m; ++O)
                        for (var E = f + O * r - l, S = g; S < y; ++S) {
                          var N = v + S * i - c;
                          x += s
                            ? p.get(C, E, N, b) * h.get(C, O, S, w)
                            : p.get(C, b, E, N) * h.get(C, w, O, S);
                        }
                    u.set(x, f, v, b, w);
                  }
            return u.toTensor();
          }),
          (e.prototype.conv3dDerFilter = function (t, e, n) {
            for (
              var r = n.strideDepth,
                i = n.strideHeight,
                a = n.strideWidth,
                o = n.filterDepth,
                s = n.filterHeight,
                u = n.filterWidth,
                c = Zn(n.filterShape, "float32"),
                l = c.values,
                p = c.strides,
                h = p[0],
                f = p[1],
                d = p[2],
                m = p[3],
                v = this.readSync(e.dataId),
                g = e.strides,
                y = g[0],
                b = g[1],
                w = g[2],
                x = g[3],
                C = this.readSync(t.dataId),
                O = t.strides,
                E = O[0],
                S = O[1],
                N = O[2],
                I = O[3],
                k = n.padInfo.front,
                _ = n.padInfo.left,
                A = n.padInfo.top,
                T = 0;
              T < o;
              ++T
            )
              for (
                var R = Math.max(0, Math.ceil((k - T) / r)),
                  D = Math.min(n.outDepth, (n.inDepth + k - T) / r),
                  F = T * h,
                  M = 0;
                M < s;
                ++M
              )
                for (
                  var j = Math.max(0, Math.ceil((A - M) / i)),
                    P = Math.min(n.outHeight, (n.inHeight + A - M) / i),
                    z = M * f + F,
                    L = 0;
                  L < u;
                  ++L
                )
                  for (
                    var B = Math.max(0, Math.ceil((_ - L) / a)),
                      W = Math.min(n.outWidth, (n.inWidth + _ - L) / a),
                      U = L * d + z,
                      V = 0;
                    V < n.inChannels;
                    ++V
                  )
                    for (var G = V * m + U, H = 0; H < n.outChannels; ++H) {
                      for (var q = 0, K = 0; K < n.batchSize; ++K)
                        for (var Z = K * E, X = K * y, Y = R; Y < D; ++Y)
                          for (
                            var J = (T + Y * r - k) * S + Z,
                              $ = Y * b + X,
                              Q = j;
                            Q < P;
                            ++Q
                          )
                            for (
                              var tt = (M + Q * i - A) * N + J,
                                et = Q * w + $,
                                nt = B;
                              nt < W;
                              ++nt
                            ) {
                              var rt = nt * x + et;
                              q += C[(L + nt * a - _) * I + tt + V] * v[rt + H];
                            }
                      l[G + H] = q;
                    }
            return c.toTensor();
          }),
          (e.prototype.fusedDepthwiseConv2D = function (t) {
            var e = t.input,
              n = t.filter,
              r = t.convInfo,
              i = t.bias,
              a = t.activation,
              o = t.preluActivationWeights,
              s = this.depthwiseConv2D(e, n, r);
            return i && (s = this.add(s, i)), a && (s = ql(this, s, a, o)), s;
          }),
          (e.prototype.depthwiseConv2D = function (t, e, n) {
            Hl([t, e], "depthwiseConv2D");
            for (
              var r = n.filterHeight,
                i = n.filterWidth,
                a = n.dilationHeight,
                o = n.dilationWidth,
                s = n.padInfo.left,
                u = n.padInfo.top,
                c = n.outChannels / n.inChannels,
                l = Zn(n.outShape, t.dtype),
                p = this.readSync(t.dataId),
                h = this.readSync(e.dataId),
                f = l.values,
                d = 0;
              d < n.batchSize;
              ++d
            )
              for (
                var m = d * t.strides[0], v = d * l.strides[0], g = 0;
                g < n.outHeight;
                ++g
              )
                for (
                  var y = v + g * l.strides[1],
                    b = g * n.strideHeight - s,
                    w = 0;
                  w < r;
                  ++w
                ) {
                  var x = b + w * a;
                  if (!(x < 0 || x >= n.inHeight))
                    for (
                      var C = w * e.strides[0], O = m + x * t.strides[1], E = 0;
                      E < n.outWidth;
                      ++E
                    )
                      for (
                        var S = y + E * l.strides[2],
                          N = E * n.strideWidth - u,
                          I = 0;
                        I < i;
                        ++I
                      ) {
                        var k = N + I * o;
                        if (!(k < 0 || k >= n.inWidth))
                          for (
                            var _ = C + I * e.strides[1],
                              A = O + k * n.inChannels,
                              T = S,
                              R = _,
                              D = 0;
                            D < n.inChannels;
                            ++D
                          ) {
                            for (var F = p[A + D], M = 0; M < c; ++M)
                              f[T + M] += F * h[R + M];
                            (T += c), (R += c);
                          }
                      }
                }
            return l.toTensor();
          }),
          (e.prototype.depthwiseConv2DDerInput = function (t, e, n) {
            Hl([t, e], "depthwiseConv2DDerInput");
            for (
              var r = Zn(n.inShape, "float32"),
                i = r.values,
                a = r.strides,
                o = a[0],
                s = a[1],
                u = a[2],
                c = this.readSync(t.dataId),
                l = t.strides,
                p = l[0],
                h = l[1],
                f = l[2],
                d = this.readSync(e.dataId),
                m = e.strides,
                v = m[0],
                g = m[1],
                y = m[2],
                b = n.batchSize,
                w = n.filterHeight,
                x = n.filterWidth,
                C = n.inChannels,
                O = n.inHeight,
                E = n.inWidth,
                S = n.outChannels,
                N = n.outHeight,
                I = n.outWidth,
                k = n.strideHeight,
                _ = n.strideWidth,
                A = w - 1 - n.padInfo.top,
                T = x - 1 - n.padInfo.left,
                R = S / C,
                D = 0;
              D < b;
              ++D
            )
              for (var F = 0; F < C; ++F)
                for (var M = 0; M < O; ++M)
                  for (
                    var j = M - A,
                      P = Math.max(0, Math.ceil(j / k)),
                      z = Math.min(N, (w + j) / k),
                      L = 0;
                    L < E;
                    ++L
                  ) {
                    for (
                      var B = L - T,
                        W = Math.max(0, Math.ceil(B / _)),
                        U = Math.min(I, (x + B) / _),
                        V = 0,
                        G = P;
                      G < z;
                      ++G
                    )
                      for (var H = G * k - j, q = W; q < U; ++q)
                        for (
                          var K = p * D + h * G + f * q,
                            Z =
                              v * (w - 1 - H) +
                              g * (x - 1 - (q * _ - B)) +
                              y * F,
                            X = 0;
                          X < R;
                          ++X
                        )
                          V += c[K + (F * R + X)] * d[Z + X];
                    i[o * D + s * M + u * L + F] = V;
                  }
            return r.toTensor();
          }),
          (e.prototype.depthwiseConv2DDerFilter = function (t, e, n) {
            Hl([t, e], "depthwiseConv2DDerFilter");
            for (
              var r = n.strideHeight,
                i = n.strideWidth,
                a = n.filterHeight,
                o = n.filterWidth,
                s = Zn(n.filterShape, "float32"),
                u = n.padInfo.left,
                c = n.padInfo.top,
                l = n.outChannels / n.inChannels,
                p = this.bufferSync(t),
                h = this.bufferSync(e),
                f = 0;
              f < a;
              ++f
            )
              for (
                var d = Math.max(0, Math.ceil((c - f) / r)),
                  m = Math.min(n.outHeight, (n.inHeight + c - f) / r),
                  v = 0;
                v < o;
                ++v
              )
                for (
                  var g = Math.max(0, Math.ceil((u - v) / i)),
                    y = Math.min(n.outWidth, (n.inWidth + u - v) / i),
                    b = 0;
                  b < n.outChannels;
                  ++b
                ) {
                  for (
                    var w = Math.trunc(b / l), x = b % l, C = 0, O = 0;
                    O < n.batchSize;
                    ++O
                  )
                    for (var E = d; E < m; ++E)
                      for (var S = f + E * r - c, N = g; N < y; ++N) {
                        var I = v + N * i - u;
                        C += p.get(O, S, I, w) * h.get(O, E, N, b);
                      }
                  s.set(C, f, v, w, x);
                }
            return s.toTensor();
          }),
          (e.prototype.tile = function (t, e) {
            return Hl(t, "tile"), Ci(this.bufferSync(t), e);
          }),
          (e.prototype.pad = function (t, e, n) {
            Hl(t, "pad");
            var r = e.map(function (e, n) {
                return e[0] + t.shape[n] + e[1];
              }),
              i = e.map(function (t) {
                return t[0];
              }),
              a = this.bufferSync(t),
              o = Zn(r, t.dtype);
            0 !== n && o.values.fill(n);
            for (var s = 0; s < t.size; s++) {
              var u = a.indexToLoc(s),
                c = u.map(function (t, e) {
                  return t + i[e];
                });
              o.set.apply(o, [a.get.apply(a, u)].concat(c));
            }
            return o.toTensor();
          }),
          (e.prototype.transpose = function (t, e) {
            Hl(t, "transpose");
            for (var n = new Array(t.rank), r = 0; r < n.length; r++)
              n[r] = t.shape[e[r]];
            var i = this.readSync(t.dataId),
              a = Zn(n, t.dtype),
              o = this.bufferSync(t);
            for (r = 0; r < t.size; ++r) {
              for (
                var s = o.indexToLoc(r), u = new Array(s.length), c = 0;
                c < u.length;
                c++
              )
                u[c] = s[e[c]];
              var l = a.locToIndex(u);
              a.values[l] = i[r];
            }
            return a.toTensor();
          }),
          (e.prototype.gather = function (t, e, n) {
            Hl([t, e], "gather");
            var r = t.shape.slice(),
              i = this.readSync(e.dataId);
            r[n] = i.length;
            for (
              var a = Zn(r, t.dtype), o = this.bufferSync(t), s = 0;
              s < a.size;
              ++s
            ) {
              var u = a.indexToLoc(s),
                c = u.slice();
              c[n] = i[u[n]];
              var l = o.locToIndex(c);
              a.values[s] = o.values[l];
            }
            return a.toTensor();
          }),
          (e.prototype.batchToSpaceND = function (t, e, n) {
            Hl([t], "batchToSpaceND");
            var r = e.reduce(function (t, e) {
                return t * e;
              }),
              i = Cr(t.shape, e, r),
              a = Or(i.length, e.length),
              o = Er(t.shape, e, r),
              s = Sr(n, e.length),
              u = Nr(o, n, e.length);
            return t.reshape(i).transpose(a).reshape(o).slice(s, u);
          }),
          (e.prototype.spaceToBatchND = function (t, e, n) {
            Hl([t], "spaceToBatchND");
            var r = e.reduce(function (t, e) {
                return t * e;
              }),
              i = [[0, 0]];
            i.push.apply(i, n);
            for (var a = 1 + e.length; a < t.shape.length; ++a) i.push([0, 0]);
            var o = t.pad(i),
              s = Cr(o.shape, e, r, !1),
              u = Or(s.length, e.length, !1),
              c = Er(o.shape, e, r, !1);
            return o.reshape(s).transpose(u).reshape(c);
          }),
          (e.prototype.pool = function (t, e, n) {
            Hl(t, "pool");
            for (
              var r = e.strideHeight,
                i = e.strideWidth,
                a = e.dilationHeight,
                o = e.dilationWidth,
                s = e.effectiveFilterHeight,
                u = e.effectiveFilterWidth,
                c = e.padInfo.top,
                l = e.padInfo.left,
                p =
                  "max" === n
                    ? Number.NEGATIVE_INFINITY
                    : Number.POSITIVE_INFINITY,
                h = this.readSync(t.dataId),
                f = Zn(e.outShape, t.dtype),
                d = f.values,
                m = e.outShape[1] * e.outShape[2] * e.outShape[3],
                v = e.outShape[2] * e.outShape[3],
                g = e.outShape[3],
                y = 0;
              y < e.batchSize;
              ++y
            )
              for (
                var b = y * m, w = y * t.strides[0], x = 0;
                x < e.inChannels;
                ++x
              )
                for (var C = 0; C < e.outHeight; ++C)
                  for (
                    var O = C * r - c,
                      E = Math.max(0, O),
                      S = Math.min(e.inHeight, s + O),
                      N = b + C * v,
                      I = 0;
                    I < e.outWidth;
                    ++I
                  ) {
                    for (
                      var k = I * i - l,
                        _ = Math.max(0, k),
                        A = Math.min(e.inWidth, u + k),
                        T = p,
                        R = 0,
                        D = 0,
                        F = E;
                      F < S;
                      F += a
                    ) {
                      for (var M = w + F * t.strides[1], j = _; j < A; j += o) {
                        var P = h[M + j * t.strides[2] + x];
                        "max" === n && P > T
                          ? (T = P)
                          : "avg" === n && ((R += P), D++);
                      }
                      if (isNaN(T)) break;
                    }
                    d[N + I * g + x] = "avg" === n ? R / D : T;
                  }
            return f.toTensor();
          }),
          (e.prototype.maxPool = function (t, e) {
            return this.pool(t, e, "max");
          }),
          (e.prototype.maxPoolPositions = function (t, e) {
            for (
              var n = Zn(e.outShape, "int32"),
                r = e.strideHeight,
                i = e.strideWidth,
                a = e.dilationHeight,
                o = e.dilationWidth,
                s = e.effectiveFilterHeight,
                u = e.effectiveFilterWidth,
                c = e.padInfo.top,
                l = e.padInfo.left,
                p = this.bufferSync(t),
                h = 0;
              h < e.batchSize;
              ++h
            )
              for (var f = 0; f < e.inChannels; ++f)
                for (var d = 0; d < e.outHeight; ++d) {
                  for (var m = d * r - c, v = m; v < 0; ) v += a;
                  for (
                    var g = Math.min(e.inHeight, s + m), y = 0;
                    y < e.outWidth;
                    ++y
                  ) {
                    for (var b = y * i - l, w = b; w < 0; ) w += o;
                    for (
                      var x = Math.min(e.inWidth, u + b),
                        C = Number.NEGATIVE_INFINITY,
                        O = -1,
                        E = v;
                      E < g;
                      E += a
                    )
                      for (var S = E - m, N = w; N < x; N += o) {
                        var I = N - b,
                          k = p.get(h, E, N, f);
                        k > C && ((C = k), (O = S * u + I));
                      }
                    n.set(O, h, d, y, f);
                  }
                }
            return n.toTensor();
          }),
          (e.prototype.maxPoolBackprop = function (t, e, n, r) {
            Hl([e, n], "maxPoolBackprop");
            for (
              var i = this.maxPoolPositions(e, r),
                a = r.strideHeight,
                o = r.strideWidth,
                s = r.dilationHeight,
                u = r.dilationWidth,
                c = r.effectiveFilterHeight,
                l = r.effectiveFilterWidth,
                p = l - 1 - r.padInfo.left,
                h = c - 1 - r.padInfo.top,
                f = Zn(e.shape, "float32"),
                d = this.bufferSync(i),
                m = this.bufferSync(t),
                v = 0;
              v < r.batchSize;
              ++v
            )
              for (var g = 0; g < r.inChannels; ++g)
                for (var y = 0; y < r.inHeight; ++y)
                  for (var b = 0; b < r.inWidth; ++b) {
                    for (
                      var w = y - h, x = b - p, C = 0, O = 0;
                      O < c;
                      O += s
                    ) {
                      var E = (w + O) / a;
                      if (!(E < 0 || E >= r.outHeight || Math.floor(E) !== E))
                        for (var S = 0; S < l; S += u) {
                          var N = (x + S) / o;
                          if (
                            !(N < 0 || N >= r.outWidth || Math.floor(N) !== N)
                          ) {
                            var I =
                              c * l - 1 - d.get(v, E, N, g) === O * l + S
                                ? 1
                                : 0;
                            0 !== I && (C += m.get(v, E, N, g) * I);
                          }
                        }
                    }
                    f.set(C, v, y, b, g);
                  }
            return f.toTensor();
          }),
          (e.prototype.avgPoolBackprop = function (t, e, n) {
            Hl([t, e], "avgPoolBackprop");
            for (
              var r = n.strideHeight,
                i = n.strideWidth,
                a = n.filterHeight,
                o = n.filterWidth,
                s = n.dilationHeight,
                u = n.dilationWidth,
                c = n.effectiveFilterHeight,
                l = n.effectiveFilterWidth,
                p = l - 1 - n.padInfo.left,
                h = c - 1 - n.padInfo.top,
                f = Zn(e.shape, "float32"),
                d = 1 / (a * o),
                m = this.bufferSync(t),
                v = 0;
              v < n.batchSize;
              ++v
            )
              for (var g = 0; g < n.inChannels; ++g)
                for (var y = 0; y < n.inHeight; ++y)
                  for (var b = 0; b < n.inWidth; ++b) {
                    for (
                      var w = y - h, x = b - p, C = 0, O = 0;
                      O < c;
                      O += s
                    ) {
                      var E = (w + O) / r;
                      if (!(E < 0 || E >= n.outHeight || Math.floor(E) !== E))
                        for (var S = 0; S < l; S += u) {
                          var N = (x + S) / i;
                          N < 0 ||
                            N >= n.outWidth ||
                            Math.floor(N) !== N ||
                            (C += m.get(v, E, N, g));
                        }
                    }
                    f.set(C * d, v, y, b, g);
                  }
            return f.toTensor();
          }),
          (e.prototype.pool3d = function (t, e, n) {
            Hl(t, "pool3d");
            for (
              var r = e.strideDepth,
                i = e.strideHeight,
                a = e.strideWidth,
                o = e.dilationDepth,
                s = e.dilationHeight,
                u = e.dilationWidth,
                c = e.effectiveFilterDepth,
                l = e.effectiveFilterHeight,
                p = e.effectiveFilterWidth,
                h = e.padInfo.front,
                f = e.padInfo.top,
                d = e.padInfo.left,
                m =
                  "max" === n
                    ? Number.NEGATIVE_INFINITY
                    : Number.POSITIVE_INFINITY,
                v = this.readSync(t.dataId),
                g = Zn(e.outShape, t.dtype),
                y = g.values,
                b =
                  e.outShape[1] * e.outShape[2] * e.outShape[3] * e.outShape[4],
                w = e.outShape[2] * e.outShape[3] * e.outShape[4],
                x = e.outShape[3] * e.outShape[4],
                C = e.outShape[4],
                O = 0;
              O < e.batchSize;
              ++O
            )
              for (
                var E = O * b, S = O * t.strides[0], N = 0;
                N < e.inChannels;
                ++N
              )
                for (var I = 0; I < e.outDepth; ++I) {
                  for (var k = I * r - h, _ = k; _ < 0; ) _ += o;
                  for (
                    var A = Math.min(e.inDepth, c + k), T = E + I * w, R = 0;
                    R < e.outHeight;
                    ++R
                  ) {
                    for (var D = R * i - f, F = D; F < 0; ) F += s;
                    for (
                      var M = Math.min(e.inHeight, l + D), j = T + R * x, P = 0;
                      P < e.outWidth;
                      ++P
                    ) {
                      for (var z = P * a - d, L = z; L < 0; ) L += u;
                      for (
                        var B = Math.min(e.inWidth, p + z),
                          W = j + P * C,
                          U = m,
                          V = 0,
                          G = 0,
                          H = _;
                        H < A;
                        H += o
                      ) {
                        for (
                          var q = S + H * t.strides[1], K = F;
                          K < M;
                          K += s
                        ) {
                          for (
                            var Z = q + K * t.strides[2], X = L;
                            X < B;
                            X += u
                          ) {
                            var Y = v[Z + X * t.strides[3] + N];
                            if (
                              ("max" === n && Y > U
                                ? (U = Y)
                                : "avg" === n && ((V += Y), G++),
                              isNaN(U))
                            )
                              break;
                          }
                          if (isNaN(U)) break;
                        }
                        if (isNaN(U)) break;
                      }
                      y[W + N] = "avg" === n ? V / G : U;
                    }
                  }
                }
            return g.toTensor();
          }),
          (e.prototype.avgPool3d = function (t, e) {
            return Hl(t, "avgPool3d"), this.pool3d(t, e, "avg").toFloat();
          }),
          (e.prototype.avgPool3dBackprop = function (t, e, n) {
            Hl([t, e], "avgPool3dBackprop");
            for (
              var r = n.strideDepth,
                i = n.strideHeight,
                a = n.strideWidth,
                o = n.filterDepth,
                s = n.filterHeight,
                u = n.filterWidth,
                c = n.dilationDepth,
                l = n.dilationHeight,
                p = n.dilationWidth,
                h = n.effectiveFilterDepth,
                f = n.effectiveFilterHeight,
                d = n.effectiveFilterWidth,
                m = h - 1 - n.padInfo.front,
                v = d - 1 - n.padInfo.left,
                g = f - 1 - n.padInfo.top,
                y = Zn(e.shape, "float32"),
                b = 1 / (o * s * u),
                w = this.bufferSync(t),
                x = 0;
              x < n.batchSize;
              ++x
            )
              for (var C = 0; C < n.inChannels; ++C)
                for (var O = 0; O < n.inDepth; ++O)
                  for (var E = 0; E < n.inHeight; ++E)
                    for (var S = 0; S < n.inWidth; ++S) {
                      for (
                        var N = O - m, I = E - g, k = S - v, _ = 0, A = 0;
                        A < h;
                        A += c
                      ) {
                        var T = (N + A) / r;
                        if (!(T < 0 || T >= n.outDepth || Math.floor(T) !== T))
                          for (var R = 0; R < f; R += l) {
                            var D = (I + R) / i;
                            if (
                              !(
                                D < 0 ||
                                D >= n.outHeight ||
                                Math.floor(D) !== D
                              )
                            )
                              for (var F = 0; F < d; F += p) {
                                var M = (k + F) / a;
                                M < 0 ||
                                  M >= n.outWidth ||
                                  Math.floor(M) !== M ||
                                  (_ += w.get(x, T, D, M, C));
                              }
                          }
                      }
                      y.set(_ * b, x, O, E, S, C);
                    }
            return y.toTensor();
          }),
          (e.prototype.maxPool3d = function (t, e) {
            return Hl(t, "maxPool3d"), this.pool3d(t, e, "max").toFloat();
          }),
          (e.prototype.maxPool3dPositions = function (t, e) {
            for (
              var n = Zn(e.outShape, "int32"),
                r = e.strideDepth,
                i = e.strideHeight,
                a = e.strideWidth,
                o = e.dilationDepth,
                s = e.dilationHeight,
                u = e.dilationWidth,
                c = e.effectiveFilterDepth,
                l = e.effectiveFilterHeight,
                p = e.effectiveFilterWidth,
                h = e.padInfo.front,
                f = e.padInfo.top,
                d = e.padInfo.left,
                m = this.bufferSync(t),
                v = 0;
              v < e.batchSize;
              ++v
            )
              for (var g = 0; g < e.inChannels; ++g)
                for (var y = 0; y < e.outDepth; ++y) {
                  for (var b = y * r - h, w = b; w < 0; ) w += o;
                  for (
                    var x = Math.min(e.inDepth, c + b), C = 0;
                    C < e.outHeight;
                    ++C
                  ) {
                    for (var O = C * i - f, E = O; E < 0; ) E += s;
                    for (
                      var S = Math.min(e.inHeight, l + O), N = 0;
                      N < e.outWidth;
                      ++N
                    ) {
                      for (var I = N * a - d, k = I; k < 0; ) k += u;
                      for (
                        var _ = Math.min(e.inWidth, p + I),
                          A = Number.NEGATIVE_INFINITY,
                          T = -1,
                          R = w;
                        R < x;
                        R += o
                      )
                        for (var D = R - b, F = E; F < S; F += s)
                          for (var M = F - O, j = k; j < _; j += u) {
                            var P = j - I,
                              z = m.get(v, R, F, j, g);
                            z >= A && ((A = z), (T = D * l * p + M * l + P));
                          }
                      n.set(T, v, y, C, N, g);
                    }
                  }
                }
            return n.toTensor();
          }),
          (e.prototype.maxPool3dBackprop = function (t, e, n, r) {
            Hl([e, n], "maxPool3dBackprop");
            for (
              var i = this.maxPool3dPositions(e, r),
                a = r.strideDepth,
                o = r.strideHeight,
                s = r.strideWidth,
                u = r.dilationDepth,
                c = r.dilationHeight,
                l = r.dilationWidth,
                p = r.effectiveFilterDepth,
                h = r.effectiveFilterHeight,
                f = r.effectiveFilterWidth,
                d = p - 1 - r.padInfo.front,
                m = f - 1 - r.padInfo.left,
                v = h - 1 - r.padInfo.top,
                g = Zn(e.shape, "float32"),
                y = this.bufferSync(i),
                b = this.bufferSync(t),
                w = 0;
              w < r.batchSize;
              ++w
            )
              for (var x = 0; x < r.inChannels; ++x)
                for (var C = 0; C < r.inDepth; ++C)
                  for (var O = 0; O < r.inHeight; ++O)
                    for (var E = 0; E < r.inWidth; ++E) {
                      for (
                        var S = C - d, N = O - v, I = E - m, k = 0, _ = 0;
                        _ < p;
                        _ += u
                      ) {
                        var A = (S + _) / a;
                        if (!(A < 0 || A >= r.outDepth || Math.floor(A) !== A))
                          for (var T = 0; T < h; T += c) {
                            var R = (N + T) / o;
                            if (
                              !(
                                R < 0 ||
                                R >= r.outHeight ||
                                Math.floor(R) !== R
                              )
                            )
                              for (var D = 0; D < f; D += l) {
                                var F = (I + D) / s;
                                if (
                                  !(
                                    F < 0 ||
                                    F >= r.outWidth ||
                                    Math.floor(F) !== F
                                  )
                                ) {
                                  var M =
                                    p * h * f - 1 - y.get(w, A, R, F, x) ===
                                    _ * h * f + T * f + D
                                      ? 1
                                      : 0;
                                  0 !== M && (k += b.get(w, A, R, F, x) * M);
                                }
                              }
                          }
                      }
                      g.set(k, w, C, O, E, x);
                    }
            return g.toTensor();
          }),
          (e.prototype.cast = function (t, e) {
            return oi(t, e, this);
          }),
          (e.prototype.reshape = function (t, e) {
            return si(t, e);
          }),
          (e.prototype.avgPool = function (t, e) {
            return Hl(t, "avgPool"), this.pool(t, e, "avg").toFloat();
          }),
          (e.prototype.resizeBilinear = function (t, e, n, r) {
            Hl(t, "resizeBilinear");
            for (
              var i = t.shape,
                a = i[0],
                o = i[1],
                s = i[2],
                u = i[3],
                c = this.readSync(t.dataId),
                l = new Float32Array(_([a, e, n, u])),
                p = [r && e > 1 ? o - 1 : o, r && n > 1 ? s - 1 : s],
                h = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n],
                f = 0,
                d = p[0] / h[0],
                m = p[1] / h[1],
                v = 0;
              v < a;
              v++
            )
              for (var g = 0; g < e; g++)
                for (
                  var y = d * g,
                    b = Math.floor(y),
                    w = y - b,
                    x = Math.min(o - 1, Math.ceil(y)),
                    C = v * t.strides[0] + b * t.strides[1],
                    O = v * t.strides[0] + x * t.strides[1],
                    E = 0;
                  E < n;
                  E++
                )
                  for (
                    var S = m * E,
                      N = Math.floor(S),
                      I = S - N,
                      k = Math.min(s - 1, Math.ceil(S)),
                      A = C + N * t.strides[2],
                      T = O + N * t.strides[2],
                      R = C + k * t.strides[2],
                      D = O + k * t.strides[2],
                      F = 0;
                    F < u;
                    F++
                  ) {
                    var M = c[A + F],
                      j = c[T + F],
                      P = M + (c[R + F] - M) * I,
                      z = P + (j + (c[D + F] - j) * I - P) * w;
                    l[f++] = z;
                  }
            return mn(l, [a, e, n, u]);
          }),
          (e.prototype.resizeBilinearBackprop = function (t, e, n) {
            Hl([t, e], "resizeBilinearBackprop");
            for (
              var r = e.shape,
                i = r[0],
                a = r[1],
                o = r[2],
                s = r[3],
                u = t.shape,
                c = u[1],
                l = u[2],
                p = new Float32Array(i * a * o * s),
                h = [n && c > 1 ? a - 1 : a, n && l > 1 ? o - 1 : o],
                f = [n && c > 1 ? c - 1 : c, n && l > 1 ? l - 1 : l],
                d = h[0] / f[0],
                m = h[1] / f[1],
                v = this.readSync(t.dataId),
                g = 0,
                y = 0;
              y < i;
              y++
            )
              for (var b = y * e.strides[0], w = 0; w < c; w++)
                for (
                  var x = w * d,
                    C = Math.floor(x),
                    O = Math.min(Math.ceil(x), a - 1),
                    E = b + C * e.strides[1],
                    S = b + O * e.strides[1],
                    N = x - C,
                    I = 1 - N,
                    k = 0;
                  k < l;
                  k++
                )
                  for (
                    var _ = k * m,
                      A = Math.floor(_),
                      T = Math.min(Math.ceil(_), o - 1),
                      R = _ - A,
                      D = 1 - R,
                      F = E + A * e.strides[2],
                      M = E + T * e.strides[2],
                      j = S + A * e.strides[2],
                      P = S + T * e.strides[2],
                      z = I * D,
                      L = I * R,
                      B = N * D,
                      W = N * R,
                      U = 0;
                    U < s;
                    U++
                  ) {
                    var V = v[g++];
                    (p[F + U] += V * z),
                      (p[M + U] += V * L),
                      (p[j + U] += V * B),
                      (p[P + U] += V * W);
                  }
            return xn(p, [i, o, a, s], e.dtype);
          }),
          (e.prototype.resizeNearestNeighbor = function (t, e, n, r) {
            Hl(t, "resizeNearestNeighbor");
            for (
              var i = t.shape,
                a = i[0],
                o = i[1],
                s = i[2],
                u = i[3],
                c = this.readSync(t.dataId),
                l = new Float32Array(a * e * n * u),
                p = [r && e > 1 ? o - 1 : o, r && n > 1 ? s - 1 : s],
                h = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n],
                f = p[0] / h[0],
                d = p[1] / h[1],
                m = 0,
                v = 0;
              v < a;
              v++
            )
              for (var g = v * t.strides[0], y = 0; y < e; y++)
                for (
                  var b = f * y,
                    w =
                      g +
                      Math.min(o - 1, r ? Math.round(b) : Math.floor(b)) *
                        t.strides[1],
                    x = 0;
                  x < n;
                  x++
                )
                  for (
                    var C = d * x,
                      O =
                        w +
                        Math.min(s - 1, r ? Math.round(C) : Math.floor(C)) *
                          t.strides[2],
                      E = 0;
                    E < u;
                    E++
                  ) {
                    var S = c[O + E];
                    l[m++] = S;
                  }
            return mn(l, [a, e, n, u], t.dtype);
          }),
          (e.prototype.resizeNearestNeighborBackprop = function (t, e, n) {
            Hl([t, e], "resizeNearestNeighborBackprop");
            for (
              var r = e.shape,
                i = r[0],
                a = r[1],
                o = r[2],
                s = r[3],
                u = t.shape,
                c = u[1],
                l = u[2],
                p = new Float32Array(i * a * o * s),
                h = this.readSync(t.dataId),
                f = [n && c > 1 ? a - 1 : a, n && l > 1 ? o - 1 : o],
                d = [n && c > 1 ? c - 1 : c, n && l > 1 ? l - 1 : l],
                m = f[0] / d[0],
                v = f[1] / d[1],
                g = 1 / m,
                y = 1 / v,
                b = 2 * Math.ceil(g) + 2,
                w = 2 * Math.ceil(y) + 2,
                x = 0;
              x < i;
              x++
            )
              for (var C = x * e.strides[0], O = 0; O < a; O++)
                for (
                  var E = C + O * e.strides[1],
                    S = Math.floor(O * g),
                    N = Math.floor(S - b / 2),
                    I = 0;
                  I < o;
                  I++
                )
                  for (
                    var k = E + I * e.strides[2],
                      _ = Math.floor(I * y),
                      A = Math.floor(_ - w / 2),
                      T = 0;
                    T < s;
                    T++
                  ) {
                    for (var R = 0, D = 0; D < b; D++) {
                      var F = D + N;
                      if (!(F < 0 || F >= c)) {
                        var M = C + F * t.strides[1],
                          j = F * m;
                        if (
                          O ===
                          Math.min(a - 1, n ? Math.round(j) : Math.floor(j))
                        )
                          for (var P = 0; P < w; P++) {
                            var z = P + A;
                            if (!(z < 0 || z >= l)) {
                              var L = M + z * t.strides[2],
                                B = z * v;
                              I ===
                                Math.min(
                                  o - 1,
                                  n ? Math.round(B) : Math.floor(B)
                                ) && (R += h[L + T]);
                            }
                          }
                      }
                    }
                    p[k + T] = R;
                  }
            return xn(p, e.shape, e.dtype);
          }),
          (e.prototype.batchNormalization = function (t, e, n, r, i, a) {
            Hl([t, e, n, i, a], "batchNorm");
            for (
              var o = this.readSync(t.dataId),
                s = this.readSync(e.dataId),
                u = this.readSync(n.dataId),
                c = i ? this.readSync(i.dataId) : new Float32Array([1]),
                l = a ? this.readSync(a.dataId) : new Float32Array([0]),
                p = new Float32Array(o.length),
                h = l.length,
                f = c.length,
                d = u.length,
                m = s.length,
                v = 0,
                g = 0,
                y = 0,
                b = 0,
                w = 0;
              w < o.length;
              ++w
            )
              (p[w] =
                l[v++] + ((o[w] - s[g++]) * c[y++]) / Math.sqrt(u[b++] + r)),
                v >= h && (v = 0),
                g >= m && (g = 0),
                y >= f && (y = 0),
                b >= d && (b = 0);
            return xn(p, t.shape);
          }),
          (e.prototype.localResponseNormalization4D = function (t, e, n, r, i) {
            Hl(t, "localResponseNormalization4D");
            var a = t.shape[3],
              o = a - 1,
              s = this.readSync(t.dataId),
              u = t.size,
              c = new Float32Array(u);
            function l(t) {
              for (
                var n = t % a,
                  r = t - n + Math.max(0, n - e),
                  i = t - n + Math.min(n + e, o),
                  u = 0;
                r <= i;
                r++
              ) {
                var c = s[r];
                u += c * c;
              }
              return u;
            }
            for (var p = 0; p < u; p++) {
              var h = l(p),
                f = s[p] * Math.pow(n + r * h, -i);
              c[p] = f;
            }
            return xn(c, t.shape);
          }),
          (e.prototype.LRNGrad = function (t, e, n, r, i, a, o) {
            Hl(t, "LRNGrad");
            for (
              var s = t.shape[3],
                u = this.readSync(t.dataId),
                c = this.readSync(e.dataId),
                l = this.readSync(n.dataId),
                p = new Float32Array(t.size),
                h = t.size,
                f = 0;
              f < h;
              f++
            ) {
              for (
                var d = f % s,
                  m = f - d + Math.max(0, d - r),
                  v = f - d + Math.min(s, d + r + 1),
                  g = 0,
                  y = m;
                y < v;
                y++
              )
                g += Math.pow(c[y], 2);
              for (g = a * g + i, y = m; y < v; y++) {
                var b = (-2 * a * o * c[y] * l[f]) / g;
                f === y && (b += Math.pow(g, -o)), (b *= u[f]), (p[y] += b);
              }
            }
            return xn(p, t.shape);
          }),
          (e.prototype.multinomial = function (t, e, n, r) {
            Hl(t, "multinomial");
            for (
              var i = e ? t : Br(t),
                a = i.shape[0],
                o = i.shape[1],
                s = En([a, n], "int32"),
                u = this.readSync(s.dataId),
                c = this.readSync(i.dataId),
                l = 0;
              l < a;
              ++l
            ) {
              var p = l * o,
                h = new Float32Array(o - 1);
              h[0] = c[p];
              for (var f = 1; f < h.length; ++f) h[f] = h[f - 1] + c[p + f];
              for (var d = Gn(r.toString()), m = l * n, v = 0; v < n; ++v) {
                var g = d();
                u[m + v] = h.length;
                for (var y = 0; y < h.length; y++)
                  if (g < h[y]) {
                    u[m + v] = y;
                    break;
                  }
              }
            }
            return s;
          }),
          (e.prototype.oneHot = function (t, e, n, r) {
            Hl(t, "oneHot");
            var i = new Float32Array(t.size * e);
            i.fill(r);
            for (var a = this.readSync(t.dataId), o = 0; o < t.size; ++o)
              a[o] >= 0 && a[o] < e && (i[o * e + a[o]] = n);
            return bn(i, [t.size, e], "int32");
          }),
          (e.prototype.nonMaxSuppression = function (t, e, n, r, i) {
            return (
              Hl(t, "nonMaxSuppression"),
              mi(this.readSync(t.dataId), this.readSync(e.dataId), n, r, i)
            );
          }),
          (e.prototype.fft = function (t) {
            return this.fftBatch(t, !1);
          }),
          (e.prototype.ifft = function (t) {
            return this.fftBatch(t, !0);
          }),
          (e.prototype.fftBatch = function (t, e) {
            for (
              var n = t.shape[0],
                r = t.shape[1],
                i = Zn(t.shape, "float32"),
                a = Zn(t.shape, "float32"),
                o = fn(t).as2D(n, r),
                s = dn(t).as2D(n, r),
                u = 0;
              u < n;
              u++
            )
              for (
                var c = o.slice([u, 0], [1, r]),
                  l = s.slice([u, 0], [1, r]),
                  p = hn(c, l),
                  h = this.readSync(this.fftImpl(p, e).dataId),
                  f = 0;
                f < r;
                f++
              ) {
                var d = li(h, f);
                (i.values[u * r + f] = d.real), (a.values[u * r + f] = d.imag);
              }
            return hn(i.toTensor(), a.toTensor()).as2D(n, r);
          }),
          (e.prototype.fftImpl = function (t, e) {
            var n = t.as1D(),
              r = n.size;
            if (this.isExponentOf2(r)) {
              var i = this.fftRadix2(n, r, e).as2D(t.shape[0], t.shape[1]);
              return e && (i = hn(fn(i).div(gn(r)), dn(i).div(gn(r)))), i;
            }
            var a = this.readSync(t.dataId),
              o = (function (t) {
                for (
                  var e = new Float32Array(t.length / 2),
                    n = new Float32Array(t.length / 2),
                    r = 0;
                  r < t.length;
                  r += 2
                )
                  (e[r / 2] = t[r]), (n[r / 2] = t[r + 1]);
                return { real: e, imag: n };
              })(this.fourierTransformByMatmul(a, r, e));
            return hn(o.real, o.imag).as2D(t.shape[0], t.shape[1]);
          }),
          (e.prototype.isExponentOf2 = function (t) {
            return 0 == (t & (t - 1));
          }),
          (e.prototype.fftRadix2 = function (t, e, n) {
            if (1 === e) return t;
            var r = this.readSync(t.dataId),
              i = e / 2,
              a = (function (t) {
                for (
                  var e = Math.ceil(t.length / 4),
                    n = new Float32Array(e),
                    r = new Float32Array(e),
                    i = 0;
                  i < t.length;
                  i += 4
                )
                  (n[Math.floor(i / 4)] = t[i]),
                    (r[Math.floor(i / 4)] = t[i + 1]);
                return { real: n, imag: r };
              })(r),
              o = hn(a.real, a.imag).as1D(),
              s = (function (t) {
                for (
                  var e = Math.floor(t.length / 4),
                    n = new Float32Array(e),
                    r = new Float32Array(e),
                    i = 2;
                  i < t.length;
                  i += 4
                )
                  (n[Math.floor(i / 4)] = t[i]),
                    (r[Math.floor(i / 4)] = t[i + 1]);
                return { real: n, imag: r };
              })(r),
              u = hn(s.real, s.imag).as1D();
            (o = this.fftRadix2(o, i, n)), (u = this.fftRadix2(u, i, n));
            var c = (function (t, e) {
                for (
                  var n = new Float32Array(t / 2),
                    r = new Float32Array(t / 2),
                    i = 0;
                  i < Math.ceil(t / 2);
                  i++
                ) {
                  var a = (e ? 2 : -2) * Math.PI * (i / t);
                  (n[i] = Math.cos(a)), (r[i] = Math.sin(a));
                }
                return { real: n, imag: r };
              })(e, n),
              l = hn(c.real, c.imag).mul(u),
              p = o.add(l),
              h = o.sub(l),
              f = fn(p).concat(fn(h)),
              d = dn(p).concat(dn(h));
            return hn(f, d).as1D();
          }),
          (e.prototype.fourierTransformByMatmul = function (t, e, n) {
            for (var r = new Float32Array(2 * e), i = 0; i < e; i++) {
              for (var a = 0, o = 0, s = 0; s < e; s++) {
                var u = hi(i * s, e, n),
                  c = li(t, s);
                (a += c.real * u.real - c.imag * u.imag),
                  (o += c.real * u.imag + c.imag * u.real);
              }
              n && ((a /= e), (o /= e)), pi(r, a, o, i);
            }
            return r;
          }),
          (e.prototype.depthToSpace = function (t, e, n) {
            S("NHWC" === n, function () {
              return (
                "Only NHWC dataFormat supported on CPU for depthToSpace. Got " +
                n
              );
            }),
              S(e > 1, function () {
                return (
                  "blockSize should be > 1 for depthToSpace, but was: " + e
                );
              });
            for (
              var r = t.shape[0],
                i = t.shape[1],
                a = t.shape[2],
                o = t.shape[3],
                s = i * e,
                u = a * e,
                c = o / (e * e),
                l = this.readSync(t.dataId),
                p = new Float32Array(r * s * u * c),
                h = 0,
                f = 0;
              f < r;
              ++f
            )
              for (var d = 0; d < s; ++d)
                for (var m = Math.floor(d / e), v = d % e, g = 0; g < u; ++g)
                  for (
                    var y = Math.floor(g / e), b = (v * e + (g % e)) * c, w = 0;
                    w < c;
                    ++w
                  ) {
                    var x = w + b + o * (y + a * (m + i * f));
                    p[h++] = l[x];
                  }
            return xn(p, [r, s, u, c]);
          }),
          (e.prototype.broadcastedBinaryOp = function (t, e, n, r) {
            var i = Kr(t.shape, e.shape),
              a = Zn(i, n),
              o = this.readSync(t.dataId),
              s = this.readSync(e.dataId),
              u = Hr(t.shape, i),
              c = Hr(e.shape, i),
              l = a.values;
            if (u.length + c.length === 0)
              for (var p = 0; p < l.length; ++p)
                l[p] = r(o[p % o.length], s[p % s.length]);
            else {
              var h = this.bufferSync(t),
                f = this.bufferSync(e),
                d = function (n) {
                  var i = a.indexToLoc(n),
                    p = i.slice(-t.rank);
                  u.forEach(function (t) {
                    return (p[t] = 0);
                  });
                  var d = h.locToIndex(p),
                    m = i.slice(-e.rank);
                  c.forEach(function (t) {
                    return (m[t] = 0);
                  });
                  var v = f.locToIndex(m);
                  l[n] = r(o[d], s[v]);
                };
              for (p = 0; p < l.length; ++p) d(p);
            }
            return a.toTensor();
          }),
          (e.prototype.broadcastedBinaryComplexOp = function (t, e, n) {
            var r = Kr(t.shape, e.shape),
              i = Zn(r, "float32"),
              a = Zn(r, "float32"),
              o = this.readSync(t.dataId),
              s = this.readSync(e.dataId),
              u = Hr(t.shape, r),
              c = Hr(e.shape, r),
              l = i.values,
              p = a.values;
            if (u.length + c.length === 0)
              for (var h = 0; h < l.length; h++) {
                var f = h % o.length,
                  d = h % s.length,
                  m = n(o[2 * f], o[2 * f + 1], s[2 * d], s[2 * d + 1]);
                (l[h] = m.real), (p[h] = m.imag);
              }
            else {
              var v = this.bufferSync(
                  this.data.get(t.dataId).complexTensors.real
                ),
                g = this.bufferSync(
                  this.data.get(e.dataId).complexTensors.real
                ),
                y = function (r) {
                  var a = i.indexToLoc(r),
                    h = a.slice(-t.rank);
                  u.forEach(function (t) {
                    return (h[t] = 0);
                  });
                  var f = v.locToIndex(h),
                    d = a.slice(-e.rank);
                  c.forEach(function (t) {
                    return (d[t] = 0);
                  });
                  var m = g.locToIndex(d),
                    y = n(o[2 * f], o[2 * f + 1], s[2 * m], s[2 * m + 1]);
                  (l[r] = y.real), (p[r] = y.imag);
                };
              for (h = 0; h < l.length; h++) y(h);
            }
            return this.complex(i.toTensor(), a.toTensor());
          }),
          (e.prototype.split = function (t, e, n) {
            return xi(t, e, n);
          }),
          (e.prototype.dispose = function () {}),
          (e.prototype.floatPrecision = function () {
            return 32;
          }),
          (e.prototype.epsilon = function () {
            return 1e-7;
          }),
          (e.prototype.cropAndResize = function (t, e, n, r, i, a) {
            for (
              var o = t.shape,
                s = o[0],
                u = o[1],
                c = o[2],
                l = o[3],
                p = e.shape[0],
                h = r[0],
                f = r[1],
                d = Zn([p, h, f, l], "float32"),
                m = this.readSync(e.dataId),
                v = this.readSync(n.dataId),
                g = this.readSync(t.dataId),
                y = t.strides,
                b = d.strides,
                w = 0;
              w < p;
              w++
            ) {
              var x = 4 * w,
                C = m[x],
                O = m[x + 1],
                E = m[x + 2],
                S = m[x + 3],
                N = v[w];
              if (!(N >= s))
                for (
                  var I = h > 1 ? ((E - C) * (u - 1)) / (h - 1) : 0,
                    k = f > 1 ? ((S - O) * (c - 1)) / (f - 1) : 0,
                    _ = 0;
                  _ < h;
                  _++
                ) {
                  var A = h > 1 ? C * (u - 1) + _ * I : 0.5 * (C + E) * (u - 1);
                  if (A < 0 || A > u - 1)
                    for (var T = 0; T < f; T++)
                      for (var R = 0; R < l; R++) {
                        var D = R + T * b[2] + _ * b[1] + w * b[0];
                        d.values[D] = a;
                      }
                  else if ("bilinear" === i) {
                    var F = Math.floor(A),
                      M = Math.ceil(A),
                      j = A - F;
                    for (T = 0; T < f; T++)
                      if (
                        (H =
                          f > 1
                            ? O * (c - 1) + T * k
                            : 0.5 * (O + S) * (c - 1)) < 0 ||
                        H > c - 1
                      )
                        for (R = 0; R < l; R++)
                          (D = R + T * b[2] + _ * b[1] + w * b[0]),
                            (d.values[D] = a);
                      else {
                        var P = Math.floor(H),
                          z = Math.ceil(H),
                          L = H - P;
                        for (R = 0; R < l; R++) {
                          var B = g[(D = R + P * y[2] + F * y[1] + N * y[0])],
                            W = g[(D = R + z * y[2] + F * y[1] + N * y[0])],
                            U = g[(D = R + P * y[2] + M * y[1] + N * y[0])],
                            V = B + (W - B) * L,
                            G =
                              U +
                              (g[(D = R + z * y[2] + M * y[1] + N * y[0])] -
                                U) *
                                L;
                          (D = R + T * b[2] + _ * b[1] + w * b[0]),
                            (d.values[D] = V + (G - V) * j);
                        }
                      }
                  } else
                    for (T = 0; T < f; ++T) {
                      var H;
                      if (
                        (H =
                          f > 1
                            ? O * (c - 1) + T * k
                            : 0.5 * (O + S) * (c - 1)) < 0 ||
                        H > c - 1
                      )
                        for (R = 0; R < l; R++)
                          (D = R + T * b[2] + _ * b[1] + w * b[0]),
                            (d.values[D] = a);
                      else {
                        var q = Math.round(H),
                          K = Math.round(A);
                        for (R = 0; R < l; R++) {
                          var Z = R + q * y[2] + K * y[1] + N * y[0],
                            X = R + T * b[2] + _ * b[1] + w * b[0];
                          d.values[X] = g[Z];
                        }
                      }
                    }
                }
            }
            return d.toTensor();
          }),
          (e.prototype.sparseToDense = function (t, e, n, r) {
            var i = Tr(0, t, n),
              a = i.sliceRank,
              o = i.numUpdates,
              s = i.sliceSize,
              u = i.strides,
              c = i.outputSize;
            return this.scatter(t, e, n, c, s, o, a, u, r, !1);
          }),
          (e.prototype.gatherND = function (t, e) {
            var n = e.shape,
              r = n[n.length - 1],
              i = Ir(t, e),
              a = i[0],
              o = i[1],
              s = i[2],
              u = i[3];
            if (0 === o) return mn([], a, t.dtype);
            for (
              var c = new vt([o, s], t.dtype),
                l = this.readSync(e.dataId),
                p = this.readSync(t.dataId),
                h = 0;
              h < o;
              h++
            ) {
              for (var f = [], d = 0, m = 0; m < r; m++) {
                var v = l[h * r + m];
                (d += v * u[m]), f.push(v);
              }
              if (d < 0 || d >= t.size / s)
                throw new Error(
                  "Invalid indices: " + f + " does not index into " + t.shape
                );
              for (var g = 0; g < s; g++) c.values[h * s + g] = p[d * s + g];
            }
            return c.toTensor().reshape(a);
          }),
          (e.prototype.scatterND = function (t, e, n) {
            var r = Tr(0, t, n),
              i = r.sliceRank,
              a = r.numUpdates,
              o = r.sliceSize,
              s = r.strides,
              u = r.outputSize,
              c = gn(0);
            return this.scatter(t, e, n, u, o, a, i, s, c, !0);
          }),
          (e.prototype.fill = function (t, e, n) {
            var r = B((n = n || Y(e)), _(t));
            return r.fill(e), Pt.makeTensor(r, t, n, this);
          }),
          (e.prototype.onesLike = function (t) {
            if ("string" === t.dtype)
              throw new Error("onesLike is not supported for string tensors");
            return this.fill(t.shape, 1, t.dtype);
          }),
          (e.prototype.zerosLike = function (t) {
            var e = B(t.dtype, _(t.shape));
            return this.makeOutput(e, t.shape, t.dtype);
          }),
          (e.prototype.linspace = function (t, e, n) {
            return ui(t, e, n);
          }),
          (e.prototype.scatter = function (t, e, n, r, i, a, o, s, u, c) {
            var l = [r / i, i],
              p = this.readSync(t.dataId),
              h = this.readSync(e.dataId);
            if (0 === r) return mn([], n, e.dtype);
            var f = new vt(l, e.dtype);
            f.values.fill(this.readSync(u.dataId)[0]);
            for (var d = 0; d < a; d++) {
              for (var m = [], v = 0, g = 0; g < o; g++) {
                var y = p[d * o + g];
                m.push(y), (v += y * s[g]);
              }
              if (v < 0 || v >= r / i)
                throw new Error(
                  "Invalid indices: " + m + " does not index into " + n
                );
              for (var b = 0; b < i; b++)
                c
                  ? (f.values[v * i + b] += h[d * i + b])
                  : (f.values[v * i + b] = 0 === e.rank ? h[0] : h[d * i + b]);
            }
            return f.toTensor().reshape(n);
          }),
          e
        );
      })(Vr);
      Pt.registerBackend(
        "cpu",
        function () {
          return new Kl();
        },
        1
      );
      for (
        var Zl = 0,
          Xl = [
            {
              kernelName: "NonMaxSuppressionV5",
              backendName: "cpu",
              kernelFunc: function (t) {
                var e = t.inputs,
                  n = t.backend,
                  r = t.attrs,
                  i = e,
                  a = i.boxes,
                  o = i.scores,
                  s = r,
                  u = s.maxOutputSize,
                  c = s.iouThreshold,
                  l = s.scoreThreshold,
                  p = s.softNmsSigma,
                  h = n;
                Hl(a, "NonMaxSuppressionWithScore");
                var f = vi(
                  h.data.get(a.dataId).values,
                  h.data.get(o.dataId).values,
                  u,
                  c,
                  l,
                  p
                );
                return [f.selectedIndices, f.selectedScores];
              },
            },
            {
              kernelName: "Square",
              backendName: "cpu",
              kernelFunc: function (t) {
                var e = t.inputs,
                  n = t.backend,
                  r = e.x,
                  i = n;
                Hl(r, "square");
                for (
                  var a = i.data.get(r.dataId).values,
                    o = new Float32Array(a.length),
                    s = 0;
                  s < a.length;
                  ++s
                ) {
                  var u = a[s];
                  o[s] = u * u;
                }
                return {
                  dataId: i.write(o, r.shape, r.dtype),
                  shape: r.shape,
                  dtype: r.dtype,
                };
              },
            },
            {
              kernelName: os,
              backendName: "cpu",
              kernelFunc: function (t) {
                var e = t.inputs,
                  n = t.backend,
                  r = e,
                  i = r.a,
                  a = r.b,
                  o = n;
                Hl([i, a], os);
                var s = o.data.get(i.dataId).values,
                  u = o.data.get(a.dataId).values,
                  c = (function (t, e, n, r, i, a) {
                    var o = Kr(t, e),
                      s = o.length,
                      u = Q(o),
                      c = L(i, _(o)),
                      l = t.length,
                      p = e.length,
                      h = Q(t),
                      f = Q(e),
                      d = Hr(t, o),
                      m = Hr(e, o);
                    if (d.length + m.length === 0)
                      for (var v = 0; v < c.length; ++v)
                        c[v] = a(n[v % n.length], r[v % r.length]);
                    else {
                      var g = function (t) {
                        var e = ct(t, s, u),
                          i = e.slice(-l);
                        d.forEach(function (t) {
                          return (i[t] = 0);
                        });
                        var o = ut(i, l, h),
                          v = e.slice(-p);
                        m.forEach(function (t) {
                          return (v[t] = 0);
                        });
                        var g = ut(v, p, f);
                        c[t] = a(n[o], r[g]);
                      };
                      for (v = 0; v < c.length; ++v) g(v);
                    }
                    return [c, o];
                  })(i.shape, a.shape, s, u, i.dtype, function (t, e) {
                    var n = t - e;
                    return n * n;
                  }),
                  l = c[0],
                  p = c[1];
                return {
                  dataId: o.write(l, p, i.dtype),
                  shape: p,
                  dtype: i.dtype,
                };
              },
            },
          ];
        Zl < Xl.length;
        Zl++
      )
        y(Xl[Zl]);
      for (
        var Yl,
          Jl = function (t) {
            this.variableNames = ["A"];
            var e = Ai(),
              n = t[0],
              r = t[1];
            (this.outputShape = t),
              (this.userCode =
                "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" +
                r +
                ".0, " +
                n +
                ".0);\n\n        vec4 values = " +
                e.texture2D +
                "(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ");
          },
          $l = function (t) {
            (this.variableNames = ["A"]),
              (this.packedInputs = !1),
              (this.packedOutput = !0);
            var e = Ai(),
              n = t[0],
              r = t[1];
            (this.outputShape = t),
              (this.userCode =
                "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(" +
                r +
                ".0, " +
                n +
                ".0);\n            vec4 values = " +
                e.texture2D +
                "(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        " +
                e.output +
                " = result;\n      }\n    ");
          },
          Ql = 0,
          tp = [
            {
              kernelName: "FromPixels",
              backendName: "webgl",
              kernelFunc: function (t) {
                var e = t.inputs,
                  n = t.backend,
                  r = t.attrs,
                  i = e.pixels,
                  a = r.numChannels,
                  o =
                    "undefined" != typeof HTMLVideoElement &&
                    i instanceof HTMLVideoElement,
                  s =
                    "undefined" != typeof HTMLImageElement &&
                    i instanceof HTMLImageElement,
                  u = o ? [i.videoWidth, i.videoHeight] : [i.width, i.height],
                  c = u[0],
                  l = u[1],
                  p = [l, c],
                  f = [l, c, a];
                (s || o) &&
                  (null == Yl &&
                    (Yl = document.createElement("canvas").getContext("2d")),
                  (Yl.canvas.width = c),
                  (Yl.canvas.height = l),
                  Yl.drawImage(i, 0, 0, c, l),
                  (i = Yl.canvas));
                var d = n.makeTensorInfo(p, "int32");
                (n.texData.get(d.dataId).usage = Wt.PIXELS),
                  n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId), i);
                var m = h().getBool("WEBGL_PACK") ? new $l(f) : new Jl(f),
                  v = n.runWebGLProgram(m, [d], "int32");
                return n.disposeData(d.dataId), v;
              },
            },
            {
              kernelName: "NonMaxSuppressionV5",
              backendName: "webgl",
              kernelFunc: function (t) {
                var e = t.inputs,
                  n = t.backend,
                  r = t.attrs;
                Xe(
                  "tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"
                );
                var i = e,
                  a = i.boxes,
                  o = i.scores,
                  s = r,
                  u = s.maxOutputSize,
                  c = s.iouThreshold,
                  l = s.scoreThreshold,
                  p = s.softNmsSigma,
                  h = n,
                  f = vi(
                    h.readSync(a.dataId),
                    h.readSync(o.dataId),
                    u,
                    c,
                    l,
                    p
                  );
                return [f.selectedIndices, f.selectedScores];
              },
            },
            {
              kernelName: "Square",
              backendName: "webgl",
              kernelFunc: function (t) {
                var e = t.inputs,
                  n = t.backend,
                  r = e.x,
                  i = n,
                  a = new Lo(r.shape, "return x * x;");
                return i.runWebGLProgram(a, [r], r.dtype);
              },
            },
            {
              kernelName: os,
              backendName: "webgl",
              kernelFunc: function (t) {
                var e = t.inputs,
                  n = t.backend,
                  r = e,
                  i = r.a,
                  a = r.b,
                  o = n,
                  s = h().getBool("WEBGL_PACK_BINARY_OPERATIONS")
                    ? new na("return (a - b) * (a - b);", i.shape, a.shape)
                    : new ta("return (a - b) * (a - b);", i.shape, a.shape);
                return o.compileAndRun(s, [i, a]);
              },
            },
          ];
        Ql < tp.length;
        Ql++
      )
        y(tp[Ql]);
      for (
        var ep = 0,
          np = [
            {
              kernelName: "Square",
              gradFunc: function (t, e) {
                var n = e[0];
                return {
                  x: function () {
                    return t.mul(n.toFloat().mul(2));
                  },
                };
              },
            },
            {
              kernelName: os,
              gradFunc: function (t, e) {
                var n = e[0],
                  r = e[1],
                  i = gn(2);
                return {
                  a: function () {
                    return Cu(t, Cu(i, Iu(n, r)));
                  },
                  b: function () {
                    return Cu(t, Cu(i, Iu(r, n)));
                  },
                };
              },
            },
          ];
        ep < np.length;
        ep++
      )
        b(np[ep]);
      var rp = (function () {
        function t() {}
        return (
          (t.prototype.fetch = function (t, e) {
            return fetch(t, e);
          }),
          (t.prototype.now = function () {
            return performance.now();
          }),
          (t.prototype.encode = function (t, e) {
            if ("utf-8" !== e && "utf8" !== e)
              throw new Error(
                "Browser's encoder only supports utf-8, but got " + e
              );
            return (
              null == this.textEncoder &&
                (this.textEncoder = new TextEncoder()),
              this.textEncoder.encode(t)
            );
          }),
          (t.prototype.decode = function (t, e) {
            return new TextDecoder(e).decode(t);
          }),
          t
        );
      })();
      h().get("IS_BROWSER") && h().setPlatform("browser", new rp());
      var ip,
        ap = (function () {
          function t() {
            (this.util = n(19)),
              (this.textEncoder = new this.util.TextEncoder());
          }
          return (
            (t.prototype.fetch = function (t, e) {
              return null != h().global.fetch
                ? h().global.fetch(t, e)
                : (null == ip && (ip = n(18)), ip(t, e));
            }),
            (t.prototype.now = function () {
              var t = r.hrtime();
              return 1e3 * t[0] + t[1] / 1e6;
            }),
            (t.prototype.encode = function (t, e) {
              if ("utf-8" !== e && "utf8" !== e)
                throw new Error(
                  "Node built-in encoder only supports utf-8, but got " + e
                );
              return this.textEncoder.encode(t);
            }),
            (t.prototype.decode = function (t, e) {
              return 0 === t.length
                ? ""
                : new this.util.TextDecoder(e).decode(t);
            }),
            t
          );
        })();
      h().get("IS_NODE") && h().setPlatform("node", new ap());
      var op = { float32: 4, int32: 4, uint16: 2, uint8: 1, bool: 1 };
      function sp(t, e) {
        for (
          var n = {},
            r = 0,
            i = function (e) {
              var i = e.name,
                a = e.dtype,
                o = e.shape,
                s = _(o),
                u = void 0;
              if (("quantization" in e)) {
                var c = e.quantization;
                if ("uint8" !== c.dtype && "uint16" !== c.dtype)
                  throw new Error(
                    "Weight " +
                      e.name +
                      " has unknown quantization dtype " +
                      c.dtype +
                      ". Supported quantization dtypes are: 'uint8' and 'uint16'."
                  );
                var l = op[c.dtype],
                  p = t.slice(r, r + s * l),
                  h =
                    "uint8" === c.dtype
                      ? new Uint8Array(p)
                      : new Uint16Array(p);
                if ("float32" === a)
                  u = Float32Array.from(h, function (t) {
                    return t * c.scale + c.min;
                  });
                else {
                  if ("int32" !== a)
                    throw new Error(
                      "Unsupported dtype in weight '" + i + "': " + a
                    );
                  u = Int32Array.from(h, function (t) {
                    return Math.round(t * c.scale + c.min);
                  });
                }
                r += s * l;
              } else if ("string" === a) {
                var f = _(e.shape);
                u = [];
                for (var d = 0; d < f; d++) {
                  var m = new Uint32Array(t.slice(r, r + 4))[0];
                  r += 4;
                  var v = new Uint8Array(t.slice(r, r + m));
                  u.push(v), (r += m);
                }
              } else {
                var g = op[a];
                if (((p = t.slice(r, r + s * g)), "float32" === a))
                  u = new Float32Array(p);
                else if ("int32" === a) u = new Int32Array(p);
                else {
                  if ("bool" !== a)
                    throw new Error(
                      "Unsupported dtype in weight '" + i + "': " + a
                    );
                  u = new Uint8Array(p);
                }
                r += s * g;
              }
              n[i] = mn(u, o, a);
            },
            a = 0,
            o = e;
          a < o.length;
          a++
        )
          i(o[a]);
        return n;
      }
      function up(t) {
        if (null === t)
          throw new Error("Invalid input value: " + JSON.stringify(t));
        var e = 0,
          n = [];
        t.forEach(function (t) {
          if (
            ((e += t.byteLength),
            n.push(
              t.byteLength === t.buffer.byteLength ? t : new t.constructor(t)
            ),
            !(
              t instanceof Float32Array ||
              t instanceof Int32Array ||
              t instanceof Uint8Array
            ))
          )
            throw new Error(
              "Unsupported TypedArray subtype: " + t.constructor.name
            );
        });
        var r = new Uint8Array(e),
          i = 0;
        return (
          n.forEach(function (t) {
            r.set(new Uint8Array(t.buffer), i), (i += t.byteLength);
          }),
          r.buffer
        );
      }
      var cp =
        void 0 !== i &&
        ("undefined" == typeof Blob ||
          "undefined" == typeof atob ||
          "undefined" == typeof btoa);
      function lp(t) {
        return cp ? i.byteLength(t) : new Blob([t]).size;
      }
      function pp(t) {
        var e = 0;
        t.forEach(function (t) {
          e += t.byteLength;
        });
        var n = new Uint8Array(e),
          r = 0;
        return (
          t.forEach(function (t) {
            n.set(new Uint8Array(t), r), (r += t.byteLength);
          }),
          n.buffer
        );
      }
      function hp(t) {
        for (t = t.trim(); t.endsWith("/"); ) t = t.slice(0, t.length - 1);
        var e = t.split("/");
        return e[e.length - 1];
      }
      function fp(t) {
        if (t.modelTopology instanceof ArrayBuffer)
          throw new Error(
            "Expected JSON model topology, received ArrayBuffer."
          );
        return {
          dateSaved: new Date(),
          modelTopologyType: "JSON",
          modelTopologyBytes:
            null == t.modelTopology ? 0 : lp(JSON.stringify(t.modelTopology)),
          weightSpecsBytes:
            null == t.weightSpecs ? 0 : lp(JSON.stringify(t.weightSpecs)),
          weightDataBytes: null == t.weightData ? 0 : t.weightData.byteLength,
        };
      }
      var dp = (function () {
          function t() {
            (this.saveRouters = []), (this.loadRouters = []);
          }
          return (
            (t.getInstance = function () {
              return null == t.instance && (t.instance = new t()), t.instance;
            }),
            (t.registerSaveRouter = function (e) {
              t.getInstance().saveRouters.push(e);
            }),
            (t.registerLoadRouter = function (e) {
              t.getInstance().loadRouters.push(e);
            }),
            (t.getSaveHandlers = function (e) {
              return t.getHandlers(e, "save");
            }),
            (t.getLoadHandlers = function (e, n) {
              return t.getHandlers(e, "load", n);
            }),
            (t.getHandlers = function (e, n, r) {
              var i = [];
              return (
                ("load" === n
                  ? t.getInstance().loadRouters
                  : t.getInstance().saveRouters
                ).forEach(function (t) {
                  var n = t(e, r);
                  null !== n && i.push(n);
                }),
                i
              );
            }),
            t
          );
        })(),
        mp = "://",
        vp = (function () {
          function t() {
            this.managers = {};
          }
          return (
            (t.getInstance = function () {
              return null == t.instance && (t.instance = new t()), t.instance;
            }),
            (t.registerManager = function (e, n) {
              S(null != e, function () {
                return "scheme must not be undefined or null.";
              }),
                e.endsWith(mp) && (e = e.slice(0, e.indexOf(mp))),
                S(e.length > 0, function () {
                  return "scheme must not be an empty string.";
                });
              var r = t.getInstance();
              S(null == r.managers[e], function () {
                return (
                  "A model store manager is already registered for scheme '" +
                  e +
                  "'."
                );
              }),
                (r.managers[e] = n);
            }),
            (t.getManager = function (t) {
              var e = this.getInstance().managers[t];
              if (null == e)
                throw new Error(
                  "Cannot find model manager for scheme '" + t + "'"
                );
              return e;
            }),
            (t.getSchemes = function () {
              return Object.keys(this.getInstance().managers);
            }),
            t
          );
        })();
      function gp(t) {
        if (-1 === t.indexOf(mp))
          throw new Error(
            "The url string provided does not contain a scheme. Supported schemes are: " +
              vp.getSchemes().join(",")
          );
        return { scheme: t.split(mp)[0], path: t.split(mp)[1] };
      }
      function yp(t, e, n) {
        return (
          void 0 === n && (n = !1),
          u(this, void 0, void 0, function () {
            var r, i, a, o, s, u, l, p, h;
            return c(this, function (c) {
              switch (c.label) {
                case 0:
                  return (
                    S(t !== e, function () {
                      return "Old path and new path are the same: '" + t + "'";
                    }),
                    S((r = dp.getLoadHandlers(t)).length > 0, function () {
                      return (
                        "Copying failed because no load handler is found for source URL " +
                        t +
                        "."
                      );
                    }),
                    S(r.length < 2, function () {
                      return (
                        "Copying failed because more than one (" +
                        r.length +
                        ") load handlers for source URL " +
                        t +
                        "."
                      );
                    }),
                    (i = r[0]),
                    S((a = dp.getSaveHandlers(e)).length > 0, function () {
                      return (
                        "Copying failed because no save handler is found for destination URL " +
                        e +
                        "."
                      );
                    }),
                    S(a.length < 2, function () {
                      return (
                        "Copying failed because more than one (" +
                        r.length +
                        ") save handlers for destination URL " +
                        e +
                        "."
                      );
                    }),
                    (o = a[0]),
                    (s = gp(t).scheme),
                    (u = gp(t).path),
                    (l = s === gp(t).scheme),
                    [4, i.load()]
                  );
                case 1:
                  return (
                    (p = c.sent()),
                    n && l ? [4, vp.getManager(s).removeModel(u)] : [3, 3]
                  );
                case 2:
                  c.sent(), (c.label = 3);
                case 3:
                  return [4, o.save(p)];
                case 4:
                  return (
                    (h = c.sent()),
                    !n || l ? [3, 6] : [4, vp.getManager(s).removeModel(u)]
                  );
                case 5:
                  c.sent(), (c.label = 6);
                case 6:
                  return [2, h.modelArtifactsInfo];
              }
            });
          })
        );
      }
      var bp = "models_store",
        wp = "model_info_store";
      function xp() {
        if (!h().getBool("IS_BROWSER"))
          throw new Error(
            "Failed to obtain IndexedDB factory because the current environmentis not a web browser."
          );
        var t = window || self,
          e =
            t.indexedDB ||
            t.mozIndexedDB ||
            t.webkitIndexedDB ||
            t.msIndexedDB ||
            t.shimIndexedDB;
        if (null == e)
          throw new Error(
            "The current browser does not appear to support IndexedDB."
          );
        return e;
      }
      function Cp(t) {
        var e = t.result;
        e.createObjectStore(bp, { keyPath: "modelPath" }),
          e.createObjectStore(wp, { keyPath: "modelPath" });
      }
      var Op = (function () {
          function t(t) {
            if (((this.indexedDB = xp()), null == t || !t))
              throw new Error(
                "For IndexedDB, modelPath must not be null, undefined or empty."
              );
            this.modelPath = t;
          }
          return (
            (t.prototype.save = function (t) {
              return u(this, void 0, void 0, function () {
                return c(this, function (e) {
                  if (t.modelTopology instanceof ArrayBuffer)
                    throw new Error(
                      "BrowserLocalStorage.save() does not support saving model topology in binary formats yet."
                    );
                  return [2, this.databaseAction(this.modelPath, t)];
                });
              });
            }),
            (t.prototype.load = function () {
              return u(this, void 0, void 0, function () {
                return c(this, function (t) {
                  return [2, this.databaseAction(this.modelPath)];
                });
              });
            }),
            (t.prototype.databaseAction = function (t, e) {
              var n = this;
              return new Promise(function (t, r) {
                var i = n.indexedDB.open("tensorflowjs", 1);
                (i.onupgradeneeded = function () {
                  return Cp(i);
                }),
                  (i.onsuccess = function () {
                    var a = i.result;
                    if (null == e) {
                      var o = a.transaction(bp, "readonly"),
                        s = o.objectStore(bp).get(n.modelPath);
                      (s.onsuccess = function () {
                        if (null == s.result)
                          return (
                            a.close(),
                            r(
                              new Error(
                                "Cannot find model with path '" +
                                  n.modelPath +
                                  "' in IndexedDB."
                              )
                            )
                          );
                        t(s.result.modelArtifacts);
                      }),
                        (s.onerror = function (t) {
                          return a.close(), r(s.error);
                        }),
                        (o.oncomplete = function () {
                          return a.close();
                        });
                    } else {
                      var u,
                        c = fp(e),
                        l = a.transaction(wp, "readwrite"),
                        p = l.objectStore(wp),
                        h = p.put({
                          modelPath: n.modelPath,
                          modelArtifactsInfo: c,
                        });
                      (h.onsuccess = function () {
                        var i = (u = a.transaction(bp, "readwrite"))
                          .objectStore(bp)
                          .put({
                            modelPath: n.modelPath,
                            modelArtifacts: e,
                            modelArtifactsInfo: c,
                          });
                        (i.onsuccess = function () {
                          return t({ modelArtifactsInfo: c });
                        }),
                          (i.onerror = function (t) {
                            var e = (p = l.objectStore(wp)).delete(n.modelPath);
                            (e.onsuccess = function () {
                              return a.close(), r(i.error);
                            }),
                              (e.onerror = function (t) {
                                return a.close(), r(i.error);
                              });
                          });
                      }),
                        (h.onerror = function (t) {
                          return a.close(), r(h.error);
                        }),
                        (l.oncomplete = function () {
                          null == u
                            ? a.close()
                            : (u.oncomplete = function () {
                                return a.close();
                              });
                        });
                    }
                  }),
                  (i.onerror = function (t) {
                    return r(i.error);
                  });
              });
            }),
            (t.URL_SCHEME = "indexeddb://"),
            t
          );
        })(),
        Ep = function (t) {
          return h().getBool("IS_BROWSER") &&
            !Array.isArray(t) &&
            t.startsWith(Op.URL_SCHEME)
            ? ((e = t.slice(Op.URL_SCHEME.length)), new Op(e))
            : null;
          var e;
        };
      dp.registerSaveRouter(Ep), dp.registerLoadRouter(Ep);
      var Sp = (function () {
        function t() {
          this.indexedDB = xp();
        }
        return (
          (t.prototype.listModels = function () {
            return u(this, void 0, void 0, function () {
              var t = this;
              return c(this, function (e) {
                return [
                  2,
                  new Promise(function (e, n) {
                    var r = t.indexedDB.open("tensorflowjs", 1);
                    (r.onupgradeneeded = function () {
                      return Cp(r);
                    }),
                      (r.onsuccess = function () {
                        var t = r.result,
                          i = t.transaction(wp, "readonly"),
                          a = i.objectStore(wp).getAll();
                        (a.onsuccess = function () {
                          for (
                            var t = {}, n = 0, r = a.result;
                            n < r.length;
                            n++
                          ) {
                            var i = r[n];
                            t[i.modelPath] = i.modelArtifactsInfo;
                          }
                          e(t);
                        }),
                          (a.onerror = function (e) {
                            return t.close(), n(a.error);
                          }),
                          (i.oncomplete = function () {
                            return t.close();
                          });
                      }),
                      (r.onerror = function (t) {
                        return n(r.error);
                      });
                  }),
                ];
              });
            });
          }),
          (t.prototype.removeModel = function (t) {
            return u(this, void 0, void 0, function () {
              var e = this;
              return c(this, function (n) {
                var r;
                return (
                  (t = (r = t).startsWith(Op.URL_SCHEME)
                    ? r.slice(Op.URL_SCHEME.length)
                    : r),
                  [
                    2,
                    new Promise(function (n, r) {
                      var i = e.indexedDB.open("tensorflowjs", 1);
                      (i.onupgradeneeded = function () {
                        return Cp(i);
                      }),
                        (i.onsuccess = function () {
                          var e,
                            a = i.result,
                            o = a.transaction(wp, "readwrite"),
                            s = o.objectStore(wp),
                            u = s.get(t);
                          (u.onsuccess = function () {
                            if (null == u.result)
                              return (
                                a.close(),
                                r(
                                  new Error(
                                    "Cannot find model with path '" +
                                      t +
                                      "' in IndexedDB."
                                  )
                                )
                              );
                            var i = s.delete(t),
                              o = function () {
                                var i = (e = a.transaction(bp, "readwrite"))
                                  .objectStore(bp)
                                  .delete(t);
                                (i.onsuccess = function () {
                                  return n(u.result.modelArtifactsInfo);
                                }),
                                  (i.onerror = function (t) {
                                    return r(u.error);
                                  });
                              };
                            (i.onsuccess = o),
                              (i.onerror = function (t) {
                                return o(), a.close(), r(u.error);
                              });
                          }),
                            (u.onerror = function (t) {
                              return a.close(), r(u.error);
                            }),
                            (o.oncomplete = function () {
                              null == e
                                ? a.close()
                                : (e.oncomplete = function () {
                                    return a.close();
                                  });
                            });
                        }),
                        (i.onerror = function (t) {
                          return r(i.error);
                        });
                    }),
                  ]
                );
              });
            });
          }),
          t
        );
      })();
      if (h().getBool("IS_BROWSER"))
        try {
          vp.registerManager(Op.URL_SCHEME, new Sp());
        } catch (o) {}
      var Np = "/",
        Ip = "tensorflowjs_models",
        kp = "info",
        _p = "model_topology",
        Ap = "weight_specs",
        Tp = "weight_data",
        Rp = "model_metadata";
      function Dp(t) {
        return {
          info: [Ip, t, kp].join(Np),
          topology: [Ip, t, _p].join(Np),
          weightSpecs: [Ip, t, Ap].join(Np),
          weightData: [Ip, t, Tp].join(Np),
          modelMetadata: [Ip, t, Rp].join(Np),
        };
      }
      function Fp(t) {
        var e = t.split(Np);
        if (e.length < 3) throw new Error("Invalid key format: " + t);
        return e.slice(1, e.length - 1).join(Np);
      }
      var Mp = (function () {
          function t(t) {
            if (
              !h().getBool("IS_BROWSER") ||
              "undefined" == typeof window ||
              void 0 === window.localStorage
            )
              throw new Error(
                "The current environment does not support local storage."
              );
            if (((this.LS = window.localStorage), null == t || !t))
              throw new Error(
                "For local storage, modelPath must not be null, undefined or empty."
              );
            (this.modelPath = t), (this.keys = Dp(this.modelPath));
          }
          return (
            (t.prototype.save = function (t) {
              return u(this, void 0, void 0, function () {
                var e, n, r;
                return c(this, function (a) {
                  if (t.modelTopology instanceof ArrayBuffer)
                    throw new Error(
                      "BrowserLocalStorage.save() does not support saving model topology in binary formats yet."
                    );
                  (e = JSON.stringify(t.modelTopology)),
                    (n = JSON.stringify(t.weightSpecs)),
                    (r = fp(t));
                  try {
                    return (
                      this.LS.setItem(this.keys.info, JSON.stringify(r)),
                      this.LS.setItem(this.keys.topology, e),
                      this.LS.setItem(this.keys.weightSpecs, n),
                      this.LS.setItem(
                        this.keys.weightData,
                        (function (t) {
                          if (cp) return i.from(t).toString("base64");
                          for (
                            var e = new Uint8Array(t),
                              n = "",
                              r = 0,
                              a = e.length;
                            r < a;
                            r++
                          )
                            n += String.fromCharCode(e[r]);
                          return btoa(n);
                        })(t.weightData)
                      ),
                      this.LS.setItem(
                        this.keys.modelMetadata,
                        JSON.stringify({
                          format: t.format,
                          generatedBy: t.generatedBy,
                          convertedBy: t.convertedBy,
                          userDefinedMetadata: t.userDefinedMetadata,
                        })
                      ),
                      [2, { modelArtifactsInfo: r }]
                    );
                  } catch (t) {
                    throw (
                      (this.LS.removeItem(this.keys.info),
                      this.LS.removeItem(this.keys.topology),
                      this.LS.removeItem(this.keys.weightSpecs),
                      this.LS.removeItem(this.keys.weightData),
                      this.LS.removeItem(this.keys.modelMetadata),
                      new Error(
                        "Failed to save model '" +
                          this.modelPath +
                          "' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=" +
                          r.modelTopologyBytes +
                          ", weightSpecsBytes=" +
                          r.weightSpecsBytes +
                          ", weightDataBytes=" +
                          r.weightDataBytes +
                          "."
                      ))
                    );
                  }
                  return [2];
                });
              });
            }),
            (t.prototype.load = function () {
              return u(this, void 0, void 0, function () {
                var t, e, n, r, a, o, s;
                return c(this, function (u) {
                  if (null == (t = JSON.parse(this.LS.getItem(this.keys.info))))
                    throw new Error(
                      "In local storage, there is no model with name '" +
                        this.modelPath +
                        "'"
                    );
                  if ("JSON" !== t.modelTopologyType)
                    throw new Error(
                      "BrowserLocalStorage does not support loading non-JSON model topology yet."
                    );
                  if (
                    ((e = {}),
                    null ==
                      (n = JSON.parse(this.LS.getItem(this.keys.topology))))
                  )
                    throw new Error(
                      "In local storage, the topology of model '" +
                        this.modelPath +
                        "' is missing."
                    );
                  if (
                    ((e.modelTopology = n),
                    null ==
                      (r = JSON.parse(this.LS.getItem(this.keys.weightSpecs))))
                  )
                    throw new Error(
                      "In local storage, the weight specs of model '" +
                        this.modelPath +
                        "' are missing."
                    );
                  if (
                    ((e.weightSpecs = r),
                    null != (a = this.LS.getItem(this.keys.modelMetadata)) &&
                      ((o = JSON.parse(a)),
                      (e.format = o.format),
                      (e.generatedBy = o.generatedBy),
                      (e.convertedBy = o.convertedBy),
                      (e.userDefinedMetadata = o.userDefinedMetadata)),
                    null == (s = this.LS.getItem(this.keys.weightData)))
                  )
                    throw new Error(
                      "In local storage, the binary weight values of model '" +
                        this.modelPath +
                        "' are missing."
                    );
                  return (
                    (e.weightData = (function (t) {
                      if (cp) {
                        var e = i.from(t, "base64");
                        return e.buffer.slice(
                          e.byteOffset,
                          e.byteOffset + e.byteLength
                        );
                      }
                      for (
                        var n = atob(t), r = new Uint8Array(n.length), a = 0;
                        a < n.length;
                        ++a
                      )
                        r.set([n.charCodeAt(a)], a);
                      return r.buffer;
                    })(s)),
                    [2, e]
                  );
                });
              });
            }),
            (t.URL_SCHEME = "localstorage://"),
            t
          );
        })(),
        jp = function (t) {
          return h().getBool("IS_BROWSER") &&
            !Array.isArray(t) &&
            t.startsWith(Mp.URL_SCHEME)
            ? ((e = t.slice(Mp.URL_SCHEME.length)), new Mp(e))
            : null;
          var e;
        };
      dp.registerSaveRouter(jp), dp.registerLoadRouter(jp);
      var Pp = (function () {
        function t() {
          S(h().getBool("IS_BROWSER"), function () {
            return "Current environment is not a web browser";
          }),
            S(
              "undefined" == typeof window || void 0 !== window.localStorage,
              function () {
                return "Current browser does not appear to support localStorage";
              }
            ),
            (this.LS = window.localStorage);
        }
        return (
          (t.prototype.listModels = function () {
            return u(this, void 0, void 0, function () {
              var t, e, n, r, i, a;
              return c(this, function (o) {
                for (
                  t = {}, e = Ip + Np, n = Np + kp, r = 0;
                  r < this.LS.length;
                  ++r
                )
                  (i = this.LS.key(r)).startsWith(e) &&
                    i.endsWith(n) &&
                    ((a = Fp(i)), (t[a] = JSON.parse(this.LS.getItem(i))));
                return [2, t];
              });
            });
          }),
          (t.prototype.removeModel = function (t) {
            return u(this, void 0, void 0, function () {
              var e, n;
              return c(this, function (r) {
                var i;
                if (
                  ((t = (i = t).startsWith(Mp.URL_SCHEME)
                    ? i.slice(Mp.URL_SCHEME.length)
                    : i),
                  (e = Dp(t)),
                  null == this.LS.getItem(e.info))
                )
                  throw new Error("Cannot find model at path '" + t + "'");
                return (
                  (n = JSON.parse(this.LS.getItem(e.info))),
                  this.LS.removeItem(e.info),
                  this.LS.removeItem(e.topology),
                  this.LS.removeItem(e.weightSpecs),
                  this.LS.removeItem(e.weightData),
                  [2, n]
                );
              });
            });
          }),
          t
        );
      })();
      if (h().getBool("IS_BROWSER"))
        try {
          vp.registerManager(Mp.URL_SCHEME, new Pp());
        } catch (o) {}
      function zp(t) {
        return new Promise(function (t) {
          return setTimeout(t);
        }).then(t);
      }
      var Lp = (function () {
          function t(e) {
            if (!h().getBool("IS_BROWSER"))
              throw new Error(
                "browserDownloads() cannot proceed because the current environment is not a browser."
              );
            e.startsWith(t.URL_SCHEME) && (e = e.slice(t.URL_SCHEME.length)),
              (null != e && 0 !== e.length) || (e = "model"),
              (this.modelTopologyFileName = e + ".json"),
              (this.weightDataFileName = e + ".weights.bin");
          }
          return (
            (t.prototype.save = function (t) {
              return u(this, void 0, void 0, function () {
                var e, n, r, i, a, o;
                return c(this, function (s) {
                  switch (s.label) {
                    case 0:
                      if ("undefined" == typeof document)
                        throw new Error(
                          "Browser downloads are not supported in this environment since `document` is not present"
                        );
                      if (
                        ((e = window.URL.createObjectURL(
                          new Blob([t.weightData], {
                            type: "application/octet-stream",
                          })
                        )),
                        !(t.modelTopology instanceof ArrayBuffer))
                      )
                        return [3, 1];
                      throw new Error(
                        "BrowserDownloads.save() does not support saving model topology in binary formats yet."
                      );
                    case 1:
                      return (
                        (n = [
                          {
                            paths: ["./" + this.weightDataFileName],
                            weights: t.weightSpecs,
                          },
                        ]),
                        (r = {
                          modelTopology: t.modelTopology,
                          format: t.format,
                          generatedBy: t.generatedBy,
                          convertedBy: t.convertedBy,
                          weightsManifest: n,
                        }),
                        (i = window.URL.createObjectURL(
                          new Blob([JSON.stringify(r)], {
                            type: "application/json",
                          })
                        )),
                        ((a =
                          null == this.jsonAnchor
                            ? document.createElement("a")
                            : this
                                .jsonAnchor).download = this.modelTopologyFileName),
                        (a.href = i),
                        [
                          4,
                          zp(function () {
                            return a.dispatchEvent(new MouseEvent("click"));
                          }),
                        ]
                      );
                    case 2:
                      return (
                        s.sent(),
                        null == t.weightData
                          ? [3, 4]
                          : (((o =
                              null == this.weightDataAnchor
                                ? document.createElement("a")
                                : this
                                    .weightDataAnchor).download = this.weightDataFileName),
                            (o.href = e),
                            [
                              4,
                              zp(function () {
                                return o.dispatchEvent(new MouseEvent("click"));
                              }),
                            ])
                      );
                    case 3:
                      s.sent(), (s.label = 4);
                    case 4:
                      return [2, { modelArtifactsInfo: fp(t) }];
                  }
                });
              });
            }),
            (t.URL_SCHEME = "downloads://"),
            t
          );
        })(),
        Bp = (function () {
          function t(t) {
            if (null == t || t.length < 1)
              throw new Error(
                "When calling browserFiles, at least 1 file is required, but received " +
                  t
              );
            this.files = t;
          }
          return (
            (t.prototype.load = function () {
              return u(this, void 0, void 0, function () {
                var t,
                  e,
                  n = this;
                return c(this, function (r) {
                  return (
                    (t = this.files[0]),
                    (e = this.files.slice(1)),
                    [
                      2,
                      new Promise(function (r, i) {
                        var a = new FileReader();
                        (a.onload = function (a) {
                          var o = JSON.parse(a.target.result),
                            s = o.modelTopology;
                          if (null != s) {
                            0 === e.length && r({ modelTopology: s });
                            var u = o.weightsManifest;
                            if (null != u) {
                              var c;
                              try {
                                c = n.checkManifestAndWeightFiles(u, e);
                              } catch (t) {
                                return void i(t);
                              }
                              var l = [],
                                p = [],
                                h = [];
                              u.forEach(function (t) {
                                t.paths.forEach(function (t) {
                                  p.push(t), h.push(null);
                                }),
                                  l.push.apply(l, t.weights);
                              }),
                                u.forEach(function (t) {
                                  t.paths.forEach(function (t) {
                                    var e = new FileReader();
                                    (e.onload = function (e) {
                                      var n = e.target.result,
                                        i = p.indexOf(t);
                                      (h[i] = n),
                                        -1 === h.indexOf(null) &&
                                          r({
                                            modelTopology: s,
                                            weightSpecs: l,
                                            weightData: pp(h),
                                            format: o.format,
                                            generatedBy: o.generatedBy,
                                            convertedBy: o.convertedBy,
                                            userDefinedMetadata:
                                              o.userDefinedMetadata,
                                          });
                                    }),
                                      (e.onerror = function (e) {
                                        return i(
                                          "Failed to weights data from file of path '" +
                                            t +
                                            "'."
                                        );
                                      }),
                                      e.readAsArrayBuffer(c[t]);
                                  });
                                });
                            } else
                              i(
                                new Error(
                                  "weightManifest field is missing from file " +
                                    t.name
                                )
                              );
                          } else
                            i(
                              new Error(
                                "modelTopology field is missing from file " +
                                  t.name
                              )
                            );
                        }),
                          (a.onerror = function (e) {
                            return i(
                              "Failed to read model topology and weights manifest JSON from file '" +
                                t.name +
                                "'. BrowserFiles supports loading Keras-style tf.Model artifacts only."
                            );
                          }),
                          a.readAsText(t);
                      }),
                    ]
                  );
                });
              });
            }),
            (t.prototype.checkManifestAndWeightFiles = function (t, e) {
              for (
                var n = [],
                  r = e.map(function (t) {
                    return hp(t.name);
                  }),
                  i = {},
                  a = 0,
                  o = t;
                a < o.length;
                a++
              )
                o[a].paths.forEach(function (t) {
                  var a = hp(t);
                  if (-1 !== n.indexOf(a))
                    throw new Error(
                      "Duplicate file basename found in weights manifest: '" +
                        a +
                        "'"
                    );
                  if ((n.push(a), -1 === r.indexOf(a)))
                    throw new Error(
                      "Weight file with basename '" + a + "' is not provided."
                    );
                  i[t] = e[r.indexOf(a)];
                });
              if (n.length !== e.length)
                throw new Error(
                  "Mismatch in the number of files in weights manifest (" +
                    n.length +
                    ") and the number of weight files provided (" +
                    e.length +
                    ")."
                );
              return i;
            }),
            t
          );
        })();
      function Wp(t, e, n, r) {
        !(function (t) {
          S(null != t && Array.isArray(t) && t.length > 0, function () {
            return "promises must be a none empty array";
          });
        })(t),
          (function (t, e) {
            S(t >= 0 && t <= 1, function () {
              return (
                "Progress fraction must be in range [0, 1], but got startFraction " +
                t
              );
            }),
              S(e >= 0 && e <= 1, function () {
                return (
                  "Progress fraction must be in range [0, 1], but got endFraction " +
                  e
                );
              }),
              S(e >= t, function () {
                return (
                  "startFraction must be no more than endFraction, but got startFraction " +
                  t +
                  " and endFraction " +
                  e
                );
              });
          })((n = null == n ? 0 : n), (r = null == r ? 1 : r));
        var i = 0;
        return Promise.all(
          t.map(function (a) {
            return (
              a.then(function (a) {
                var o = n + (++i / t.length) * (r - n);
                return e(o), a;
              }),
              a
            );
          })
        );
      }
      function Up(t, e) {
        return u(this, void 0, void 0, function () {
          var n, r, i, a, o, s, u, l, p;
          return c(this, function (c) {
            switch (c.label) {
              case 0:
                return (
                  null == e && (e = {}),
                  (n = null == e.fetchFunc ? h().platform.fetch : e.fetchFunc),
                  (r = t.map(function (t) {
                    return n(t, e.requestInit, { isBinary: !0 });
                  })),
                  (i = 0),
                  (a = 0.5),
                  null != e.onProgress ? [3, 2] : [4, Promise.all(r)]
                );
              case 1:
                return (o = c.sent()), [3, 4];
              case 2:
                return [4, Wp(r, e.onProgress, i, a)];
              case 3:
                (o = c.sent()), (c.label = 4);
              case 4:
                return (
                  (s = o.map(function (t) {
                    return t.arrayBuffer();
                  })),
                  (u = 0.5),
                  (l = 1),
                  null != e.onProgress ? [3, 6] : [4, Promise.all(s)]
                );
              case 5:
                return (p = c.sent()), [3, 8];
              case 6:
                return [4, Wp(s, e.onProgress, u, l)];
              case 7:
                (p = c.sent()), (c.label = 8);
              case 8:
                return [2, p];
            }
          });
        });
      }
      function Vp(t) {
        var e = this;
        return function (n, r, i) {
          return (
            void 0 === r && (r = ""),
            u(e, void 0, void 0, function () {
              var e, a, o, s, u, l, p, h, f, d;
              return c(this, function (c) {
                switch (c.label) {
                  case 0:
                    if (
                      ((e = n.map(function () {
                        return !1;
                      })),
                      (a = {}),
                      (o =
                        null != i
                          ? i.map(function () {
                              return !1;
                            })
                          : []),
                      (s = []),
                      n.forEach(function (t, n) {
                        var r = 0;
                        t.weights.forEach(function (t) {
                          var u =
                              "quantization" in t
                                ? t.quantization.dtype
                                : t.dtype,
                            c = op[u] * _(t.shape),
                            l = function () {
                              (e[n] = !0),
                                null == a[n] && (a[n] = []),
                                a[n].push({
                                  manifestEntry: t,
                                  groupOffset: r,
                                  sizeBytes: c,
                                });
                            };
                          null != i
                            ? i.forEach(function (e, n) {
                                e === t.name && (l(), (o[n] = !0));
                              })
                            : l(),
                            s.push(t.name),
                            (r += c);
                        });
                      }),
                      !o.every(function (t) {
                        return t;
                      }))
                    )
                      throw (
                        ((u = i.filter(function (t, e) {
                          return !o[e];
                        })),
                        new Error(
                          "Could not find weights in manifest with names: " +
                            u.join(", ") +
                            ". \nManifest JSON has weights with names: " +
                            s.join(", ") +
                            "."
                        ))
                      );
                    return (
                      (l = e.reduce(function (t, e, n) {
                        return e && t.push(n), t;
                      }, [])),
                      (p = []),
                      l.forEach(function (t) {
                        n[t].paths.forEach(function (t) {
                          var e = r + (r.endsWith("/") ? "" : "/") + t;
                          p.push(e);
                        });
                      }),
                      [4, t(p)]
                    );
                  case 1:
                    return (
                      (h = c.sent()),
                      (f = {}),
                      (d = 0),
                      l.forEach(function (t) {
                        for (
                          var e = n[t].paths.length, r = 0, i = 0;
                          i < e;
                          i++
                        )
                          r += h[d + i].byteLength;
                        for (
                          var o = new ArrayBuffer(r),
                            s = new Uint8Array(o),
                            u = 0,
                            c = 0;
                          c < e;
                          c++
                        ) {
                          var l = new Uint8Array(h[d + c]);
                          s.set(l, u), (u += l.byteLength);
                        }
                        a[t].forEach(function (t) {
                          var e = sp(
                            o.slice(t.groupOffset, t.groupOffset + t.sizeBytes),
                            [t.manifestEntry]
                          );
                          for (var n in e) f[n] = e[n];
                        }),
                          (d += e);
                      }),
                      [2, f]
                    );
                }
              });
            })
          );
        };
      }
      dp.registerSaveRouter(function (t) {
        return h().getBool("IS_BROWSER") &&
          !Array.isArray(t) &&
          t.startsWith(Lp.URL_SCHEME)
          ? (function (t) {
              return void 0 === t && (t = "model"), new Lp(t);
            })(t.slice(Lp.URL_SCHEME.length))
          : null;
      });
      var Gp = (function () {
        function t(t, e) {
          if (
            ((this.DEFAULT_METHOD = "POST"),
            null == e && (e = {}),
            (this.weightPathPrefix = e.weightPathPrefix),
            (this.onProgress = e.onProgress),
            null != e.fetchFunc
              ? (S("function" == typeof e.fetchFunc, function () {
                  return "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)";
                }),
                (this.fetch = e.fetchFunc))
              : (this.fetch = h().platform.fetch),
            S(null != t && t.length > 0, function () {
              return "URL path for http must not be null, undefined or empty.";
            }),
            Array.isArray(t) &&
              S(2 === t.length, function () {
                return (
                  "URL paths for http must have a length of 2, (actual length is " +
                  t.length +
                  ")."
                );
              }),
            (this.path = t),
            null != e.requestInit && null != e.requestInit.body)
          )
            throw new Error(
              "requestInit is expected to have no pre-existing body, but has one."
            );
          this.requestInit = e.requestInit || {};
        }
        return (
          (t.prototype.save = function (t) {
            return u(this, void 0, void 0, function () {
              var e, n, r, i;
              return c(this, function (a) {
                switch (a.label) {
                  case 0:
                    if (t.modelTopology instanceof ArrayBuffer)
                      throw new Error(
                        "BrowserHTTPRequest.save() does not support saving model topology in binary formats yet."
                      );
                    return (
                      ((e = Object.assign(
                        { method: this.DEFAULT_METHOD },
                        this.requestInit
                      )).body = new FormData()),
                      (n = [
                        {
                          paths: ["./model.weights.bin"],
                          weights: t.weightSpecs,
                        },
                      ]),
                      (r = {
                        modelTopology: t.modelTopology,
                        format: t.format,
                        generatedBy: t.generatedBy,
                        convertedBy: t.convertedBy,
                        userDefinedMetadata: t.userDefinedMetadata,
                        weightsManifest: n,
                      }),
                      e.body.append(
                        "model.json",
                        new Blob([JSON.stringify(r)], {
                          type: "application/json",
                        }),
                        "model.json"
                      ),
                      null != t.weightData &&
                        e.body.append(
                          "model.weights.bin",
                          new Blob([t.weightData], {
                            type: "application/octet-stream",
                          }),
                          "model.weights.bin"
                        ),
                      [4, this.fetch(this.path, e)]
                    );
                  case 1:
                    if ((i = a.sent()).ok)
                      return [2, { modelArtifactsInfo: fp(t), responses: [i] }];
                    throw new Error(
                      "BrowserHTTPRequest.save() failed due to HTTP response status " +
                        i.status +
                        "."
                    );
                }
              });
            });
          }),
          (t.prototype.load = function () {
            return u(this, void 0, void 0, function () {
              var t, e, n, r, i, a, o, s, u, l, p, h;
              return c(this, function (c) {
                switch (c.label) {
                  case 0:
                    return [4, this.fetch(this.path, this.requestInit)];
                  case 1:
                    if (!(t = c.sent()).ok)
                      throw new Error(
                        "Request to " +
                          this.path +
                          " failed with status code " +
                          t.status +
                          ". Please verify this URL points to the model JSON of the model to load."
                      );
                    c.label = 2;
                  case 2:
                    return c.trys.push([2, 4, , 5]), [4, t.json()];
                  case 3:
                    return (e = c.sent()), [3, 5];
                  case 4:
                    throw (
                      (c.sent(),
                      (n =
                        "Failed to parse model JSON of response from " +
                        this.path +
                        "."),
                      this.path.endsWith(".pb")
                        ? (n +=
                            " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.")
                        : (n +=
                            " Please make sure the server is serving valid JSON for this request."),
                      new Error(n))
                    );
                  case 5:
                    if (
                      ((r = e.modelTopology),
                      (i = e.weightsManifest),
                      (a = e.generatedBy),
                      (o = e.convertedBy),
                      (s = e.format),
                      (u = e.userDefinedMetadata),
                      null == r && null == i)
                    )
                      throw new Error(
                        "The JSON from HTTP path " +
                          this.path +
                          " contains neither model topology or manifest for weights."
                      );
                    return null == i ? [3, 7] : [4, this.loadWeights(i)];
                  case 6:
                    (h = c.sent()), (l = h[0]), (p = h[1]), (c.label = 7);
                  case 7:
                    return [
                      2,
                      {
                        modelTopology: r,
                        weightSpecs: l,
                        weightData: p,
                        userDefinedMetadata: u,
                        generatedBy: a,
                        convertedBy: o,
                        format: s,
                      },
                    ];
                }
              });
            });
          }),
          (t.prototype.loadWeights = function (t) {
            return u(this, void 0, void 0, function () {
              var e, n, r, i, a, o, s, u, l, p, h;
              return c(this, function (c) {
                switch (c.label) {
                  case 0:
                    for (
                      e = Array.isArray(this.path) ? this.path[1] : this.path,
                        n = (function (t) {
                          var e = t.lastIndexOf("/"),
                            n = t.lastIndexOf("?");
                          return [
                            t.substring(0, e) + "/",
                            n > e ? t.substring(n) : "",
                          ];
                        })(e),
                        r = n[0],
                        i = n[1],
                        a = this.weightPathPrefix || r,
                        o = [],
                        s = 0,
                        u = t;
                      s < u.length;
                      s++
                    )
                      (l = u[s]), o.push.apply(o, l.weights);
                    return (
                      (p = []),
                      t.forEach(function (t) {
                        t.paths.forEach(function (t) {
                          p.push(a + t + i);
                        });
                      }),
                      [
                        4,
                        Up(p, {
                          requestInit: this.requestInit,
                          fetchFunc: this.fetch,
                          onProgress: this.onProgress,
                        }),
                      ]
                    );
                  case 1:
                    return (h = c.sent()), [2, [o, pp(h)]];
                }
              });
            });
          }),
          (t.URL_SCHEME_REGEX = /^https?:\/\//),
          t
        );
      })();
      function Hp(t) {
        return null != t.match(Gp.URL_SCHEME_REGEX);
      }
      var qp = function (t, e) {
        return "undefined" == typeof fetch
          ? null
          : (
              Array.isArray(t)
                ? t.every(function (t) {
                    return Hp(t);
                  })
                : Hp(t)
            )
          ? Kp(t, { onProgress: e })
          : null;
      };
      function Kp(t, e) {
        return new Gp(t, e);
      }
      dp.registerSaveRouter(qp), dp.registerLoadRouter(qp);
      var Zp,
        Xp = (function () {
          function t(t) {
            this.modelArtifacts = t;
          }
          return (
            (t.prototype.load = function () {
              return u(this, void 0, void 0, function () {
                return c(this, function (t) {
                  return [2, this.modelArtifacts];
                });
              });
            }),
            t
          );
        })(),
        Yp = (function () {
          function t(t) {
            this.saveHandler = t;
          }
          return (
            (t.prototype.save = function (t) {
              return u(this, void 0, void 0, function () {
                return c(this, function (e) {
                  return [2, this.saveHandler(t)];
                });
              });
            }),
            t
          );
        })(),
        Jp = Object.freeze({
          browserFiles: function (t) {
            return new Bp(t);
          },
          browserHTTPRequest: function (t, e) {
            return Kp(t, e);
          },
          concatenateArrayBuffers: pp,
          decodeWeights: sp,
          encodeWeights: function (t, e) {
            return u(this, void 0, void 0, function () {
              var n,
                r,
                i,
                a,
                o,
                s = this;
              return c(this, function (l) {
                switch (l.label) {
                  case 0:
                    for (
                      n = [],
                        r = [],
                        i = Array.isArray(t)
                          ? t.map(function (t) {
                              return t.name;
                            })
                          : Object.keys(t),
                        a = function (a) {
                          var o = i[a],
                            l = Array.isArray(t) ? t[a].tensor : t[o];
                          if (
                            "float32" !== l.dtype &&
                            "int32" !== l.dtype &&
                            "bool" !== l.dtype &&
                            "string" !== l.dtype
                          )
                            throw new Error(
                              "Unsupported dtype in weight '" +
                                o +
                                "': " +
                                l.dtype
                            );
                          var p = { name: o, shape: l.shape, dtype: l.dtype };
                          if ("string" === l.dtype) {
                            var h = new Promise(function (t) {
                              return u(s, void 0, void 0, function () {
                                var e, n, r, i, a, o, s;
                                return c(this, function (u) {
                                  switch (u.label) {
                                    case 0:
                                      return [4, l.bytes()];
                                    case 1:
                                      for (
                                        e = u.sent(),
                                          n =
                                            e.reduce(function (t, e) {
                                              return t + e.length;
                                            }, 0) +
                                            4 * e.length,
                                          r = new Uint8Array(n),
                                          i = 0,
                                          a = 0;
                                        a < e.length;
                                        a++
                                      )
                                        (o = e[a]),
                                          (s = new Uint8Array(
                                            new Uint32Array([o.length]).buffer
                                          )),
                                          r.set(s, i),
                                          (i += 4),
                                          r.set(o, i),
                                          (i += o.length);
                                      return t(r), [2];
                                  }
                                });
                              });
                            });
                            r.push(h);
                          } else r.push(l.data());
                          null != e && (p.group = e), n.push(p);
                        },
                        o = 0;
                      o < i.length;
                      ++o
                    )
                      a(o);
                    return [4, Promise.all(r)];
                  case 1:
                    return [2, { data: up(l.sent()), specs: n }];
                }
              });
            });
          },
          fromMemory: function (t, e, n, r) {
            return 1 === arguments.length
              ? null != t.modelTopology || null != t.weightSpecs
                ? new Xp(t)
                : (console.warn(
                    "Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."
                  ),
                  new Xp({ modelTopology: t }))
              : (console.warn(
                  "Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."
                ),
                new Xp({
                  modelTopology: t,
                  weightSpecs: e,
                  weightData: n,
                  trainingConfig: r,
                }));
          },
          getLoadHandlers: function (t, e) {
            return dp.getLoadHandlers(t, e);
          },
          getModelArtifactsInfoForJSON: fp,
          getSaveHandlers: function (t) {
            return dp.getSaveHandlers(t);
          },
          http: Kp,
          isHTTPScheme: Hp,
          loadWeights: function (t, e, n, r) {
            return (
              void 0 === e && (e = ""),
              u(this, void 0, void 0, function () {
                return c(this, function (i) {
                  return [
                    2,
                    Vp(function (t) {
                      return Up(t, { requestInit: r });
                    })(t, e, n),
                  ];
                });
              })
            );
          },
          registerLoadRouter: function (t) {
            return dp.registerLoadRouter(t);
          },
          registerSaveRouter: function (t) {
            return dp.registerSaveRouter(t);
          },
          weightsLoaderFactory: Vp,
          withSaveHandler: function (t) {
            return new Yp(t);
          },
          copyModel: function (t, e) {
            return u(this, void 0, void 0, function () {
              return c(this, function (n) {
                return [2, yp(t, e, !1)];
              });
            });
          },
          listModels: function () {
            return u(this, void 0, void 0, function () {
              var t, e, n, r, i, a, o;
              return c(this, function (s) {
                switch (s.label) {
                  case 0:
                    (t = vp.getSchemes()),
                      (e = {}),
                      (n = 0),
                      (r = t),
                      (s.label = 1);
                  case 1:
                    return n < r.length
                      ? ((i = r[n]), [4, vp.getManager(i).listModels()])
                      : [3, 4];
                  case 2:
                    for (o in (a = s.sent())) e[i + mp + o] = a[o];
                    s.label = 3;
                  case 3:
                    return n++, [3, 1];
                  case 4:
                    return [2, e];
                }
              });
            });
          },
          moveModel: function (t, e) {
            return u(this, void 0, void 0, function () {
              return c(this, function (n) {
                return [2, yp(t, e, !0)];
              });
            });
          },
          removeModel: function (t) {
            return u(this, void 0, void 0, function () {
              var e;
              return c(this, function (n) {
                return (
                  (e = gp(t)), [2, vp.getManager(e.scheme).removeModel(e.path)]
                );
              });
            });
          },
        }),
        $p = pn({
          confusionMatrix_: function (t, e, n) {
            var r = $e(t, "labels", "confusionMatrix"),
              i = $e(e, "predictions", "confusionMatrix");
            S(null == n || (n > 0 && Number.isInteger(n)), function () {
              return (
                "If provided, numClasses must be a positive integer, but got " +
                n
              );
            }),
              S(1 === r.rank, function () {
                return "Expected the rank of labels to be 1, but got " + r.rank;
              }),
              S(1 === i.rank, function () {
                return (
                  "Expected the rank of predictions to be 1, but got " + i.rank
                );
              }),
              S(r.shape[0] === i.shape[0], function () {
                return (
                  "Mismatch in the number of examples: " +
                  r.shape[0] +
                  " vs. " +
                  i.shape[0] +
                  ". Labels and predictions should have the same number of elements."
                );
              }),
              S(n > 0 && Number.isInteger(n), function () {
                return (
                  "numClasses is required to be a positive integer, but got " +
                  n
                );
              });
            var a = ir(r.asType("int32"), n),
              o = ir(i.asType("int32"), n);
            return a.transpose().matMul(o).asType("int32");
          },
        }),
        Qp =
          (Object.freeze({ confusionMatrix: $p }),
          pn({
            fromPixels_: function (t, e) {
              if ((void 0 === e && (e = 3), e > 4))
                throw new Error(
                  "Cannot construct Tensor with more than 4 channels from pixels."
                );
              if (null == t)
                throw new Error(
                  "pixels passed to tf.browser.fromPixels() can not be null"
                );
              var n = !1,
                r = !1,
                i = !1,
                a = !1,
                o = !1;
              if (t.data instanceof Uint8Array) n = !0;
              else if (
                "undefined" != typeof ImageData &&
                t instanceof ImageData
              )
                r = !0;
              else if (
                "undefined" != typeof HTMLVideoElement &&
                t instanceof HTMLVideoElement
              )
                i = !0;
              else if (
                "undefined" != typeof HTMLImageElement &&
                t instanceof HTMLImageElement
              )
                a = !0;
              else {
                if (null == t.getContext)
                  throw new Error(
                    "pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was " +
                      t.constructor.name
                  );
                o = !0;
              }
              if (i && i && t.readyState < 2)
                throw new Error(
                  "The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element."
                );
              if (null != v("FromPixels", Pt.backendName))
                return Pt.runKernel(
                  "FromPixels",
                  { pixels: t },
                  { numChannels: e }
                );
              var s,
                u,
                c = i ? [t.videoWidth, t.videoHeight] : [t.width, t.height],
                l = c[0],
                p = c[1];
              if (
                (o
                  ? (s = t.getContext("2d").getImageData(0, 0, l, p).data)
                  : r || n
                  ? (s = t.data)
                  : (a || i) &&
                    (null == Zp &&
                      (Zp = document.createElement("canvas").getContext("2d")),
                    (Zp.canvas.width = l),
                    (Zp.canvas.height = p),
                    Zp.drawImage(t, 0, 0, l, p),
                    (s = Zp.getImageData(0, 0, l, p).data)),
                4 === e)
              )
                u = new Int32Array(s);
              else {
                var h = l * p;
                u = new Int32Array(h * e);
                for (var f = 0; f < h; f++)
                  for (var d = 0; d < e; ++d) u[f * e + d] = s[4 * f + d];
              }
              return wn(u, [p, l, e], "int32");
            },
          })),
        th = Object.freeze({
          toPixels: function (t, e) {
            return u(this, void 0, void 0, function () {
              var n,
                r,
                i,
                a,
                o,
                s,
                u,
                l,
                p,
                h,
                f,
                d,
                m,
                v,
                g,
                y,
                b,
                w,
                x,
                C,
                O,
                E,
                S;
              return c(this, function (c) {
                switch (c.label) {
                  case 0:
                    if (
                      ((n = $e(t, "img", "toPixels")),
                      t instanceof wt || (n = n.toInt()),
                      2 !== n.rank && 3 !== n.rank)
                    )
                      throw new Error(
                        "toPixels only supports rank 2 or 3 tensors, got rank " +
                          n.rank +
                          "."
                      );
                    if (
                      ((r = n.shape.slice(0, 2)),
                      (i = r[0]),
                      (a = r[1]),
                      (o = 2 === n.rank ? 1 : n.shape[2]) > 4 || 2 === o)
                    )
                      throw new Error(
                        "toPixels only supports depth of size 1, 3 or 4 but got " +
                          o
                      );
                    return [4, n.data()];
                  case 1:
                    return (
                      (s = c.sent()),
                      (u = n.min()),
                      (l = n.max()),
                      [4, Promise.all([u.data(), l.data()])]
                    );
                  case 2:
                    if (
                      ((p = c.sent()),
                      (h = p[0]),
                      (f = p[1]),
                      (d = h[0]),
                      (m = f[0]),
                      u.dispose(),
                      l.dispose(),
                      "float32" === n.dtype)
                    ) {
                      if (d < 0 || m > 1)
                        throw new Error(
                          "Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [" +
                            d +
                            " - " +
                            m +
                            "]."
                        );
                    } else {
                      if ("int32" !== n.dtype)
                        throw new Error(
                          "Unsupported type for toPixels: " +
                            n.dtype +
                            ". Please use float32 or int32 tensors."
                        );
                      if (d < 0 || m > 255)
                        throw new Error(
                          "Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [" +
                            d +
                            " - " +
                            m +
                            "]."
                        );
                    }
                    for (
                      v = "float32" === n.dtype ? 255 : 1,
                        g = new Uint8ClampedArray(a * i * 4),
                        y = 0;
                      y < i * a;
                      ++y
                    )
                      (b = void 0),
                        (w = void 0),
                        (x = void 0),
                        (C = void 0),
                        1 === o
                          ? ((b = s[y] * v),
                            (w = s[y] * v),
                            (x = s[y] * v),
                            (C = 255))
                          : 3 === o
                          ? ((b = s[3 * y] * v),
                            (w = s[3 * y + 1] * v),
                            (x = s[3 * y + 2] * v),
                            (C = 255))
                          : 4 === o &&
                            ((b = s[4 * y] * v),
                            (w = s[4 * y + 1] * v),
                            (x = s[4 * y + 2] * v),
                            (C = s[4 * y + 3] * v)),
                        (g[0 + (O = 4 * y)] = Math.round(b)),
                        (g[O + 1] = Math.round(w)),
                        (g[O + 2] = Math.round(x)),
                        (g[O + 3] = Math.round(C));
                    return (
                      null != e &&
                        ((e.width = a),
                        (e.height = i),
                        (E = e.getContext("2d")),
                        (S = new ImageData(g, a, i)),
                        E.putImageData(S, 0, 0)),
                      n !== t && n.dispose(),
                      [2, g]
                    );
                }
              });
            });
          },
          fromPixels: Qp,
        }),
        eh = (function () {
          function t() {}
          return (
            (t.prototype.getClassName = function () {
              return this.constructor.className;
            }),
            (t.fromConfig = function (t, e) {
              return new t(e);
            }),
            t
          );
        })(),
        nh = (function () {
          function t() {
            this.classNameMap = {};
          }
          return (
            (t.getMap = function () {
              return null == t.instance && (t.instance = new t()), t.instance;
            }),
            (t.register = function (e) {
              t.getMap().classNameMap[e.className] = [e, e.fromConfig];
            }),
            t
          );
        })();
      function rh(t) {
        S(null != t.className, function () {
          return "Class being registered does not have the static className property defined.";
        }),
          S("string" == typeof t.className, function () {
            return (
              "className is required to be a string, but got type " +
              typeof t.className
            );
          }),
          S(t.className.length > 0, function () {
            return "Class being registered has an empty-string as its className, which is disallowed.";
          }),
          nh.register(t);
      }
      var ih = Object.freeze({
        Serializable: eh,
        SerializationMap: nh,
        registerClass: rh,
      });
      function ah() {
        return 32 === Pt.backend.floatPrecision() ? 0.001 : 0.1;
      }
      function oh(t, e, n) {
        var r = !0;
        if (((G(t) || G(e)) && (r = !1), G(t) && G(e) && (r = !0), r)) {
          var i = t.constructor.name,
            a = e.constructor.name;
          if (i !== a)
            throw new Error(
              "Arrays are of different type. Actual: " + i + ". Expected: " + a
            );
        }
        if (Array.isArray(t) && Array.isArray(e)) {
          var o = Ye(t),
            s = Ye(e);
          if (!A(o, s))
            throw new Error(
              "Arrays have different shapes. Actual: [" +
                o +
                "]. Expected: [" +
                s +
                "]"
            );
        }
        var u = G(t) ? t : k(t),
          c = G(e) ? e : k(e);
        if (u.length !== c.length)
          throw new Error(
            "Arrays have different lengths actual: " +
              u.length +
              " vs expected: " +
              c.length +
              ".\nActual:   " +
              u +
              ".\nExpected: " +
              c +
              "."
          );
        for (var l = 0; l < c.length; ++l) {
          var p = u[l],
            h = c[l];
          if (!n(p, h))
            throw new Error(
              "Arrays differ: actual[" +
                l +
                "] = " +
                p +
                ", expected[" +
                l +
                "] = " +
                h +
                ".\nActual:   " +
                u +
                ".\nExpected: " +
                c +
                "."
            );
        }
      }
      function sh(t, e, n) {
        return (
          (!isFinite(t) && !isFinite(e)) ||
          !(isNaN(t) || isNaN(e) || Math.abs(t - e) > n)
        );
      }
      Object.freeze({
        TEST_EPSILON_FLOAT16: 0.1,
        expectArraysClose: function (t, e, n) {
          return (
            null == n && (n = ah()),
            oh(t, e, function (t, e) {
              return sh(t, e, n);
            })
          );
        },
        testEpsilon: ah,
        expectPromiseToFail: function (t, e) {
          t().then(
            function () {
              return e.fail();
            },
            function () {
              return e();
            }
          );
        },
        expectArraysEqual: function (t, e) {
          var n =
            "string" == typeof e ||
            "number" == typeof e ||
            "boolean" == typeof e
              ? [e]
              : e;
          return K(t) || K(t[0]) || K(e) || K(e[0])
            ? oh(t, n, function (t, e) {
                return t == e;
              })
            : oh(t, e, function (t, e) {
                return sh(t, e, 0);
              });
        },
        expectNumbersClose: function (t, e, n) {
          if ((null == n && (n = ah()), !sh(t, e, n)))
            throw new Error(
              "Numbers differ: actual === " + t + ", expected === " + e
            );
        },
        expectValuesInRange: function (t, e, n) {
          for (var r = 0; r < t.length; r++)
            if (t[r] < e || t[r] > n)
              throw new Error(
                "Value out of range:" + t[r] + " low: " + e + ", high: " + n
              );
        },
        expectArrayBuffersEqual: function (t, e) {
          expect(new Float32Array(t)).toEqual(new Float32Array(e));
        },
      });
      var uh = "1.7.0",
        ch =
          (Object.freeze({
            gpgpu_util: Ja,
            webgl_util: Be,
            forceHalfFloat: function () {
              h().set("WEBGL_FORCE_F16_TEXTURES", !0);
            },
            MathBackendWebGL: is,
            setWebGLContext: Ht,
            GPGPUContext: $a,
          }),
          (function (t) {
            function e() {
              return (null !== t && t.apply(this, arguments)) || this;
            }
            return (
              s(e, t),
              (e.prototype.minimize = function (t, e, n) {
                void 0 === e && (e = !1);
                var r = this.computeGradients(t, n),
                  i = r.value,
                  a = r.grads;
                if (null != n) {
                  var o = n.map(function (t) {
                    return { name: t.name, tensor: a[t.name] };
                  });
                  this.applyGradients(o);
                } else this.applyGradients(a);
                return qe(a), e ? i : (i.dispose(), null);
              }),
              Object.defineProperty(e.prototype, "iterations", {
                get: function () {
                  return (
                    null == this.iterations_ && (this.iterations_ = 0),
                    this.iterations_
                  );
                },
                enumerable: !0,
                configurable: !0,
              }),
              (e.prototype.incrementIterations = function () {
                this.iterations_ = this.iterations + 1;
              }),
              (e.prototype.computeGradients = function (t, e) {
                return (function (t, e) {
                  S(J(t), function () {
                    return "The f passed in variableGrads(f) must be a function";
                  }),
                    S(
                      null == e ||
                        (Array.isArray(e) &&
                          e.every(function (t) {
                            return t instanceof Nt;
                          })),
                      function () {
                        return "The varList passed in variableGrads(f, varList) must be an array of variables";
                      }
                    );
                  var n = null != e;
                  if (!n)
                    for (var r in ((e = []), Pt.registeredVariables))
                      e.push(Pt.registeredVariables[r]);
                  var i = n
                      ? e.filter(function (t) {
                          return !t.trainable;
                        })
                      : null,
                    a = e.length;
                  S(
                    (e = e.filter(function (t) {
                      return t.trainable;
                    })).length > 0,
                    function () {
                      return (
                        "variableGrads() expects at least one of the input variables to be trainable, but none of the " +
                        a +
                        " variables is trainable."
                      );
                    }
                  );
                  var o = Pt.gradients(t, e, null, !0),
                    s = o.value,
                    u = o.grads;
                  S(
                    u.some(function (t) {
                      return null != t;
                    }),
                    function () {
                      return "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().";
                    }
                  ),
                    S(0 === s.rank, function () {
                      return (
                        "The f passed in variableGrads(f) must return a scalar, but it returned a rank-" +
                        s.rank +
                        " tensor"
                      );
                    });
                  var c = {};
                  return (
                    e.forEach(function (t, e) {
                      null != u[e] && (c[t.name] = u[e]);
                    }),
                    null != i &&
                      i.forEach(function (t) {
                        return (c[t.name] = null);
                      }),
                    { value: s, grads: c }
                  );
                })(t, e);
              }),
              (e.prototype.dispose = function () {
                null != this.iterations_ && qe(this.iterations_);
              }),
              (e.prototype.saveIterations = function () {
                return u(this, void 0, void 0, function () {
                  return c(this, function (t) {
                    return (
                      null == this.iterations_ && (this.iterations_ = 0),
                      [
                        2,
                        { name: "iter", tensor: gn(this.iterations_, "int32") },
                      ]
                    );
                  });
                });
              }),
              (e.prototype.getWeights = function () {
                return u(this, void 0, void 0, function () {
                  return c(this, function (t) {
                    throw new Error(
                      "getWeights() is not implemented for this optimizer yet."
                    );
                  });
                });
              }),
              (e.prototype.setWeights = function (t) {
                return u(this, void 0, void 0, function () {
                  return c(this, function (t) {
                    throw new Error(
                      "setWeights() is not implemented for this optimizer class " +
                        this.getClassName()
                    );
                  });
                });
              }),
              (e.prototype.extractIterations = function (t) {
                return u(this, void 0, void 0, function () {
                  var e;
                  return c(this, function (n) {
                    switch (n.label) {
                      case 0:
                        return (e = this), [4, t[0].tensor.data()];
                      case 1:
                        return (e.iterations_ = n.sent()[0]), [2, t.slice(1)];
                    }
                  });
                });
              }),
              e
            );
          })(eh));
      Object.defineProperty(ch, Symbol.hasInstance, {
        value: function (t) {
          return (
            null != t.minimize &&
            null != t.computeGradients &&
            null != t.applyGradients
          );
        },
      });
      var lh = (function (t) {
        function e(e, n, r) {
          void 0 === r && (r = null);
          var i = t.call(this) || this;
          return (
            (i.learningRate = e),
            (i.rho = n),
            (i.epsilon = r),
            (i.accumulatedGrads = []),
            (i.accumulatedUpdates = []),
            null == r && (i.epsilon = Pt.backend.epsilon()),
            i
          );
        }
        return (
          s(e, t),
          (e.prototype.applyGradients = function (t) {
            var e = this;
            (Array.isArray(t)
              ? t.map(function (t) {
                  return t.name;
                })
              : Object.keys(t)
            ).forEach(function (n, r) {
              var i = Pt.registeredVariables[n];
              null == e.accumulatedGrads[r] &&
                (e.accumulatedGrads[r] = {
                  originalName: n + "/accum_grad",
                  variable: He(function () {
                    return _n(i).variable(!1);
                  }),
                }),
                null == e.accumulatedUpdates[r] &&
                  (e.accumulatedUpdates[r] = {
                    originalName: n + "/accum_var",
                    variable: He(function () {
                      return _n(i).variable(!1);
                    }),
                  });
              var a = Array.isArray(t) ? t[r].tensor : t[n];
              if (null != a) {
                var o = e.accumulatedGrads[r].variable,
                  s = e.accumulatedUpdates[r].variable;
                He(function () {
                  var t = o.mul(e.rho).add(a.square().mul(1 - e.rho)),
                    n = s
                      .add(e.epsilon)
                      .sqrt()
                      .div(o.add(e.epsilon).sqrt())
                      .mul(a),
                    r = s.mul(e.rho).add(n.square().mul(1 - e.rho));
                  o.assign(t), s.assign(r);
                  var u = n.mul(-e.learningRate).add(i);
                  i.assign(u);
                });
              }
            }),
              this.incrementIterations();
          }),
          (e.prototype.dispose = function () {
            null != this.accumulatedUpdates &&
              (qe(
                this.accumulatedGrads.map(function (t) {
                  return t.variable;
                })
              ),
              qe(
                this.accumulatedUpdates.map(function (t) {
                  return t.variable;
                })
              ));
          }),
          (e.prototype.getWeights = function () {
            return u(this, void 0, void 0, function () {
              var t;
              return c(this, function (e) {
                switch (e.label) {
                  case 0:
                    return (
                      (t = this.accumulatedGrads.concat(
                        this.accumulatedUpdates
                      )),
                      [4, this.saveIterations()]
                    );
                  case 1:
                    return [
                      2,
                      [e.sent()].concat(
                        t.map(function (t) {
                          return { name: t.originalName, tensor: t.variable };
                        })
                      ),
                    ];
                }
              });
            });
          }),
          (e.prototype.setWeights = function (t) {
            return u(this, void 0, void 0, function () {
              var e;
              return c(this, function (n) {
                switch (n.label) {
                  case 0:
                    return [4, this.extractIterations(t)];
                  case 1:
                    return (
                      (t = n.sent()),
                      (e = t.length / 2),
                      (this.accumulatedGrads = t.slice(0, e).map(function (t) {
                        return {
                          originalName: t.name,
                          variable: t.tensor.variable(!1),
                        };
                      })),
                      (this.accumulatedUpdates = t
                        .slice(e, 2 * e)
                        .map(function (t) {
                          return {
                            originalName: t.name,
                            variable: t.tensor.variable(!1),
                          };
                        })),
                      [2]
                    );
                }
              });
            });
          }),
          (e.prototype.getConfig = function () {
            return {
              learningRate: this.learningRate,
              rho: this.rho,
              epsilon: this.epsilon,
            };
          }),
          (e.fromConfig = function (t, e) {
            return new t(e.learningRate, e.rho, e.epsilon);
          }),
          (e.className = "Adadelta"),
          e
        );
      })(ch);
      rh(lh);
      var ph = (function (t) {
        function e(e, n) {
          void 0 === n && (n = 0.1);
          var r = t.call(this) || this;
          return (
            (r.learningRate = e),
            (r.initialAccumulatorValue = n),
            (r.accumulatedGrads = []),
            r
          );
        }
        return (
          s(e, t),
          (e.prototype.applyGradients = function (t) {
            var e = this;
            (Array.isArray(t)
              ? t.map(function (t) {
                  return t.name;
                })
              : Object.keys(t)
            ).forEach(function (n, r) {
              var i = Pt.registeredVariables[n];
              null == e.accumulatedGrads[r] &&
                (e.accumulatedGrads[r] = {
                  originalName: n + "/accumulator",
                  variable: He(function () {
                    return Sn(i.shape, e.initialAccumulatorValue).variable(!1);
                  }),
                });
              var a = Array.isArray(t) ? t[r].tensor : t[n];
              if (null != a) {
                var o = e.accumulatedGrads[r].variable;
                He(function () {
                  var t = o.add(a.square());
                  o.assign(t);
                  var n = a
                    .div(t.add(Pt.backend.epsilon()).sqrt())
                    .mul(-e.learningRate)
                    .add(i);
                  i.assign(n);
                });
              }
            }),
              this.incrementIterations();
          }),
          (e.prototype.dispose = function () {
            null != this.accumulatedGrads &&
              qe(
                this.accumulatedGrads.map(function (t) {
                  return t.variable;
                })
              );
          }),
          (e.prototype.getWeights = function () {
            return u(this, void 0, void 0, function () {
              return c(this, function (t) {
                switch (t.label) {
                  case 0:
                    return [4, this.saveIterations()];
                  case 1:
                    return [
                      2,
                      [t.sent()].concat(
                        this.accumulatedGrads.map(function (t) {
                          return { name: t.originalName, tensor: t.variable };
                        })
                      ),
                    ];
                }
              });
            });
          }),
          (e.prototype.setWeights = function (t) {
            return u(this, void 0, void 0, function () {
              return c(this, function (e) {
                switch (e.label) {
                  case 0:
                    return [4, this.extractIterations(t)];
                  case 1:
                    return (
                      (t = e.sent()),
                      (this.accumulatedGrads = t.map(function (t) {
                        return {
                          originalName: t.name,
                          variable: t.tensor.variable(!1),
                        };
                      })),
                      [2]
                    );
                }
              });
            });
          }),
          (e.prototype.getConfig = function () {
            return {
              learningRate: this.learningRate,
              initialAccumulatorValue: this.initialAccumulatorValue,
            };
          }),
          (e.fromConfig = function (t, e) {
            return new t(e.learningRate, e.initialAccumulatorValue);
          }),
          (e.className = "Adagrad"),
          e
        );
      })(ch);
      rh(ph);
      var hh = (function (t) {
        function e(e, n, r, i) {
          void 0 === i && (i = null);
          var a = t.call(this) || this;
          return (
            (a.learningRate = e),
            (a.beta1 = n),
            (a.beta2 = r),
            (a.epsilon = i),
            (a.accumulatedFirstMoment = []),
            (a.accumulatedSecondMoment = []),
            He(function () {
              (a.accBeta1 = gn(n).variable()), (a.accBeta2 = gn(r).variable());
            }),
            null == i && (a.epsilon = Pt.backend.epsilon()),
            a
          );
        }
        return (
          s(e, t),
          (e.prototype.applyGradients = function (t) {
            var e = this,
              n = Array.isArray(t)
                ? t.map(function (t) {
                    return t.name;
                  })
                : Object.keys(t);
            He(function () {
              var r = Iu(1, e.accBeta1),
                i = Iu(1, e.accBeta2);
              n.forEach(function (n, a) {
                var o = Pt.registeredVariables[n];
                null == e.accumulatedFirstMoment[a] &&
                  (e.accumulatedFirstMoment[a] = {
                    originalName: n + "/m",
                    variable: He(function () {
                      return _n(o).variable(!1);
                    }),
                  }),
                  null == e.accumulatedSecondMoment[a] &&
                    (e.accumulatedSecondMoment[a] = {
                      originalName: n + "/v",
                      variable: He(function () {
                        return _n(o).variable(!1);
                      }),
                    });
                var s = Array.isArray(t) ? t[a].tensor : t[n];
                if (null != s) {
                  var u = e.accumulatedFirstMoment[a].variable,
                    c = e.accumulatedSecondMoment[a].variable,
                    l = u.mul(e.beta1).add(s.mul(1 - e.beta1)),
                    p = c.mul(e.beta2).add(s.square().mul(1 - e.beta2)),
                    h = l.div(r),
                    f = p.div(i);
                  u.assign(l), c.assign(p);
                  var d = h
                    .div(f.sqrt().add(e.epsilon))
                    .mul(-e.learningRate)
                    .add(o);
                  o.assign(d);
                }
              }),
                e.accBeta1.assign(e.accBeta1.mul(e.beta1)),
                e.accBeta2.assign(e.accBeta2.mul(e.beta2));
            }),
              this.incrementIterations();
          }),
          (e.prototype.dispose = function () {
            this.accBeta1.dispose(),
              this.accBeta2.dispose(),
              null != this.accumulatedFirstMoment &&
                qe(
                  this.accumulatedFirstMoment.map(function (t) {
                    return t.variable;
                  })
                ),
              null != this.accumulatedSecondMoment &&
                qe(
                  this.accumulatedSecondMoment.map(function (t) {
                    return t.variable;
                  })
                );
          }),
          (e.prototype.getWeights = function () {
            return u(this, void 0, void 0, function () {
              var t;
              return c(this, function (e) {
                switch (e.label) {
                  case 0:
                    return (
                      (t = this.accumulatedFirstMoment.concat(
                        this.accumulatedSecondMoment
                      )),
                      [4, this.saveIterations()]
                    );
                  case 1:
                    return [
                      2,
                      [e.sent()].concat(
                        t.map(function (t) {
                          return { name: t.originalName, tensor: t.variable };
                        })
                      ),
                    ];
                }
              });
            });
          }),
          (e.prototype.setWeights = function (t) {
            return u(this, void 0, void 0, function () {
              var e,
                n = this;
              return c(this, function (r) {
                switch (r.label) {
                  case 0:
                    return [4, this.extractIterations(t)];
                  case 1:
                    return (
                      (t = r.sent()),
                      He(function () {
                        n.accBeta1.assign(Eu(n.beta1, n.iterations_ + 1)),
                          n.accBeta2.assign(Eu(n.beta2, n.iterations_ + 1));
                      }),
                      (e = t.length / 2),
                      (this.accumulatedFirstMoment = t
                        .slice(0, e)
                        .map(function (t) {
                          return {
                            originalName: t.name,
                            variable: t.tensor.variable(!1),
                          };
                        })),
                      (this.accumulatedSecondMoment = t
                        .slice(e, 2 * e)
                        .map(function (t) {
                          return {
                            originalName: t.name,
                            variable: t.tensor.variable(!1),
                          };
                        })),
                      [2]
                    );
                }
              });
            });
          }),
          (e.prototype.getConfig = function () {
            return {
              learningRate: this.learningRate,
              beta1: this.beta1,
              beta2: this.beta2,
              epsilon: this.epsilon,
            };
          }),
          (e.fromConfig = function (t, e) {
            return new t(e.learningRate, e.beta1, e.beta2, e.epsilon);
          }),
          (e.className = "Adam"),
          e
        );
      })(ch);
      rh(hh);
      var fh = (function (t) {
        function e(e, n, r, i, a) {
          void 0 === i && (i = null), void 0 === a && (a = 0);
          var o = t.call(this) || this;
          return (
            (o.learningRate = e),
            (o.beta1 = n),
            (o.beta2 = r),
            (o.epsilon = i),
            (o.decay = a),
            (o.accumulatedFirstMoment = []),
            (o.accumulatedWeightedInfNorm = []),
            He(function () {
              (o.iteration = gn(0).variable()), (o.accBeta1 = gn(n).variable());
            }),
            null == i && (o.epsilon = Pt.backend.epsilon()),
            o
          );
        }
        return (
          s(e, t),
          (e.prototype.applyGradients = function (t) {
            var e = this,
              n = Array.isArray(t)
                ? t.map(function (t) {
                    return t.name;
                  })
                : Object.keys(t);
            He(function () {
              var r = Iu(1, e.accBeta1),
                i = hu(-e.learningRate, e.iteration.mul(e.decay).add(1));
              n.forEach(function (n, a) {
                var o = Pt.registeredVariables[n];
                null == e.accumulatedFirstMoment[a] &&
                  (e.accumulatedFirstMoment[a] = {
                    originalName: n + "/m",
                    variable: _n(o).variable(!1),
                  }),
                  null == e.accumulatedWeightedInfNorm[a] &&
                    (e.accumulatedWeightedInfNorm[a] = {
                      originalName: n + "/v",
                      variable: _n(o).variable(!1),
                    });
                var s = Array.isArray(t) ? t[a].tensor : t[n];
                if (null != s) {
                  var u = e.accumulatedFirstMoment[a].variable,
                    c = e.accumulatedWeightedInfNorm[a].variable,
                    l = u.mul(e.beta1).add(s.mul(1 - e.beta1)),
                    p = c.mul(e.beta2),
                    h = s.abs(),
                    f = p.maximum(h);
                  u.assign(l), c.assign(f);
                  var d = i
                    .div(r)
                    .mul(l.div(f.add(e.epsilon)))
                    .add(o);
                  o.assign(d);
                }
              }),
                e.iteration.assign(e.iteration.add(1)),
                e.accBeta1.assign(e.accBeta1.mul(e.beta1));
            }),
              this.incrementIterations();
          }),
          (e.prototype.dispose = function () {
            this.accBeta1.dispose(),
              this.iteration.dispose(),
              null != this.accumulatedFirstMoment &&
                qe(
                  this.accumulatedFirstMoment.map(function (t) {
                    return t.variable;
                  })
                ),
              null != this.accumulatedWeightedInfNorm &&
                qe(
                  this.accumulatedWeightedInfNorm.map(function (t) {
                    return t.variable;
                  })
                );
          }),
          (e.prototype.getWeights = function () {
            return u(this, void 0, void 0, function () {
              return c(this, function (t) {
                throw new Error(
                  "getWeights() is not implemented for Adamax yet."
                );
              });
            });
          }),
          (e.prototype.setWeights = function (t) {
            return u(this, void 0, void 0, function () {
              return c(this, function (t) {
                throw new Error(
                  "setWeights() is not implemented for Adamax yet."
                );
              });
            });
          }),
          (e.prototype.getConfig = function () {
            return {
              learningRate: this.learningRate,
              beta1: this.beta1,
              beta2: this.beta2,
              epsilon: this.epsilon,
              decay: this.decay,
            };
          }),
          (e.fromConfig = function (t, e) {
            return new t(e.learningRate, e.beta1, e.beta2, e.epsilon, e.decay);
          }),
          (e.className = "Adamax"),
          e
        );
      })(ch);
      rh(fh);
      var dh = (function (t) {
        function e(e) {
          var n = t.call(this) || this;
          return (n.learningRate = e), n.setLearningRate(e), n;
        }
        return (
          s(e, t),
          (e.prototype.applyGradients = function (t) {
            var e = this;
            (Array.isArray(t)
              ? t.map(function (t) {
                  return t.name;
                })
              : Object.keys(t)
            ).forEach(function (n, r) {
              var i = Array.isArray(t) ? t[r].tensor : t[n];
              if (null != i) {
                var a = Pt.registeredVariables[n];
                He(function () {
                  var t = e.c.mul(i).add(a);
                  a.assign(t);
                });
              }
            }),
              this.incrementIterations();
          }),
          (e.prototype.setLearningRate = function (t) {
            (this.learningRate = t),
              null != this.c && this.c.dispose(),
              (this.c = Ke(gn(-t)));
          }),
          (e.prototype.dispose = function () {
            this.c.dispose();
          }),
          (e.prototype.getWeights = function () {
            return u(this, void 0, void 0, function () {
              return c(this, function (t) {
                switch (t.label) {
                  case 0:
                    return [4, this.saveIterations()];
                  case 1:
                    return [2, [t.sent()]];
                }
              });
            });
          }),
          (e.prototype.setWeights = function (t) {
            return u(this, void 0, void 0, function () {
              return c(this, function (e) {
                switch (e.label) {
                  case 0:
                    return [4, this.extractIterations(t)];
                  case 1:
                    if (0 !== (t = e.sent()).length)
                      throw new Error(
                        "SGD optimizer does not have settable weights."
                      );
                    return [2];
                }
              });
            });
          }),
          (e.prototype.getConfig = function () {
            return { learningRate: this.learningRate };
          }),
          (e.fromConfig = function (t, e) {
            return new t(e.learningRate);
          }),
          (e.className = "SGD"),
          e
        );
      })(ch);
      rh(dh);
      var mh = (function (t) {
        function e(e, n, r) {
          void 0 === r && (r = !1);
          var i = t.call(this, e) || this;
          return (
            (i.learningRate = e),
            (i.momentum = n),
            (i.useNesterov = r),
            (i.accumulations = []),
            (i.m = gn(i.momentum)),
            i
          );
        }
        return (
          s(e, t),
          (e.prototype.applyGradients = function (t) {
            var e = this;
            (Array.isArray(t)
              ? t.map(function (t) {
                  return t.name;
                })
              : Object.keys(t)
            ).forEach(function (n, r) {
              var i = Pt.registeredVariables[n];
              null == e.accumulations[r] &&
                (e.accumulations[r] = {
                  originalName: n + "/momentum",
                  variable: He(function () {
                    return _n(i).variable(!1);
                  }),
                });
              var a = e.accumulations[r].variable,
                o = Array.isArray(t) ? t[r].tensor : t[n];
              null != o &&
                He(function () {
                  var t,
                    n = e.m.mul(a).add(o);
                  (t = e.useNesterov
                    ? e.c.mul(o.add(n.mul(e.m))).add(i)
                    : e.c.mul(n).add(i)),
                    a.assign(n),
                    i.assign(t);
                });
            }),
              this.incrementIterations();
          }),
          (e.prototype.dispose = function () {
            this.m.dispose(),
              null != this.accumulations &&
                qe(
                  this.accumulations.map(function (t) {
                    return t.variable;
                  })
                );
          }),
          (e.prototype.setMomentum = function (t) {
            this.momentum = t;
          }),
          (e.prototype.getWeights = function () {
            return u(this, void 0, void 0, function () {
              return c(this, function (t) {
                switch (t.label) {
                  case 0:
                    return [4, this.saveIterations()];
                  case 1:
                    return [
                      2,
                      [t.sent()].concat(
                        this.accumulations.map(function (t) {
                          return { name: t.originalName, tensor: t.variable };
                        })
                      ),
                    ];
                }
              });
            });
          }),
          (e.prototype.setWeights = function (t) {
            return u(this, void 0, void 0, function () {
              return c(this, function (e) {
                switch (e.label) {
                  case 0:
                    return [4, this.extractIterations(t)];
                  case 1:
                    return (
                      (t = e.sent()),
                      (this.accumulations = t.map(function (t) {
                        return {
                          originalName: t.name,
                          variable: t.tensor.variable(!1),
                        };
                      })),
                      [2]
                    );
                }
              });
            });
          }),
          (e.prototype.getConfig = function () {
            return {
              learningRate: this.learningRate,
              momentum: this.momentum,
              useNesterov: this.useNesterov,
            };
          }),
          (e.fromConfig = function (t, e) {
            return new t(e.learningRate, e.momentum, e.useNesterov);
          }),
          (e.className = "Momentum"),
          e
        );
      })(dh);
      rh(mh);
      var vh = (function (t) {
        function e(e, n, r, i, a) {
          void 0 === n && (n = 0.9),
            void 0 === r && (r = 0),
            void 0 === i && (i = null),
            void 0 === a && (a = !1);
          var o = t.call(this) || this;
          if (
            ((o.learningRate = e),
            (o.decay = n),
            (o.momentum = r),
            (o.epsilon = i),
            (o.accumulatedMeanSquares = []),
            (o.accumulatedMoments = []),
            (o.accumulatedMeanGrads = []),
            (o.centered = a),
            null == i && (o.epsilon = Pt.backend.epsilon()),
            null == e)
          )
            throw new Error(
              "learningRate for RMSPropOptimizer must be defined."
            );
          return o;
        }
        return (
          s(e, t),
          (e.prototype.applyGradients = function (t) {
            var e = this;
            (Array.isArray(t)
              ? t.map(function (t) {
                  return t.name;
                })
              : Object.keys(t)
            ).forEach(function (n, r) {
              var i = Pt.registeredVariables[n];
              null == e.accumulatedMeanSquares[r] &&
                (e.accumulatedMeanSquares[r] = {
                  originalName: n + "/rms",
                  variable: He(function () {
                    return _n(i).variable(!1);
                  }),
                }),
                null == e.accumulatedMoments[r] &&
                  (e.accumulatedMoments[r] = {
                    originalName: n + "/momentum",
                    variable: He(function () {
                      return _n(i).variable(!1);
                    }),
                  }),
                null == e.accumulatedMeanGrads[r] &&
                  e.centered &&
                  (e.accumulatedMeanGrads[r] = {
                    originalName: n + "/mg",
                    variable: He(function () {
                      return _n(i).variable(!1);
                    }),
                  });
              var a = Array.isArray(t) ? t[r].tensor : t[n];
              if (null != a) {
                var o = e.accumulatedMeanSquares[r].variable,
                  s = e.accumulatedMoments[r].variable;
                He(function () {
                  var t = o.mul(e.decay).add(a.square().mul(1 - e.decay));
                  if (e.centered) {
                    var n = e.accumulatedMeanGrads[r].variable,
                      u = n.mul(e.decay).add(a.mul(1 - e.decay)),
                      c = s
                        .mul(e.momentum)
                        .add(
                          a
                            .mul(e.learningRate)
                            .div(t.sub(u.square().add(e.epsilon)).sqrt())
                        );
                    o.assign(t), n.assign(u), s.assign(c);
                    var l = i.sub(c);
                    i.assign(l);
                  } else {
                    var p = o.mul(e.decay).add(a.square().mul(1 - e.decay));
                    (c = s
                      .mul(e.momentum)
                      .add(a.mul(e.learningRate).div(p.add(e.epsilon).sqrt()))),
                      o.assign(p),
                      s.assign(c),
                      (l = i.sub(c)),
                      i.assign(l);
                  }
                });
              }
            }),
              this.incrementIterations();
          }),
          (e.prototype.dispose = function () {
            null != this.accumulatedMeanSquares &&
              qe(
                this.accumulatedMeanSquares.map(function (t) {
                  return t.variable;
                })
              ),
              null != this.accumulatedMeanGrads &&
                this.centered &&
                qe(
                  this.accumulatedMeanGrads.map(function (t) {
                    return t.variable;
                  })
                ),
              null != this.accumulatedMoments &&
                qe(
                  this.accumulatedMoments.map(function (t) {
                    return t.variable;
                  })
                );
          }),
          (e.prototype.getWeights = function () {
            return u(this, void 0, void 0, function () {
              var t;
              return c(this, function (e) {
                switch (e.label) {
                  case 0:
                    return (
                      (t = this.accumulatedMeanSquares.concat(
                        this.accumulatedMoments
                      )),
                      this.centered &&
                        t.push.apply(t, this.accumulatedMeanGrads),
                      [4, this.saveIterations()]
                    );
                  case 1:
                    return [
                      2,
                      [e.sent()].concat(
                        t.map(function (t) {
                          return { name: t.originalName, tensor: t.variable };
                        })
                      ),
                    ];
                }
              });
            });
          }),
          (e.prototype.setWeights = function (t) {
            return u(this, void 0, void 0, function () {
              var e;
              return c(this, function (n) {
                switch (n.label) {
                  case 0:
                    return [4, this.extractIterations(t)];
                  case 1:
                    return (
                      (t = n.sent()),
                      (e = this.centered ? t.length / 3 : t.length / 2),
                      (this.accumulatedMeanSquares = t
                        .slice(0, e)
                        .map(function (t) {
                          return {
                            originalName: t.name,
                            variable: t.tensor.variable(!1),
                          };
                        })),
                      (this.accumulatedMoments = t
                        .slice(e, 2 * e)
                        .map(function (t) {
                          return {
                            originalName: t.name,
                            variable: t.tensor.variable(!1),
                          };
                        })),
                      this.centered &&
                        (this.accumulatedMeanGrads = t
                          .slice(2 * e, 3 * e)
                          .map(function (t) {
                            return {
                              originalName: t.name,
                              variable: t.tensor.variable(!1),
                            };
                          })),
                      [2]
                    );
                }
              });
            });
          }),
          (e.prototype.getConfig = function () {
            return {
              learningRate: this.learningRate,
              decay: this.decay,
              momentum: this.momentum,
              epsilon: this.epsilon,
              centered: this.centered,
            };
          }),
          (e.fromConfig = function (t, e) {
            return new t(
              e.learningRate,
              e.decay,
              e.momentum,
              e.epsilon,
              e.centered
            );
          }),
          (e.className = "RMSProp"),
          e
        );
      })(ch);
      rh(vh);
      var gh = (function () {
          function t() {}
          return (
            (t.sgd = function (t) {
              return new dh(t);
            }),
            (t.momentum = function (t, e, n) {
              return void 0 === n && (n = !1), new mh(t, e, n);
            }),
            (t.rmsprop = function (t, e, n, r, i) {
              return (
                void 0 === e && (e = 0.9),
                void 0 === n && (n = 0),
                void 0 === r && (r = null),
                void 0 === i && (i = !1),
                new vh(t, e, n, r, i)
              );
            }),
            (t.adam = function (t, e, n, r) {
              return (
                void 0 === t && (t = 0.001),
                void 0 === e && (e = 0.9),
                void 0 === n && (n = 0.999),
                void 0 === r && (r = null),
                new hh(t, e, n, r)
              );
            }),
            (t.adadelta = function (t, e, n) {
              return (
                void 0 === t && (t = 0.001),
                void 0 === e && (e = 0.95),
                void 0 === n && (n = null),
                new lh(t, e, n)
              );
            }),
            (t.adamax = function (t, e, n, r, i) {
              return (
                void 0 === t && (t = 0.002),
                void 0 === e && (e = 0.9),
                void 0 === n && (n = 0.999),
                void 0 === r && (r = null),
                void 0 === i && (i = 0),
                new fh(t, e, n, r, i)
              );
            }),
            (t.adagrad = function (t, e) {
              return void 0 === e && (e = 0.1), new ph(t, e);
            }),
            t
          );
        })(),
        yh = {
          sgd: gh.sgd,
          momentum: gh.momentum,
          adadelta: gh.adadelta,
          adagrad: gh.adagrad,
          rmsprop: gh.rmsprop,
          adamax: gh.adamax,
          adam: gh.adam,
        },
        bh =
          "undefined" != typeof requestAnimationFrame
            ? requestAnimationFrame
            : void 0 !== a
            ? a
            : function (t) {
                return t();
              };
      function wh() {
        return new Promise(function (t) {
          return bh(function () {
            return t();
          });
        });
      }
      (wt.prototype.squaredDifference = function (t) {
        return ss(this, t);
      }),
        (yt = Gl);
    }.call(this, n(2), n(6), n(7).Buffer, n(15).setImmediate));
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "c", function () {
      return i;
    }),
      n.d(e, "a", function () {
        return a;
      }),
      n.d(e, "b", function () {
        return o;
      }),
      n.d(e, "d", function () {
        return s;
      }),
      n.d(e, "e", function () {
        return u;
      });
    /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
    var r = function (t, e) {
      return (r =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (t, e) {
            t.__proto__ = e;
          }) ||
        function (t, e) {
          for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
        })(t, e);
    };
    function i(t, e) {
      function n() {
        this.constructor = t;
      }
      r(t, e),
        (t.prototype =
          null === e
            ? Object.create(e)
            : ((n.prototype = e.prototype), new n()));
    }
    var a = function () {
      return (a =
        Object.assign ||
        function (t) {
          for (var e, n = 1, r = arguments.length; n < r; n++)
            for (var i in (e = arguments[n]))
              Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
          return t;
        }).apply(this, arguments);
    };
    function o(t, e, n, r) {
      return new (n || (n = Promise))(function (i, a) {
        function o(t) {
          try {
            u(r.next(t));
          } catch (t) {
            a(t);
          }
        }
        function s(t) {
          try {
            u(r.throw(t));
          } catch (t) {
            a(t);
          }
        }
        function u(t) {
          var e;
          t.done
            ? i(t.value)
            : ((e = t.value),
              e instanceof n
                ? e
                : new n(function (t) {
                    t(e);
                  })).then(o, s);
        }
        u((r = r.apply(t, e || [])).next());
      });
    }
    function s(t, e) {
      var n,
        r,
        i,
        a,
        o = {
          label: 0,
          sent: function () {
            if (1 & i[0]) throw i[1];
            return i[1];
          },
          trys: [],
          ops: [],
        };
      return (
        (a = { next: s(0), throw: s(1), return: s(2) }),
        "function" == typeof Symbol &&
          (a[Symbol.iterator] = function () {
            return this;
          }),
        a
      );
      function s(a) {
        return function (s) {
          return (function (a) {
            if (n) throw new TypeError("Generator is already executing.");
            for (; o; )
              try {
                if (
                  ((n = 1),
                  r &&
                    (i =
                      2 & a[0]
                        ? r.return
                        : a[0]
                        ? r.throw || ((i = r.return) && i.call(r), 0)
                        : r.next) &&
                    !(i = i.call(r, a[1])).done)
                )
                  return i;
                switch (((r = 0), i && (a = [2 & a[0], i.value]), a[0])) {
                  case 0:
                  case 1:
                    i = a;
                    break;
                  case 4:
                    return o.label++, { value: a[1], done: !1 };
                  case 5:
                    o.label++, (r = a[1]), (a = [0]);
                    continue;
                  case 7:
                    (a = o.ops.pop()), o.trys.pop();
                    continue;
                  default:
                    if (
                      !((i = o.trys),
                      (i = i.length > 0 && i[i.length - 1]) ||
                        (6 !== a[0] && 2 !== a[0]))
                    ) {
                      o = 0;
                      continue;
                    }
                    if (3 === a[0] && (!i || (a[1] > i[0] && a[1] < i[3]))) {
                      o.label = a[1];
                      break;
                    }
                    if (6 === a[0] && o.label < i[1]) {
                      (o.label = i[1]), (i = a);
                      break;
                    }
                    if (i && o.label < i[2]) {
                      (o.label = i[2]), o.ops.push(a);
                      break;
                    }
                    i[2] && o.ops.pop(), o.trys.pop();
                    continue;
                }
                a = e.call(t, o);
              } catch (t) {
                (a = [6, t]), (r = 0);
              } finally {
                n = i = 0;
              }
            if (5 & a[0]) throw a[1];
            return { value: a[0] ? a[1] : void 0, done: !0 };
          })([a, s]);
        };
      }
    }
    function u() {
      for (var t = 0, e = 0, n = arguments.length; e < n; e++)
        t += arguments[e].length;
      var r = Array(t),
        i = 0;
      for (e = 0; e < n; e++)
        for (var a = arguments[e], o = 0, s = a.length; o < s; o++, i++)
          r[i] = a[o];
      return r;
    }
  },
  function (t, e) {
    var n;
    n = (function () {
      return this;
    })();
    try {
      n = n || new Function("return this")();
    } catch (t) {
      "object" == typeof window && (n = window);
    }
    t.exports = n;
  },
  function (t, e, n) {
    "use strict";
    (function (t) {
      n.d(e, "a", function () {
        return at;
      }),
        n.d(e, "b", function () {
          return ot;
        });
      var r,
        i,
        a,
        o = n(0),
        s = function () {
          return (s =
            Object.assign ||
            function (t) {
              for (var e, n = 1, r = arguments.length; n < r; n++)
                for (var i in (e = arguments[n]))
                  Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
              return t;
            }).apply(this, arguments);
        };
      /**
       * @license
       * Copyright 2020 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       * http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       * =============================================================================
       */ function u(t, e, n, r) {
        return new (n || (n = Promise))(function (i, a) {
          function o(t) {
            try {
              u(r.next(t));
            } catch (t) {
              a(t);
            }
          }
          function s(t) {
            try {
              u(r.throw(t));
            } catch (t) {
              a(t);
            }
          }
          function u(t) {
            t.done
              ? i(t.value)
              : new n(function (e) {
                  e(t.value);
                }).then(o, s);
          }
          u((r = r.apply(t, e || [])).next());
        });
      }
      function c(t, e) {
        var n,
          r,
          i,
          a,
          o = {
            label: 0,
            sent: function () {
              if (1 & i[0]) throw i[1];
              return i[1];
            },
            trys: [],
            ops: [],
          };
        return (
          (a = { next: s(0), throw: s(1), return: s(2) }),
          "function" == typeof Symbol &&
            (a[Symbol.iterator] = function () {
              return this;
            }),
          a
        );
        function s(a) {
          return function (s) {
            return (function (a) {
              if (n) throw new TypeError("Generator is already executing.");
              for (; o; )
                try {
                  if (
                    ((n = 1),
                    r &&
                      (i =
                        2 & a[0]
                          ? r.return
                          : a[0]
                          ? r.throw || ((i = r.return) && i.call(r), 0)
                          : r.next) &&
                      !(i = i.call(r, a[1])).done)
                  )
                    return i;
                  switch (((r = 0), i && (a = [2 & a[0], i.value]), a[0])) {
                    case 0:
                    case 1:
                      i = a;
                      break;
                    case 4:
                      return o.label++, { value: a[1], done: !1 };
                    case 5:
                      o.label++, (r = a[1]), (a = [0]);
                      continue;
                    case 7:
                      (a = o.ops.pop()), o.trys.pop();
                      continue;
                    default:
                      if (
                        !(i = (i = o.trys).length > 0 && i[i.length - 1]) &&
                        (6 === a[0] || 2 === a[0])
                      ) {
                        o = 0;
                        continue;
                      }
                      if (3 === a[0] && (!i || (a[1] > i[0] && a[1] < i[3]))) {
                        o.label = a[1];
                        break;
                      }
                      if (6 === a[0] && o.label < i[1]) {
                        (o.label = i[1]), (i = a);
                        break;
                      }
                      if (i && o.label < i[2]) {
                        (o.label = i[2]), o.ops.push(a);
                        break;
                      }
                      i[2] && o.ops.pop(), o.trys.pop();
                      continue;
                  }
                  a = e.call(t, o);
                } catch (t) {
                  (a = [6, t]), (r = 0);
                } finally {
                  n = i = 0;
                }
              if (5 & a[0]) throw a[1];
              return { value: a[0] ? a[1] : void 0, done: !0 };
            })([a, s]);
          };
        }
      }
      ((a = r || (r = {}))[(a.DT_INVALID = 0)] = "DT_INVALID"),
        (a[(a.DT_FLOAT = 1)] = "DT_FLOAT"),
        (a[(a.DT_DOUBLE = 2)] = "DT_DOUBLE"),
        (a[(a.DT_INT32 = 3)] = "DT_INT32"),
        (a[(a.DT_UINT8 = 4)] = "DT_UINT8"),
        (a[(a.DT_INT16 = 5)] = "DT_INT16"),
        (a[(a.DT_INT8 = 6)] = "DT_INT8"),
        (a[(a.DT_STRING = 7)] = "DT_STRING"),
        (a[(a.DT_COMPLEX64 = 8)] = "DT_COMPLEX64"),
        (a[(a.DT_INT64 = 9)] = "DT_INT64"),
        (a[(a.DT_BOOL = 10)] = "DT_BOOL"),
        (a[(a.DT_QINT8 = 11)] = "DT_QINT8"),
        (a[(a.DT_QUINT8 = 12)] = "DT_QUINT8"),
        (a[(a.DT_QINT32 = 13)] = "DT_QINT32"),
        (a[(a.DT_BFLOAT16 = 14)] = "DT_BFLOAT16"),
        (a[(a.DT_FLOAT_REF = 101)] = "DT_FLOAT_REF"),
        (a[(a.DT_DOUBLE_REF = 102)] = "DT_DOUBLE_REF"),
        (a[(a.DT_INT32_REF = 103)] = "DT_INT32_REF"),
        (a[(a.DT_UINT8_REF = 104)] = "DT_UINT8_REF"),
        (a[(a.DT_INT16_REF = 105)] = "DT_INT16_REF"),
        (a[(a.DT_INT8_REF = 106)] = "DT_INT8_REF"),
        (a[(a.DT_STRING_REF = 107)] = "DT_STRING_REF"),
        (a[(a.DT_COMPLEX64_REF = 108)] = "DT_COMPLEX64_REF"),
        (a[(a.DT_INT64_REF = 109)] = "DT_INT64_REF"),
        (a[(a.DT_BOOL_REF = 110)] = "DT_BOOL_REF"),
        (a[(a.DT_QINT8_REF = 111)] = "DT_QINT8_REF"),
        (a[(a.DT_QUINT8_REF = 112)] = "DT_QUINT8_REF"),
        (a[(a.DT_QINT32_REF = 113)] = "DT_QINT32_REF"),
        (a[(a.DT_BFLOAT16_REF = 114)] = "DT_BFLOAT16_REF"),
        (function (t) {
          !(function (t) {
            (t[(t.LEGACY = 0)] = "LEGACY"),
              (t[(t.V1 = 1)] = "V1"),
              (t[(t.V2 = 2)] = "V2");
          })(t.CheckpointFormatVersion || (t.CheckpointFormatVersion = {}));
        })(i || (i = {}));
      var l = {};
      function p(t) {
        return l[t];
      }
      function h(t, e, n, r) {
        var i = e.inputParams[t];
        if (i && void 0 !== i.inputIndexStart) {
          var a = i.inputIndexStart,
            o =
              0 === i.inputIndexEnd
                ? void 0
                : void 0 === i.inputIndexEnd
                ? a + 1
                : i.inputIndexEnd;
          if ("tensor" === i.type)
            return f(e.inputNames[i.inputIndexStart], n, r);
          if ("tensors" === i.type)
            return e.inputNames.slice(a, o).map(function (t) {
              return f(t, n, r);
            });
          var s = Array.prototype.slice.call(
            f(e.inputNames.slice(a)[0], n, r).dataSync()
          );
          return "number" === i.type ? s[0] : s;
        }
        var u = e.attrParams[t];
        return u && u.value;
      }
      function f(t, e, n) {
        var r = v(t),
          i = r[0],
          a = r[1],
          o = n.currentContextIds.find(function (t) {
            return !!e[m(i, t)];
          });
        return void 0 !== o ? e[m(i, o)][a] : void 0;
      }
      function d(t, e) {
        var n = v(t),
          r = n[0],
          i = n[1];
        return [m(r, e && e.currentContextId), i];
      }
      function m(t, e) {
        return e ? t + "-" + e : t;
      }
      function v(t) {
        var e = t.lastIndexOf(":");
        return -1 === e
          ? [t, 0]
          : [t.substring(0, e), Number(t.substring(e + 1))];
      }
      function g(t, e) {
        for (var n = [], r = 0; r < t.length; r += e) n.push(t.slice(r, r + e));
        return n;
      }
      var y = Object.freeze({
          json: [
            {
              tfOpName: "Add",
              category: "arithmetic",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "AddV2",
              category: "arithmetic",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "AddN",
              category: "arithmetic",
              inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }],
            },
            {
              tfOpName: "BiasAdd",
              category: "arithmetic",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Sub",
              category: "arithmetic",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "RealDiv",
              category: "arithmetic",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Div",
              category: "arithmetic",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "DivNoNan",
              category: "arithmetic",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "FloorDiv",
              category: "arithmetic",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Mul",
              category: "arithmetic",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Maximum",
              category: "arithmetic",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
            },
            {
              tfOpName: "Minimum",
              category: "arithmetic",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
            },
            {
              tfOpName: "Pow",
              category: "arithmetic",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "SquaredDifference",
              category: "arithmetic",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Mod",
              category: "arithmetic",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "FloorMod",
              category: "arithmetic",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
          ],
        }),
        b = Object.freeze({
          json: [
            {
              tfOpName: "Abs",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Acos",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Asin",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Atan",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Atan2",
              category: "basic_math",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "y", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Ceil",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "ClipByValue",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                {
                  tfName: "clip_value_min",
                  name: "clipValueMin",
                  type: "number",
                },
                {
                  tfName: "clip_value_max",
                  name: "clipValueMax",
                  type: "number",
                },
              ],
            },
            {
              tfOpName: "Complex",
              category: "basic_math",
              inputs: [
                { start: 0, name: "real", type: "tensor" },
                { start: 1, name: "imag", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "ComplexAbs",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Cos",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Cosh",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Elu",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Exp",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Floor",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Log",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Imag",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
                {
                  tfName: "Tout",
                  name: "outputType",
                  type: "dtype",
                  notSupported: !0,
                },
              ],
            },
            {
              tfOpName: "Neg",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Real",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
                {
                  tfName: "Tout",
                  name: "outputType",
                  type: "dtype",
                  notSupported: !0,
                },
              ],
            },
            {
              tfOpName: "Prelu",
              category: "basic_math",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "alpha", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Relu",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Relu6",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
                {
                  tfName: "clipValueMin",
                  name: "clipValueMin",
                  type: "number",
                  defaultValue: 0,
                },
                {
                  tfName: "clipValueMax",
                  name: "clipValueMax",
                  type: "number",
                  defaultValue: 6,
                },
              ],
            },
            {
              tfOpName: "Selu",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Sigmoid",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Sin",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Sinh",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Sqrt",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Rsqrt",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Square",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Tan",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Tanh",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Sign",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Round",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Expm1",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Log1p",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Reciprocal",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Softplus",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Asinh",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Acosh",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Atanh",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Erf",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Prod",
              category: "basic_math",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "axes", type: "number[]" },
              ],
              attrs: [
                {
                  tfName: "keep_dims",
                  name: "keepDims",
                  type: "bool",
                  notSupported: !0,
                },
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "LeakyRelu",
              category: "basic_math",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                {
                  tfName: "alpha",
                  name: "alpha",
                  type: "number",
                  defaultValue: 0.2,
                },
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
          ],
        }),
        w = Object.freeze({
          json: [
            {
              tfOpName: "LoopCond",
              category: "control",
              inputs: [{ start: 0, name: "pred", type: "tensor" }],
            },
            {
              tfOpName: "Switch",
              category: "control",
              inputs: [
                { start: 0, name: "data", type: "tensor" },
                { start: 1, name: "pred", type: "tensor" },
              ],
            },
            {
              tfOpName: "Merge",
              category: "control",
              inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }],
            },
            {
              tfOpName: "Enter",
              category: "control",
              inputs: [{ start: 0, name: "tensor", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
                { tfName: "frame_name", name: "frameName", type: "string" },
                { tfName: "is_constant", name: "isConstant", type: "bool" },
              ],
            },
            {
              tfOpName: "Exit",
              category: "control",
              inputs: [{ start: 0, name: "tensor", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "NextIteration",
              category: "control",
              inputs: [{ start: 0, name: "tensor", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "TensorArrayV3",
              category: "control",
              inputs: [{ start: 0, name: "size", type: "number" }],
              attrs: [
                { tfName: "dtype", name: "dtype", type: "dtype" },
                {
                  tfName: "element_shape",
                  name: "elementShape",
                  type: "shape",
                },
                { tfName: "dynamic_size", name: "dynamicSize", type: "bool" },
                {
                  tfName: "clear_after_read",
                  name: "clearAfterRead",
                  type: "bool",
                },
                {
                  tfName: "identical_element_shapes",
                  name: "identicalElementShapes",
                  type: "bool",
                },
                { tfName: "tensor_array_name", name: "name", type: "string" },
              ],
            },
            {
              tfOpName: "TensorArrayWriteV3",
              category: "control",
              inputs: [
                { start: 0, name: "tensorArrayId", type: "number" },
                { start: 1, name: "index", type: "number" },
                { start: 2, name: "tensor", type: "tensor" },
                { start: 3, name: "flowIn", type: "number" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "TensorArrayReadV3",
              category: "control",
              inputs: [
                { start: 0, name: "tensorArrayId", type: "number" },
                { start: 1, name: "index", type: "number" },
                { start: 2, name: "flowIn", type: "number" },
              ],
              attrs: [
                {
                  tfName: "dtype",
                  name: "dtype",
                  type: "dtype",
                  notSupported: !0,
                },
              ],
            },
            {
              tfOpName: "TensorArrayGatherV3",
              category: "control",
              inputs: [
                { start: 0, name: "tensorArrayId", type: "number" },
                { start: 1, name: "indices", type: "number[]" },
                { start: 2, name: "flowIn", type: "number" },
              ],
              attrs: [
                { tfName: "dtype", name: "dtype", type: "dtype" },
                {
                  tfName: "element_shape",
                  name: "elementShape",
                  type: "shape",
                },
              ],
            },
            {
              tfOpName: "TensorArrayScatterV3",
              category: "control",
              inputs: [
                { start: 0, name: "tensorArrayId", type: "number" },
                { start: 1, name: "indices", type: "number[]" },
                { start: 2, name: "tensor", type: "tensor" },
                { start: 3, name: "flowIn", type: "number" },
              ],
              attrs: [{ tfName: "T", name: "dtype", type: "dtype" }],
            },
            {
              tfOpName: "TensorArrayConcatV3",
              category: "control",
              inputs: [
                { start: 0, name: "tensorArrayId", type: "number" },
                { start: 1, name: "flowIn", type: "number" },
              ],
              attrs: [
                { tfName: "dtype", name: "dtype", type: "dtype" },
                {
                  tfName: "element_shape_except0",
                  name: "elementShapeExcept0",
                  type: "shape",
                  notSupported: !0,
                },
              ],
            },
            {
              tfOpName: "TensorArraySplitV3",
              category: "control",
              inputs: [
                { start: 0, name: "tensorArrayId", type: "number" },
                { start: 1, name: "tensor", type: "tensor" },
                { start: 2, name: "lengths", type: "number[]" },
                { start: 3, name: "flowIn", type: "number" },
              ],
              attrs: [{ tfName: "T", name: "dtype", type: "dtype" }],
            },
            {
              tfOpName: "TensorArraySizeV3",
              category: "control",
              inputs: [
                { start: 0, name: "tensorArrayId", type: "number" },
                { start: 1, name: "flowIn", type: "number" },
              ],
            },
            {
              tfOpName: "TensorArrayCloseV3",
              category: "control",
              inputs: [{ start: 0, name: "tensorArrayId", type: "number" }],
            },
          ],
        }),
        x = Object.freeze({
          json: [
            {
              tfOpName: "AvgPool",
              category: "convolution",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "strides", name: "strides", type: "number[]" },
                { tfName: "padding", name: "pad", type: "string" },
                {
                  tfName: "data_format",
                  name: "dataFormat",
                  type: "string",
                  notSupported: !0,
                },
                { tfName: "ksize", name: "kernelSize", type: "number[]" },
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "MaxPool",
              category: "convolution",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "strides", name: "strides", type: "number[]" },
                { tfName: "padding", name: "pad", type: "string" },
                {
                  tfName: "data_format",
                  name: "dataFormat",
                  type: "string",
                  notSupported: !0,
                },
                { tfName: "ksize", name: "kernelSize", type: "number[]" },
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "AvgPool3D",
              category: "convolution",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "strides", name: "strides", type: "number[]" },
                { tfName: "padding", name: "pad", type: "string" },
                {
                  tfName: "data_format",
                  name: "dataFormat",
                  type: "string",
                  notSupported: !0,
                },
                { tfName: "ksize", name: "kernelSize", type: "number[]" },
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "MaxPool3D",
              category: "convolution",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "strides", name: "strides", type: "number[]" },
                { tfName: "padding", name: "pad", type: "string" },
                {
                  tfName: "data_format",
                  name: "dataFormat",
                  type: "string",
                  notSupported: !0,
                },
                { tfName: "ksize", name: "kernelSize", type: "number[]" },
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Conv1D",
              category: "convolution",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "filter", type: "tensor" },
              ],
              attrs: [
                { tfName: "stride", name: "stride", type: "number" },
                { tfName: "padding", name: "pad", type: "string" },
                {
                  tfName: "data_format",
                  name: "dataFormat",
                  type: "string",
                  defaultValue: "NWC",
                },
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
                {
                  tfName: "dilation",
                  name: "dilation",
                  type: "number",
                  defaultValue: 1,
                },
              ],
            },
            {
              tfOpName: "Conv2D",
              category: "convolution",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "filter", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
                { tfName: "strides", name: "strides", type: "number[]" },
                { tfName: "padding", name: "pad", type: "string" },
                {
                  tfName: "useCudnnOnGpu",
                  name: "useCudnnOnGpu",
                  type: "bool",
                },
                {
                  tfName: "data_format",
                  name: "dataFormat",
                  type: "string",
                  defaultValue: "NHWC",
                },
                { tfName: "dilations", name: "dilations", type: "number[]" },
              ],
            },
            {
              tfOpName: "_FusedConv2D",
              category: "convolution",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "filter", type: "tensor" },
                { start: 2, end: 0, name: "args", type: "tensors" },
              ],
              attrs: [
                { tfName: "num_args", name: "numArgs", type: "number" },
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
                { tfName: "strides", name: "strides", type: "number[]" },
                { tfName: "padding", name: "pad", type: "string" },
                {
                  tfName: "explicit_paddings",
                  name: "explicitPaddings",
                  type: "number[]",
                  defaultValue: [],
                },
                {
                  tfName: "use_cudnn_on_gpu",
                  name: "useCudnnOnGpu",
                  type: "bool",
                  defaultValue: !0,
                },
                {
                  tfName: "data_format",
                  name: "dataFormat",
                  type: "string",
                  defaultValue: "NHWC",
                },
                {
                  tfName: "dilations",
                  name: "dilations",
                  type: "number[]",
                  defaultValue: [1, 1, 1, 1],
                },
                {
                  tfName: "fused_ops",
                  name: "fusedOps",
                  type: "string[]",
                  defaultValue: [],
                },
                {
                  tfName: "epsilon",
                  name: "epsilon",
                  type: "number",
                  defaultValue: 1e-4,
                },
              ],
            },
            {
              tfOpName: "Conv2DBackpropInput",
              category: "convolution",
              inputs: [
                { start: 2, name: "x", type: "tensor" },
                { start: 1, name: "filter", type: "tensor" },
                { start: 0, name: "outputShape", type: "number[]" },
              ],
              attrs: [
                { tfName: "strides", name: "strides", type: "number[]" },
                { tfName: "padding", name: "pad", type: "string" },
                {
                  tfName: "data_format",
                  name: "dataFormat",
                  type: "string",
                  notSupported: !0,
                },
              ],
            },
            {
              tfOpName: "DepthwiseConv2d",
              category: "convolution",
              inputs: [
                { start: 0, name: "input", type: "tensor" },
                { start: 1, name: "filter", type: "tensor" },
              ],
              attrs: [
                { tfName: "strides", name: "strides", type: "number[]" },
                { tfName: "padding", name: "pad", type: "string" },
                {
                  tfName: "data_format",
                  name: "dataFormat",
                  type: "string",
                  defaultValue: "NHWC",
                },
                { tfName: "dilations", name: "dilations", type: "number[]" },
              ],
            },
            {
              tfOpName: "DepthwiseConv2dNative",
              category: "convolution",
              inputs: [
                { start: 0, name: "input", type: "tensor" },
                { start: 1, name: "filter", type: "tensor" },
              ],
              attrs: [
                { tfName: "strides", name: "strides", type: "number[]" },
                { tfName: "padding", name: "pad", type: "string" },
                {
                  tfName: "data_format",
                  name: "dataFormat",
                  type: "string",
                  defaultValue: "NHWC",
                },
                { tfName: "dilations", name: "dilations", type: "number[]" },
              ],
            },
            {
              tfOpName: "FusedDepthwiseConv2dNative",
              category: "convolution",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "filter", type: "tensor" },
                { start: 2, end: 0, name: "args", type: "tensors" },
              ],
              attrs: [
                { tfName: "num_args", name: "numArgs", type: "number" },
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
                { tfName: "strides", name: "strides", type: "number[]" },
                { tfName: "padding", name: "pad", type: "string" },
                {
                  tfName: "data_format",
                  name: "dataFormat",
                  type: "string",
                  defaultValue: "NHWC",
                },
                {
                  tfName: "dilations",
                  name: "dilations",
                  type: "number[]",
                  defaultValue: [1, 1, 1, 1],
                },
                {
                  tfName: "fused_ops",
                  name: "fusedOps",
                  type: "string[]",
                  defaultValue: [],
                },
              ],
            },
            {
              tfOpName: "Conv3D",
              category: "convolution",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "filter", type: "tensor" },
              ],
              attrs: [
                { tfName: "strides", name: "strides", type: "number[]" },
                { tfName: "padding", name: "pad", type: "string" },
                {
                  tfName: "data_format",
                  name: "dataFormat",
                  type: "string",
                  defaultValue: "NHWC",
                },
                { tfName: "dilations", name: "dilations", type: "number[]" },
              ],
            },
          ],
        }),
        C = Object.freeze({
          json: [
            {
              tfOpName: "Fill",
              category: "creation",
              inputs: [
                { start: 0, name: "shape", type: "number[]" },
                { start: 1, name: "value", type: "number" },
              ],
              attrs: [{ tfName: "T", name: "dtype", type: "dtype" }],
            },
            {
              tfOpName: "LinSpace",
              category: "creation",
              inputs: [
                { start: 0, name: "start", type: "number" },
                { start: 1, name: "stop", type: "number" },
                { start: 2, name: "num", type: "number" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "OneHot",
              category: "creation",
              inputs: [
                { start: 0, name: "indices", type: "tensor" },
                { start: 1, name: "depth", type: "number" },
                { start: 2, name: "onValue", type: "number", defaultValue: 1 },
                { start: 3, name: "offValue", type: "number", defaultValue: 0 },
              ],
              attrs: [
                {
                  tfName: "axis",
                  name: "axis",
                  type: "number",
                  notSupported: !0,
                },
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Ones",
              category: "creation",
              inputs: [{ start: 0, name: "shape", type: "number[]" }],
              attrs: [{ tfName: "T", name: "dtype", type: "dtype" }],
            },
            {
              tfOpName: "OnesLike",
              category: "creation",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }],
            },
            {
              tfOpName: "RandomUniform",
              category: "creation",
              inputs: [{ start: 0, name: "shape", type: "number[]" }],
              attrs: [
                {
                  tfName: "minval",
                  name: "minval",
                  type: "number",
                  defaultValue: 0,
                },
                {
                  tfName: "maxval",
                  name: "maxval",
                  type: "number",
                  defaultValue: 1,
                },
                { tfName: "dtype", name: "dtype", type: "dtype" },
                {
                  tfName: "seed",
                  name: "seed",
                  type: "number",
                  defaultValue: 0,
                },
                {
                  tfName: "seed2",
                  name: "seed2",
                  type: "number",
                  defaultValue: 0,
                  notSupported: !0,
                },
                { tfName: "T", name: "T", type: "number", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Range",
              category: "creation",
              inputs: [
                { start: 0, name: "start", type: "number" },
                { start: 1, name: "stop", type: "number" },
                { start: 2, name: "step", type: "number", defaultValue: 0 },
              ],
              attrs: [{ tfName: "Tidx", name: "dtype", type: "dtype" }],
            },
            {
              tfOpName: "TruncatedNormal",
              category: "creation",
              inputs: [{ start: 0, name: "shape", type: "number[]" }],
              attrs: [
                {
                  tfName: "means",
                  name: "mean",
                  type: "number",
                  defaultValue: 0,
                },
                {
                  tfName: "stddev",
                  name: "stdDev",
                  type: "number",
                  defaultValue: 1,
                },
                { tfName: "seed", name: "seed", type: "number" },
                {
                  tfName: "seed2",
                  name: "seed2",
                  type: "number",
                  defaultValue: 0,
                  notSupported: !0,
                },
                { tfName: "dtype", name: "dtype", type: "dtype" },
                { tfName: "T", name: "T", type: "number", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Zeros",
              category: "creation",
              inputs: [{ start: 0, name: "shape", type: "number[]" }],
              attrs: [{ tfName: "T", name: "dtype", type: "dtype" }],
            },
            {
              tfOpName: "ZerosLike",
              category: "creation",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [{ tfName: "T", name: "dtype", type: "dtype" }],
            },
            {
              tfOpName: "Multinomial",
              category: "creation",
              inputs: [
                { start: 0, name: "logits", type: "tensor" },
                { start: 1, name: "numSamples", type: "number" },
              ],
              attrs: [
                { tfName: "seed", name: "seed", type: "number" },
                { tfName: "seed2", name: "seed2", type: "number" },
                { tfName: "T", name: "dtype", type: "dtype" },
                { tfName: "output_dtype", name: "output_dtype", type: "dtype" },
              ],
            },
          ],
        }),
        O = Object.freeze({
          json: [
            {
              tfOpName: "NonMaxSuppressionV2",
              category: "dynamic",
              inputs: [
                { start: 0, name: "boxes", type: "tensor" },
                { start: 1, name: "scores", type: "tensor" },
                { start: 2, name: "maxOutputSize", type: "number" },
                { start: 3, name: "iouThreshold", type: "number" },
              ],
            },
            {
              tfOpName: "NonMaxSuppressionV3",
              category: "dynamic",
              inputs: [
                { start: 0, name: "boxes", type: "tensor" },
                { start: 1, name: "scores", type: "tensor" },
                { start: 2, name: "maxOutputSize", type: "number" },
                { start: 3, name: "iouThreshold", type: "number" },
                { start: 4, name: "scoreThreshold", type: "number" },
              ],
            },
            {
              tfOpName: "NonMaxSuppressionV5",
              category: "dynamic",
              inputs: [
                { start: 0, name: "boxes", type: "tensor" },
                { start: 1, name: "scores", type: "tensor" },
                { start: 2, name: "maxOutputSize", type: "number" },
                { start: 3, name: "iouThreshold", type: "number" },
                { start: 4, name: "scoreThreshold", type: "number" },
                { start: 5, name: "softNmsSigma", type: "number" },
              ],
            },
            {
              tfOpName: "Where",
              category: "dynamic",
              inputs: [{ start: 0, name: "condition", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "ListDiff",
              category: "dynamic",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "y", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
          ],
        }),
        E = Object.freeze({
          json: [
            {
              tfOpName: "TopKV2",
              category: "evaluation",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "k", type: "number" },
              ],
              attrs: [{ tfName: "sorted", name: "sorted", type: "bool" }],
            },
          ],
        }),
        S = Object.freeze({
          json: [
            {
              tfOpName: "PlaceholderWithDefault",
              category: "graph",
              inputs: [{ start: 0, name: "default", type: "tensor" }],
              attrs: [
                { tfName: "shape", name: "shape", type: "shape" },
                { tfName: "dtype", name: "dtype", type: "dtype" },
              ],
            },
            {
              tfOpName: "Placeholder",
              category: "graph",
              attrs: [
                { tfName: "shape", name: "shape", type: "shape" },
                { tfName: "dtype", name: "dtype", type: "dtype" },
              ],
            },
            { tfOpName: "Const", category: "graph" },
            {
              tfOpName: "Identity",
              category: "graph",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
            },
            {
              tfOpName: "IdentityN",
              category: "graph",
              inputs: [{ start: 0, end: 0, name: "x", type: "tensors" }],
            },
            {
              tfOpName: "Snapshot",
              category: "graph",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
            },
            {
              tfOpName: "Rank",
              category: "graph",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
            },
            {
              tfOpName: "Size",
              category: "graph",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
            },
            {
              tfOpName: "Shape",
              category: "graph",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
            },
            {
              tfOpName: "ShapeN",
              category: "graph",
              inputs: [{ start: 0, end: 0, name: "x", type: "tensors" }],
            },
            {
              tfOpName: "Print",
              category: "graph",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "data", type: "tensors" },
              ],
              attrs: [
                { tfName: "message", name: "message", type: "string" },
                {
                  tfName: "first_n",
                  name: "firstN",
                  type: "number",
                  notSupported: !0,
                },
                {
                  tfName: "summarize",
                  name: "summarize",
                  type: "number",
                  defaultValue: 3,
                },
              ],
            },
            { tfOpName: "NoOp", category: "graph", inputs: [] },
            {
              tfOpName: "StopGradient",
              category: "graph",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
            },
            {
              tfOpName: "FakeQuantWithMinMaxVars",
              category: "graph",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "min", name: "min", type: "number" },
                { tfName: "max", name: "max", type: "number" },
              ],
            },
          ],
        }),
        N = Object.freeze({
          json: [
            {
              tfOpName: "ResizeBilinear",
              category: "image",
              inputs: [
                { start: 0, name: "images", type: "tensor" },
                { start: 1, name: "size", type: "number[]" },
              ],
              attrs: [
                { tfName: "align_corners", name: "alignCorners", type: "bool" },
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "ResizeNearestNeighbor",
              category: "image",
              inputs: [
                { start: 0, name: "images", type: "tensor" },
                { start: 1, name: "size", type: "number[]" },
              ],
              attrs: [
                { tfName: "align_corners", name: "alignCorners", type: "bool" },
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "CropAndResize",
              category: "image",
              inputs: [
                { start: 0, name: "image", type: "tensor" },
                { start: 1, name: "boxes", type: "tensor" },
                { start: 2, name: "boxInd", type: "tensor" },
                { start: 3, name: "cropSize", type: "number[]" },
              ],
              attrs: [
                { tfName: "method", name: "method", type: "string" },
                {
                  tfName: "extrapolation_value",
                  name: "extrapolationValue",
                  type: "number",
                },
              ],
            },
          ],
        }),
        I = Object.freeze({
          json: [
            {
              tfOpName: "Equal",
              category: "logical",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "NotEqual",
              category: "logical",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Greater",
              category: "logical",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "GreaterEqual",
              category: "logical",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Less",
              category: "logical",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "LessEqual",
              category: "logical",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "LogicalAnd",
              category: "logical",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "LogicalNot",
              category: "logical",
              inputs: [{ start: 0, name: "a", type: "tensor" }],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "LogicalOr",
              category: "logical",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Select",
              category: "logical",
              inputs: [
                { start: 0, name: "condition", type: "tensor" },
                { start: 1, name: "a", type: "tensor" },
                { start: 2, name: "b", type: "tensor" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
          ],
        }),
        k = Object.freeze({
          json: [
            {
              tfOpName: "_FusedMatMul",
              category: "matrices",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
                { start: 2, end: 0, name: "args", type: "tensors" },
              ],
              attrs: [
                { tfName: "num_args", name: "numArgs", type: "number" },
                {
                  tfName: "fused_ops",
                  name: "fusedOps",
                  type: "string[]",
                  defaultValue: [],
                },
                {
                  tfName: "epsilon",
                  name: "epsilon",
                  type: "number",
                  defaultValue: 1e-4,
                },
                {
                  tfName: "transpose_a",
                  name: "transposeA",
                  type: "bool",
                  defaultValue: !1,
                },
                {
                  tfName: "transpose_b",
                  name: "transposeB",
                  type: "bool",
                  defaultValue: !1,
                },
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "MatMul",
              category: "matrices",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
              attrs: [
                {
                  tfName: "transpose_a",
                  name: "transposeA",
                  type: "bool",
                  defaultValue: !1,
                },
                {
                  tfName: "transpose_b",
                  name: "transposeB",
                  type: "bool",
                  defaultValue: !1,
                },
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "BatchMatMul",
              category: "matrices",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
              attrs: [
                {
                  tfName: "adj_x",
                  name: "transposeA",
                  type: "bool",
                  defaultValue: !1,
                },
                {
                  tfName: "adj_y",
                  name: "transposeB",
                  type: "bool",
                  defaultValue: !1,
                },
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "BatchMatMulV2",
              category: "matrices",
              inputs: [
                { start: 0, name: "a", type: "tensor" },
                { start: 1, name: "b", type: "tensor" },
              ],
              attrs: [
                {
                  tfName: "adj_x",
                  name: "transposeA",
                  type: "bool",
                  defaultValue: !1,
                },
                {
                  tfName: "adj_y",
                  name: "transposeB",
                  type: "bool",
                  defaultValue: !1,
                },
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
            {
              tfOpName: "Transpose",
              category: "matrices",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "perm", type: "number[]" },
              ],
              attrs: [
                { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
              ],
            },
          ],
        }),
        _ = Object.freeze({
          json: [
            {
              tfOpName: "FusedBatchNorm",
              category: "normalization",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "scale", type: "tensor" },
                { start: 2, name: "offset", type: "tensor" },
                { start: 3, name: "mean", type: "tensor" },
                { start: 4, name: "variance", type: "tensor" },
              ],
              attrs: [
                {
                  tfName: "epsilon",
                  name: "epsilon",
                  type: "number",
                  defaultValue: 0.001,
                },
                {
                  tfName: "data_format",
                  name: "dataFormat",
                  type: "string",
                  notSupported: !0,
                },
              ],
            },
            {
              tfOpName: "FusedBatchNormV2",
              category: "normalization",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "scale", type: "tensor" },
                { start: 2, name: "offset", type: "tensor" },
                { start: 3, name: "mean", type: "tensor" },
                { start: 4, name: "variance", type: "tensor" },
              ],
              attrs: [
                {
                  tfName: "epsilon",
                  name: "epsilon",
                  type: "number",
                  defaultValue: 0.001,
                },
                {
                  tfName: "data_format",
                  name: "dataFormat",
                  type: "string",
                  notSupported: !0,
                },
              ],
            },
            {
              tfOpName: "FusedBatchNormV3",
              category: "normalization",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "scale", type: "tensor" },
                { start: 2, name: "offset", type: "tensor" },
                { start: 3, name: "mean", type: "tensor" },
                { start: 4, name: "variance", type: "tensor" },
              ],
              attrs: [
                {
                  tfName: "epsilon",
                  name: "epsilon",
                  type: "number",
                  defaultValue: 0.001,
                },
                {
                  tfName: "data_format",
                  name: "dataFormat",
                  type: "string",
                  notSupported: !0,
                },
              ],
            },
            {
              tfOpName: "LRN",
              category: "normalization",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                {
                  tfName: "depth_radius",
                  name: "radius",
                  type: "number",
                  defaultValue: 5,
                },
                {
                  tfName: "bias",
                  name: "bias",
                  type: "number",
                  defaultValue: 1,
                },
                {
                  tfName: "alpha",
                  name: "alpha",
                  type: "number",
                  defaultValue: 1,
                },
                {
                  tfName: "beta",
                  name: "beta",
                  type: "number",
                  defaultValue: 0.5,
                },
              ],
            },
            {
              tfOpName: "Softmax",
              category: "normalization",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
            },
            {
              tfOpName: "LogSoftmax",
              category: "normalization",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
            },
            {
              tfOpName: "SparseToDense",
              category: "normalization",
              inputs: [
                { start: 0, name: "sparseIndices", type: "tensor" },
                { start: 1, name: "outputShape", type: "number[]" },
                { start: 2, name: "sparseValues", type: "tensor" },
                { start: 3, name: "defaultValue", type: "tensor" },
              ],
              attrs: [
                {
                  tfName: "validate_indices",
                  name: "validateIndices",
                  type: "bool",
                  defaultValue: !0,
                  notSupported: !0,
                },
              ],
            },
          ],
        }),
        A = Object.freeze({
          json: [
            {
              tfOpName: "Max",
              category: "reduction",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "axis", type: "number[]" },
              ],
              attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }],
            },
            {
              tfOpName: "Mean",
              category: "reduction",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "axis", type: "number[]" },
              ],
              attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }],
            },
            {
              tfOpName: "Min",
              category: "reduction",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "axis", type: "number[]" },
              ],
              attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }],
            },
            {
              tfOpName: "Sum",
              category: "reduction",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "axis", type: "number[]" },
              ],
              attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }],
            },
            {
              tfOpName: "All",
              category: "reduction",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "axis", type: "number[]" },
              ],
              attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }],
            },
            {
              tfOpName: "Any",
              category: "reduction",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "axis", type: "number[]" },
              ],
              attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }],
            },
            {
              tfOpName: "ArgMax",
              category: "reduction",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "axis", type: "number" },
              ],
            },
            {
              tfOpName: "ArgMin",
              category: "reduction",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "axis", type: "number" },
              ],
            },
            {
              tfOpName: "Prod",
              category: "reduction",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "axis", type: "number[]" },
              ],
              attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }],
            },
          ],
        }),
        T = Object.freeze({
          json: [
            {
              tfOpName: "ConcatV2",
              category: "slice_join",
              inputs: [
                { start: 0, end: -1, name: "tensors", type: "tensors" },
                { start: -1, name: "axis", type: "number" },
              ],
              attrs: [
                { tfName: "N", name: "n", type: "number", defaultValue: 2 },
              ],
            },
            {
              tfOpName: "Concat",
              category: "slice_join",
              inputs: [
                { start: 1, end: 0, name: "tensors", type: "tensors" },
                { start: 0, name: "axis", type: "number" },
              ],
              attrs: [
                { tfName: "N", name: "n", type: "number", defaultValue: 2 },
              ],
            },
            {
              tfOpName: "GatherV2",
              category: "slice_join",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "indices", type: "tensor" },
                { start: 2, name: "axis", type: "number", defaultValue: 0 },
              ],
            },
            {
              tfOpName: "Gather",
              category: "slice_join",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "indices", type: "tensor" },
              ],
              attrs: [
                {
                  tfName: "axis",
                  name: "axis",
                  type: "number",
                  defaultValue: 0,
                },
                {
                  tfName: "validate_indices",
                  name: "validateIndices",
                  type: "bool",
                  notSupported: !0,
                },
              ],
            },
            {
              tfOpName: "Reverse",
              category: "slice_join",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "dims", type: "bool", notSupported: !0 },
              ],
            },
            {
              tfOpName: "ReverseV2",
              category: "slice_join",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "axis", type: "number[]" },
              ],
            },
            {
              tfOpName: "Slice",
              category: "slice_join",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "begin", type: "number[]" },
                { start: 2, name: "size", type: "number[]" },
              ],
            },
            {
              tfOpName: "StridedSlice",
              category: "slice_join",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "begin", type: "number[]" },
                { start: 2, name: "end", type: "number[]" },
                { start: 3, name: "strides", type: "number[]" },
              ],
              attrs: [
                {
                  tfName: "begin_mask",
                  name: "beginMask",
                  type: "number",
                  defaultValue: 0,
                },
                {
                  tfName: "end_mask",
                  name: "endMask",
                  type: "number",
                  defaultValue: 0,
                },
                {
                  tfName: "new_axis_mask",
                  name: "newAxisMask",
                  type: "number",
                  defaultValue: 0,
                },
                {
                  tfName: "ellipsis_mask",
                  name: "ellipsisMask",
                  type: "number",
                  defaultValue: 0,
                },
                {
                  tfName: "shrink_axis_mask",
                  name: "shrinkAxisMask",
                  type: "number",
                  defaultValue: 0,
                },
              ],
            },
            {
              tfOpName: "Pack",
              category: "slice_join",
              inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }],
              attrs: [
                {
                  tfName: "axis",
                  name: "axis",
                  type: "number",
                  defaultValue: 0,
                },
              ],
            },
            {
              tfOpName: "Unpack",
              category: "slice_join",
              inputs: [{ start: 0, name: "tensor", type: "tensor" }],
              attrs: [
                {
                  tfName: "axis",
                  name: "axis",
                  type: "number",
                  defaultValue: 0,
                },
                {
                  tfName: "num",
                  name: "num",
                  type: "number",
                  defaultValue: 0,
                  notSupported: !0,
                },
              ],
            },
            {
              tfOpName: "Tile",
              category: "slice_join",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "reps", type: "number[]" },
              ],
            },
            {
              tfOpName: "Split",
              category: "slice_join",
              inputs: [
                { start: 0, name: "axis", type: "number", defaultValue: 0 },
                { start: 1, name: "x", type: "tensor" },
              ],
              attrs: [
                {
                  tfName: "num_split",
                  name: "numOrSizeSplits",
                  type: "number",
                  defaultValue: 1,
                },
              ],
            },
            {
              tfOpName: "SplitV",
              category: "slice_join",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "numOrSizeSplits", type: "number[]" },
                { start: 2, name: "axis", type: "number", defaultValue: 0 },
              ],
            },
            {
              tfOpName: "ScatterNd",
              category: "slice_join",
              inputs: [
                { start: 0, name: "indices", type: "tensor" },
                { start: 1, name: "values", type: "tensor" },
                { start: 2, name: "shape", type: "number[]" },
              ],
            },
            {
              tfOpName: "GatherNd",
              category: "slice_join",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "indices", type: "tensor" },
              ],
            },
            {
              tfOpName: "SparseToDense",
              category: "slice_join",
              inputs: [
                { start: 0, name: "sparseIndices", type: "tensor" },
                { start: 1, name: "outputShape", type: "number[]" },
                { start: 2, name: "sparseValues", type: "tensor" },
                { start: 3, name: "defaultValue", type: "tensor" },
              ],
              attrs: [
                {
                  tfName: "validate_indices",
                  name: "validateIndices",
                  type: "bool",
                  defaultValue: !1,
                  notSupported: !0,
                },
              ],
            },
          ],
        }),
        R = Object.freeze({
          json: [
            {
              tfOpName: "FFT",
              category: "spectral",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
            },
            {
              tfOpName: "IFFT",
              category: "spectral",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
            },
            {
              tfOpName: "RFFT",
              category: "spectral",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                {
                  start: 1,
                  name: "fft_length",
                  type: "number",
                  notSupported: !0,
                },
              ],
            },
            {
              tfOpName: "IRFFT",
              category: "spectral",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                {
                  start: 1,
                  name: "fft_length",
                  type: "number",
                  notSupported: !0,
                },
              ],
            },
          ],
        }),
        D = Object.freeze({
          json: [
            {
              tfOpName: "Cast",
              category: "transformation",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                {
                  tfName: "SrcT",
                  name: "sdtype",
                  type: "dtype",
                  notSupported: !0,
                },
                { tfName: "DstT", name: "dtype", type: "dtype" },
              ],
            },
            {
              tfOpName: "ExpandDims",
              category: "transformation",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "axis", type: "number" },
              ],
            },
            {
              tfOpName: "Pad",
              category: "transformation",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "padding", type: "number[]" },
              ],
              attrs: [
                {
                  tfName: "constant_value",
                  name: "constantValue",
                  type: "number",
                  defaultValue: 0,
                },
              ],
            },
            {
              tfOpName: "PadV2",
              category: "transformation",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "padding", type: "number[]" },
                {
                  start: 2,
                  name: "constantValue",
                  type: "number",
                  defaultValue: 0,
                },
              ],
            },
            {
              tfOpName: "Reshape",
              category: "transformation",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "shape", type: "number[]" },
              ],
            },
            {
              tfOpName: "Squeeze",
              category: "transformation",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                {
                  tfName: "axis",
                  tfDeprecatedName: "squeeze_dims",
                  name: "axis",
                  type: "number[]",
                },
              ],
            },
            {
              tfOpName: "SpaceToBatchND",
              category: "transformation",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "blockShape", type: "number[]" },
                { start: 2, name: "paddings", type: "number[]" },
              ],
            },
            {
              tfOpName: "BatchToSpaceND",
              category: "transformation",
              inputs: [
                { start: 0, name: "x", type: "tensor" },
                { start: 1, name: "blockShape", type: "number[]" },
                { start: 2, name: "crops", type: "number[]" },
              ],
            },
            {
              tfOpName: "DepthToSpace",
              category: "transformation",
              inputs: [{ start: 0, name: "x", type: "tensor" }],
              attrs: [
                { tfName: "block_size", name: "blockSize", type: "number" },
                { tfName: "data_format", name: "dataFormat", type: "string" },
              ],
            },
          ],
        }),
        F = (function () {
          function t() {
            var t = [y, b, w, x, C, O, E, I, N, S, k, _, A, T, R, D],
              e = [].concat.apply(
                [],
                t.map(function (t) {
                  return t.json;
                })
              );
            this.opMappers = e.reduce(function (t, e) {
              return (t[e.tfOpName] = e), t;
            }, {});
          }
          return (
            Object.defineProperty(t, "Instance", {
              get: function () {
                return this._instance || (this._instance = new this());
              },
              enumerable: !0,
              configurable: !0,
            }),
            (t.prototype.transformGraph = function (t, e) {
              var n = this;
              void 0 === e && (e = {});
              var r = [],
                i = [],
                a = t.node.reduce(function (t, e) {
                  return (
                    (t[e.name] = n.mapNode(e)),
                    e.op.startsWith("Placeholder") && r.push(t[e.name]),
                    "Const" === e.op && i.push(t[e.name]),
                    t
                  );
                }, {}),
                o = [],
                s = [],
                u = {},
                c = {};
              null != e &&
                ((u = this.mapSignatureEntries(e.inputs)),
                (c = this.mapSignatureEntries(e.outputs)));
              var l = Object.keys(a);
              return (
                l.forEach(function (t) {
                  var e = a[t];
                  e.inputNames.forEach(function (t) {
                    var n = d(t)[0];
                    e.inputs.push(a[n]), a[n].children.push(e);
                  });
                }),
                0 === Object.keys(c).length
                  ? l.forEach(function (t) {
                      var e = a[t];
                      0 === e.children.length && s.push(e);
                    })
                  : Object.keys(c).forEach(function (t) {
                      var e = d(t)[0],
                        n = a[e];
                      null != n && ((n.signatureKey = c[t]), s.push(n));
                    }),
                Object.keys(u).length > 0
                  ? Object.keys(u).forEach(function (t) {
                      var e = d(t)[0],
                        n = a[e];
                      n && ((n.signatureKey = u[t]), o.push(n));
                    })
                  : (o = r),
                {
                  nodes: a,
                  inputs: o,
                  outputs: s,
                  weights: i,
                  placeholders: r,
                  signature: e,
                }
              );
            }),
            (t.prototype.mapSignatureEntries = function (t) {
              return Object.keys(t || {}).reduce(function (e, n) {
                return (e[t[n].name] = n), e;
              }, {});
            }),
            (t.prototype.mapNode = function (t) {
              var e = p(t.op) || this.opMappers[t.op] || {};
              null == t.attr && (t.attr = {});
              var n = {
                name: t.name,
                op: t.op,
                category: e.category,
                inputNames: (t.input || []).map(function (t) {
                  return t.startsWith("^") ? t.substr(1) : t;
                }),
                inputs: [],
                children: [],
                inputParams: {},
                attrParams: {},
                rawAttrs: t.attr,
              };
              return (
                null != e.inputs &&
                  (n.inputParams = e.inputs.reduce(function (t, e) {
                    return (
                      (t[e.name] = {
                        type: e.type,
                        inputIndexStart: e.start,
                        inputIndexEnd: e.end,
                      }),
                      t
                    );
                  }, {})),
                null != e.attrs &&
                  (n.attrParams = e.attrs.reduce(function (e, n) {
                    var r = n.type,
                      i = void 0;
                    switch (n.type) {
                      case "string":
                        void 0 === (i = j(t.attr, n.tfName, n.defaultValue)) &&
                          n.tfDeprecatedName &&
                          (i = j(t.attr, n.tfDeprecatedName, n.defaultValue));
                        break;
                      case "string[]":
                        void 0 === (i = H(t.attr, n.tfName, n.defaultValue)) &&
                          n.tfDeprecatedName &&
                          (i = H(t.attr, n.tfDeprecatedName, n.defaultValue));
                        break;
                      case "number":
                        void 0 ===
                          (i = z(t.attr, n.tfName, n.defaultValue || 0)) &&
                          n.tfDeprecatedName &&
                          (i = z(t.attr, n.tfDeprecatedName, n.defaultValue));
                        break;
                      case "number[]":
                        void 0 === (i = G(t.attr, n.tfName, n.defaultValue)) &&
                          n.tfDeprecatedName &&
                          (i = G(t.attr, n.tfDeprecatedName, n.defaultValue));
                        break;
                      case "bool":
                        void 0 === (i = P(t.attr, n.tfName, n.defaultValue)) &&
                          n.tfDeprecatedName &&
                          (i = P(t.attr, n.tfDeprecatedName, n.defaultValue));
                        break;
                      case "bool[]":
                        void 0 === (i = K(t.attr, n.tfName, n.defaultValue)) &&
                          n.tfDeprecatedName &&
                          (i = K(t.attr, n.tfDeprecatedName, n.defaultValue));
                        break;
                      case "shape":
                        void 0 === (i = V(t.attr, n.tfName, n.defaultValue)) &&
                          n.tfDeprecatedName &&
                          (i = V(t.attr, n.tfDeprecatedName, n.defaultValue));
                        break;
                      case "shape[]":
                        void 0 === (i = q(t.attr, n.tfName, n.defaultValue)) &&
                          n.tfDeprecatedName &&
                          (i = q(t.attr, n.tfDeprecatedName, n.defaultValue));
                        break;
                      case "dtype":
                        void 0 === (i = B(t.attr, n.tfName, n.defaultValue)) &&
                          n.tfDeprecatedName &&
                          (i = B(t.attr, n.tfDeprecatedName, n.defaultValue));
                        break;
                      case "dtype[]":
                        void 0 === (i = W(t.attr, n.tfName, n.defaultValue)) &&
                          n.tfDeprecatedName &&
                          (i = W(t.attr, n.tfDeprecatedName, n.defaultValue));
                        break;
                      case "tensor":
                      case "tensors":
                        break;
                      default:
                        throw new Error(
                          "Unsupported param type: " +
                            n.type +
                            " for op: " +
                            t.op
                        );
                    }
                    return (e[n.name] = { value: i, type: r }), e;
                  }, {})),
                n
              );
            }),
            t
          );
        })();
      function M(e, n) {
        var r = Array.isArray(e)
          ? String.fromCharCode.apply(null, e)
          : (function (e) {
              var n = Object(o.Y)().global;
              if (void 0 !== n.atob) return n.atob(e);
              if (void 0 !== t) return new t(e, "base64").toString();
              throw new Error(
                "Unable to decode base64 in this environment. Missing built-in atob() or Buffer()"
              );
            })(e);
        return n ? r : r.toLowerCase();
      }
      function j(t, e, n, r) {
        void 0 === r && (r = !1);
        var i = t[e];
        return null != i ? M(i.s, r) : n;
      }
      function P(t, e, n) {
        var r = t[e];
        return r ? r.b : n;
      }
      function z(t, e, n) {
        var r = t[e] || {},
          i = null != r.i ? r.i : null != r.f ? r.f : n;
        return "number" == typeof i ? i : parseInt(i, 10);
      }
      function L(t) {
        switch (("string" == typeof t && (t = r[t]), t)) {
          case r.DT_FLOAT:
            return "float32";
          case r.DT_INT32:
          case r.DT_INT64:
            return "int32";
          case r.DT_BOOL:
            return "bool";
          case r.DT_DOUBLE:
            return "float32";
          case r.DT_STRING:
            return "string";
          default:
            return null;
        }
      }
      function B(t, e, n) {
        var r = t[e];
        return r && r.type ? L(r.type) : n;
      }
      function W(t, e, n) {
        var r = t[e];
        return r && r.list && r.list.type
          ? r.list.type.map(function (t) {
              return L(t);
            })
          : n;
      }
      function U(t) {
        if (!t.unknownRank)
          return null != t.dim
            ? t.dim.map(function (t) {
                return "number" == typeof t.size
                  ? t.size
                  : parseInt(t.size, 10);
              })
            : [];
      }
      function V(t, e, n) {
        var r = t[e];
        return r && r.shape ? U(r.shape) : n;
      }
      function G(t, e, n) {
        var r = t[e];
        return r
          ? ((r.list.f && r.list.f.length ? r.list.f : r.list.i) || []).map(
              function (t) {
                return "number" == typeof t ? t : parseInt(t, 10);
              }
            )
          : n;
      }
      function H(t, e, n, r) {
        void 0 === r && (r = !1);
        var i = t[e];
        return i && i.list && i.list.s
          ? i.list.s.map(function (t) {
              return M(t, r);
            })
          : n;
      }
      function q(t, e, n) {
        var r = t[e];
        return r && r.list && r.list.shape
          ? r.list.shape.map(function (t) {
              return U(t);
            })
          : n;
      }
      function K(t, e, n) {
        var r = t[e];
        return r && r.list && r.list.b ? r.list.b : n;
      }
      var Z = (function () {
          function t(t, e, n) {
            var r = this;
            (this.node = t),
              (this.tensorMap = e),
              (this.context = n),
              (this.inputs = []),
              (this.attrs = {}),
              (this.inputs = t.inputNames.map(function (t) {
                return r.getInput(t);
              })),
              null != t.rawAttrs &&
                (this.attrs = Object.keys(t.rawAttrs).reduce(function (t, e) {
                  return (t[e] = r.getAttr(e)), t;
                }, {}));
          }
          return (
            (t.prototype.getInput = function (t) {
              return f(t, this.tensorMap, this.context);
            }),
            (t.prototype.getAttr = function (t, e) {
              var n = this.node.rawAttrs[t];
              if (null != n.tensor) return f(t, this.tensorMap, this.context);
              if (null != n.i || null != n.f)
                return z(this.node.rawAttrs, t, e);
              if (null != n.s) return j(this.node.rawAttrs, t, e);
              if (null != n.b) return P(this.node.rawAttrs, t, e);
              if (null != n.shape) return V(this.node.rawAttrs, t, e);
              if (null != n.type) return B(this.node.rawAttrs, t, e);
              if (null != n.list) {
                if (null != n.list.i || null != n.list.f)
                  return G(this.node.rawAttrs, t, e);
                if (null != n.list.s) return H(this.node.rawAttrs, t, e);
                if (null != n.list.shape) return q(this.node.rawAttrs, t, e);
                if (null != n.list.b) return K(this.node.rawAttrs, t, e);
                if (null != n.list.type) return W(this.node.rawAttrs, t, e);
              }
              return e;
            }),
            t
          );
        })(),
        X = (function () {
          function t(e, n, r, i, a, o, s) {
            (this.name = e),
              (this.dtype = n),
              (this.maxSize = r),
              (this.elementShape = i),
              (this.identicalElementShapes = a),
              (this.dynamicSize = o),
              (this.clearAfterRead = s),
              (this.tensors = []),
              (this.closed_ = !1),
              (this.id = t.nextId++);
          }
          return (
            Object.defineProperty(t.prototype, "closed", {
              get: function () {
                return this.closed_;
              },
              enumerable: !0,
              configurable: !0,
            }),
            (t.prototype.clearAndClose = function () {
              this.tensors.forEach(function (t) {
                return t.tensor.dispose();
              }),
                (this.tensors = []),
                (this.closed_ = !0);
            }),
            (t.prototype.size = function () {
              return this.tensors.length;
            }),
            (t.prototype.read = function (t) {
              if (this.closed_)
                throw new Error(
                  "TensorArray " + this.name + " has already been closed."
                );
              if (t < 0 || t >= this.tensors.length)
                throw new Error(
                  "Tried to read from index " +
                    t +
                    ", but array size is: " +
                    this.tensors.length
                );
              var e = this.tensors[t];
              if (e.cleared)
                throw new Error(
                  "TensorArray " +
                    this.name +
                    ": Could not read index " +
                    t +
                    " twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?)."
                );
              return (
                this.clearAfterRead && (e.cleared = !0), (e.read = !0), e.tensor
              );
            }),
            (t.prototype.readMany = function (t) {
              var e = this;
              return t.map(function (t) {
                return e.read(t);
              });
            }),
            (t.prototype.write = function (t, e) {
              if (this.closed_)
                throw new Error(
                  "TensorArray " + this.name + " has already been closed."
                );
              if (t < 0 || (!this.dynamicSize && t >= this.maxSize))
                throw new Error(
                  "Tried to write to index " +
                    t +
                    ", but array is not resizeable and size is: " +
                    this.maxSize
                );
              var n = this.tensors[t] || {};
              if (e.dtype !== this.dtype)
                throw new Error(
                  "TensorArray " +
                    this.name +
                    ": Could not write to TensorArray index " +
                    t +
                    ",\n          because the value dtype is " +
                    e.dtype +
                    ", but TensorArray dtype is " +
                    this.dtype +
                    "."
                );
              if (
                (0 !== this.size() ||
                  (null != this.elementShape &&
                    0 !== this.elementShape.length) ||
                  (this.elementShape = e.shape),
                this.assertShapesMatchAllowUndefinedSize(
                  this.elementShape,
                  e.shape,
                  "TensorArray " +
                    this.name +
                    ": Could not write to TensorArray index " +
                    t +
                    "."
                ),
                n && n.read)
              )
                throw new Error(
                  "TensorArray " +
                    this.name +
                    ": Could not write to TensorArray index " +
                    t +
                    ", because it has already been read."
                );
              if (n && n.written)
                throw new Error(
                  "TensorArray " +
                    this.name +
                    ": Could not write to TensorArray index " +
                    t +
                    ", because it has already been written."
                );
              (n.tensor = e), (n.written = !0), (this.tensors[t] = n);
            }),
            (t.prototype.writeMany = function (t, e) {
              var n = this;
              if (t.length !== e.length)
                throw new Error(
                  "TensorArray " +
                    this.name +
                    ": could not write multiple tensors,because the index size: " +
                    t.length +
                    " is not the same as tensors size: " +
                    e.length +
                    "."
                );
              t.forEach(function (t, r) {
                return n.write(t, e[r]);
              });
            }),
            (t.prototype.gather = function (t, e) {
              if (e && e !== this.dtype)
                throw new Error(
                  "TensorArray dtype is " +
                    this.dtype +
                    " but gather requested dtype " +
                    e
                );
              if (!t) {
                t = [];
                for (var n = 0; n < this.size(); n++) t.push(n);
              }
              if (0 === t.length)
                return Object(o.Tc)([], [0].concat(this.elementShape));
              var r = this.readMany(t);
              return (
                this.assertShapesMatchAllowUndefinedSize(
                  this.elementShape,
                  r[0].shape,
                  "TensorArray shape mismatch: "
                ),
                Object(o.Nc)(r, 0)
              );
            }),
            (t.prototype.concat = function (t) {
              if (t && t !== this.dtype)
                throw new Error(
                  "TensorArray dtype is " +
                    this.dtype +
                    " but concat requested dtype " +
                    t
                );
              if (0 === this.size())
                return Object(o.Tc)([], [0].concat(this.elementShape));
              for (var e = [], n = 0; n < this.size(); n++) e.push(n);
              var r = this.readMany(e);
              return (
                this.assertShapesMatchAllowUndefinedSize(
                  this.elementShape,
                  r[0].shape,
                  "TensorArray shape mismatch: tensor array shape (" +
                    this.elementShape +
                    ") vs first tensor shape (" +
                    r[0].shape +
                    ")"
                ),
                Object(o.E)(r, 0)
              );
            }),
            (t.prototype.scatter = function (t, e) {
              if (e.dtype !== this.dtype)
                throw new Error(
                  "TensorArray dtype is " +
                    this.dtype +
                    " but tensor has dtype " +
                    e.dtype
                );
              if (t.length !== e.shape[0])
                throw new Error(
                  "Expected len(indices) == tensor.shape[0], but saw: " +
                    t.length +
                    " vs. " +
                    e.shape[0]
                );
              var n = Math.max.apply(Math, t);
              if (!this.dynamicSize && n >= this.maxSize)
                throw new Error(
                  "Max index must be < array size (" +
                    n +
                    "  vs. " +
                    this.maxSize +
                    ")"
                );
              this.writeMany(t, Object(o.fd)(e, 0));
            }),
            (t.prototype.split = function (t, e) {
              var n = this;
              if (e.dtype !== this.dtype)
                throw new Error(
                  "TensorArray dtype is " +
                    this.dtype +
                    " but tensor has dtype " +
                    e.dtype
                );
              var r = 0,
                i = t.map(function (t) {
                  return (r += t);
                });
              if (r !== e.shape[0])
                throw new Error(
                  "Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        " +
                    r +
                    ", and tensor's shape is: " +
                    e.shape
                );
              if (!this.dynamicSize && t.length !== this.maxSize)
                throw new Error(
                  "TensorArray's size is not equal to the size of lengths (" +
                    this.maxSize +
                    " vs. " +
                    t.length +
                    "), and the TensorArray is not marked as dynamically resizeable"
                );
              var a = 0 === r ? 0 : e.size / r,
                s = [];
              Object(o.Zc)(function () {
                e = e.reshape([1, r, a]);
                for (var u = 0; u < t.length; ++u) {
                  var c = [0, 0 === u ? 0 : i[u - 1], 0],
                    l = [1, t[u], a];
                  s[u] = Object(o.zc)(e, c, l).reshape(n.elementShape);
                }
                return s;
              });
              for (var u = [], c = 0; c < t.length; c++) u[c] = c;
              this.writeMany(u, s);
            }),
            (t.prototype.assertShapesMatchAllowUndefinedSize = function (
              t,
              e,
              n
            ) {
              void 0 === n && (n = ""),
                o.gd.assert(
                  this.shapesEqualAllowUndefinedSize(t, e),
                  function () {
                    return n + " Shapes " + t + " and " + e + " must match";
                  }
                );
            }),
            (t.prototype.shapesEqualAllowUndefinedSize = function (t, e) {
              if (t.length !== e.length) return !1;
              for (var n = 0; n < t.length; n++)
                if (-1 !== t[n] && -1 !== e[n] && t[n] !== e[n]) return !1;
              return !0;
            }),
            (t.nextId = 0),
            t
          );
        })();
      function Y(t, e, n) {
        var r = (function (t, e, n) {
          switch (t.category) {
            case "arithmetic":
              return Object(o.Zc)(function () {
                return (function (t, e, n) {
                  switch (t.op) {
                    case "BiasAdd":
                    case "AddV2":
                    case "Add":
                      return [Object(o.g)(h("a", t, e, n), h("b", t, e, n))];
                    case "AddN":
                      return [Object(o.h)(h("tensors", t, e, n))];
                    case "FloorMod":
                    case "Mod":
                      return [Object(o.Pb)(h("a", t, e, n), h("b", t, e, n))];
                    case "Mul":
                      return [Object(o.Rb)(h("a", t, e, n), h("b", t, e, n))];
                    case "RealDiv":
                    case "Div":
                      return [Object(o.T)(h("a", t, e, n), h("b", t, e, n))];
                    case "DivNoNan":
                      return [Object(o.U)(h("a", t, e, n), h("b", t, e, n))];
                    case "FloorDiv":
                      return [Object(o.ib)(h("a", t, e, n), h("b", t, e, n))];
                    case "Sub":
                      return [Object(o.Pc)(h("a", t, e, n), h("b", t, e, n))];
                    case "Minimum":
                      return [Object(o.Ob)(h("a", t, e, n), h("b", t, e, n))];
                    case "Maximum":
                      return [Object(o.Kb)(h("a", t, e, n), h("b", t, e, n))];
                    case "Pow":
                      return [Object(o.bc)(h("a", t, e, n), h("b", t, e, n))];
                    case "SquaredDifference":
                      return [Object(o.Lc)(h("a", t, e, n), h("b", t, e, n))];
                    default:
                      throw TypeError(
                        "Node type " + t.op + " is not implemented"
                      );
                  }
                })(t, e, n);
              });
            case "basic_math":
              return Object(o.Zc)(function () {
                return (function (t, e, n) {
                  switch (t.op) {
                    case "Abs":
                    case "ComplexAbs":
                      return [Object(o.d)(h("x", t, e, n))];
                    case "Acos":
                      return [Object(o.e)(h("x", t, e, n))];
                    case "Acosh":
                      return [Object(o.f)(h("x", t, e, n))];
                    case "Asin":
                      return [Object(o.m)(h("x", t, e, n))];
                    case "Asinh":
                      return [Object(o.n)(h("x", t, e, n))];
                    case "Atan":
                      return [Object(o.o)(h("x", t, e, n))];
                    case "Atan2":
                      return [Object(o.p)(h("x", t, e, n), h("y", t, e, n))];
                    case "Atanh":
                      return [Object(o.q)(h("x", t, e, n))];
                    case "Ceil":
                      return [Object(o.B)(h("x", t, e, n))];
                    case "Complex":
                      return [
                        Object(o.D)(h("real", t, e, n), h("imag", t, e, n)),
                      ];
                    case "Cos":
                      return [Object(o.N)(h("x", t, e, n))];
                    case "Cosh":
                      return [Object(o.O)(h("x", t, e, n))];
                    case "Elu":
                      return [Object(o.W)(h("x", t, e, n))];
                    case "Erf":
                      return [Object(o.ab)(h("x", t, e, n))];
                    case "Exp":
                      return [Object(o.bb)(h("x", t, e, n))];
                    case "Expm1":
                      return [Object(o.db)(h("x", t, e, n))];
                    case "Floor":
                      return [Object(o.hb)(h("x", t, e, n))];
                    case "Log":
                      return [Object(o.Ab)(h("x", t, e, n))];
                    case "Log1p":
                      return [Object(o.Bb)(h("x", t, e, n))];
                    case "Imag":
                      return [Object(o.pb)(h("x", t, e, n))];
                    case "Neg":
                      return [Object(o.Ub)(h("x", t, e, n))];
                    case "Reciprocal":
                      return [Object(o.ic)(h("x", t, e, n))];
                    case "Real":
                      return [Object(o.hc)(h("x", t, e, n))];
                    case "Relu":
                      return [Object(o.jc)(h("x", t, e, n))];
                    case "Round":
                      return [Object(o.nc)(h("x", t, e, n))];
                    case "Selu":
                      return [Object(o.rc)(h("x", t, e, n))];
                    case "Sigmoid":
                      return [Object(o.vc)(h("x", t, e, n))];
                    case "Sin":
                      return [Object(o.xc)(h("x", t, e, n))];
                    case "Sign":
                      return [Object(o.wc)(h("x", t, e, n))];
                    case "Sinh":
                      return [Object(o.yc)(h("x", t, e, n))];
                    case "Softplus":
                      return [Object(o.Fc)(h("x", t, e, n))];
                    case "Sqrt":
                      return [Object(o.Jc)(h("x", t, e, n))];
                    case "Square":
                      return [Object(o.Kc)(h("x", t, e, n))];
                    case "Tanh":
                      return [Object(o.Sc)(h("x", t, e, n))];
                    case "Tan":
                      return [Object(o.Rc)(h("x", t, e, n))];
                    case "Relu6":
                    case "ClipByValue":
                      return [
                        Object(o.C)(
                          h("x", t, e, n),
                          h("clipValueMin", t, e, n),
                          h("clipValueMax", t, e, n)
                        ),
                      ];
                    case "Rsqrt":
                      return [Object(o.oc)(f(t.inputNames[0], e, n))];
                    case "Prod":
                      return [
                        Object(o.dc)(h("x", t, e, n), h("axes", t, e, n)),
                      ];
                    case "LeakyRelu":
                      return [
                        Object(o.ub)(h("x", t, e, n), h("alpha", t, e, n)),
                      ];
                    case "Prelu":
                      return [
                        Object(o.cc)(h("x", t, e, n), h("alpha", t, e, n)),
                      ];
                    default:
                      throw TypeError(
                        "Node type " + t.op + " is not implemented"
                      );
                  }
                })(t, e, n);
              });
            case "control":
              return (function (t, e, n) {
                return u(void 0, void 0, void 0, function () {
                  var r,
                    i,
                    a,
                    s,
                    u,
                    l,
                    p,
                    d,
                    m,
                    v,
                    g,
                    y,
                    b,
                    w,
                    x,
                    C,
                    O,
                    E,
                    S,
                    N,
                    I,
                    k,
                    _,
                    A,
                    T,
                    R,
                    D,
                    F,
                    M,
                    j,
                    P,
                    z,
                    L,
                    B,
                    W;
                  return c(this, function (c) {
                    switch (c.label) {
                      case 0:
                        switch (t.op) {
                          case "LoopCond":
                            return [3, 1];
                          case "Switch":
                            return [3, 2];
                          case "Merge":
                            return [3, 4];
                          case "Enter":
                            return [3, 5];
                          case "Exit":
                            return [3, 6];
                          case "NextIteration":
                            return [3, 7];
                          case "TensorArrayV3":
                            return [3, 8];
                          case "TensorArrayWriteV3":
                            return [3, 9];
                          case "TensorArrayReadV3":
                            return [3, 10];
                          case "TensorArrayGatherV3":
                            return [3, 11];
                          case "TensorArrayScatterV3":
                            return [3, 12];
                          case "TensorArrayConcatV3":
                            return [3, 13];
                          case "TensorArraySplitV3":
                            return [3, 14];
                          case "TensorArraySizeV3":
                            return [3, 15];
                          case "TensorArrayCloseV3":
                            return [3, 16];
                        }
                        return [3, 17];
                      case 1:
                        return [2, [h("pred", t, e, n).clone()]];
                      case 2:
                        return (
                          (r = h("pred", t, e, n)),
                          (i = h("data", t, e, n)),
                          [4, r.data()]
                        );
                      case 3:
                        return [
                          2,
                          c.sent()[0]
                            ? [void 0, i.clone()]
                            : [i.clone(), void 0],
                        ];
                      case 4:
                        return [
                          2,
                          (a = t.inputNames.find(function (t) {
                            return void 0 !== f(t, e, n);
                          }))
                            ? [f(a, e, n).clone()]
                            : void 0,
                        ];
                      case 5:
                        return (
                          (s = h("frameName", t, e, n)),
                          (u = h("tensor", t, e, n)),
                          n.enterFrame(s),
                          [2, [u.clone()]]
                        );
                      case 6:
                        return (
                          (l = h("tensor", t, e, n)),
                          n.exitFrame(),
                          [2, [l.clone()]]
                        );
                      case 7:
                        return (
                          (p = h("tensor", t, e, n)),
                          n.nextIteration(),
                          [2, [p.clone()]]
                        );
                      case 8:
                        return (
                          (d = h("size", t, e, n)),
                          (m = h("dtype", t, e, n)),
                          (v = h("elementShape", t, e, n)),
                          (g = h("dynamicSize", t, e, n)),
                          (y = h("clearAfterRead", t, e, n)),
                          (b = h("identicalElementShapes", t, e, n)),
                          (w = h("name", t, e, n)),
                          (x = new X(w, m, d, v, b, g, y)),
                          n.addTensorArray(x),
                          [2, [Object(o.pc)(x.id), Object(o.pc)(1)]]
                        );
                      case 9:
                        return (
                          (C = h("tensorArrayId", t, e, n)),
                          (O = h("index", t, e, n)),
                          (E = h("tensor", t, e, n)),
                          n.getTensorArray(C).write(O, E),
                          [2, [Object(o.pc)(1)]]
                        );
                      case 10:
                        return (
                          (S = h("tensorArrayId", t, e, n)),
                          (N = h("index", t, e, n)),
                          [2, [n.getTensorArray(S).read(N)]]
                        );
                      case 11:
                        return (
                          (I = h("tensorArrayId", t, e, n)),
                          (k = h("indices", t, e, n)),
                          (_ = h("dtype", t, e, n)),
                          [2, [n.getTensorArray(I).gather(k, _)]]
                        );
                      case 12:
                        return (
                          (A = h("tensorArrayId", t, e, n)),
                          (T = h("indices", t, e, n)),
                          (R = h("tensor", t, e, n)),
                          n.getTensorArray(A).scatter(T, R),
                          [2, [Object(o.pc)(1)]]
                        );
                      case 13:
                        return (
                          (D = h("tensorArrayId", t, e, n)),
                          (F = n.getTensorArray(D)),
                          (M = h("dtype", t, e, n)),
                          [2, [F.concat(M)]]
                        );
                      case 14:
                        return (
                          (j = h("tensorArrayId", t, e, n)),
                          (P = h("tensor", t, e, n)),
                          (z = h("lengths", t, e, n)),
                          n.getTensorArray(j).split(z, P),
                          [2, [Object(o.pc)(1)]]
                        );
                      case 15:
                        return (
                          (L = h("tensorArrayId", t, e, n)),
                          (B = n.getTensorArray(L)),
                          [2, [Object(o.pc)(B.size(), "int32")]]
                        );
                      case 16:
                        return (
                          (W = h("tensorArrayId", t, e, n)),
                          n.getTensorArray(W).clearAndClose(),
                          [2, [Object(o.pc)(0)]]
                        );
                      case 17:
                        throw TypeError(
                          "Node type " + t.op + " is not implemented"
                        );
                    }
                  });
                });
              })(t, e, n);
            case "convolution":
              return Object(o.Zc)(function () {
                return (function (t, e, n) {
                  switch (t.op) {
                    case "Conv1D":
                      var r = h("stride", t, e, n),
                        i = h("pad", t, e, n),
                        a = h("dataFormat", t, e, n).toUpperCase(),
                        s = h("dilation", t, e, n);
                      return [
                        Object(o.J)(
                          h("x", t, e, n),
                          h("filter", t, e, n),
                          r,
                          i,
                          a,
                          s
                        ),
                      ];
                    case "Conv2D":
                      (r = h("strides", t, e, n)),
                        (i = h("pad", t, e, n)),
                        (a = h("dataFormat", t, e, n).toUpperCase());
                      var u = h("dilations", t, e, n);
                      return [
                        Object(o.K)(
                          h("x", t, e, n),
                          h("filter", t, e, n),
                          [r[1], r[2]],
                          i,
                          a,
                          [u[1], u[2]]
                        ),
                      ];
                    case "_FusedConv2D":
                    case "FusedDepthwiseConv2dNative":
                      var c = h("fusedOps", t, e, n),
                        l = c[0],
                        p = c[1],
                        f = "biasadd" === l,
                        d = "prelu" === p,
                        m = "fusedbatchnorm" === l,
                        v = h("numArgs", t, e, n);
                      if (f) {
                        if (d && 2 !== v)
                          throw new Error(
                            "FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha."
                          );
                        if (!d && 1 !== v)
                          throw new Error(
                            "FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias."
                          );
                      }
                      if (m)
                        throw new Error(
                          "FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported."
                        );
                      (r = h("strides", t, e, n)),
                        (i = h("pad", t, e, n)),
                        (a = h("dataFormat", t, e, n).toUpperCase()),
                        (u = h("dilations", t, e, n));
                      var g = h("args", t, e, n),
                        y = g[0],
                        b = g[1];
                      return [
                        ("_FusedConv2D" === t.op
                          ? o.jb.conv2d
                          : o.jb.depthwiseConv2d)({
                          x: h("x", t, e, n),
                          filter: h("filter", t, e, n),
                          strides: [r[1], r[2]],
                          pad: i,
                          dataFormat: a,
                          dilations: [u[1], u[2]],
                          bias: y,
                          activation: p,
                          preluActivationWeights: b,
                        }),
                      ];
                    case "Conv2DBackpropInput":
                    case "Conv2dTranspose":
                      var w = h("outputShape", t, e, n);
                      return (
                        (r = h("strides", t, e, n)),
                        (i = h("pad", t, e, n)),
                        [
                          Object(o.L)(
                            h("x", t, e, n),
                            h("filter", t, e, n),
                            w,
                            [r[1], r[2]],
                            i
                          ),
                        ]
                      );
                    case "DepthwiseConv2dNative":
                    case "DepthwiseConv2d":
                      return (
                        (r = h("strides", t, e, n)),
                        (i = h("pad", t, e, n)),
                        (u = h("dilations", t, e, n)),
                        (a = h("dataFormat", t, e, n).toUpperCase()),
                        [
                          Object(o.R)(
                            h("input", t, e, n),
                            h("filter", t, e, n),
                            [r[1], r[2]],
                            i,
                            a,
                            [u[1], u[2]]
                          ),
                        ]
                      );
                    case "Conv3D":
                      return (
                        (r = h("strides", t, e, n)),
                        (i = h("pad", t, e, n)),
                        (a = h("dataFormat", t, e, n).toUpperCase()),
                        (u = h("dilations", t, e, n)),
                        [
                          Object(o.M)(
                            h("x", t, e, n),
                            h("filter", t, e, n),
                            [r[1], r[2], r[3]],
                            i,
                            a,
                            [u[1], u[2], u[3]]
                          ),
                        ]
                      );
                    case "AvgPool":
                      (r = h("strides", t, e, n)), (i = h("pad", t, e, n));
                      var x = h("kernelSize", t, e, n);
                      return [
                        Object(o.r)(
                          h("x", t, e, n),
                          [x[1], x[2]],
                          [r[1], r[2]],
                          i
                        ),
                      ];
                    case "MaxPool":
                      return (
                        (r = h("strides", t, e, n)),
                        (i = h("pad", t, e, n)),
                        (x = h("kernelSize", t, e, n)),
                        [
                          Object(o.Ib)(
                            h("x", t, e, n),
                            [x[1], x[2]],
                            [r[1], r[2]],
                            i
                          ),
                        ]
                      );
                    case "AvgPool3D":
                      return (
                        (r = h("strides", t, e, n)),
                        (i = h("pad", t, e, n)),
                        (x = h("kernelSize", t, e, n)),
                        [
                          Object(o.s)(
                            h("x", t, e, n),
                            [x[1], x[2], x[3]],
                            [r[1], r[2], r[3]],
                            i
                          ),
                        ]
                      );
                    case "MaxPool3D":
                      return (
                        (r = h("strides", t, e, n)),
                        (i = h("pad", t, e, n)),
                        (x = h("kernelSize", t, e, n)),
                        [
                          Object(o.Jb)(
                            h("x", t, e, n),
                            [x[1], x[2], x[3]],
                            [r[1], r[2], r[3]],
                            i
                          ),
                        ]
                      );
                    default:
                      throw TypeError(
                        "Node type " + t.op + " is not implemented"
                      );
                  }
                })(t, e, n);
              });
            case "creation":
              return Object(o.Zc)(function () {
                return (function (t, e, n) {
                  switch (t.op) {
                    case "Fill":
                      var r = h("shape", t, e, n),
                        i = h("dtype", t, e, n),
                        a = h("value", t, e, n);
                      return [Object(o.gb)(r, a, i)];
                    case "LinSpace":
                      var s = h("start", t, e, n),
                        u = h("stop", t, e, n),
                        c = h("num", t, e, n);
                      return [Object(o.yb)(s, u, c)];
                    case "Multinomial":
                      var l = h("logits", t, e, n),
                        p = h("numSamples", t, e, n),
                        f = h("seed", t, e, n);
                      return [Object(o.Tb)(l, p, f)];
                    case "OneHot":
                      var d = h("indices", t, e, n),
                        m = h("depth", t, e, n),
                        v = h("onValue", t, e, n),
                        g = h("offValue", t, e, n);
                      return [Object(o.Xb)(d, m, v, g)];
                    case "Ones":
                      return [
                        Object(o.Yb)(h("shape", t, e, n), h("dtype", t, e, n)),
                      ];
                    case "OnesLike":
                      return [Object(o.Zb)(h("x", t, e, n))];
                    case "RandomUniform":
                      return [
                        Object(o.fc)(
                          h("shape", t, e, n),
                          h("minval", t, e, n),
                          h("maxval", t, e, n),
                          h("dtype", t, e, n)
                        ),
                      ];
                    case "Range":
                      s = h("start", t, e, n);
                      var y = h("stop", t, e, n),
                        b = h("step", t, e, n);
                      return [Object(o.gc)(s, y, b, h("dtype", t, e, n))];
                    case "TruncatedNormal":
                      r = h("shape", t, e, n);
                      var w = h("mean", t, e, n),
                        x = h("stdDev", t, e, n);
                      return (
                        (f = h("seed", t, e, n)),
                        [Object(o.ed)(r, w, x, h("dtype", t, e, n), f)]
                      );
                    case "Zeros":
                      return [
                        Object(o.ld)(h("shape", t, e, n), h("dtype", t, e, n)),
                      ];
                    case "ZerosLike":
                      return [Object(o.md)(h("x", t, e, n))];
                    default:
                      throw TypeError(
                        "Node type " + t.op + " is not implemented"
                      );
                  }
                })(t, e, n);
              });
            case "dynamic":
              return (function (t, e, n) {
                return u(void 0, void 0, void 0, function () {
                  var r, i, a, s, u, l, p, f;
                  return c(this, function (c) {
                    switch (c.label) {
                      case 0:
                        switch (t.op) {
                          case "NonMaxSuppressionV5":
                          case "NonMaxSuppressionV3":
                          case "NonMaxSuppressionV2":
                            return [3, 1];
                          case "Where":
                            return [3, 5];
                          case "ListDiff":
                            return [3, 7];
                        }
                        return [3, 8];
                      case 1:
                        return (
                          (r = h("boxes", t, e, n)),
                          (i = h("scores", t, e, n)),
                          (a = h("maxOutputSize", t, e, n)),
                          (s = h("iouThreshold", t, e, n)),
                          (u = h("scoreThreshold", t, e, n)),
                          "NonMaxSuppressionV5" !== t.op
                            ? [3, 3]
                            : ((l = h("softNmsSigma", t, e, n)),
                              [
                                4,
                                o.qb.nonMaxSuppressionWithScoreAsync(
                                  r,
                                  i,
                                  a,
                                  s,
                                  u,
                                  l
                                ),
                              ])
                        );
                      case 2:
                        return [
                          2,
                          [(f = c.sent()).selectedIndices, f.selectedScores],
                        ];
                      case 3:
                        return [4, o.qb.nonMaxSuppressionAsync(r, i, a, s, u)];
                      case 4:
                        return [2, [c.sent()]];
                      case 5:
                        return (
                          (p = h("condition", t, e, n).asType("bool")),
                          [4, Object(o.kd)(p)]
                        );
                      case 6:
                        return (f = [c.sent()]), p.dispose(), [2, f];
                      case 7:
                        return [
                          2,
                          Object(o.uc)(h("x", t, e, n), h("y", t, e, n)),
                        ];
                      case 8:
                        throw TypeError(
                          "Node type " + t.op + " is not implemented"
                        );
                    }
                  });
                });
              })(t, e, n);
            case "evaluation":
              return Object(o.Zc)(function () {
                return (function (t, e, n) {
                  switch (t.op) {
                    case "TopKV2":
                      var r = h("x", t, e, n),
                        i = h("k", t, e, n),
                        a = h("sorted", t, e, n),
                        s = Object(o.bd)(r, i, a);
                      return [s.values, s.indices];
                    default:
                      throw TypeError(
                        "Node type " + t.op + " is not implemented"
                      );
                  }
                })(t, e, n);
              });
            case "image":
              return Object(o.Zc)(function () {
                return (function (t, e, n) {
                  switch (t.op) {
                    case "ResizeBilinear":
                      var r = h("images", t, e, n),
                        i = h("size", t, e, n),
                        a = h("alignCorners", t, e, n);
                      return [o.qb.resizeBilinear(r, [i[0], i[1]], a)];
                    case "ResizeNearestNeighbor":
                      return (
                        (r = h("images", t, e, n)),
                        (i = h("size", t, e, n)),
                        (a = h("alignCorners", t, e, n)),
                        [o.qb.resizeNearestNeighbor(r, [i[0], i[1]], a)]
                      );
                    case "CropAndResize":
                      var s = h("image", t, e, n),
                        u = h("boxes", t, e, n),
                        c = h("boxInd", t, e, n),
                        l = h("cropSize", t, e, n),
                        p = h("method", t, e, n),
                        f = h("extrapolationValue", t, e, n);
                      return [o.qb.cropAndResize(s, u, c, l, p, f)];
                    default:
                      throw TypeError(
                        "Node type " + t.op + " is not implemented"
                      );
                  }
                })(t, e, n);
              });
            case "graph":
              return Object(o.Zc)(function () {
                return (function (t, e, n) {
                  switch (t.op) {
                    case "Const":
                      return e[t.name];
                    case "PlaceholderWithDefault":
                      var r = h("default", t, e, n);
                      return [f(t.name, e, n) || r];
                    case "Placeholder":
                      return [f(t.name, e, n)];
                    case "Identity":
                    case "StopGradient":
                    case "FakeQuantWithMinMaxVars":
                      return [h("x", t, e, n).clone()];
                    case "IdentityN":
                      return h("x", t, e, n).map(function (t) {
                        return t.clone();
                      });
                    case "Snapshot":
                      return [h("x", t, e, n).clone()];
                    case "Shape":
                      return [Object(o.Uc)(h("x", t, e, n).shape, "int32")];
                    case "ShapeN":
                      return h("x", t, e, n).map(function (t) {
                        return Object(o.Uc)(t.shape);
                      });
                    case "Size":
                      return [Object(o.pc)(h("x", t, e, n).size, "int32")];
                    case "Rank":
                      return [Object(o.pc)(h("x", t, e, n).rank, "int32")];
                    case "NoOp":
                      return [Object(o.pc)(1)];
                    case "Print":
                      var i = h("x", t, e, n),
                        a = h("data", t, e, n),
                        s = h("message", t, e, n),
                        u = h("summarize", t, e, n);
                      console.warn(
                        "The graph has a tf.print() operation,usually used for debugging, which slows down performance."
                      ),
                        console.log(s);
                      for (var c = 0; c < a.length; c++)
                        console.log(
                          Array.prototype.slice
                            .call(a[c].dataSync())
                            .slice(0, u)
                        );
                      return [i];
                    default:
                      throw TypeError(
                        "Node type " + t.op + " is not implemented"
                      );
                  }
                })(t, e, n);
              });
            case "logical":
              return Object(o.Zc)(function () {
                return (function (t, e, n) {
                  switch (t.op) {
                    case "Equal":
                      return [Object(o.Z)(h("a", t, e, n), h("b", t, e, n))];
                    case "NotEqual":
                      return [Object(o.Wb)(h("a", t, e, n), h("b", t, e, n))];
                    case "Greater":
                      return [Object(o.mb)(h("a", t, e, n), h("b", t, e, n))];
                    case "GreaterEqual":
                      return [Object(o.nb)(h("a", t, e, n), h("b", t, e, n))];
                    case "Less":
                      return [Object(o.vb)(h("a", t, e, n), h("b", t, e, n))];
                    case "LessEqual":
                      return [Object(o.wb)(h("a", t, e, n), h("b", t, e, n))];
                    case "LogicalAnd":
                      return [Object(o.Db)(h("a", t, e, n), h("b", t, e, n))];
                    case "LogicalNot":
                      return [Object(o.Eb)(h("a", t, e, n))];
                    case "LogicalOr":
                      return [Object(o.Fb)(h("a", t, e, n), h("b", t, e, n))];
                    case "Select":
                      return [
                        Object(o.jd)(
                          h("condition", t, e, n),
                          h("a", t, e, n),
                          h("b", t, e, n)
                        ),
                      ];
                    default:
                      throw TypeError(
                        "Node type " + t.op + " is not implemented"
                      );
                  }
                })(t, e, n);
              });
            case "matrices":
              return Object(o.Zc)(function () {
                return (function (t, e, n) {
                  switch (t.op) {
                    case "BatchMatMul":
                    case "BatchMatMulV2":
                    case "MatMul":
                      return [
                        Object(o.Gb)(
                          h("a", t, e, n),
                          h("b", t, e, n),
                          h("transposeA", t, e, n),
                          h("transposeB", t, e, n)
                        ),
                      ];
                    case "Transpose":
                      return [
                        Object(o.dd)(h("x", t, e, n), h("perm", t, e, n)),
                      ];
                    case "_FusedMatMul":
                      var r = h("fusedOps", t, e, n),
                        i = r[0],
                        a = r[1],
                        s = "biasadd" === i,
                        u = "prelu" === a,
                        c = h("numArgs", t, e, n);
                      if (s) {
                        if (u && 2 !== c)
                          throw new Error(
                            "Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha."
                          );
                        if (!u && 1 !== c)
                          throw new Error(
                            "Fused MatMul with BiasAdd must have one extra argument: bias."
                          );
                      }
                      var l = h("args", t, e, n),
                        p = l[0],
                        f = l[1];
                      return [
                        o.jb.matMul({
                          a: h("a", t, e, n),
                          b: h("b", t, e, n),
                          transposeA: h("transposeA", t, e, n),
                          transposeB: h("transposeB", t, e, n),
                          bias: p,
                          activation: a,
                          preluActivationWeights: f,
                        }),
                      ];
                    default:
                      throw TypeError(
                        "Node type " + t.op + " is not implemented"
                      );
                  }
                })(t, e, n);
              });
            case "normalization":
              return Object(o.Zc)(function () {
                return (function (t, e, n) {
                  switch (t.op) {
                    case "FusedBatchNorm":
                    case "FusedBatchNormV2":
                    case "FusedBatchNormV3":
                      return [
                        Object(o.u)(
                          h("x", t, e, n),
                          h("mean", t, e, n),
                          h("variance", t, e, n),
                          h("offset", t, e, n),
                          h("scale", t, e, n),
                          h("epsilon", t, e, n)
                        ),
                      ];
                    case "LRN":
                      return [
                        Object(o.zb)(
                          h("x", t, e, n),
                          h("radius", t, e, n),
                          h("bias", t, e, n),
                          h("alpha", t, e, n),
                          h("beta", t, e, n)
                        ),
                      ];
                    case "Softmax":
                      return [Object(o.Ec)(h("x", t, e, n))];
                    case "LogSoftmax":
                      return [Object(o.Cb)(h("x", t, e, n))];
                    case "SparseToDense":
                      return [
                        Object(o.Hc)(
                          h("sparseIndices", t, e, n),
                          h("outputShape", t, e, n),
                          h("sparseValues", t, e, n),
                          h("defaultValue", t, e, n)
                        ),
                      ];
                    default:
                      throw TypeError(
                        "Node type " + t.op + " is not implemented"
                      );
                  }
                })(t, e, n);
              });
            case "reduction":
              return Object(o.Zc)(function () {
                return (function (t, e, n) {
                  switch (t.op) {
                    case "Max":
                      var r = h("axis", t, e, n),
                        i = h("keepDims", t, e, n);
                      return [Object(o.Hb)(h("x", t, e, n), r, i)];
                    case "Mean":
                      return (
                        (r = h("axis", t, e, n)),
                        (i = h("keepDims", t, e, n)),
                        [Object(o.Lb)(h("x", t, e, n), r, i)]
                      );
                    case "Min":
                      return (
                        (r = h("axis", t, e, n)),
                        (i = h("keepDims", t, e, n)),
                        [Object(o.Nb)(h("x", t, e, n), r, i)]
                      );
                    case "Sum":
                      return (
                        (r = h("axis", t, e, n)),
                        (i = h("keepDims", t, e, n)),
                        [Object(o.Qc)(h("x", t, e, n), r, i)]
                      );
                    case "All":
                      return (
                        (r = h("axis", t, e, n)),
                        (i = h("keepDims", t, e, n)),
                        [Object(o.i)(h("x", t, e, n), r, i)]
                      );
                    case "Any":
                      return (
                        (r = h("axis", t, e, n)),
                        (i = h("keepDims", t, e, n)),
                        [Object(o.j)(h("x", t, e, n), r, i)]
                      );
                    case "ArgMax":
                      return (
                        (r = h("axis", t, e, n)),
                        [Object(o.k)(h("x", t, e, n), r)]
                      );
                    case "ArgMin":
                      return (
                        (r = h("axis", t, e, n)),
                        [Object(o.l)(h("x", t, e, n), r)]
                      );
                    case "Prod":
                      return (
                        (r = h("axis", t, e, n)),
                        (i = h("keepDims", t, e, n)),
                        [Object(o.dc)(h("x", t, e, n), r, i)]
                      );
                    default:
                      throw TypeError(
                        "Node type " + t.op + " is not implemented"
                      );
                  }
                })(t, e, n);
              });
            case "slice_join":
              return Object(o.Zc)(function () {
                return (function (t, e, n) {
                  switch (t.op) {
                    case "ConcatV2":
                    case "Concat":
                      var r = h("n", t, e, n),
                        i = h("axis", t, e, n),
                        a = h("tensors", t, e, n);
                      return (a = a.slice(0, r)), [Object(o.E)(a, i)];
                    case "GatherV2":
                    case "Gather":
                      i = h("axis", t, e, n);
                      var s = h("x", t, e, n),
                        u = h("indices", t, e, n);
                      return [Object(o.kb)(s, u.asType("int32"), i)];
                    case "ReverseV2":
                    case "Reverse":
                      return (
                        (i = h("axis", t, e, n)),
                        (s = h("x", t, e, n)),
                        [Object(o.lc)(s, i)]
                      );
                    case "Slice":
                      var c = h("begin", t, e, n),
                        l = h("size", t, e, n);
                      return [Object(o.zc)(h("x", t, e, n), c, l)];
                    case "StridedSlice":
                      c = h("begin", t, e, n);
                      var p = h("end", t, e, n),
                        f = h("strides", t, e, n),
                        d = h("beginMask", t, e, n),
                        m = h("endMask", t, e, n),
                        v = h("ellipsisMask", t, e, n),
                        g = h("newAxisMask", t, e, n),
                        y = h("shrinkAxisMask", t, e, n),
                        b = h("x", t, e, n);
                      if (1 === c.length && b.shape.length > 1)
                        for (var w = 1; w < b.shape.length; w++)
                          c.push(0), p.push(b.shape[w]), f.push(f[0]);
                      return [Object(o.Oc)(b, c, p, f, d, m, v, g, y)];
                    case "Pack":
                      return Object(o.Zc)(function () {
                        var r = h("axis", t, e, n),
                          i = h("tensors", t, e, n),
                          a = i[0].shape,
                          s = i[0].squeeze().shape,
                          u = i.map(function (t) {
                            var e = o.gd.arraysEqual(t.shape, a);
                            if (!e && !o.gd.arraysEqual(t.squeeze().shape, s))
                              throw new Error(
                                "the input tensors shape does not match"
                              );
                            return e ? t : t.reshape(a);
                          });
                        return [Object(o.Nc)(u, r)];
                      });
                    case "Unpack":
                      return Object(o.Zc)(function () {
                        var r = h("axis", t, e, n),
                          i = h("tensor", t, e, n);
                        return Object(o.fd)(i, r);
                      });
                    case "Tile":
                      var x = h("reps", t, e, n);
                      return [Object(o.ad)(h("x", t, e, n), x)];
                    case "Split":
                    case "SplitV":
                      i = h("axis", t, e, n);
                      var C = h("numOrSizeSplits", t, e, n);
                      return Object(o.Ic)(h("x", t, e, n), C, i);
                    case "ScatterNd":
                      u = h("indices", t, e, n);
                      var O = h("values", t, e, n),
                        E = h("shape", t, e, n);
                      return [Object(o.qc)(u, O, E)];
                    case "GatherNd":
                      var S = h("x", t, e, n);
                      return (u = h("indices", t, e, n)), [Object(o.lb)(S, u)];
                    case "SparseToDense":
                      (u = h("sparseIndices", t, e, n)),
                        (E = h("outputShape", t, e, n));
                      var N = h("sparseValues", t, e, n),
                        I = h("defaultValue", t, e, n);
                      return [
                        Object(o.Hc)(
                          u,
                          N,
                          E,
                          N.dtype === I.dtype ? I : I.asType(N.dtype)
                        ),
                      ];
                    default:
                      throw TypeError(
                        "Node type " + t.op + " is not implemented"
                      );
                  }
                })(t, e, n);
              });
            case "spectral":
              return Object(o.Zc)(function () {
                return (function (t, e, n) {
                  switch (t.op) {
                    case "FFT":
                      return [Object(o.fb)(h("x", t, e, n))];
                    case "IFFT":
                      return [Object(o.ob)(h("x", t, e, n))];
                    case "RFFT":
                      return [Object(o.mc)(h("x", t, e, n))];
                    case "IRFFT":
                      return [Object(o.sb)(h("x", t, e, n))];
                    default:
                      throw TypeError(
                        "Node type " + t.op + " is not implemented"
                      );
                  }
                })(t, e, n);
              });
            case "transformation":
              return Object(o.Zc)(function () {
                return (function (t, e, n) {
                  switch (t.op) {
                    case "Cast":
                      return [
                        Object(o.A)(h("x", t, e, n), h("dtype", t, e, n)),
                      ];
                    case "ExpandDims":
                      var r = h("axis", t, e, n);
                      return [Object(o.cb)(h("x", t, e, n), r)];
                    case "Squeeze":
                      return (
                        (r = h("axis", t, e, n)),
                        [Object(o.Mc)(h("x", t, e, n), r)]
                      );
                    case "Reshape":
                      return [
                        Object(o.kc)(h("x", t, e, n), h("shape", t, e, n)),
                      ];
                    case "PadV2":
                    case "Pad":
                      return [
                        Object(o.ac)(
                          h("x", t, e, n),
                          g(h("padding", t, e, n), 2),
                          h("constantValue", t, e, n)
                        ),
                      ];
                    case "SpaceToBatchND":
                      var i = h("blockShape", t, e, n),
                        a = g(h("paddings", t, e, n), 2);
                      return [Object(o.Gc)(h("x", t, e, n), i, a)];
                    case "BatchToSpaceND":
                      i = h("blockShape", t, e, n);
                      var s = g(h("crops", t, e, n), 2);
                      return [Object(o.y)(h("x", t, e, n), i, s)];
                    case "DepthToSpace":
                      var u = h("blockSize", t, e, n),
                        c = h("dataFormat", t, e, n).toUpperCase();
                      return [Object(o.Q)(h("x", t, e, n), u, c)];
                    default:
                      throw TypeError(
                        "Node type " + t.op + " is not implemented"
                      );
                  }
                })(t, e, n);
              });
            case "custom":
              var r = p(t.op);
              if (r && r.customExecutor)
                return r.customExecutor(new Z(t, e, n));
              throw TypeError("Custom op " + t.op + " is not registered.");
            default:
              throw TypeError(
                "Unknown op '" +
                  t.op +
                  "'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()"
              );
          }
        })(t, e, n);
        return r instanceof Promise
          ? r.then(function (t) {
              return [].concat(t);
            })
          : [].concat(r);
      }
      var J = (function () {
        function t(t, e) {
          (this.weightMap = t),
            (this.tensorArrayMap = e),
            (this.rootContext = { id: 0, frameName: "", iterationId: 0 }),
            (this.contexts = [this.rootContext]),
            (this.lastId = 0),
            this.generateCurrentContextIds();
        }
        return (
          (t.prototype.newFrame = function (t, e) {
            return { id: t, frameName: e, iterationId: 0 };
          }),
          Object.defineProperty(t.prototype, "currentContext", {
            get: function () {
              return this.contexts;
            },
            set: function (t) {
              this.contexts !== t &&
                ((this.contexts = t), this.generateCurrentContextIds());
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "currentContextId", {
            get: function () {
              return this._currentContextIds[0];
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "currentContextIds", {
            get: function () {
              return this._currentContextIds;
            },
            enumerable: !0,
            configurable: !0,
          }),
          (t.prototype.generateCurrentContextIds = function () {
            for (var t = [], e = 0; e < this.contexts.length - 1; e++) {
              var n = this.contexts.slice(0, this.contexts.length - e);
              t.push(this.contextIdforContexts(n));
            }
            t.push(""), (this._currentContextIds = t);
          }),
          (t.prototype.contextIdforContexts = function (t) {
            return t
              ? t
                  .map(function (t) {
                    return 0 === t.id && 0 === t.iterationId
                      ? ""
                      : t.frameName + "-" + t.iterationId;
                  })
                  .join("/")
              : "";
          }),
          (t.prototype.enterFrame = function (t) {
            this.contexts &&
              (this.lastId++,
              (this.contexts = this.contexts.slice()),
              this.contexts.push(this.newFrame(this.lastId, t)),
              this._currentContextIds.unshift(
                this.contextIdforContexts(this.contexts)
              ));
          }),
          (t.prototype.exitFrame = function () {
            if (!(this.contexts && this.contexts.length > 1))
              throw new Error("Cannot exit frame, the context is empty");
            (this.contexts = this.contexts.slice()),
              this.contexts.splice(-1),
              this.currentContextIds.shift();
          }),
          (t.prototype.nextIteration = function () {
            if (!(this.contexts && this.contexts.length > 0))
              throw new Error(
                "Cannot increase frame iteration, the context is empty"
              );
            (this.contexts = this.contexts.slice()), this.lastId++;
            var t = Object.assign({}, this.contexts[this.contexts.length - 1]);
            (t.iterationId += 1),
              (t.id = this.lastId),
              this.contexts.splice(-1, 1, t),
              this._currentContextIds.splice(
                0,
                1,
                this.contextIdforContexts(this.contexts)
              );
          }),
          (t.prototype.getWeight = function (t) {
            return this.weightMap[t];
          }),
          (t.prototype.addTensorArray = function (t) {
            this.tensorArrayMap[t.id] = t;
          }),
          (t.prototype.getTensorArray = function (t) {
            return this.tensorArrayMap[t];
          }),
          t
        );
      })();
      function $(t, e, n) {
        for (
          var r = new Set(),
            i = [],
            a = null,
            o = null,
            s = new Set(),
            u = Object.keys(t).map(function (t) {
              return v(t)[0];
            }),
            c = e.slice();
          c.length > 0;

        ) {
          var l = c.pop();
          (et(l) || nt(l)) &&
            null == a &&
            (o = (a = l).children
              .map(function (t) {
                return t.name;
              })
              .filter(function (t) {
                return r.has(t);
              })),
            r.add(l.name),
            null == n[l.name] &&
              -1 === u.indexOf(l.name) &&
              (0 !== l.inputs.length
                ? l.inputs.forEach(function (t) {
                    s.has(t.name) || (s.add(t.name), c.push(t));
                  })
                : i.push(l.name));
        }
        return {
          inputs: t,
          outputs: e,
          usedNodes: r,
          missingInputs: i,
          dynamicNode: a,
          syncInputs: o,
        };
      }
      var Q = ["Switch", "Merge", "Enter", "Exit", "NextIteration"],
        tt = [
          "NonMaxSuppressionV2",
          "NonMaxSuppressionV3",
          "NonMaxSuppressionV5",
          "Where",
        ];
      function et(t) {
        return Q.indexOf(t.op) >= 0;
      }
      function nt(t) {
        return tt.indexOf(t.op) >= 0;
      }
      var rt = (function () {
          function t(t) {
            (this.graph = t),
              (this.compiledMap = new Map()),
              (this._weightMap = {}),
              (this.SEPERATOR = ","),
              (this._outputs = t.outputs),
              (this._inputs = t.inputs),
              (this._signature = t.signature);
          }
          return (
            Object.defineProperty(t.prototype, "weightMap", {
              get: function () {
                return this._weightMap;
              },
              set: function (t) {
                var e = Object.keys(t).map(function (e) {
                  return t[e].map(function (t) {
                    return t.id;
                  });
                });
                (this.weightIds = [].concat.apply([], e)),
                  (this._weightMap = t);
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(t.prototype, "inputs", {
              get: function () {
                return this._inputs.map(function (t) {
                  return {
                    name: t.name,
                    shape: t.attrParams.shape
                      ? t.attrParams.shape.value
                      : void 0,
                    dtype: t.attrParams.dtype
                      ? t.attrParams.dtype.value
                      : void 0,
                  };
                });
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(t.prototype, "outputs", {
              get: function () {
                return this._outputs.map(function (t) {
                  return {
                    name: t.name,
                    shape: t.attrParams.shape
                      ? t.attrParams.shape.value
                      : void 0,
                    dtype: t.attrParams.dtype
                      ? t.attrParams.dtype.value
                      : void 0,
                  };
                });
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(t.prototype, "inputNodes", {
              get: function () {
                return this._inputs.map(function (t) {
                  return t.signatureKey || t.name;
                });
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(t.prototype, "outputNodes", {
              get: function () {
                return this._outputs.map(function (t) {
                  return t.signatureKey || t.name;
                });
              },
              enumerable: !0,
              configurable: !0,
            }),
            (t.prototype.getCompilationKey = function (t, e) {
              var n = t
                  .map(function (t) {
                    return t.name;
                  })
                  .sort(),
                r = e
                  .map(function (t) {
                    return t.name;
                  })
                  .sort();
              return n.join(this.SEPERATOR) + "--" + r.join(this.SEPERATOR);
            }),
            (t.prototype.compile = function (t, e) {
              var n = $(t, e, this.weightMap),
                r = n.missingInputs,
                i = n.dynamicNode,
                a = n.syncInputs;
              if (null != i)
                throw new Error(
                  "This execution contains the node '" +
                    i.name +
                    "', which has the dynamic op '" +
                    i.op +
                    "'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [" +
                    a +
                    "]"
                );
              if (r.length > 0) {
                var o = e.map(function (t) {
                    return t.name;
                  }),
                  s = Object.keys(t);
                throw new Error(
                  "Cannot compute the outputs [" +
                    o +
                    "] from the provided inputs [" +
                    s +
                    "]. Missing the following inputs: [" +
                    r +
                    "]"
                );
              }
              return (function (t, e, n) {
                var r = n.usedNodes,
                  i = n.inputs,
                  a = [];
                Object.keys(i)
                  .map(function (t) {
                    return v(t)[0];
                  })
                  .map(function (e) {
                    return t.nodes[e];
                  })
                  .forEach(function (t) {
                    r.has(t.name) && a.push(t);
                  }),
                  t.weights.forEach(function (t) {
                    r.has(t.name) && a.push(t);
                  });
                for (var o = new Set(), s = []; a.length > 0; ) {
                  var u = a.pop();
                  o.add(u.name),
                    e[u.name] || s.push(u),
                    u.children.forEach(function (t) {
                      !o.has(t.name) &&
                        r.has(t.name) &&
                        t.inputs.every(function (t) {
                          return o.has(t.name);
                        }) &&
                        a.push(t);
                    });
                }
                return s;
              })(this.graph, this.weightMap, n);
            }),
            (t.prototype.execute = function (t, e) {
              var n = this;
              t = this.mapInputs(t);
              var r = Object.keys(t).sort();
              this.checkInputs(t),
                this.checkInputShapeAndType(t),
                (e = this.mapOutputs(e)),
                this.checkOutputs(e);
              var i = r.map(function (t) {
                  return n.graph.nodes[v(t)[0]];
                }),
                a = e.map(function (t) {
                  return n.graph.nodes[v(t)[0]];
                }),
                u = this.getCompilationKey(i, a),
                c = this.compiledMap.get(u);
              null == c &&
                ((c = this.compile(t, a)), this.compiledMap.set(u, c));
              var l = {};
              return Object(o.Zc)(function () {
                var r = new J(n._weightMap, l),
                  i = s({}, n.weightMap);
                Object.keys(t).forEach(function (e) {
                  var n = v(e),
                    r = n[0],
                    a = [];
                  (a[n[1]] = t[e]), (i[r] = a);
                });
                for (
                  var a = n.getFrozenTensorIds(i), o = {}, u = 0;
                  u < c.length;
                  u++
                ) {
                  var p = c[u];
                  if (!i[p.name]) {
                    var h = Y(p, i, r);
                    if (h instanceof Promise)
                      throw new Error(
                        "The execution of the op '" +
                          p.op +
                          "' returned a promise. Please use model.executeAsync() instead."
                      );
                    (i[p.name] = h),
                      n.checkTensorForDisposal(p.name, p, i, r, a, e, o);
                  }
                }
                return e.map(function (t) {
                  return f(t, i, r);
                });
              });
            }),
            (t.prototype.getFrozenTensorIds = function (t) {
              var e = [].concat.apply(
                [],
                Object.keys(t)
                  .map(function (e) {
                    return t[e];
                  })
                  .map(function (t) {
                    return t.map(function (t) {
                      return t.id;
                    });
                  })
              );
              return new Set(e);
            }),
            (t.prototype.checkTensorForDisposal = function (
              t,
              e,
              n,
              r,
              i,
              a,
              o
            ) {
              "control" !== e.category &&
                -1 === a.indexOf(t) &&
                (n[t].forEach(function (t) {
                  null != t && (o[t.id] = (o[t.id] || 0) + e.children.length);
                }),
                e.inputs.forEach(function (t) {
                  if ("control" !== t.category) {
                    var e = (function (t, e, n) {
                      return e[m(t, n.currentContextId)];
                    })(t.name, n, r);
                    null != e &&
                      e.forEach(function (t) {
                        if (t && !i.has(t.id)) {
                          var e = o[t.id];
                          1 === e
                            ? (t.dispose(), delete o[t.id])
                            : null != e && o[t.id]--;
                        }
                      });
                  }
                }));
            }),
            (t.prototype.executeAsync = function (t, e) {
              return u(this, void 0, void 0, function () {
                var n,
                  r,
                  i,
                  a,
                  o,
                  s,
                  u = this;
                return c(this, function (c) {
                  switch (c.label) {
                    case 0:
                      return (
                        (t = this.mapInputs(t)),
                        this.checkInputs(t),
                        this.checkInputShapeAndType(t),
                        (e = this.mapOutputs(e)),
                        this.checkOutputs(e),
                        (n = {}),
                        (r = new J(this._weightMap, n)),
                        [4, this.executeWithControlFlow(t, r, e)]
                      );
                    case 1:
                      return (
                        (i = c.sent()),
                        (a = e.map(function (t) {
                          return f(t, i, r);
                        })),
                        (o = new Set(
                          a.map(function (t) {
                            return t.id;
                          })
                        )),
                        (s = new Set(
                          Object.keys(t).map(function (e) {
                            return t[e].id;
                          })
                        )),
                        Object.keys(i).forEach(function (t) {
                          i[t].forEach(function (t) {
                            !t ||
                              t.isDisposed ||
                              o.has(t.id) ||
                              s.has(t.id) ||
                              -1 !== u.weightIds.indexOf(t.id) ||
                              t.dispose();
                          });
                        }),
                        [2, a]
                      );
                  }
                });
              });
            }),
            (t.prototype.executeWithControlFlow = function (t, e, n) {
              return u(this, void 0, void 0, function () {
                var r,
                  i,
                  a,
                  o,
                  u,
                  l,
                  p,
                  h,
                  d,
                  m,
                  g,
                  y,
                  b,
                  w,
                  x,
                  C,
                  O = this;
                return c(this, function (c) {
                  switch (c.label) {
                    case 0:
                      (r = Object.keys(t)),
                        (i = r.map(function (t) {
                          return O.graph.nodes[v(t)[0]];
                        })),
                        (a = n.map(function (t) {
                          return O.graph.nodes[v(t)[0]];
                        })),
                        (o = $(t, a, this.weightMap)),
                        (u = o.usedNodes),
                        (l = o.missingInputs),
                        (p = o.dynamicNode),
                        (h = o.syncInputs),
                        (d = i.concat(this.graph.weights).map(function (t) {
                          return { node: t, contexts: e.currentContext };
                        })),
                        (m = s({}, this.weightMap)),
                        Object.keys(t).forEach(function (e) {
                          var n = v(e),
                            r = n[0],
                            i = [];
                          (i[n[1]] = t[e]), (m[r] = i);
                        }),
                        (g = {}),
                        (y = this.getFrozenTensorIds(m)),
                        (b = {}),
                        (c.label = 1);
                    case 1:
                      return d.length > 0
                        ? ((w = this.processStack(i, d, e, m, b, y, n, g, u)),
                          [4, Promise.all(w)])
                        : [3, 3];
                    case 2:
                      return c.sent(), [3, 1];
                    case 3:
                      if (
                        (null == p &&
                          console.warn(
                            "This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead."
                          ),
                        (x = a
                          .filter(function (t) {
                            return !et(t) && !f(t.name, m, e);
                          })
                          .map(function (t) {
                            return t.name;
                          })).length > 0)
                      )
                        throw (
                          ((C = ""),
                          null != p &&
                            (C =
                              "Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [" +
                              h +
                              "]"),
                          new Error(
                            "Cannot compute the outputs [" +
                              x +
                              "] from the provided inputs [" +
                              r +
                              "]. Consider providing the following inputs: [" +
                              l +
                              "]. " +
                              C
                          ))
                        );
                      return [2, m];
                  }
                });
              });
            }),
            (t.prototype.processStack = function (t, e, n, r, i, a, o, s, u) {
              for (
                var c = this,
                  l = [],
                  p = function () {
                    var p = e.pop();
                    n.currentContext = p.contexts;
                    var m = "";
                    if (
                      ("Enter" === p.node.op &&
                        h("isConstant", p.node, r, n) &&
                        (m = d(p.node.name, n)[0]),
                      -1 === t.indexOf(p.node))
                    ) {
                      var v = Y(p.node, r, n);
                      m || (m = d(p.node.name, n)[0]);
                      var g = n.currentContext;
                      v instanceof Promise
                        ? l.push(
                            v.then(function (t) {
                              return (
                                (r[m] = t),
                                (n.currentContext = g),
                                c.checkTensorForDisposal(
                                  m,
                                  p.node,
                                  r,
                                  n,
                                  a,
                                  o,
                                  s
                                ),
                                c.processChildNodes(p.node, e, n, r, i, u),
                                t
                              );
                            })
                          )
                        : ((r[m] = v),
                          f.checkTensorForDisposal(m, p.node, r, n, a, o, s),
                          f.processChildNodes(p.node, e, n, r, i, u));
                    } else f.processChildNodes(p.node, e, n, r, i, u);
                  },
                  f = this;
                e.length > 0;

              )
                p();
              return l;
            }),
            (t.prototype.processChildNodes = function (t, e, n, r, i, a) {
              t.children.forEach(function (t) {
                var o = d(t.name, n)[0];
                !i[o] &&
                  a.has(t.name) &&
                  ("Merge" === t.op
                    ? t.inputNames.some(function (t) {
                        return !!f(t, r, n);
                      }) &&
                      ((i[o] = !0),
                      e.push({ contexts: n.currentContext, node: t }))
                    : t.inputNames.every(function (t) {
                        return !!f(t, r, n);
                      }) &&
                      ((i[o] = !0),
                      e.push({ contexts: n.currentContext, node: t })));
              });
            }),
            (t.prototype.dispose = function () {
              var t = this;
              Object.keys(this.weightMap).forEach(function (e) {
                return t.weightMap[e].forEach(function (t) {
                  return t.dispose();
                });
              });
            }),
            (t.prototype.checkInputShapeAndType = function (t) {
              var e = this;
              Object.keys(t).forEach(function (n) {
                var r = t[n],
                  i = v(n)[0],
                  a = e.graph.nodes[i];
                if (a.attrParams.shape && a.attrParams.shape.value) {
                  var s = a.attrParams.shape.value,
                    u =
                      s.length === r.shape.length &&
                      r.shape.every(function (t, e) {
                        return -1 === s[e] || s[e] === t;
                      });
                  o.gd.assert(u, function () {
                    return (
                      "The shape of dict['" +
                      a.name +
                      "'] provided in model.execute(dict) must be [" +
                      s +
                      "], but was [" +
                      r.shape +
                      "]"
                    );
                  });
                }
                a.attrParams.dtype &&
                  a.attrParams.dtype.value &&
                  o.gd.assert(
                    r.dtype === a.attrParams.dtype.value,
                    function () {
                      return (
                        "The dtype of dict['" +
                        a.name +
                        "'] provided in model.execute(dict) must be " +
                        a.attrParams.dtype.value +
                        ", but was " +
                        r.dtype
                      );
                    }
                  );
              });
            }),
            (t.prototype.mapInputs = function (t) {
              var e = {};
              for (var n in t)
                null != this._signature &&
                null != this._signature.inputs &&
                null != this._signature.inputs[n]
                  ? (e[this._signature.inputs[n].name] = t[n])
                  : (e[n] = t[n]);
              return e;
            }),
            (t.prototype.checkInputs = function (t) {
              var e = this,
                n = Object.keys(t).filter(function (t) {
                  var n = v(t)[0];
                  return null == e.graph.nodes[n];
                });
              if (n.length > 0)
                throw new Error(
                  "The dict provided in model.execute(dict) has keys: [" +
                    n +
                    "] that are not part of graph"
                );
            }),
            (t.prototype.mapOutputs = function (t) {
              var e = this;
              return t.map(function (t) {
                return null != e._signature &&
                  null != e._signature.outputs &&
                  null != e._signature.outputs[t]
                  ? e._signature.outputs[t].name
                  : t;
              }, {});
            }),
            (t.prototype.checkOutputs = function (t) {
              var e = this;
              t.forEach(function (t) {
                var n = v(t)[0];
                if (!e.graph.nodes[n])
                  throw new Error(
                    "The output '" + t + "' is not found in the graph"
                  );
              });
            }),
            t
          );
        })(),
        it = (function () {
          function t(t, e) {
            void 0 === e && (e = {}),
              (this.modelUrl = t),
              (this.loadOptions = e),
              (this.version = "n/a"),
              null == e && (this.loadOptions = {});
          }
          return (
            Object.defineProperty(t.prototype, "modelVersion", {
              get: function () {
                return this.version;
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(t.prototype, "inputNodes", {
              get: function () {
                return this.executor.inputNodes;
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(t.prototype, "outputNodes", {
              get: function () {
                return this.executor.outputNodes;
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(t.prototype, "inputs", {
              get: function () {
                return this.executor.inputs;
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(t.prototype, "outputs", {
              get: function () {
                return this.executor.outputs;
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(t.prototype, "weights", {
              get: function () {
                return this.executor.weightMap;
              },
              enumerable: !0,
              configurable: !0,
            }),
            (t.prototype.findIOHandler = function () {
              var t = this.modelUrl;
              if (null != t.load) this.handler = t;
              else if (null != this.loadOptions.requestInit)
                this.handler = o.rb.browserHTTPRequest(t, this.loadOptions);
              else {
                var e = o.rb.getLoadHandlers(t, this.loadOptions.onProgress);
                if (0 === e.length)
                  e.push(o.rb.browserHTTPRequest(t, this.loadOptions));
                else if (e.length > 1)
                  throw new Error(
                    "Found more than one (" +
                      e.length +
                      ") load handlers for URL '" +
                      [t] +
                      "'"
                  );
                this.handler = e[0];
              }
            }),
            (t.prototype.load = function () {
              return u(this, void 0, void 0, function () {
                var t, e, n, r;
                return c(this, function (i) {
                  switch (i.label) {
                    case 0:
                      if ((this.findIOHandler(), null == this.handler.load))
                        throw new Error(
                          "Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented."
                        );
                      return (t = this), [4, this.handler.load()];
                    case 1:
                      return (
                        (t.artifacts = i.sent()),
                        (e = this.artifacts.modelTopology),
                        (n = {}),
                        null != this.artifacts.userDefinedMetadata &&
                          (n = this.artifacts.userDefinedMetadata.signature),
                        (this.version =
                          e.versions.producer + "." + e.versions.minConsumer),
                        (r = o.rb.decodeWeights(
                          this.artifacts.weightData,
                          this.artifacts.weightSpecs
                        )),
                        (this.executor = new rt(
                          F.Instance.transformGraph(e, n)
                        )),
                        (this.executor.weightMap = this.convertTensorMapToTensorsMap(
                          r
                        )),
                        [2, !0]
                      );
                  }
                });
              });
            }),
            (t.prototype.save = function (t, e) {
              return u(this, void 0, void 0, function () {
                var e;
                return c(this, function (n) {
                  if ("string" == typeof t) {
                    if (0 === (e = o.rb.getSaveHandlers(t)).length)
                      throw new Error(
                        "Cannot find any save handlers for URL '" + t + "'"
                      );
                    if (e.length > 1)
                      throw new Error(
                        "Found more than one (" +
                          e.length +
                          ") save handlers for URL '" +
                          t +
                          "'"
                      );
                    t = e[0];
                  }
                  if (null == t.save)
                    throw new Error(
                      "GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined."
                    );
                  return [2, t.save(this.artifacts)];
                });
              });
            }),
            (t.prototype.predict = function (t, e) {
              return this.execute(t, this.outputNodes);
            }),
            (t.prototype.normalizeInputs = function (t) {
              if (!(t instanceof o.b || Array.isArray(t))) return t;
              if (
                (t = Array.isArray(t) ? t : [t]).length !==
                this.inputNodes.length
              )
                throw new Error(
                  "Input tensor count mismatch,the graph model has " +
                    this.inputNodes.length +
                    " placeholders, while there are " +
                    t.length +
                    " input tensors."
                );
              return this.inputNodes.reduce(function (e, n, r) {
                return (e[n] = t[r]), e;
              }, {});
            }),
            (t.prototype.normalizeOutputs = function (t) {
              return (t = t || this.outputNodes), Array.isArray(t) ? t : [t];
            }),
            (t.prototype.execute = function (t, e) {
              (t = this.normalizeInputs(t)), (e = this.normalizeOutputs(e));
              var n = this.executor.execute(t, e);
              return n.length > 1 ? n : n[0];
            }),
            (t.prototype.executeAsync = function (t, e) {
              return u(this, void 0, void 0, function () {
                var n;
                return c(this, function (r) {
                  switch (r.label) {
                    case 0:
                      return (
                        (t = this.normalizeInputs(t)),
                        (e = this.normalizeOutputs(e)),
                        [4, this.executor.executeAsync(t, e)]
                      );
                    case 1:
                      return [2, (n = r.sent()).length > 1 ? n : n[0]];
                  }
                });
              });
            }),
            (t.prototype.convertTensorMapToTensorsMap = function (t) {
              return Object.keys(t).reduce(function (e, n) {
                return (e[n] = [t[n]]), e;
              }, {});
            }),
            (t.prototype.dispose = function () {
              this.executor.dispose();
            }),
            t
          );
        })();
      function at(t, e) {
        return (
          void 0 === e && (e = {}),
          u(this, void 0, void 0, function () {
            var n;
            return c(this, function (r) {
              switch (r.label) {
                case 0:
                  if (null == t)
                    throw new Error(
                      "modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model"
                    );
                  return (
                    null == e && (e = {}),
                    e.fromTFHub &&
                      null == t.load &&
                      (t.endsWith("/") || (t += "/"),
                      (t += "model.json?tfjs-format=file")),
                    [4, (n = new it(t, e)).load()]
                  );
                case 1:
                  return r.sent(), [2, n];
              }
            });
          })
        );
      }
      var ot = "1.7.0";
    }.call(this, n(7).Buffer));
  },
  function (t, e, n) {
    "use strict";
    n.r(e),
      function (t, r) {
        n.d(e, "array", function () {
          return $;
        }),
          n.d(e, "Dataset", function () {
            return Y;
          }),
          n.d(e, "zip", function () {
            return Q;
          }),
          n.d(e, "CSVDataset", function () {
            return ut;
          }),
          n.d(e, "TextLineDataset", function () {
            return nt;
          }),
          n.d(e, "csv", function () {
            return Et;
          }),
          n.d(e, "func", function () {
            return St;
          }),
          n.d(e, "generator", function () {
            return Nt;
          }),
          n.d(e, "microphone", function () {
            return kt;
          }),
          n.d(e, "webcam", function () {
            return It;
          }),
          n.d(e, "FileDataSource", function () {
            return Ct;
          }),
          n.d(e, "URLDataSource", function () {
            return Ot;
          }),
          n.d(e, "version_data", function () {
            return _t;
          });
        var i = n(0),
          a = function (t, e) {
            return (a =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (t, e) {
                  t.__proto__ = e;
                }) ||
              function (t, e) {
                for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
              })(t, e);
          };
        /**
         * @license
         * Copyright 2020 Google LLC. All Rights Reserved.
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         * =============================================================================
         */ function o(t, e) {
          function n() {
            this.constructor = t;
          }
          a(t, e),
            (t.prototype =
              null === e
                ? Object.create(e)
                : ((n.prototype = e.prototype), new n()));
        }
        function s(t, e, n, r) {
          return new (n || (n = Promise))(function (i, a) {
            function o(t) {
              try {
                u(r.next(t));
              } catch (t) {
                a(t);
              }
            }
            function s(t) {
              try {
                u(r.throw(t));
              } catch (t) {
                a(t);
              }
            }
            function u(t) {
              t.done
                ? i(t.value)
                : new n(function (e) {
                    e(t.value);
                  }).then(o, s);
            }
            u((r = r.apply(t, e || [])).next());
          });
        }
        function u(t, e) {
          var n,
            r,
            i,
            a,
            o = {
              label: 0,
              sent: function () {
                if (1 & i[0]) throw i[1];
                return i[1];
              },
              trys: [],
              ops: [],
            };
          return (
            (a = { next: s(0), throw: s(1), return: s(2) }),
            "function" == typeof Symbol &&
              (a[Symbol.iterator] = function () {
                return this;
              }),
            a
          );
          function s(a) {
            return function (s) {
              return (function (a) {
                if (n) throw new TypeError("Generator is already executing.");
                for (; o; )
                  try {
                    if (
                      ((n = 1),
                      r &&
                        (i =
                          2 & a[0]
                            ? r.return
                            : a[0]
                            ? r.throw || ((i = r.return) && i.call(r), 0)
                            : r.next) &&
                        !(i = i.call(r, a[1])).done)
                    )
                      return i;
                    switch (((r = 0), i && (a = [2 & a[0], i.value]), a[0])) {
                      case 0:
                      case 1:
                        i = a;
                        break;
                      case 4:
                        return o.label++, { value: a[1], done: !1 };
                      case 5:
                        o.label++, (r = a[1]), (a = [0]);
                        continue;
                      case 7:
                        (a = o.ops.pop()), o.trys.pop();
                        continue;
                      default:
                        if (
                          !(i = (i = o.trys).length > 0 && i[i.length - 1]) &&
                          (6 === a[0] || 2 === a[0])
                        ) {
                          o = 0;
                          continue;
                        }
                        if (
                          3 === a[0] &&
                          (!i || (a[1] > i[0] && a[1] < i[3]))
                        ) {
                          o.label = a[1];
                          break;
                        }
                        if (6 === a[0] && o.label < i[1]) {
                          (o.label = i[1]), (i = a);
                          break;
                        }
                        if (i && o.label < i[2]) {
                          (o.label = i[2]), o.ops.push(a);
                          break;
                        }
                        i[2] && o.ops.pop(), o.trys.pop();
                        continue;
                    }
                    a = e.call(t, o);
                  } catch (t) {
                    (a = [6, t]), (r = 0);
                  } finally {
                    n = i = 0;
                  }
                if (5 & a[0]) throw a[1];
                return { value: a[0] ? a[1] : void 0, done: !0 };
              })([a, s]);
            };
          }
        }
        "undefined" != typeof window
          ? window
          : void 0 !== t || ("undefined" != typeof self && self);
        function c(t, e) {
          return t((e = { exports: {} }), e.exports), e.exports;
        }
        var l = c(function (t) {
            !(function (t, e, n) {
              function r(t, e) {
                return (
                  (e.c = t.c), (e.s0 = t.s0), (e.s1 = t.s1), (e.s2 = t.s2), e
                );
              }
              function i(t, e) {
                var n = new (function (t) {
                    var e,
                      n = this,
                      r =
                        ((e = 4022871197),
                        function (t) {
                          t = t.toString();
                          for (var n = 0; n < t.length; n++) {
                            var r =
                              0.02519603282416938 * (e += t.charCodeAt(n));
                            (r -= e = r >>> 0),
                              (e = (r *= e) >>> 0),
                              (e += 4294967296 * (r -= e));
                          }
                          return 2.3283064365386963e-10 * (e >>> 0);
                        });
                    (n.next = function () {
                      var t = 2091639 * n.s0 + 2.3283064365386963e-10 * n.c;
                      return (
                        (n.s0 = n.s1), (n.s1 = n.s2), (n.s2 = t - (n.c = 0 | t))
                      );
                    }),
                      (n.c = 1),
                      (n.s0 = r(" ")),
                      (n.s1 = r(" ")),
                      (n.s2 = r(" ")),
                      (n.s0 -= r(t)),
                      n.s0 < 0 && (n.s0 += 1),
                      (n.s1 -= r(t)),
                      n.s1 < 0 && (n.s1 += 1),
                      (n.s2 -= r(t)),
                      n.s2 < 0 && (n.s2 += 1),
                      (r = null);
                  })(t),
                  i = e && e.state,
                  a = n.next;
                return (
                  (a.int32 = function () {
                    return (4294967296 * n.next()) | 0;
                  }),
                  (a.double = function () {
                    return a() + 11102230246251565e-32 * ((2097152 * a()) | 0);
                  }),
                  (a.quick = a),
                  i &&
                    ("object" == typeof i && r(i, n),
                    (a.state = function () {
                      return r(n, {});
                    })),
                  a
                );
              }
              e && e.exports ? (e.exports = i) : (this.alea = i);
            })(0, t);
          }),
          p = c(function (t) {
            !(function (t, e, n) {
              function r(t, e) {
                return (e.x = t.x), (e.y = t.y), (e.z = t.z), (e.w = t.w), e;
              }
              function i(t, e) {
                var n = new (function (t) {
                    var e = this,
                      n = "";
                    (e.x = 0),
                      (e.y = 0),
                      (e.z = 0),
                      (e.w = 0),
                      (e.next = function () {
                        var t = e.x ^ (e.x << 11);
                        return (
                          (e.x = e.y),
                          (e.y = e.z),
                          (e.z = e.w),
                          (e.w ^= (e.w >>> 19) ^ t ^ (t >>> 8))
                        );
                      }),
                      t === (0 | t) ? (e.x = t) : (n += t);
                    for (var r = 0; r < n.length + 64; r++)
                      (e.x ^= 0 | n.charCodeAt(r)), e.next();
                  })(t),
                  i = e && e.state,
                  a = function () {
                    return (n.next() >>> 0) / 4294967296;
                  };
                return (
                  (a.double = function () {
                    do {
                      var t =
                        ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) /
                        (1 << 21);
                    } while (0 === t);
                    return t;
                  }),
                  (a.int32 = n.next),
                  (a.quick = a),
                  i &&
                    ("object" == typeof i && r(i, n),
                    (a.state = function () {
                      return r(n, {});
                    })),
                  a
                );
              }
              e && e.exports ? (e.exports = i) : (this.xor128 = i);
            })(0, t);
          }),
          h = c(function (t) {
            !(function (t, e, n) {
              function r(t, e) {
                return (
                  (e.x = t.x),
                  (e.y = t.y),
                  (e.z = t.z),
                  (e.w = t.w),
                  (e.v = t.v),
                  (e.d = t.d),
                  e
                );
              }
              function i(t, e) {
                var n = new (function (t) {
                    var e = this,
                      n = "";
                    (e.next = function () {
                      var t = e.x ^ (e.x >>> 2);
                      return (
                        (e.x = e.y),
                        (e.y = e.z),
                        (e.z = e.w),
                        (e.w = e.v),
                        ((e.d = (e.d + 362437) | 0) +
                          (e.v = e.v ^ (e.v << 4) ^ t ^ (t << 1))) |
                          0
                      );
                    }),
                      (e.x = 0),
                      (e.y = 0),
                      (e.z = 0),
                      (e.w = 0),
                      (e.v = 0),
                      t === (0 | t) ? (e.x = t) : (n += t);
                    for (var r = 0; r < n.length + 64; r++)
                      (e.x ^= 0 | n.charCodeAt(r)),
                        r == n.length && (e.d = (e.x << 10) ^ (e.x >>> 4)),
                        e.next();
                  })(t),
                  i = e && e.state,
                  a = function () {
                    return (n.next() >>> 0) / 4294967296;
                  };
                return (
                  (a.double = function () {
                    do {
                      var t =
                        ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) /
                        (1 << 21);
                    } while (0 === t);
                    return t;
                  }),
                  (a.int32 = n.next),
                  (a.quick = a),
                  i &&
                    ("object" == typeof i && r(i, n),
                    (a.state = function () {
                      return r(n, {});
                    })),
                  a
                );
              }
              e && e.exports ? (e.exports = i) : (this.xorwow = i);
            })(0, t);
          }),
          f = c(function (t) {
            !(function (t, e, n) {
              function r(t, e) {
                return (e.x = t.x.slice()), (e.i = t.i), e;
              }
              function i(t, e) {
                null == t && (t = +new Date());
                var n = new (function (t) {
                    var e = this;
                    (e.next = function () {
                      var t,
                        n,
                        r = e.x,
                        i = e.i;
                      return (
                        (t = r[i]),
                        (n = (t ^= t >>> 7) ^ (t << 24)),
                        (n ^= (t = r[(i + 1) & 7]) ^ (t >>> 10)),
                        (n ^= (t = r[(i + 3) & 7]) ^ (t >>> 3)),
                        (n ^= (t = r[(i + 4) & 7]) ^ (t << 7)),
                        (t = r[(i + 7) & 7]),
                        (n ^= (t ^= t << 13) ^ (t << 9)),
                        (r[i] = n),
                        (e.i = (i + 1) & 7),
                        n
                      );
                    }),
                      (function (t, e) {
                        var n,
                          r = [];
                        if (e === (0 | e)) r[0] = e;
                        else
                          for (e = "" + e, n = 0; n < e.length; ++n)
                            r[7 & n] =
                              (r[7 & n] << 15) ^
                              ((e.charCodeAt(n) + r[(n + 1) & 7]) << 13);
                        for (; r.length < 8; ) r.push(0);
                        for (n = 0; n < 8 && 0 === r[n]; ++n);
                        for (
                          8 == n ? (r[7] = -1) : r[n],
                            t.x = r,
                            t.i = 0,
                            n = 256;
                          n > 0;
                          --n
                        )
                          t.next();
                      })(e, t);
                  })(t),
                  i = e && e.state,
                  a = function () {
                    return (n.next() >>> 0) / 4294967296;
                  };
                return (
                  (a.double = function () {
                    do {
                      var t =
                        ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) /
                        (1 << 21);
                    } while (0 === t);
                    return t;
                  }),
                  (a.int32 = n.next),
                  (a.quick = a),
                  i &&
                    (i.x && r(i, n),
                    (a.state = function () {
                      return r(n, {});
                    })),
                  a
                );
              }
              e && e.exports ? (e.exports = i) : (this.xorshift7 = i);
            })(0, t);
          }),
          d = c(function (t) {
            !(function (t, e, n) {
              function r(t, e) {
                return (e.i = t.i), (e.w = t.w), (e.X = t.X.slice()), e;
              }
              function i(t, e) {
                null == t && (t = +new Date());
                var n = new (function (t) {
                    var e = this;
                    (e.next = function () {
                      var t,
                        n,
                        r = e.w,
                        i = e.X,
                        a = e.i;
                      return (
                        (e.w = r = (r + 1640531527) | 0),
                        (n = i[(a + 34) & 127]),
                        (t = i[(a = (a + 1) & 127)]),
                        (n ^= n << 13),
                        (t ^= t << 17),
                        (n ^= n >>> 15),
                        (t ^= t >>> 12),
                        (n = i[a] = n ^ t),
                        (e.i = a),
                        (n + (r ^ (r >>> 16))) | 0
                      );
                    }),
                      (function (t, e) {
                        var n,
                          r,
                          i,
                          a,
                          o,
                          s = [],
                          u = 128;
                        for (
                          e === (0 | e)
                            ? ((r = e), (e = null))
                            : ((e += "\0"),
                              (r = 0),
                              (u = Math.max(u, e.length))),
                            i = 0,
                            a = -32;
                          a < u;
                          ++a
                        )
                          e && (r ^= e.charCodeAt((a + 32) % e.length)),
                            0 === a && (o = r),
                            (r ^= r << 10),
                            (r ^= r >>> 15),
                            (r ^= r << 4),
                            (r ^= r >>> 13),
                            a >= 0 &&
                              ((o = (o + 1640531527) | 0),
                              (i = 0 == (n = s[127 & a] ^= r + o) ? i + 1 : 0));
                        for (
                          i >= 128 && (s[127 & ((e && e.length) || 0)] = -1),
                            i = 127,
                            a = 512;
                          a > 0;
                          --a
                        )
                          (r = s[(i + 34) & 127]),
                            (n = s[(i = (i + 1) & 127)]),
                            (r ^= r << 13),
                            (n ^= n << 17),
                            (r ^= r >>> 15),
                            (n ^= n >>> 12),
                            (s[i] = r ^ n);
                        (t.w = o), (t.X = s), (t.i = i);
                      })(e, t);
                  })(t),
                  i = e && e.state,
                  a = function () {
                    return (n.next() >>> 0) / 4294967296;
                  };
                return (
                  (a.double = function () {
                    do {
                      var t =
                        ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) /
                        (1 << 21);
                    } while (0 === t);
                    return t;
                  }),
                  (a.int32 = n.next),
                  (a.quick = a),
                  i &&
                    (i.X && r(i, n),
                    (a.state = function () {
                      return r(n, {});
                    })),
                  a
                );
              }
              e && e.exports ? (e.exports = i) : (this.xor4096 = i);
            })(0, t);
          }),
          m = c(function (t) {
            !(function (t, e, n) {
              function r(t, e) {
                return (e.a = t.a), (e.b = t.b), (e.c = t.c), (e.d = t.d), e;
              }
              function i(t, e) {
                var n = new (function (t) {
                    var e = this,
                      n = "";
                    (e.next = function () {
                      var t = e.b,
                        n = e.c,
                        r = e.d,
                        i = e.a;
                      return (
                        (t = (t << 25) ^ (t >>> 7) ^ n),
                        (n = (n - r) | 0),
                        (r = (r << 24) ^ (r >>> 8) ^ i),
                        (i = (i - t) | 0),
                        (e.b = t = (t << 20) ^ (t >>> 12) ^ n),
                        (e.c = n = (n - r) | 0),
                        (e.d = (r << 16) ^ (n >>> 16) ^ i),
                        (e.a = (i - t) | 0)
                      );
                    }),
                      (e.a = 0),
                      (e.b = 0),
                      (e.c = -1640531527),
                      (e.d = 1367130551),
                      t === Math.floor(t)
                        ? ((e.a = (t / 4294967296) | 0), (e.b = 0 | t))
                        : (n += t);
                    for (var r = 0; r < n.length + 20; r++)
                      (e.b ^= 0 | n.charCodeAt(r)), e.next();
                  })(t),
                  i = e && e.state,
                  a = function () {
                    return (n.next() >>> 0) / 4294967296;
                  };
                return (
                  (a.double = function () {
                    do {
                      var t =
                        ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) /
                        (1 << 21);
                    } while (0 === t);
                    return t;
                  }),
                  (a.int32 = n.next),
                  (a.quick = a),
                  i &&
                    ("object" == typeof i && r(i, n),
                    (a.state = function () {
                      return r(n, {});
                    })),
                  a
                );
              }
              e && e.exports ? (e.exports = i) : (this.tychei = i);
            })(0, t);
          }),
          v = c(function (t) {
            !(function (e, r) {
              var i,
                a = this,
                o = 256,
                s = "random",
                u = r.pow(o, 6),
                c = r.pow(2, 52),
                l = 2 * c,
                p = 255;
              function h(t, n, h) {
                var v = [],
                  g = d(
                    (function t(e, n) {
                      var r,
                        i = [],
                        a = typeof e;
                      if (n && "object" == a)
                        for (r in e)
                          try {
                            i.push(t(e[r], n - 1));
                          } catch (t) {}
                      return i.length ? i : "string" == a ? e : e + "\0";
                    })(
                      (n = 1 == n ? { entropy: !0 } : n || {}).entropy
                        ? [t, m(e)]
                        : null == t
                        ? (function () {
                            try {
                              var t;
                              return (
                                i && (t = i.randomBytes)
                                  ? (t = t(o))
                                  : ((t = new Uint8Array(o)),
                                    (a.crypto || a.msCrypto).getRandomValues(
                                      t
                                    )),
                                m(t)
                              );
                            } catch (t) {
                              var n = a.navigator,
                                r = n && n.plugins;
                              return [+new Date(), a, r, a.screen, m(e)];
                            }
                          })()
                        : t,
                      3
                    ),
                    v
                  ),
                  y = new (function (t) {
                    var e,
                      n = t.length,
                      r = this,
                      i = 0,
                      a = (r.i = r.j = 0),
                      s = (r.S = []);
                    for (n || (t = [n++]); i < o; ) s[i] = i++;
                    for (i = 0; i < o; i++)
                      (s[i] = s[(a = p & (a + t[i % n] + (e = s[i])))]),
                        (s[a] = e);
                    (r.g = function (t) {
                      for (var e, n = 0, i = r.i, a = r.j, s = r.S; t--; )
                        (e = s[(i = p & (i + 1))]),
                          (n =
                            n * o +
                            s[
                              p & ((s[i] = s[(a = p & (a + e))]) + (s[a] = e))
                            ]);
                      return (r.i = i), (r.j = a), n;
                    })(o);
                  })(v),
                  b = function () {
                    for (var t = y.g(6), e = u, n = 0; t < c; )
                      (t = (t + n) * o), (e *= o), (n = y.g(1));
                    for (; t >= l; ) (t /= 2), (e /= 2), (n >>>= 1);
                    return (t + n) / e;
                  };
                return (
                  (b.int32 = function () {
                    return 0 | y.g(4);
                  }),
                  (b.quick = function () {
                    return y.g(4) / 4294967296;
                  }),
                  (b.double = b),
                  d(m(y.S), e),
                  (
                    n.pass ||
                    h ||
                    function (t, e, n, i) {
                      return (
                        i &&
                          (i.S && f(i, y),
                          (t.state = function () {
                            return f(y, {});
                          })),
                        n ? ((r[s] = t), e) : t
                      );
                    }
                  )(b, g, "global" in n ? n.global : this == r, n.state)
                );
              }
              function f(t, e) {
                return (e.i = t.i), (e.j = t.j), (e.S = t.S.slice()), e;
              }
              function d(t, e) {
                for (var n, r = t + "", i = 0; i < r.length; )
                  e[p & i] = p & ((n ^= 19 * e[p & i]) + r.charCodeAt(i++));
                return m(e);
              }
              function m(t) {
                return String.fromCharCode.apply(0, t);
              }
              if (((r.seedrandom = h), d(r.random(), e), t.exports)) {
                t.exports = h;
                try {
                  i = n(21);
                } catch (t) {}
              }
            })([], Math);
          });
        (v.alea = l),
          (v.xor128 = p),
          (v.xorwow = h),
          (v.xorshift7 = f),
          (v.xor4096 = d),
          (v.tychei = m);
        var g = v.alea;
        function y(t, e, n, r) {
          if (
            (void 0 === n && (n = new Map()),
            void 0 === r && (r = new Set()),
            null == t)
          )
            return null;
          if (r.has(t))
            throw new Error("Circular references are not supported.");
          if (n.has(t)) return n.get(t);
          var i = e(t);
          if (i.recurse && null !== i.value)
            throw new Error(
              "A deep map function may not return both a value and recurse=true."
            );
          if (i.recurse) {
            if (C(t)) {
              var a = Array.isArray(t) ? [] : {};
              for (var o in (r.add(t), t)) {
                var s = y(t[o], e, n, r);
                a[o] = s;
              }
              return r.delete(t), a;
            }
            throw new Error("Can't recurse into non-iterable type: " + t);
          }
          return n.set(t, i.value), i.value;
        }
        function b(t, e) {
          return (
            void 0 === e && (e = w),
            (function t(e, n, r) {
              void 0 === r && (r = new Set());
              var i = e[0];
              if (r.has(i))
                throw new Error("Circular references are not supported.");
              var a = n(e);
              if (a.recurse && null !== a.value)
                throw new Error(
                  "A deep zip function may not return both a value and recurse=true."
                );
              if (a.recurse) {
                if (C(i)) {
                  var o = Array.isArray(i) ? [] : {};
                  r.add(i);
                  var s = function (i) {
                    var a = t(
                      e.map(function (t) {
                        return t[i];
                      }),
                      n,
                      r
                    );
                    o[i] = a;
                  };
                  for (var u in i) s(u);
                  return r.delete(i), o;
                }
                throw new Error("Can't recurse into non-iterable type: " + i);
              }
              return a.value;
            })(t, e)
          );
        }
        function w(t) {
          return null === t
            ? null
            : C(t[0])
            ? { value: null, recurse: !0 }
            : { value: t, recurse: !1 };
        }
        function x(t, e) {
          return s(this, void 0, void 0, function () {
            var n, r, i, a, o, s;
            return u(this, function (u) {
              switch (u.label) {
                case 0:
                  (n = new Map()),
                    y(t, e, n),
                    (r = 0),
                    (i = Array.from(n.keys())),
                    (u.label = 1);
                case 1:
                  return r < i.length
                    ? ((a = i[r]),
                      (o = n.get(a)) instanceof Promise ? [4, o] : [3, 3])
                    : [3, 4];
                case 2:
                  (s = u.sent()), n.set(a, s), (u.label = 3);
                case 3:
                  return r++, [3, 1];
                case 4:
                  return [2, y(t, e, n)];
              }
            });
          });
        }
        function C(t) {
          return (
            null != t &&
            !ArrayBuffer.isView(t) &&
            (Array.isArray(t) || ("object" == typeof t && !(t instanceof i.b)))
          );
        }
        function O(t) {
          return (function (t, e) {
            return y(t, e);
          })(t, E);
        }
        function E(t) {
          return t instanceof i.b
            ? { value: t.clone(), recurse: !1 }
            : C(t)
            ? { value: null, recurse: !0 }
            : { value: t, recurse: !1 };
        }
        var S = (function () {
            function t(t) {
              if (
                ((this.capacity = t),
                (this.begin = 0),
                (this.end = 0),
                null == t)
              )
                throw new RangeError(
                  "Can't create a ring buffer of unknown capacity."
                );
              if (t < 1)
                throw new RangeError(
                  "Can't create ring buffer of capacity < 1."
                );
              (this.data = new Array(t)), (this.doubledCapacity = 2 * t);
            }
            return (
              (t.prototype.wrap = function (t) {
                for (; t < 0; ) t += this.doubledCapacity;
                return t % this.doubledCapacity;
              }),
              (t.prototype.get = function (t) {
                if (t < 0)
                  throw new RangeError("Can't get item at a negative index.");
                return this.data[t % this.capacity];
              }),
              (t.prototype.set = function (t, e) {
                if (t < 0)
                  throw new RangeError("Can't set item at a negative index.");
                this.data[t % this.capacity] = e;
              }),
              (t.prototype.length = function () {
                var t = this.end - this.begin;
                return t < 0 && (t = this.doubledCapacity + t), t;
              }),
              (t.prototype.isFull = function () {
                return this.length() === this.capacity;
              }),
              (t.prototype.isEmpty = function () {
                return 0 === this.length();
              }),
              (t.prototype.push = function (t) {
                if (this.isFull()) throw new RangeError("Ring buffer is full.");
                this.set(this.end, t), (this.end = this.wrap(this.end + 1));
              }),
              (t.prototype.pushAll = function (t) {
                for (var e = 0, n = t; e < n.length; e++) {
                  var r = n[e];
                  this.push(r);
                }
              }),
              (t.prototype.pop = function () {
                if (this.isEmpty())
                  throw new RangeError("Ring buffer is empty.");
                this.end = this.wrap(this.end - 1);
                var t = this.get(this.end);
                return this.set(this.end, void 0), t;
              }),
              (t.prototype.unshift = function (t) {
                if (this.isFull()) throw new RangeError("Ring buffer is full.");
                (this.begin = this.wrap(this.begin - 1)),
                  this.set(this.begin, t);
              }),
              (t.prototype.shift = function () {
                if (this.isEmpty())
                  throw new RangeError("Ring buffer is empty.");
                var t = this.get(this.begin);
                return (
                  this.set(this.begin, void 0),
                  (this.begin = this.wrap(this.begin + 1)),
                  t
                );
              }),
              (t.prototype.shuffleExcise = function (t) {
                if (this.isEmpty())
                  throw new RangeError("Ring buffer is empty.");
                var e = this.wrap(this.begin + t),
                  n = this.get(e);
                return this.set(e, this.pop()), n;
              }),
              t
            );
          })(),
          N = (function (t) {
            function e() {
              return t.call(this, e.INITIAL_CAPACITY) || this;
            }
            return (
              o(e, t),
              (e.prototype.isFull = function () {
                return !1;
              }),
              (e.prototype.push = function (e) {
                t.prototype.isFull.call(this) && this.expand(),
                  t.prototype.push.call(this, e);
              }),
              (e.prototype.unshift = function (e) {
                t.prototype.isFull.call(this) && this.expand(),
                  t.prototype.unshift.call(this, e);
              }),
              (e.prototype.expand = function () {
                for (
                  var t = 2 * this.capacity,
                    e = new Array(t),
                    n = this.length(),
                    r = 0;
                  r < n;
                  r++
                )
                  e[r] = this.get(this.wrap(this.begin + r));
                (this.data = e),
                  (this.capacity = t),
                  (this.doubledCapacity = 2 * this.capacity),
                  (this.begin = 0),
                  (this.end = n);
              }),
              (e.INITIAL_CAPACITY = 32),
              e
            );
          })(S);
        function I(t) {
          return new F(t);
        }
        function k(t) {
          return new M(t);
        }
        function _(t, e) {
          return new q(t, e);
        }
        function A(t, e) {
          return void 0 === e && (e = T.FAIL), new K(t, e);
        }
        var T,
          R,
          D = (function () {
            function t() {}
            return (
              (t.prototype.toArray = function () {
                return s(this, void 0, void 0, function () {
                  var t, e;
                  return u(this, function (n) {
                    switch (n.label) {
                      case 0:
                        return (t = []), [4, this.next()];
                      case 1:
                        (e = n.sent()), (n.label = 2);
                      case 2:
                        return e.done
                          ? [3, 4]
                          : (t.push(e.value), [4, this.next()]);
                      case 3:
                        return (e = n.sent()), [3, 2];
                      case 4:
                        return [2, t];
                    }
                  });
                });
              }),
              (t.prototype.toArrayForTest = function () {
                return s(this, void 0, void 0, function () {
                  var t, e, n;
                  return u(this, function (r) {
                    switch (r.label) {
                      case 0:
                        return (
                          (t = this.prefetch(100)), (e = []), [4, t.next()]
                        );
                      case 1:
                        (n = r.sent()), (r.label = 2);
                      case 2:
                        return n.done
                          ? [3, 4]
                          : (e.push(n.value), [4, t.next()]);
                      case 3:
                        return (n = r.sent()), [3, 2];
                      case 4:
                        return [2, e];
                    }
                  });
                });
              }),
              (t.prototype.resolveFully = function () {
                return s(this, void 0, void 0, function () {
                  var t;
                  return u(this, function (e) {
                    switch (e.label) {
                      case 0:
                        return [4, this.next()];
                      case 1:
                        (t = e.sent()), (e.label = 2);
                      case 2:
                        return t.done ? [3, 4] : [4, this.next()];
                      case 3:
                        return (t = e.sent()), [3, 2];
                      case 4:
                        return [2];
                    }
                  });
                });
              }),
              (t.prototype.resolveWhile = function (t) {
                return s(this, void 0, void 0, function () {
                  var e, n;
                  return u(this, function (r) {
                    switch (r.label) {
                      case 0:
                        return [4, this.next()];
                      case 1:
                        (e = r.sent()), (n = t(e.value)), (r.label = 2);
                      case 2:
                        return e.done || !n ? [3, 4] : [4, this.next()];
                      case 3:
                        return (e = r.sent()), (n = t(e.value)), [3, 2];
                      case 4:
                        return [2];
                    }
                  });
                });
              }),
              (t.prototype.handleErrors = function (t) {
                return new U(this, t);
              }),
              (t.prototype.filter = function (t) {
                return new B(this, t);
              }),
              (t.prototype.map = function (t) {
                return new W(this, t);
              }),
              (t.prototype.mapAsync = function (t) {
                return new V(this, t);
              }),
              (t.prototype.serialMapAsync = function (t) {
                return new V(this, t).serial();
              }),
              (t.prototype.flatmap = function (t) {
                return new H(this, t);
              }),
              (t.prototype.forEachAsync = function (t) {
                return s(this, void 0, void 0, function () {
                  return u(this, function (e) {
                    return [2, this.map(t).resolveFully()];
                  });
                });
              }),
              (t.prototype.serialForEach = function (t) {
                return s(this, void 0, void 0, function () {
                  return u(this, function (e) {
                    return [
                      2,
                      this.serialMapAsync(t).resolveWhile(function (t) {
                        return !0 === t;
                      }),
                    ];
                  });
                });
              }),
              (t.prototype.rowMajorBatch = function (t, e) {
                return void 0 === e && (e = !0), new L(this, t, e);
              }),
              (t.prototype.columnMajorBatch = function (t, e, n) {
                return (
                  void 0 === e && (e = !0),
                  void 0 === n && (n = w),
                  this.rowMajorBatch(t, e).map(function (t) {
                    return b(t, n);
                  })
                );
              }),
              (t.prototype.concatenate = function (t, e) {
                return new q(I([this, t]), e);
              }),
              (t.prototype.take = function (t) {
                return t < 0 || null == t ? this : new z(this, t);
              }),
              (t.prototype.skip = function (t) {
                return t < 0 || null == t ? this : new P(this, t);
              }),
              (t.prototype.prefetch = function (t) {
                return new Z(this, t);
              }),
              (t.prototype.shuffle = function (t, e) {
                return new X(this, t, e);
              }),
              (t.prototype.serial = function () {
                return new j(this);
              }),
              t
            );
          })(),
          F = (function (t) {
            function e(e) {
              var n = t.call(this) || this;
              return (n.items = e), (n.trav = 0), n;
            }
            return (
              o(e, t),
              (e.prototype.summary = function () {
                return "Array of " + this.items.length + " items";
              }),
              (e.prototype.next = function () {
                return s(this, void 0, void 0, function () {
                  var t;
                  return u(this, function (e) {
                    return this.trav >= this.items.length
                      ? [2, { value: null, done: !0 }]
                      : ((t = this.items[this.trav]),
                        this.trav++,
                        [2, { value: O(t), done: !1 }]);
                  });
                });
              }),
              e
            );
          })(D),
          M = (function (t) {
            function e(e) {
              var n = t.call(this) || this;
              return (n.nextFn = e), n;
            }
            return (
              o(e, t),
              (e.prototype.summary = function () {
                return "Function call";
              }),
              (e.prototype.next = function () {
                return s(this, void 0, void 0, function () {
                  return u(this, function (t) {
                    try {
                      return [2, this.nextFn()];
                    } catch (t) {
                      throw (
                        ((t.message =
                          "Error thrown while iterating through a dataset: " +
                          t.message),
                        t)
                      );
                    }
                    return [2];
                  });
                });
              }),
              e
            );
          })(D),
          j = (function (t) {
            function e(e) {
              var n = t.call(this) || this;
              return (
                (n.upstream = e),
                (n.lastRead = Promise.resolve({ value: null, done: !1 })),
                n
              );
            }
            return (
              o(e, t),
              (e.prototype.summary = function () {
                return this.upstream.summary() + " -> Serial";
              }),
              (e.prototype.next = function () {
                return s(this, void 0, void 0, function () {
                  var t = this;
                  return u(this, function (e) {
                    return (
                      (this.lastRead = this.lastRead.then(function () {
                        return t.serialNext();
                      })),
                      [2, this.lastRead]
                    );
                  });
                });
              }),
              (e.prototype.serialNext = function () {
                return s(this, void 0, void 0, function () {
                  return u(this, function (t) {
                    return [2, this.upstream.next()];
                  });
                });
              }),
              e
            );
          })(D),
          P = (function (t) {
            function e(e, n) {
              var r = t.call(this) || this;
              return (
                (r.upstream = e),
                (r.maxCount = n),
                (r.count = 0),
                (r.lastRead = Promise.resolve({ value: null, done: !1 })),
                r
              );
            }
            return (
              o(e, t),
              (e.prototype.summary = function () {
                return this.upstream.summary() + " -> Skip";
              }),
              (e.prototype.next = function () {
                return s(this, void 0, void 0, function () {
                  var t = this;
                  return u(this, function (e) {
                    return (
                      (this.lastRead = this.lastRead.then(function () {
                        return t.serialNext();
                      })),
                      [2, this.lastRead]
                    );
                  });
                });
              }),
              (e.prototype.serialNext = function () {
                return s(this, void 0, void 0, function () {
                  var t;
                  return u(this, function (e) {
                    switch (e.label) {
                      case 0:
                        return this.count++ < this.maxCount
                          ? [4, this.upstream.next()]
                          : [3, 2];
                      case 1:
                        return (t = e.sent()).done
                          ? [2, t]
                          : (Object(i.S)(t.value), [3, 0]);
                      case 2:
                        return [2, this.upstream.next()];
                    }
                  });
                });
              }),
              e
            );
          })(D),
          z = (function (t) {
            function e(e, n) {
              var r = t.call(this) || this;
              return (r.upstream = e), (r.maxCount = n), (r.count = 0), r;
            }
            return (
              o(e, t),
              (e.prototype.summary = function () {
                return this.upstream.summary() + " -> Take";
              }),
              (e.prototype.next = function () {
                return s(this, void 0, void 0, function () {
                  return u(this, function (t) {
                    return this.count++ >= this.maxCount
                      ? [2, { value: null, done: !0 }]
                      : [2, this.upstream.next()];
                  });
                });
              }),
              e
            );
          })(D),
          L = (function (t) {
            function e(e, n, r) {
              void 0 === r && (r = !0);
              var i = t.call(this) || this;
              return (
                (i.upstream = e),
                (i.batchSize = n),
                (i.enableSmallLastBatch = r),
                (i.lastRead = Promise.resolve({ value: null, done: !1 })),
                i
              );
            }
            return (
              o(e, t),
              (e.prototype.summary = function () {
                return this.upstream.summary() + " -> RowMajorBatch";
              }),
              (e.prototype.next = function () {
                return s(this, void 0, void 0, function () {
                  var t = this;
                  return u(this, function (e) {
                    return (
                      (this.lastRead = this.lastRead.then(function () {
                        return t.serialNext();
                      })),
                      [2, this.lastRead]
                    );
                  });
                });
              }),
              (e.prototype.serialNext = function () {
                return s(this, void 0, void 0, function () {
                  var t, e;
                  return u(this, function (n) {
                    switch (n.label) {
                      case 0:
                        (t = []), (n.label = 1);
                      case 1:
                        return t.length < this.batchSize
                          ? [4, this.upstream.next()]
                          : [3, 3];
                      case 2:
                        return (e = n.sent()).done
                          ? this.enableSmallLastBatch && t.length > 0
                            ? [2, { value: t, done: !1 }]
                            : [2, { value: null, done: !0 }]
                          : (t.push(e.value), [3, 1]);
                      case 3:
                        return [2, { value: t, done: !1 }];
                    }
                  });
                });
              }),
              e
            );
          })(D),
          B = (function (t) {
            function e(e, n) {
              var r = t.call(this) || this;
              return (
                (r.upstream = e),
                (r.predicate = n),
                (r.lastRead = Promise.resolve({ value: null, done: !1 })),
                r
              );
            }
            return (
              o(e, t),
              (e.prototype.summary = function () {
                return this.upstream.summary() + " -> Filter";
              }),
              (e.prototype.next = function () {
                return s(this, void 0, void 0, function () {
                  var t = this;
                  return u(this, function (e) {
                    return (
                      (this.lastRead = this.lastRead.then(function () {
                        return t.serialNext();
                      })),
                      [2, this.lastRead]
                    );
                  });
                });
              }),
              (e.prototype.serialNext = function () {
                return s(this, void 0, void 0, function () {
                  var t;
                  return u(this, function (e) {
                    switch (e.label) {
                      case 0:
                        return [4, this.upstream.next()];
                      case 1:
                        return (t = e.sent()).done || this.predicate(t.value)
                          ? [2, t]
                          : (Object(i.S)(t.value), [3, 0]);
                      case 2:
                        return [2];
                    }
                  });
                });
              }),
              e
            );
          })(D),
          W = (function (t) {
            function e(e, n) {
              var r = t.call(this) || this;
              return (r.upstream = e), (r.transform = n), r;
            }
            return (
              o(e, t),
              (e.prototype.summary = function () {
                return this.upstream.summary() + " -> Map";
              }),
              (e.prototype.next = function () {
                return s(this, void 0, void 0, function () {
                  var t, e, n, r, a, o, s;
                  return u(this, function (u) {
                    switch (u.label) {
                      case 0:
                        return [4, this.upstream.next()];
                      case 1:
                        if ((t = u.sent()).done)
                          return [2, { value: null, done: !0 }];
                        for (
                          e = i.Yc.getTensorsInContainer(t.value),
                            n = this.transform(t.value),
                            r = i.Yc.getTensorsInContainer(n),
                            a = 0,
                            o = e;
                          a < o.length;
                          a++
                        )
                          (s = o[a]), i.Yc.isTensorInList(s, r) || s.dispose();
                        return [2, { value: n, done: !1 }];
                    }
                  });
                });
              }),
              e
            );
          })(D),
          U = (function (t) {
            function e(e, n) {
              var r = t.call(this) || this;
              return (
                (r.upstream = e),
                (r.handler = n),
                (r.count = 0),
                (r.lastRead = Promise.resolve({ value: null, done: !1 })),
                r
              );
            }
            return (
              o(e, t),
              (e.prototype.summary = function () {
                return this.upstream.summary() + " -> handleErrors";
              }),
              (e.prototype.next = function () {
                return s(this, void 0, void 0, function () {
                  var t = this;
                  return u(this, function (e) {
                    return (
                      (this.lastRead = this.lastRead.then(function () {
                        return t.serialNext();
                      })),
                      [2, this.lastRead]
                    );
                  });
                });
              }),
              (e.prototype.serialNext = function () {
                return s(this, void 0, void 0, function () {
                  var t;
                  return u(this, function (e) {
                    switch (e.label) {
                      case 0:
                        e.label = 1;
                      case 1:
                        return (
                          e.trys.push([1, 3, , 4]), [4, this.upstream.next()]
                        );
                      case 2:
                        return [2, e.sent()];
                      case 3:
                        return (
                          (t = e.sent()),
                          this.handler(t)
                            ? [3, 4]
                            : [2, { value: null, done: !0 }]
                        );
                      case 4:
                        return [3, 0];
                      case 5:
                        return [2];
                    }
                  });
                });
              }),
              e
            );
          })(D),
          V = (function (t) {
            function e(e, n) {
              var r = t.call(this) || this;
              return (r.upstream = e), (r.transform = n), r;
            }
            return (
              o(e, t),
              (e.prototype.summary = function () {
                return this.upstream.summary() + " -> AsyncMap";
              }),
              (e.prototype.next = function () {
                return s(this, void 0, void 0, function () {
                  var t, e, n, r, a, o, s;
                  return u(this, function (u) {
                    switch (u.label) {
                      case 0:
                        return [4, this.upstream.next()];
                      case 1:
                        return (t = u.sent()).done
                          ? [2, { value: null, done: !0 }]
                          : ((e = i.Yc.getTensorsInContainer(t.value)),
                            [4, this.transform(t.value)]);
                      case 2:
                        for (
                          n = u.sent(),
                            r = i.Yc.getTensorsInContainer(n),
                            a = 0,
                            o = e;
                          a < o.length;
                          a++
                        )
                          (s = o[a]), i.Yc.isTensorInList(s, r) || s.dispose();
                        return [2, { value: n, done: !1 }];
                    }
                  });
                });
              }),
              e
            );
          })(D),
          G = (function (t) {
            function e() {
              var e = t.call(this) || this;
              return (
                (e.outputQueue = new N()),
                (e.lastRead = Promise.resolve({ value: null, done: !1 })),
                e
              );
            }
            return (
              o(e, t),
              (e.prototype.next = function () {
                return s(this, void 0, void 0, function () {
                  var t = this;
                  return u(this, function (e) {
                    return (
                      (this.lastRead = this.lastRead.then(function () {
                        return t.serialNext();
                      })),
                      [2, this.lastRead]
                    );
                  });
                });
              }),
              (e.prototype.serialNext = function () {
                return s(this, void 0, void 0, function () {
                  return u(this, function (t) {
                    switch (t.label) {
                      case 0:
                        return 0 !== this.outputQueue.length()
                          ? [3, 2]
                          : [4, this.pump()];
                      case 1:
                        return t.sent()
                          ? [3, 0]
                          : [2, { value: null, done: !0 }];
                      case 2:
                        return [
                          2,
                          { value: this.outputQueue.shift(), done: !1 },
                        ];
                    }
                  });
                });
              }),
              e
            );
          })(D),
          H = (function (t) {
            function e(e, n) {
              var r = t.call(this) || this;
              return (r.upstream = e), (r.transform = n), r;
            }
            return (
              o(e, t),
              (e.prototype.summary = function () {
                return this.upstream.summary() + " -> Flatmap";
              }),
              (e.prototype.pump = function () {
                return s(this, void 0, void 0, function () {
                  var t, e, n, r, a, o, s;
                  return u(this, function (u) {
                    switch (u.label) {
                      case 0:
                        return [4, this.upstream.next()];
                      case 1:
                        if ((t = u.sent()).done) return [2, !1];
                        for (
                          e = i.Yc.getTensorsInContainer(t.value),
                            n = this.transform(t.value),
                            r = i.Yc.getTensorsInContainer(n),
                            this.outputQueue.pushAll(n),
                            a = 0,
                            o = e;
                          a < o.length;
                          a++
                        )
                          (s = o[a]), i.Yc.isTensorInList(s, r) || s.dispose();
                        return [2, !0];
                    }
                  });
                });
              }),
              e
            );
          })(G),
          q = (function (t) {
            function e(e, n) {
              var r = t.call(this) || this;
              return (
                (r.baseErrorHandler = n),
                (r.lastRead = null),
                (r.iterator = null),
                (r.moreIterators = e),
                r
              );
            }
            return (
              o(e, t),
              (e.prototype.summary = function () {
                return "TODO: fill in upstream of chained summaries -> Chained";
              }),
              (e.prototype.next = function () {
                return s(this, void 0, void 0, function () {
                  return u(this, function (t) {
                    return (
                      (this.lastRead = this.readFromChain(this.lastRead)),
                      [2, this.lastRead]
                    );
                  });
                });
              }),
              (e.prototype.readFromChain = function (t) {
                return s(this, void 0, void 0, function () {
                  var e, n;
                  return u(this, function (r) {
                    switch (r.label) {
                      case 0:
                        return [4, t];
                      case 1:
                        return (
                          r.sent(),
                          null != this.iterator
                            ? [3, 3]
                            : [4, this.moreIterators.next()]
                        );
                      case 2:
                        if ((e = r.sent()).done)
                          return [2, { value: null, done: !0 }];
                        (this.iterator = e.value),
                          null != this.baseErrorHandler &&
                            (this.iterator = this.iterator.handleErrors(
                              this.baseErrorHandler
                            )),
                          (r.label = 3);
                      case 3:
                        return [4, this.iterator.next()];
                      case 4:
                        return (n = r.sent()).done
                          ? ((this.iterator = null), [2, this.readFromChain(t)])
                          : [2, n];
                    }
                  });
                });
              }),
              e
            );
          })(D);
        ((R = T || (T = {}))[(R.FAIL = 0)] = "FAIL"),
          (R[(R.SHORTEST = 1)] = "SHORTEST"),
          (R[(R.LONGEST = 2)] = "LONGEST");
        var K = (function (t) {
            function e(e, n) {
              void 0 === n && (n = T.FAIL);
              var r = t.call(this) || this;
              return (
                (r.iterators = e),
                (r.mismatchMode = n),
                (r.count = 0),
                (r.currentPromise = null),
                r
              );
            }
            return (
              o(e, t),
              (e.prototype.summary = function () {
                return "{TODO: fill in upstream of zip summaries} -> Zip";
              }),
              (e.prototype.nextState = function (t) {
                return s(this, void 0, void 0, function () {
                  function e(t) {
                    return t instanceof D
                      ? {
                          value: t.next().then(function (t) {
                            return n++, t.done && r++, t.value;
                          }),
                          recurse: !1,
                        }
                      : { value: null, recurse: !0 };
                  }
                  var n, r, i;
                  return u(this, function (a) {
                    switch (a.label) {
                      case 0:
                        return [4, t];
                      case 1:
                        return (
                          a.sent(), (n = 0), (r = 0), [4, x(this.iterators, e)]
                        );
                      case 2:
                        if (((i = a.sent()), n === r))
                          return [2, { value: null, done: !0 }];
                        if (r > 0)
                          switch (this.mismatchMode) {
                            case T.FAIL:
                              throw new Error(
                                "Zipped streams should have the same length. Mismatched at element " +
                                  this.count +
                                  "."
                              );
                            case T.SHORTEST:
                              return [2, { value: null, done: !0 }];
                            case T.LONGEST:
                          }
                        return this.count++, [2, { value: i, done: !1 }];
                    }
                  });
                });
              }),
              (e.prototype.next = function () {
                return s(this, void 0, void 0, function () {
                  return u(this, function (t) {
                    return (
                      (this.currentPromise = this.nextState(
                        this.currentPromise
                      )),
                      [2, this.currentPromise]
                    );
                  });
                });
              }),
              e
            );
          })(D),
          Z = (function (t) {
            function e(e, n) {
              var r = t.call(this) || this;
              return (
                (r.upstream = e), (r.bufferSize = n), (r.buffer = new S(n)), r
              );
            }
            return (
              o(e, t),
              (e.prototype.summary = function () {
                return this.upstream.summary() + " -> Prefetch";
              }),
              (e.prototype.refill = function () {
                for (; !this.buffer.isFull(); ) {
                  var t = this.upstream.next();
                  this.buffer.push(t);
                }
              }),
              (e.prototype.next = function () {
                return this.refill(), this.buffer.shift();
              }),
              e
            );
          })(D),
          X = (function (t) {
            function e(e, n, r) {
              var a = t.call(this, e, n) || this;
              return (
                (a.upstream = e),
                (a.windowSize = n),
                (a.upstreamExhausted = !1),
                (a.random = g(r || i.gd.now().toString())),
                (a.lastRead = Promise.resolve({ value: null, done: !1 })),
                a
              );
            }
            return (
              o(e, t),
              (e.prototype.next = function () {
                return s(this, void 0, void 0, function () {
                  var t = this;
                  return u(this, function (e) {
                    return (
                      (this.lastRead = this.lastRead.then(function () {
                        return t.serialNext();
                      })),
                      [2, this.lastRead]
                    );
                  });
                });
              }),
              (e.prototype.randomInt = function (t) {
                return Math.floor(this.random() * t);
              }),
              (e.prototype.chooseIndex = function () {
                return this.randomInt(this.buffer.length());
              }),
              (e.prototype.serialNext = function () {
                return s(this, void 0, void 0, function () {
                  var t, e;
                  return u(this, function (n) {
                    switch (n.label) {
                      case 0:
                        this.upstreamExhausted || this.refill(), (n.label = 1);
                      case 1:
                        return this.buffer.isEmpty()
                          ? [3, 3]
                          : ((t = this.chooseIndex()),
                            [4, this.buffer.shuffleExcise(t)]);
                      case 2:
                        return (e = n.sent()).done
                          ? ((this.upstreamExhausted = !0), [3, 1])
                          : (this.refill(), [2, e]);
                      case 3:
                        return [2, { value: null, done: !0 }];
                    }
                  });
                });
              }),
              e
            );
          })(Z),
          Y = (function () {
            function t() {
              this.size = null;
            }
            return (
              (t.prototype.batch = function (t, e) {
                var n = this;
                void 0 === e && (e = !0);
                var r = this;
                return (
                  i.gd.assert(t > 0, function () {
                    return (
                      "batchSize needs to be positive, but it is\n      " + t
                    );
                  }),
                  J(
                    function () {
                      return s(n, void 0, void 0, function () {
                        return u(this, function (n) {
                          switch (n.label) {
                            case 0:
                              return [4, r.iterator()];
                            case 1:
                              return [2, n.sent().columnMajorBatch(t, e, tt)];
                          }
                        });
                      });
                    },
                    this.size === 1 / 0 || null == this.size
                      ? this.size
                      : e
                      ? Math.ceil(this.size / t)
                      : Math.floor(this.size / t)
                  )
                );
              }),
              (t.prototype.concatenate = function (t) {
                var e = this,
                  n = this;
                return J(
                  function () {
                    return s(e, void 0, void 0, function () {
                      var e, r;
                      return u(this, function (i) {
                        switch (i.label) {
                          case 0:
                            return [4, n.iterator()];
                          case 1:
                            return (
                              (r = (e = i.sent()).concatenate),
                              [4, t.iterator()]
                            );
                          case 2:
                            return [2, r.apply(e, [i.sent()])];
                        }
                      });
                    });
                  },
                  this.size === 1 / 0 || t.size === 1 / 0
                    ? 1 / 0
                    : null != this.size && null != t.size
                    ? this.size + t.size
                    : null
                );
              }),
              (t.prototype.filter = function (t) {
                var e = this,
                  n = this;
                return J(
                  function () {
                    return s(e, void 0, void 0, function () {
                      return u(this, function (e) {
                        switch (e.label) {
                          case 0:
                            return [4, n.iterator()];
                          case 1:
                            return [
                              2,
                              e.sent().filter(function (e) {
                                return Object(i.Zc)(function () {
                                  return t(e);
                                });
                              }),
                            ];
                        }
                      });
                    });
                  },
                  this.size === 1 / 0 ? 1 / 0 : null
                );
              }),
              (t.prototype.forEachAsync = function (t) {
                return s(this, void 0, void 0, function () {
                  return u(this, function (e) {
                    switch (e.label) {
                      case 0:
                        return [4, this.iterator()];
                      case 1:
                        return [2, e.sent().forEachAsync(t)];
                    }
                  });
                });
              }),
              (t.prototype.forEach = function (t) {
                return s(this, void 0, void 0, function () {
                  return u(this, function (e) {
                    return (
                      Object(i.P)(
                        "dataset.forEach() is deprecated and will be removed. Please use dataset.forEachAsync() instead"
                      ),
                      [2, this.forEachAsync(t)]
                    );
                  });
                });
              }),
              (t.prototype.map = function (t) {
                var e = this,
                  n = this;
                return J(function () {
                  return s(e, void 0, void 0, function () {
                    return u(this, function (e) {
                      switch (e.label) {
                        case 0:
                          return [4, n.iterator()];
                        case 1:
                          return [
                            2,
                            e.sent().map(function (e) {
                              return Object(i.Zc)(function () {
                                return t(e);
                              });
                            }),
                          ];
                      }
                    });
                  });
                }, this.size);
              }),
              (t.prototype.mapAsync = function (t) {
                var e = this,
                  n = this;
                return J(function () {
                  return s(e, void 0, void 0, function () {
                    return u(this, function (e) {
                      switch (e.label) {
                        case 0:
                          return [4, n.iterator()];
                        case 1:
                          return [2, e.sent().mapAsync(t)];
                      }
                    });
                  });
                }, this.size);
              }),
              (t.prototype.prefetch = function (t) {
                var e = this;
                if (null == t)
                  throw new RangeError(
                    "`Dataset.prefetch()` requires bufferSize to be specified."
                  );
                var n = this;
                return J(function () {
                  return s(e, void 0, void 0, function () {
                    return u(this, function (e) {
                      switch (e.label) {
                        case 0:
                          return [4, n.iterator()];
                        case 1:
                          return [2, e.sent().prefetch(t)];
                      }
                    });
                  });
                }, this.size);
              }),
              (t.prototype.repeat = function (t) {
                var e = this,
                  n = this;
                return J(
                  function () {
                    return s(e, void 0, void 0, function () {
                      var e = this;
                      return u(this, function (r) {
                        return [
                          2,
                          _(
                            k(function () {
                              return s(e, void 0, void 0, function () {
                                var t;
                                return u(this, function (e) {
                                  switch (e.label) {
                                    case 0:
                                      return (t = {}), [4, n.iterator()];
                                    case 1:
                                      return [
                                        2,
                                        ((t.value = e.sent()),
                                        (t.done = !1),
                                        t),
                                      ];
                                  }
                                });
                              });
                            }).take(t)
                          ),
                        ];
                      });
                    });
                  },
                  null != this.size && t > 0
                    ? this.size * t
                    : 0 === t
                    ? 0
                    : null != this.size && (void 0 === t || t < 0)
                    ? 1 / 0
                    : null
                );
              }),
              (t.prototype.skip = function (t) {
                var e = this,
                  n = this;
                return J(
                  function () {
                    return s(e, void 0, void 0, function () {
                      return u(this, function (e) {
                        switch (e.label) {
                          case 0:
                            return [4, n.iterator()];
                          case 1:
                            return [2, e.sent().skip(t)];
                        }
                      });
                    });
                  },
                  null != this.size && t >= 0 && this.size >= t
                    ? this.size - t
                    : null != this.size &&
                      (this.size < t || void 0 === t || t < 0)
                    ? 0
                    : null
                );
              }),
              (t.prototype.shuffle = function (t, e, n) {
                var r = this;
                if ((void 0 === n && (n = !0), null == t || t < 0))
                  throw null == this.size
                    ? new RangeError(
                        "`Dataset.shuffle()` requires bufferSize to be specified."
                      )
                    : new RangeError(
                        "`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting bufferSize to the dataset size (" +
                          this.size +
                          " elements)"
                      );
                var a = this,
                  o = g(e || i.gd.now().toString());
                return J(function () {
                  return s(r, void 0, void 0, function () {
                    var e;
                    return u(this, function (r) {
                      switch (r.label) {
                        case 0:
                          return (
                            (e = o.int32()),
                            n && (e += o.int32()),
                            [4, a.iterator()]
                          );
                        case 1:
                          return [2, r.sent().shuffle(t, e.toString())];
                      }
                    });
                  });
                }, this.size);
              }),
              (t.prototype.take = function (t) {
                var e = this,
                  n = this;
                return J(
                  function () {
                    return s(e, void 0, void 0, function () {
                      return u(this, function (e) {
                        switch (e.label) {
                          case 0:
                            return [4, n.iterator()];
                          case 1:
                            return [2, e.sent().take(t)];
                        }
                      });
                    });
                  },
                  null != this.size && this.size > t
                    ? t
                    : null != this.size && this.size <= t
                    ? this.size
                    : null
                );
              }),
              (t.prototype.toArray = function () {
                return s(this, void 0, void 0, function () {
                  return u(this, function (t) {
                    switch (t.label) {
                      case 0:
                        if (this.size === 1 / 0)
                          throw new Error(
                            "Can not convert infinite data stream to array."
                          );
                        return [4, this.iterator()];
                      case 1:
                        return [2, t.sent().toArray()];
                    }
                  });
                });
              }),
              (t.prototype.toArrayForTest = function () {
                return s(this, void 0, void 0, function () {
                  return u(this, function (t) {
                    switch (t.label) {
                      case 0:
                        if (this.size === 1 / 0)
                          throw new Error(
                            "Can not convert infinite data stream to array."
                          );
                        return [4, this.iterator()];
                      case 1:
                        return [2, t.sent().toArrayForTest()];
                    }
                  });
                });
              }),
              (t.MAX_BUFFER_SIZE = 1e4),
              t
            );
          })();
        function J(t, e) {
          return (
            void 0 === e && (e = null),
            new ((function (n) {
              function r() {
                var t = (null !== n && n.apply(this, arguments)) || this;
                return (t.size = e), t;
              }
              return (
                o(r, n),
                (r.prototype.iterator = function () {
                  return s(this, void 0, void 0, function () {
                    return u(this, function (e) {
                      return [2, t()];
                    });
                  });
                }),
                r
              );
            })(Y))()
          );
        }
        function $(t) {
          var e = this;
          return J(function () {
            return s(e, void 0, void 0, function () {
              return u(this, function (e) {
                return [2, I(t)];
              });
            });
          }, t.length);
        }
        function Q(t) {
          var e,
            n = this;
          if (!C(t))
            throw new Error(
              "The argument to zip() must be an object or array."
            );
          if (Array.isArray(t))
            for (var r = 0; r < t.length; r++)
              e = null == e ? t[r].size : Math.min(e, t[r].size);
          else if (t instanceof Object)
            for (var i in t) e = null == e ? t[i].size : Math.min(e, t[i].size);
          return J(function () {
            return s(n, void 0, void 0, function () {
              return u(this, function (e) {
                switch (e.label) {
                  case 0:
                    return [
                      4,
                      x(t, function (t) {
                        if (t instanceof Y)
                          return { value: t.iterator(), recurse: !1 };
                        if (C(t)) return { value: null, recurse: !0 };
                        throw new Error(
                          "Leaves of the structure passed to zip() must be Datasets, not primitives."
                        );
                      }),
                    ];
                  case 1:
                    return [2, A(e.sent(), T.SHORTEST)];
                }
              });
            });
          }, e);
        }
        function tt(t) {
          return null === t
            ? null
            : (function (t) {
                return (
                  null == t ||
                  (function (t) {
                    return (
                      null === t ||
                      ("object" != typeof t && "function" != typeof t)
                    );
                  })(t) ||
                  Array.isArray(t) ||
                  ("object" == typeof t && t instanceof i.b) ||
                  i.gd.isTypedArray(t)
                );
              })(t[0])
            ? { value: et(t), recurse: !1 }
            : { value: null, recurse: !0 };
        }
        function et(t) {
          if (0 === t.length)
            throw new Error("Can't make a batch of zero elements.");
          return t[0] instanceof i.b ? Object(i.Nc)(t) : Object(i.Tc)(t);
        }
        var nt = (function (t) {
            function e(e) {
              var n = t.call(this) || this;
              return (n.input = e), n;
            }
            return (
              o(e, t),
              (e.prototype.iterator = function () {
                return s(this, void 0, void 0, function () {
                  var t;
                  return u(this, function (e) {
                    switch (e.label) {
                      case 0:
                        return [4, this.input.iterator()];
                      case 1:
                        return (
                          (t = e.sent()),
                          [
                            2,
                            t
                              .decodeUTF8()
                              .split("\n")
                              .map(function (t) {
                                return (
                                  t.endsWith("\r") && (t = t.slice(0, -1)), t
                                );
                              }),
                          ]
                        );
                    }
                  });
                });
              }),
              e
            );
          })(Y),
          rt = Symbol("out"),
          it = Symbol("field"),
          at = Symbol("quote"),
          ot = Symbol("quoteafterquote"),
          st = Symbol("quoteinquote"),
          ut = (function (t) {
            function e(e, n) {
              var r = t.call(this) || this;
              return (
                (r.input = e),
                (r.hasHeader = !0),
                (r.fullColumnNames = null),
                (r.columnNamesValidated = !1),
                (r.columnConfigs = null),
                (r.configuredColumnsOnly = !1),
                (r.delimiter = ","),
                (r.delimWhitespace = !1),
                (r.base = new nt(e)),
                n || (n = {}),
                (r.hasHeader = !1 !== n.hasHeader),
                (r.fullColumnNames = n.columnNames),
                (r.columnConfigs = n.columnConfigs),
                (r.configuredColumnsOnly = n.configuredColumnsOnly),
                n.delimWhitespace
                  ? (i.gd.assert(null == n.delimiter, function () {
                      return "Delimiter should not be provided when delimWhitespace is true.";
                    }),
                    (r.delimWhitespace = !0),
                    (r.delimiter = " "))
                  : (r.delimiter = n.delimiter ? n.delimiter : ","),
                r
              );
            }
            return (
              o(e, t),
              (e.prototype.columnNames = function () {
                return s(this, void 0, void 0, function () {
                  return u(this, function (t) {
                    switch (t.label) {
                      case 0:
                        return this.columnNamesValidated
                          ? [3, 2]
                          : [4, this.setColumnNames()];
                      case 1:
                        t.sent(), (t.label = 2);
                      case 2:
                        return [
                          2,
                          this.configuredColumnsOnly
                            ? Object.keys(this.columnConfigs)
                            : this.fullColumnNames,
                        ];
                    }
                  });
                });
              }),
              (e.prototype.setColumnNames = function () {
                return s(this, void 0, void 0, function () {
                  var t,
                    e,
                    n,
                    r,
                    a,
                    o,
                    s = this;
                  return u(this, function (u) {
                    switch (u.label) {
                      case 0:
                        return [4, this.maybeReadHeaderLine()];
                      case 1:
                        if (((t = u.sent()), !this.fullColumnNames && !t))
                          throw new Error(
                            "Column names must be provided if there is no header line."
                          );
                        if (
                          (this.fullColumnNames &&
                            t &&
                            i.gd.assert(
                              t.length === this.fullColumnNames.length,
                              function () {
                                return (
                                  "The length of provided columnNames (" +
                                  s.fullColumnNames.length.toString() +
                                  ") does not match the length of the header line read from file (" +
                                  t.length.toString() +
                                  ")."
                                );
                              }
                            ),
                          this.fullColumnNames || (this.fullColumnNames = t),
                          (e = this.fullColumnNames.reduce(function (t, e) {
                            return (t[e] = t[e] + 1 || 1), t;
                          }, {})),
                          (n = Object.keys(e).filter(function (t) {
                            return e[t] > 1;
                          })),
                          i.gd.assert(0 === n.length, function () {
                            return (
                              "Duplicate column names found: " + n.toString()
                            );
                          }),
                          this.columnConfigs)
                        )
                          for (
                            r = 0, a = Object.keys(this.columnConfigs);
                            r < a.length;
                            r++
                          )
                            if (
                              ((o = a[r]),
                              -1 === this.fullColumnNames.indexOf(o))
                            )
                              throw new Error(
                                'The key "' +
                                  o +
                                  '" provided in columnConfigs does not match any of the column names (' +
                                  this.fullColumnNames.toString() +
                                  ")."
                              );
                        return (this.columnNamesValidated = !0), [2];
                    }
                  });
                });
              }),
              (e.prototype.maybeReadHeaderLine = function () {
                return s(this, void 0, void 0, function () {
                  var t, e;
                  return u(this, function (n) {
                    switch (n.label) {
                      case 0:
                        return this.hasHeader
                          ? [4, this.base.iterator()]
                          : [3, 3];
                      case 1:
                        return [4, n.sent().next()];
                      case 2:
                        if ((t = n.sent()).done)
                          throw new Error("No data was found for CSV parsing.");
                        return (e = t.value), [2, this.parseRow(e, !1)];
                      case 3:
                        return [2, null];
                    }
                  });
                });
              }),
              (e.prototype.iterator = function () {
                return s(this, void 0, void 0, function () {
                  var t,
                    e = this;
                  return u(this, function (n) {
                    switch (n.label) {
                      case 0:
                        return this.columnNamesValidated
                          ? [3, 2]
                          : [4, this.setColumnNames()];
                      case 1:
                        n.sent(), (n.label = 2);
                      case 2:
                        return [4, this.base.iterator()];
                      case 3:
                        return (
                          (t = n.sent()),
                          this.hasHeader && (t = t.skip(1)),
                          [
                            2,
                            t.map(function (t) {
                              return e.makeDataElement(t);
                            }),
                          ]
                        );
                    }
                  });
                });
              }),
              (e.prototype.makeDataElement = function (t) {
                for (
                  var e = this.parseRow(t), n = {}, r = {}, i = 0;
                  i < this.fullColumnNames.length;
                  i++
                ) {
                  var a = this.fullColumnNames[i],
                    o = this.columnConfigs ? this.columnConfigs[a] : null;
                  if (!this.configuredColumnsOnly || o) {
                    var s = e[i],
                      u = null;
                    if ("" === s)
                      if (o && void 0 !== o.default) u = o.default;
                      else {
                        if (o && (o.required || o.isLabel))
                          throw new Error(
                            "Required column " +
                              a +
                              " is empty in this line: " +
                              t
                          );
                        u = void 0;
                      }
                    else {
                      var c = Number(s);
                      if (isNaN(c))
                        u = o && "bool" === o.dtype ? this.getBoolean(s) : s;
                      else if (o && o.dtype)
                        switch (o.dtype) {
                          case "float32":
                            u = c;
                            break;
                          case "int32":
                            u = Math.floor(c);
                            break;
                          case "bool":
                            u = this.getBoolean(s);
                            break;
                          default:
                            u = c;
                        }
                      else u = c;
                    }
                    o && o.isLabel ? (r[a] = u) : (n[a] = u);
                  }
                }
                return 0 === Object.keys(r).length ? n : { xs: n, ys: r };
              }),
              (e.prototype.getBoolean = function (t) {
                return "1" === t || "true" === t.toLowerCase() ? 1 : 0;
              }),
              (e.prototype.parseRow = function (t, e) {
                void 0 === e && (e = !0);
                for (var n = [], r = 0, i = t.length, a = rt, o = 0; o < i; o++)
                  switch (a) {
                    case rt:
                      switch (t.charAt(o)) {
                        case '"':
                          (r = o + 1), (a = at);
                          break;
                        case this.delimiter:
                          if (
                            ((r = o + 1),
                            " " === this.delimiter && this.delimWhitespace)
                          )
                            break;
                          n.push(""), (a = rt);
                          break;
                        default:
                          (a = it), (r = o);
                      }
                      break;
                    case it:
                      switch (t.charAt(o)) {
                        case this.delimiter:
                          n.push(t.substring(r, o)), (a = rt), (r = o + 1);
                      }
                      break;
                    case at:
                      switch (t.charAt(o)) {
                        case '"':
                          a = ot;
                      }
                      break;
                    case ot:
                      switch (t.charAt(o)) {
                        case this.delimiter:
                          n.push(t.substring(r, o - 1)), (a = rt), (r = o + 1);
                          break;
                        case '"':
                          a = at;
                          break;
                        default:
                          a = st;
                      }
                      break;
                    case st:
                      switch (t.charAt(o)) {
                        case '"':
                          a = at;
                      }
                  }
                if (
                  (a === ot
                    ? n.push(t.substring(r, i - 1))
                    : n.push(t.substring(r)),
                  e && n.length !== this.fullColumnNames.length)
                )
                  throw new Error(
                    "Invalid row in csv file. Should have " +
                      this.fullColumnNames.length +
                      " elements in a row, but got " +
                      n
                  );
                return n;
              }),
              e
            );
          })(Y),
          ct = (function (t) {
            function e(e) {
              var n = t.call(this) || this;
              (n.microphoneConfig = e),
                (n.isClosed = !1),
                (n.fftSize = e.fftSize || 1024);
              var r = Math.log2(n.fftSize);
              if (n.fftSize < 0 || r < 4 || r > 14 || !Number.isInteger(r))
                throw new Error(
                  "Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got " +
                    n.fftSize
                );
              if (
                ((n.numFrames = e.numFramesPerSpectrogram || 43),
                (n.sampleRateHz = e.sampleRateHz),
                (n.columnTruncateLength = e.columnTruncateLength || n.fftSize),
                (n.audioTrackConstraints = e.audioTrackConstraints),
                (n.smoothingTimeConstant = e.smoothingTimeConstant || 0),
                (n.includeSpectrogram = !1 !== e.includeSpectrogram),
                (n.includeWaveform = !0 === e.includeWaveform),
                !n.includeSpectrogram && !n.includeWaveform)
              )
                throw new Error(
                  "Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned."
                );
              return n;
            }
            return (
              o(e, t),
              (e.prototype.summary = function () {
                return "microphone";
              }),
              (e.create = function (t) {
                return (
                  void 0 === t && (t = {}),
                  s(this, void 0, void 0, function () {
                    var n;
                    return u(this, function (r) {
                      switch (r.label) {
                        case 0:
                          if (Object(i.Y)().get("IS_NODE"))
                            throw new Error(
                              "microphone API is only supported in browser environment."
                            );
                          return [4, (n = new e(t)).start()];
                        case 1:
                          return r.sent(), [2, n];
                      }
                    });
                  })
                );
              }),
              (e.prototype.start = function () {
                return s(this, void 0, void 0, function () {
                  var t, e, n, r;
                  return u(this, function (i) {
                    switch (i.label) {
                      case 0:
                        return (
                          i.trys.push([0, 2, , 3]),
                          (t = this),
                          [
                            4,
                            navigator.mediaDevices.getUserMedia({
                              audio:
                                null == this.audioTrackConstraints ||
                                this.audioTrackConstraints,
                              video: !1,
                            }),
                          ]
                        );
                      case 1:
                        return (t.stream = i.sent()), [3, 3];
                      case 2:
                        throw (
                          ((e = i.sent()),
                          new Error(
                            "Error thrown while initializing video stream: " +
                              e.message
                          ))
                        );
                      case 3:
                        if (!this.stream)
                          throw new Error(
                            "Could not obtain audio from microphone."
                          );
                        if (
                          ((n =
                            window.AudioContext || window.webkitAudioContext),
                          (this.audioContext = new n()),
                          this.sampleRateHz)
                        ) {
                          if (
                            this.audioContext.sampleRate !== this.sampleRateHz
                          )
                            throw new Error(
                              "Mismatch in sampling rate: Expected: " +
                                this.sampleRateHz +
                                "; Actual: " +
                                this.audioContext.sampleRate
                            );
                        } else this.sampleRateHz = this.audioContext.sampleRate;
                        return (
                          (r = this.audioContext.createMediaStreamSource(
                            this.stream
                          )),
                          (this.analyser = this.audioContext.createAnalyser()),
                          (this.analyser.fftSize = 2 * this.fftSize),
                          (this.analyser.smoothingTimeConstant = this.smoothingTimeConstant),
                          r.connect(this.analyser),
                          (this.freqData = new Float32Array(this.fftSize)),
                          (this.timeData = new Float32Array(this.fftSize)),
                          [2]
                        );
                    }
                  });
                });
              }),
              (e.prototype.next = function () {
                return s(this, void 0, void 0, function () {
                  var t, e, n, r, i;
                  return u(this, function (a) {
                    switch (a.label) {
                      case 0:
                        return this.isClosed
                          ? [2, { value: null, done: !0 }]
                          : [4, this.getAudioData()];
                      case 1:
                        return (
                          (n = a.sent()),
                          this.includeSpectrogram &&
                            ((r = this.flattenQueue(n.freqDataQueue)),
                            (t = this.getTensorFromAudioDataArray(r, [
                              this.numFrames,
                              this.columnTruncateLength,
                              1,
                            ]))),
                          this.includeWaveform &&
                            ((i = this.flattenQueue(n.timeDataQueue)),
                            (e = this.getTensorFromAudioDataArray(i, [
                              this.numFrames * this.fftSize,
                              1,
                            ]))),
                          [
                            2,
                            {
                              value: { spectrogram: t, waveform: e },
                              done: !1,
                            },
                          ]
                        );
                    }
                  });
                });
              }),
              (e.prototype.capture = function () {
                return s(this, void 0, void 0, function () {
                  return u(this, function (t) {
                    switch (t.label) {
                      case 0:
                        return [4, this.next()];
                      case 1:
                        return [2, t.sent().value];
                    }
                  });
                });
              }),
              (e.prototype.getAudioData = function () {
                return s(this, void 0, void 0, function () {
                  var t,
                    e,
                    n,
                    r = this;
                  return u(this, function (i) {
                    return (
                      (t = []),
                      (e = []),
                      (n = 0),
                      [
                        2,
                        new Promise(function (i) {
                          var a = setInterval(function () {
                            r.includeSpectrogram &&
                              (r.analyser.getFloatFrequencyData(r.freqData),
                              r.freqData[0] === -1 / 0 &&
                                i({ freqDataQueue: t, timeDataQueue: e }),
                              t.push(
                                r.freqData.slice(0, r.columnTruncateLength)
                              )),
                              r.includeWaveform &&
                                (r.analyser.getFloatTimeDomainData(r.timeData),
                                e.push(r.timeData.slice())),
                              ++n === r.numFrames &&
                                (clearInterval(a),
                                i({ freqDataQueue: t, timeDataQueue: e }));
                          }, (r.fftSize / r.sampleRateHz) * 1e3);
                        }),
                      ]
                    );
                  });
                });
              }),
              (e.prototype.stop = function () {
                this.isClosed ||
                  ((this.isClosed = !0),
                  this.analyser.disconnect(),
                  this.audioContext.close(),
                  null != this.stream &&
                    this.stream.getTracks().length > 0 &&
                    this.stream.getTracks()[0].stop());
              }),
              (e.prototype.toArray = function () {
                throw new Error(
                  "Can not convert infinite audio stream to array."
                );
              }),
              (e.prototype.getSampleRate = function () {
                return this.sampleRateHz;
              }),
              (e.prototype.flattenQueue = function (t) {
                var e = t[0].length,
                  n = new Float32Array(t.length * e);
                return (
                  t.forEach(function (t, r) {
                    return n.set(t, r * e);
                  }),
                  n
                );
              }),
              (e.prototype.getTensorFromAudioDataArray = function (t, e) {
                var n = new Float32Array(i.gd.sizeFromShape(e));
                return n.set(t, n.length - t.length), Object(i.Tc)(n, e);
              }),
              e
            );
          })(D),
          lt = (function (t) {
            function e(e, n) {
              var r = t.call(this) || this;
              if (
                ((r.webcamVideoElement = e),
                (r.webcamConfig = n),
                (r.isClosed = !0),
                (r.resize = !1),
                r.needToResize())
              )
                if (
                  ((r.resize = !0),
                  (r.cropSize = [
                    r.webcamConfig.resizeHeight,
                    r.webcamConfig.resizeWidth,
                  ]),
                  (r.cropBoxInd = Object(i.Uc)([0], "int32")),
                  r.webcamConfig.centerCrop)
                ) {
                  var a =
                      (1 * r.webcamConfig.resizeWidth) /
                      r.webcamVideoElement.width,
                    o =
                      (1 * r.webcamConfig.resizeHeight) /
                      r.webcamVideoElement.height,
                    s = (1 - a) / 2,
                    u = (1 - o) / 2,
                    c = s + a,
                    l = o + u;
                  r.cropBox = Object(i.Vc)([u, s, l, c], [1, 4]);
                } else r.cropBox = Object(i.Vc)([0, 0, 1, 1], [1, 4]);
              return r;
            }
            return (
              o(e, t),
              (e.prototype.summary = function () {
                return "webcam";
              }),
              (e.create = function (t, n) {
                return (
                  void 0 === n && (n = {}),
                  s(this, void 0, void 0, function () {
                    var r;
                    return u(this, function (a) {
                      switch (a.label) {
                        case 0:
                          if (Object(i.Y)().get("IS_NODE"))
                            throw new Error(
                              "tf.data.webcam is only supported in browser environment."
                            );
                          if (!t) {
                            if (
                              ((t = document.createElement("video")),
                              !n.resizeWidth || !n.resizeHeight)
                            )
                              throw new Error(
                                "Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element."
                              );
                            (t.width = n.resizeWidth),
                              (t.height = n.resizeHeight);
                          }
                          return [4, (r = new e(t, n)).start()];
                        case 1:
                          return a.sent(), [2, r];
                      }
                    });
                  })
                );
              }),
              (e.prototype.start = function () {
                return s(this, void 0, void 0, function () {
                  var t,
                    e,
                    n = this;
                  return u(this, function (r) {
                    switch (r.label) {
                      case 0:
                        this.webcamConfig.facingMode &&
                          i.gd.assert(
                            "user" === this.webcamConfig.facingMode ||
                              "environment" === this.webcamConfig.facingMode,
                            function () {
                              return (
                                "Invalid webcam facing mode: " +
                                n.webcamConfig.facingMode +
                                ". Please provide 'user' or 'environment'"
                              );
                            }
                          ),
                          (r.label = 1);
                      case 1:
                        return (
                          r.trys.push([1, 3, , 4]),
                          (t = this),
                          [
                            4,
                            navigator.mediaDevices.getUserMedia({
                              video: {
                                deviceId: this.webcamConfig.deviceId,
                                facingMode: this.webcamConfig.facingMode
                                  ? this.webcamConfig.facingMode
                                  : "user",
                                width: this.webcamVideoElement.width,
                                height: this.webcamVideoElement.height,
                              },
                            }),
                          ]
                        );
                      case 2:
                        return (t.stream = r.sent()), [3, 4];
                      case 3:
                        throw (
                          (((e = r.sent()).message =
                            "Error thrown while initializing video stream: " +
                            e.message),
                          e)
                        );
                      case 4:
                        if (!this.stream)
                          throw new Error(
                            "Could not obtain video from webcam."
                          );
                        try {
                          this.webcamVideoElement.srcObject = this.stream;
                        } catch (t) {
                          console.log(t),
                            (this.webcamVideoElement.src = window.URL.createObjectURL(
                              this.stream
                            ));
                        }
                        return (
                          this.webcamVideoElement.play(),
                          (this.isClosed = !1),
                          [
                            2,
                            new Promise(function (t) {
                              n.webcamVideoElement.onloadedmetadata = function () {
                                t();
                              };
                            }),
                          ]
                        );
                    }
                  });
                });
              }),
              (e.prototype.next = function () {
                return s(this, void 0, void 0, function () {
                  var t;
                  return u(this, function (e) {
                    if (this.isClosed) return [2, { value: null, done: !0 }];
                    try {
                      t = i.z.fromPixels(this.webcamVideoElement);
                    } catch (t) {
                      throw new Error(
                        "Error thrown converting video to pixels: " +
                          JSON.stringify(t)
                      );
                    }
                    if (!this.resize) return [2, { value: t, done: !1 }];
                    try {
                      return [
                        2,
                        { value: this.cropAndResizeFrame(t), done: !1 },
                      ];
                    } catch (t) {
                      throw new Error(
                        "Error thrown cropping the video: " + t.message
                      );
                    } finally {
                      t.dispose();
                    }
                    return [2];
                  });
                });
              }),
              (e.prototype.needToResize = function () {
                return !(
                  !this.webcamConfig.resizeWidth ||
                  !this.webcamConfig.resizeHeight ||
                  (this.webcamVideoElement.width ===
                    this.webcamConfig.resizeWidth &&
                    this.webcamVideoElement.height ===
                      this.webcamConfig.resizeHeight)
                );
              }),
              (e.prototype.cropAndResizeFrame = function (t) {
                var e = this;
                return Object(i.Zc)(function () {
                  var n,
                    r = t.toFloat().expandDims(0),
                    a = (n = i.qb.cropAndResize(
                      r,
                      e.cropBox,
                      e.cropBoxInd,
                      e.cropSize,
                      "bilinear"
                    )).shape;
                  return n.reshape(a.slice(1));
                });
              }),
              (e.prototype.capture = function () {
                return s(this, void 0, void 0, function () {
                  return u(this, function (t) {
                    switch (t.label) {
                      case 0:
                        return [4, this.next()];
                      case 1:
                        return [2, t.sent().value];
                    }
                  });
                });
              }),
              (e.prototype.stop = function () {
                this.stream.getTracks().forEach(function (t) {
                  return t.stop();
                });
                try {
                  this.webcamVideoElement.srcObject = null;
                } catch (t) {
                  console.log(t), (this.webcamVideoElement.src = null);
                }
                this.isClosed = !0;
              }),
              (e.prototype.toArray = function () {
                throw new Error(
                  "Can not convert infinite video stream to array."
                );
              }),
              e
            );
          })(D),
          pt = function () {},
          ht = (function (t) {
            function e() {
              return (null !== t && t.apply(this, arguments)) || this;
            }
            return (
              o(e, t),
              (e.prototype.split = function (t) {
                return new ft(this, t);
              }),
              e
            );
          })(D),
          ft = (function (t) {
            function e(e, n) {
              var r = t.call(this) || this;
              return (r.upstream = e), (r.impl = new dt(e, n)), r;
            }
            return (
              o(e, t),
              (e.prototype.summary = function () {
                return this.impl.summary();
              }),
              (e.prototype.next = function () {
                return s(this, void 0, void 0, function () {
                  return u(this, function (t) {
                    return [2, this.impl.next()];
                  });
                });
              }),
              e
            );
          })(ht),
          dt = (function (t) {
            function e(e, n) {
              var r = t.call(this) || this;
              return (r.upstream = e), (r.separator = n), (r.carryover = ""), r;
            }
            return (
              o(e, t),
              (e.prototype.summary = function () {
                return (
                  this.upstream.summary() +
                  " -> Split('" +
                  this.separator +
                  "')"
                );
              }),
              (e.prototype.pump = function () {
                return s(this, void 0, void 0, function () {
                  var t, e, n, r, i;
                  return u(this, function (a) {
                    switch (a.label) {
                      case 0:
                        return [4, this.upstream.next()];
                      case 1:
                        if ((t = a.sent()).done)
                          return "" === this.carryover
                            ? [2, !1]
                            : (this.outputQueue.push(this.carryover),
                              (this.carryover = ""),
                              [2, !0]);
                        for (
                          (e = t.value.split(this.separator))[0] =
                            this.carryover + e[0],
                            n = 0,
                            r = e.slice(0, -1);
                          n < r.length;
                          n++
                        )
                          (i = r[n]), this.outputQueue.push(i);
                        return (this.carryover = e[e.length - 1]), [2, !0];
                    }
                  });
                });
              }),
              e
            );
          })(G),
          mt = (function (t) {
            function e() {
              return (null !== t && t.apply(this, arguments)) || this;
            }
            return (
              o(e, t),
              (e.prototype.decodeUTF8 = function () {
                return new vt(this);
              }),
              e
            );
          })(D),
          vt = (function (t) {
            function e(e) {
              var n = t.call(this) || this;
              return (n.upstream = e), (n.impl = new gt(e)), n;
            }
            return (
              o(e, t),
              (e.prototype.summary = function () {
                return this.impl.summary();
              }),
              (e.prototype.next = function () {
                return s(this, void 0, void 0, function () {
                  return u(this, function (t) {
                    return [2, this.impl.next()];
                  });
                });
              }),
              e
            );
          })(ht),
          gt = (function (t) {
            function e(e) {
              var r = t.call(this) || this;
              if (((r.upstream = e), Object(i.Y)().get("IS_BROWSER")))
                r.decoder = new TextDecoder("utf-8");
              else {
                var a = n(22).StringDecoder;
                r.decoder = new a("utf8");
              }
              return r;
            }
            return (
              o(e, t),
              (e.prototype.summary = function () {
                return this.upstream.summary() + " -> Utf8";
              }),
              (e.prototype.pump = function () {
                return s(this, void 0, void 0, function () {
                  var t, e, n;
                  return u(this, function (a) {
                    switch (a.label) {
                      case 0:
                        return [4, this.upstream.next()];
                      case 1:
                        return (t = a.sent()).done
                          ? [2, !1]
                          : ((e = t.value),
                            (n = Object(i.Y)().get("IS_BROWSER")
                              ? this.decoder.decode(e, { stream: !0 })
                              : this.decoder.write(r.from(e.buffer))),
                            this.outputQueue.push(n),
                            [2, !0]);
                    }
                  });
                });
              }),
              e
            );
          })(G),
          yt = (function (t) {
            function e(e, n) {
              void 0 === n && (n = {});
              var r = t.call(this) || this;
              return (
                (r.file = e),
                (r.options = n),
                i.gd.assert(
                  e instanceof Uint8Array ||
                    (!!Object(i.Y)().get("IS_BROWSER") &&
                      (e instanceof File || e instanceof Blob)),
                  function () {
                    return "FileChunkIterator only supports File, Blob and Uint8Array right now.";
                  }
                ),
                (r.offset = n.offset || 0),
                (r.chunkSize = n.chunkSize || 1048576),
                r
              );
            }
            return (
              o(e, t),
              (e.prototype.summary = function () {
                return "FileChunks " + this.file;
              }),
              (e.prototype.next = function () {
                return s(this, void 0, void 0, function () {
                  var t,
                    e,
                    n = this;
                  return u(this, function (r) {
                    switch (r.label) {
                      case 0:
                        return this.offset >=
                          (this.file instanceof Uint8Array
                            ? this.file.byteLength
                            : this.file.size)
                          ? [2, { value: null, done: !0 }]
                          : ((t = new Promise(function (t, e) {
                              var r = n.offset + n.chunkSize;
                              if (n.file instanceof Uint8Array)
                                t(new Uint8Array(n.file.slice(n.offset, r)));
                              else {
                                var i = new FileReader();
                                (i.onload = function (n) {
                                  var r = i.result;
                                  if (
                                    (r instanceof ArrayBuffer &&
                                      (r = new Uint8Array(r)),
                                    !(r instanceof Uint8Array))
                                  )
                                    return e(
                                      new TypeError(
                                        "FileReader returned unknown type."
                                      )
                                    );
                                  t(r);
                                }),
                                  (i.onabort = function (t) {
                                    return e(new Error("Aborted"));
                                  }),
                                  (i.onerror = function (t) {
                                    return e(new Error(t.type));
                                  });
                                var a = n.file.slice(n.offset, r);
                                i.readAsArrayBuffer(a);
                              }
                              n.offset = r;
                            })),
                            (e = {}),
                            [4, t]);
                      case 1:
                        return [2, ((e.value = r.sent()), (e.done = !1), e)];
                    }
                  });
                });
              }),
              e
            );
          })(mt);
        function bt(t, e) {
          return (
            void 0 === e && (e = {}),
            s(this, void 0, void 0, function () {
              var n, r, a, o, s;
              return u(this, function (u) {
                switch (u.label) {
                  case 0:
                    return (
                      "string" == typeof t
                        ? (n = t)
                        : ((n = t.url), (r = wt(t))),
                      [4, i.gd.fetch(n, r)]
                    );
                  case 1:
                    return (a = u.sent()).ok
                      ? ((s = Uint8Array.bind), [4, a.arrayBuffer()])
                      : [3, 3];
                  case 2:
                    return (
                      (o = new (s.apply(Uint8Array, [void 0, u.sent()]))()),
                      [2, new yt(o, e)]
                    );
                  case 3:
                    throw new Error(a.statusText);
                }
              });
            })
          );
        }
        var wt = function (t) {
          return {
            method: t.method,
            headers: t.headers,
            body: t.body,
            mode: t.mode,
            credentials: t.credentials,
            cache: t.cache,
            redirect: t.redirect,
            referrer: t.referrer,
            integrity: t.integrity,
          };
        };
        function xt(t) {
          return "string" == typeof t && "file://" === t.substr(0, 7);
        }
        var Ct = (function (t) {
            function e(e, n) {
              void 0 === n && (n = {});
              var r = t.call(this) || this;
              return (r.input = e), (r.options = n), r;
            }
            return (
              o(e, t),
              (e.prototype.iterator = function () {
                return s(this, void 0, void 0, function () {
                  var t;
                  return u(this, function (e) {
                    return (
                      xt(this.input) &&
                        Object(i.Y)().get("IS_NODE") &&
                        ((t = n(23)),
                        (this.input = t.readFileSync(this.input.substr(7)))),
                      [2, new yt(this.input, this.options)]
                    );
                  });
                });
              }),
              e
            );
          })(pt),
          Ot = (function (t) {
            function e(e, n) {
              void 0 === n && (n = {});
              var r = t.call(this) || this;
              return (r.url = e), (r.fileOptions = n), r;
            }
            return (
              o(e, t),
              (e.prototype.iterator = function () {
                return s(this, void 0, void 0, function () {
                  return u(this, function (t) {
                    return xt(this.url)
                      ? [2, new Ct(this.url, this.fileOptions).iterator()]
                      : [2, bt(this.url, this.fileOptions)];
                  });
                });
              }),
              e
            );
          })(pt);
        function Et(t, e) {
          return void 0 === e && (e = {}), new ut(new Ot(t), e);
        }
        function St(t) {
          var e = this,
            n = k(t);
          return J(function () {
            return s(e, void 0, void 0, function () {
              return u(this, function (t) {
                return [2, n];
              });
            });
          });
        }
        function Nt(t) {
          var e = this;
          return J(function () {
            return s(e, void 0, void 0, function () {
              var e;
              return u(this, function (n) {
                switch (n.label) {
                  case 0:
                    return [4, t()];
                  case 1:
                    return (
                      (e = n.sent()),
                      [
                        2,
                        k(function () {
                          return e.next();
                        }),
                      ]
                    );
                }
              });
            });
          });
        }
        function It(t, e) {
          return s(this, void 0, void 0, function () {
            return u(this, function (n) {
              return [2, lt.create(t, e)];
            });
          });
        }
        function kt(t) {
          return s(this, void 0, void 0, function () {
            return u(this, function (e) {
              return [2, ct.create(t)];
            });
          });
        }
        var _t = "1.7.0";
      }.call(this, n(2), n(7).Buffer);
  },
  function (t, e, n) {
    "use strict";
    function r(t) {
      var e = "";
      if (!t)
        try {
          t = n(20);
        } catch (t) {
          e = t.toString();
        }
      return {
        readFile: t
          ? function (e) {
              return new Promise(function (n, r) {
                t.readFile(e, function (t, e) {
                  return t ? r(t) : n(e);
                });
              });
            }
          : function () {
              throw new Error(
                "readFile - failed to require fs in nodejs environment with error: " +
                  e
              );
            },
      };
    }
    n.d(e, "a", function () {
      return r;
    });
  },
  function (t, e) {
    var n,
      r,
      i = (t.exports = {});
    function a() {
      throw new Error("setTimeout has not been defined");
    }
    function o() {
      throw new Error("clearTimeout has not been defined");
    }
    function s(t) {
      if (n === setTimeout) return setTimeout(t, 0);
      if ((n === a || !n) && setTimeout)
        return (n = setTimeout), setTimeout(t, 0);
      try {
        return n(t, 0);
      } catch (e) {
        try {
          return n.call(null, t, 0);
        } catch (e) {
          return n.call(this, t, 0);
        }
      }
    }
    !(function () {
      try {
        n = "function" == typeof setTimeout ? setTimeout : a;
      } catch (t) {
        n = a;
      }
      try {
        r = "function" == typeof clearTimeout ? clearTimeout : o;
      } catch (t) {
        r = o;
      }
    })();
    var u,
      c = [],
      l = !1,
      p = -1;
    function h() {
      l &&
        u &&
        ((l = !1), u.length ? (c = u.concat(c)) : (p = -1), c.length && f());
    }
    function f() {
      if (!l) {
        var t = s(h);
        l = !0;
        for (var e = c.length; e; ) {
          for (u = c, c = []; ++p < e; ) u && u[p].run();
          (p = -1), (e = c.length);
        }
        (u = null),
          (l = !1),
          (function (t) {
            if (r === clearTimeout) return clearTimeout(t);
            if ((r === o || !r) && clearTimeout)
              return (r = clearTimeout), clearTimeout(t);
            try {
              r(t);
            } catch (e) {
              try {
                return r.call(null, t);
              } catch (e) {
                return r.call(this, t);
              }
            }
          })(t);
      }
    }
    function d(t, e) {
      (this.fun = t), (this.array = e);
    }
    function m() {}
    (i.nextTick = function (t) {
      var e = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
      c.push(new d(t, e)), 1 !== c.length || l || s(f);
    }),
      (d.prototype.run = function () {
        this.fun.apply(null, this.array);
      }),
      (i.title = "browser"),
      (i.browser = !0),
      (i.env = {}),
      (i.argv = []),
      (i.version = ""),
      (i.versions = {}),
      (i.on = m),
      (i.addListener = m),
      (i.once = m),
      (i.off = m),
      (i.removeListener = m),
      (i.removeAllListeners = m),
      (i.emit = m),
      (i.prependListener = m),
      (i.prependOnceListener = m),
      (i.listeners = function (t) {
        return [];
      }),
      (i.binding = function (t) {
        throw new Error("process.binding is not supported");
      }),
      (i.cwd = function () {
        return "/";
      }),
      (i.chdir = function (t) {
        throw new Error("process.chdir is not supported");
      }),
      (i.umask = function () {
        return 0;
      });
  },
  function (t, e, n) {
    "use strict";
    (function (t) {
      /*!
       * The buffer module from node.js, for the browser.
       *
       * @author   Feross Aboukhadijeh <http://feross.org>
       * @license  MIT
       */
      var r = n(12),
        i = n(13),
        a = n(14);
      function o() {
        return u.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
      }
      function s(t, e) {
        if (o() < e) throw new RangeError("Invalid typed array length");
        return (
          u.TYPED_ARRAY_SUPPORT
            ? ((t = new Uint8Array(e)).__proto__ = u.prototype)
            : (null === t && (t = new u(e)), (t.length = e)),
          t
        );
      }
      function u(t, e, n) {
        if (!(u.TYPED_ARRAY_SUPPORT || this instanceof u))
          return new u(t, e, n);
        if ("number" == typeof t) {
          if ("string" == typeof e)
            throw new Error(
              "If encoding is specified then the first argument must be a string"
            );
          return p(this, t);
        }
        return c(this, t, e, n);
      }
      function c(t, e, n, r) {
        if ("number" == typeof e)
          throw new TypeError('"value" argument must not be a number');
        return "undefined" != typeof ArrayBuffer && e instanceof ArrayBuffer
          ? (function (t, e, n, r) {
              if ((e.byteLength, n < 0 || e.byteLength < n))
                throw new RangeError("'offset' is out of bounds");
              if (e.byteLength < n + (r || 0))
                throw new RangeError("'length' is out of bounds");
              e =
                void 0 === n && void 0 === r
                  ? new Uint8Array(e)
                  : void 0 === r
                  ? new Uint8Array(e, n)
                  : new Uint8Array(e, n, r);
              u.TYPED_ARRAY_SUPPORT
                ? ((t = e).__proto__ = u.prototype)
                : (t = h(t, e));
              return t;
            })(t, e, n, r)
          : "string" == typeof e
          ? (function (t, e, n) {
              ("string" == typeof n && "" !== n) || (n = "utf8");
              if (!u.isEncoding(n))
                throw new TypeError(
                  '"encoding" must be a valid string encoding'
                );
              var r = 0 | d(e, n),
                i = (t = s(t, r)).write(e, n);
              i !== r && (t = t.slice(0, i));
              return t;
            })(t, e, n)
          : (function (t, e) {
              if (u.isBuffer(e)) {
                var n = 0 | f(e.length);
                return 0 === (t = s(t, n)).length || e.copy(t, 0, 0, n), t;
              }
              if (e) {
                if (
                  ("undefined" != typeof ArrayBuffer &&
                    e.buffer instanceof ArrayBuffer) ||
                  "length" in e
                )
                  return "number" != typeof e.length || (r = e.length) != r
                    ? s(t, 0)
                    : h(t, e);
                if ("Buffer" === e.type && a(e.data)) return h(t, e.data);
              }
              var r;
              throw new TypeError(
                "First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object."
              );
            })(t, e);
      }
      function l(t) {
        if ("number" != typeof t)
          throw new TypeError('"size" argument must be a number');
        if (t < 0) throw new RangeError('"size" argument must not be negative');
      }
      function p(t, e) {
        if ((l(e), (t = s(t, e < 0 ? 0 : 0 | f(e))), !u.TYPED_ARRAY_SUPPORT))
          for (var n = 0; n < e; ++n) t[n] = 0;
        return t;
      }
      function h(t, e) {
        var n = e.length < 0 ? 0 : 0 | f(e.length);
        t = s(t, n);
        for (var r = 0; r < n; r += 1) t[r] = 255 & e[r];
        return t;
      }
      function f(t) {
        if (t >= o())
          throw new RangeError(
            "Attempt to allocate Buffer larger than maximum size: 0x" +
              o().toString(16) +
              " bytes"
          );
        return 0 | t;
      }
      function d(t, e) {
        if (u.isBuffer(t)) return t.length;
        if (
          "undefined" != typeof ArrayBuffer &&
          "function" == typeof ArrayBuffer.isView &&
          (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)
        )
          return t.byteLength;
        "string" != typeof t && (t = "" + t);
        var n = t.length;
        if (0 === n) return 0;
        for (var r = !1; ; )
          switch (e) {
            case "ascii":
            case "latin1":
            case "binary":
              return n;
            case "utf8":
            case "utf-8":
            case void 0:
              return B(t).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * n;
            case "hex":
              return n >>> 1;
            case "base64":
              return W(t).length;
            default:
              if (r) return B(t).length;
              (e = ("" + e).toLowerCase()), (r = !0);
          }
      }
      function m(t, e, n) {
        var r = !1;
        if (((void 0 === e || e < 0) && (e = 0), e > this.length)) return "";
        if (((void 0 === n || n > this.length) && (n = this.length), n <= 0))
          return "";
        if ((n >>>= 0) <= (e >>>= 0)) return "";
        for (t || (t = "utf8"); ; )
          switch (t) {
            case "hex":
              return _(this, e, n);
            case "utf8":
            case "utf-8":
              return N(this, e, n);
            case "ascii":
              return I(this, e, n);
            case "latin1":
            case "binary":
              return k(this, e, n);
            case "base64":
              return S(this, e, n);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return A(this, e, n);
            default:
              if (r) throw new TypeError("Unknown encoding: " + t);
              (t = (t + "").toLowerCase()), (r = !0);
          }
      }
      function v(t, e, n) {
        var r = t[e];
        (t[e] = t[n]), (t[n] = r);
      }
      function g(t, e, n, r, i) {
        if (0 === t.length) return -1;
        if (
          ("string" == typeof n
            ? ((r = n), (n = 0))
            : n > 2147483647
            ? (n = 2147483647)
            : n < -2147483648 && (n = -2147483648),
          (n = +n),
          isNaN(n) && (n = i ? 0 : t.length - 1),
          n < 0 && (n = t.length + n),
          n >= t.length)
        ) {
          if (i) return -1;
          n = t.length - 1;
        } else if (n < 0) {
          if (!i) return -1;
          n = 0;
        }
        if (("string" == typeof e && (e = u.from(e, r)), u.isBuffer(e)))
          return 0 === e.length ? -1 : y(t, e, n, r, i);
        if ("number" == typeof e)
          return (
            (e &= 255),
            u.TYPED_ARRAY_SUPPORT &&
            "function" == typeof Uint8Array.prototype.indexOf
              ? i
                ? Uint8Array.prototype.indexOf.call(t, e, n)
                : Uint8Array.prototype.lastIndexOf.call(t, e, n)
              : y(t, [e], n, r, i)
          );
        throw new TypeError("val must be string, number or Buffer");
      }
      function y(t, e, n, r, i) {
        var a,
          o = 1,
          s = t.length,
          u = e.length;
        if (
          void 0 !== r &&
          ("ucs2" === (r = String(r).toLowerCase()) ||
            "ucs-2" === r ||
            "utf16le" === r ||
            "utf-16le" === r)
        ) {
          if (t.length < 2 || e.length < 2) return -1;
          (o = 2), (s /= 2), (u /= 2), (n /= 2);
        }
        function c(t, e) {
          return 1 === o ? t[e] : t.readUInt16BE(e * o);
        }
        if (i) {
          var l = -1;
          for (a = n; a < s; a++)
            if (c(t, a) === c(e, -1 === l ? 0 : a - l)) {
              if ((-1 === l && (l = a), a - l + 1 === u)) return l * o;
            } else -1 !== l && (a -= a - l), (l = -1);
        } else
          for (n + u > s && (n = s - u), a = n; a >= 0; a--) {
            for (var p = !0, h = 0; h < u; h++)
              if (c(t, a + h) !== c(e, h)) {
                p = !1;
                break;
              }
            if (p) return a;
          }
        return -1;
      }
      function b(t, e, n, r) {
        n = Number(n) || 0;
        var i = t.length - n;
        r ? (r = Number(r)) > i && (r = i) : (r = i);
        var a = e.length;
        if (a % 2 != 0) throw new TypeError("Invalid hex string");
        r > a / 2 && (r = a / 2);
        for (var o = 0; o < r; ++o) {
          var s = parseInt(e.substr(2 * o, 2), 16);
          if (isNaN(s)) return o;
          t[n + o] = s;
        }
        return o;
      }
      function w(t, e, n, r) {
        return U(B(e, t.length - n), t, n, r);
      }
      function x(t, e, n, r) {
        return U(
          (function (t) {
            for (var e = [], n = 0; n < t.length; ++n)
              e.push(255 & t.charCodeAt(n));
            return e;
          })(e),
          t,
          n,
          r
        );
      }
      function C(t, e, n, r) {
        return x(t, e, n, r);
      }
      function O(t, e, n, r) {
        return U(W(e), t, n, r);
      }
      function E(t, e, n, r) {
        return U(
          (function (t, e) {
            for (
              var n, r, i, a = [], o = 0;
              o < t.length && !((e -= 2) < 0);
              ++o
            )
              (n = t.charCodeAt(o)),
                (r = n >> 8),
                (i = n % 256),
                a.push(i),
                a.push(r);
            return a;
          })(e, t.length - n),
          t,
          n,
          r
        );
      }
      function S(t, e, n) {
        return 0 === e && n === t.length
          ? r.fromByteArray(t)
          : r.fromByteArray(t.slice(e, n));
      }
      function N(t, e, n) {
        n = Math.min(t.length, n);
        for (var r = [], i = e; i < n; ) {
          var a,
            o,
            s,
            u,
            c = t[i],
            l = null,
            p = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1;
          if (i + p <= n)
            switch (p) {
              case 1:
                c < 128 && (l = c);
                break;
              case 2:
                128 == (192 & (a = t[i + 1])) &&
                  (u = ((31 & c) << 6) | (63 & a)) > 127 &&
                  (l = u);
                break;
              case 3:
                (a = t[i + 1]),
                  (o = t[i + 2]),
                  128 == (192 & a) &&
                    128 == (192 & o) &&
                    (u = ((15 & c) << 12) | ((63 & a) << 6) | (63 & o)) >
                      2047 &&
                    (u < 55296 || u > 57343) &&
                    (l = u);
                break;
              case 4:
                (a = t[i + 1]),
                  (o = t[i + 2]),
                  (s = t[i + 3]),
                  128 == (192 & a) &&
                    128 == (192 & o) &&
                    128 == (192 & s) &&
                    (u =
                      ((15 & c) << 18) |
                      ((63 & a) << 12) |
                      ((63 & o) << 6) |
                      (63 & s)) > 65535 &&
                    u < 1114112 &&
                    (l = u);
            }
          null === l
            ? ((l = 65533), (p = 1))
            : l > 65535 &&
              ((l -= 65536),
              r.push(((l >>> 10) & 1023) | 55296),
              (l = 56320 | (1023 & l))),
            r.push(l),
            (i += p);
        }
        return (function (t) {
          var e = t.length;
          if (e <= 4096) return String.fromCharCode.apply(String, t);
          var n = "",
            r = 0;
          for (; r < e; )
            n += String.fromCharCode.apply(String, t.slice(r, (r += 4096)));
          return n;
        })(r);
      }
      (e.Buffer = u),
        (e.SlowBuffer = function (t) {
          +t != t && (t = 0);
          return u.alloc(+t);
        }),
        (e.INSPECT_MAX_BYTES = 50),
        (u.TYPED_ARRAY_SUPPORT =
          void 0 !== t.TYPED_ARRAY_SUPPORT
            ? t.TYPED_ARRAY_SUPPORT
            : (function () {
                try {
                  var t = new Uint8Array(1);
                  return (
                    (t.__proto__ = {
                      __proto__: Uint8Array.prototype,
                      foo: function () {
                        return 42;
                      },
                    }),
                    42 === t.foo() &&
                      "function" == typeof t.subarray &&
                      0 === t.subarray(1, 1).byteLength
                  );
                } catch (t) {
                  return !1;
                }
              })()),
        (e.kMaxLength = o()),
        (u.poolSize = 8192),
        (u._augment = function (t) {
          return (t.__proto__ = u.prototype), t;
        }),
        (u.from = function (t, e, n) {
          return c(null, t, e, n);
        }),
        u.TYPED_ARRAY_SUPPORT &&
          ((u.prototype.__proto__ = Uint8Array.prototype),
          (u.__proto__ = Uint8Array),
          "undefined" != typeof Symbol &&
            Symbol.species &&
            u[Symbol.species] === u &&
            Object.defineProperty(u, Symbol.species, {
              value: null,
              configurable: !0,
            })),
        (u.alloc = function (t, e, n) {
          return (function (t, e, n, r) {
            return (
              l(e),
              e <= 0
                ? s(t, e)
                : void 0 !== n
                ? "string" == typeof r
                  ? s(t, e).fill(n, r)
                  : s(t, e).fill(n)
                : s(t, e)
            );
          })(null, t, e, n);
        }),
        (u.allocUnsafe = function (t) {
          return p(null, t);
        }),
        (u.allocUnsafeSlow = function (t) {
          return p(null, t);
        }),
        (u.isBuffer = function (t) {
          return !(null == t || !t._isBuffer);
        }),
        (u.compare = function (t, e) {
          if (!u.isBuffer(t) || !u.isBuffer(e))
            throw new TypeError("Arguments must be Buffers");
          if (t === e) return 0;
          for (
            var n = t.length, r = e.length, i = 0, a = Math.min(n, r);
            i < a;
            ++i
          )
            if (t[i] !== e[i]) {
              (n = t[i]), (r = e[i]);
              break;
            }
          return n < r ? -1 : r < n ? 1 : 0;
        }),
        (u.isEncoding = function (t) {
          switch (String(t).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return !0;
            default:
              return !1;
          }
        }),
        (u.concat = function (t, e) {
          if (!a(t))
            throw new TypeError('"list" argument must be an Array of Buffers');
          if (0 === t.length) return u.alloc(0);
          var n;
          if (void 0 === e)
            for (e = 0, n = 0; n < t.length; ++n) e += t[n].length;
          var r = u.allocUnsafe(e),
            i = 0;
          for (n = 0; n < t.length; ++n) {
            var o = t[n];
            if (!u.isBuffer(o))
              throw new TypeError(
                '"list" argument must be an Array of Buffers'
              );
            o.copy(r, i), (i += o.length);
          }
          return r;
        }),
        (u.byteLength = d),
        (u.prototype._isBuffer = !0),
        (u.prototype.swap16 = function () {
          var t = this.length;
          if (t % 2 != 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (var e = 0; e < t; e += 2) v(this, e, e + 1);
          return this;
        }),
        (u.prototype.swap32 = function () {
          var t = this.length;
          if (t % 4 != 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (var e = 0; e < t; e += 4)
            v(this, e, e + 3), v(this, e + 1, e + 2);
          return this;
        }),
        (u.prototype.swap64 = function () {
          var t = this.length;
          if (t % 8 != 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (var e = 0; e < t; e += 8)
            v(this, e, e + 7),
              v(this, e + 1, e + 6),
              v(this, e + 2, e + 5),
              v(this, e + 3, e + 4);
          return this;
        }),
        (u.prototype.toString = function () {
          var t = 0 | this.length;
          return 0 === t
            ? ""
            : 0 === arguments.length
            ? N(this, 0, t)
            : m.apply(this, arguments);
        }),
        (u.prototype.equals = function (t) {
          if (!u.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
          return this === t || 0 === u.compare(this, t);
        }),
        (u.prototype.inspect = function () {
          var t = "",
            n = e.INSPECT_MAX_BYTES;
          return (
            this.length > 0 &&
              ((t = this.toString("hex", 0, n).match(/.{2}/g).join(" ")),
              this.length > n && (t += " ... ")),
            "<Buffer " + t + ">"
          );
        }),
        (u.prototype.compare = function (t, e, n, r, i) {
          if (!u.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
          if (
            (void 0 === e && (e = 0),
            void 0 === n && (n = t ? t.length : 0),
            void 0 === r && (r = 0),
            void 0 === i && (i = this.length),
            e < 0 || n > t.length || r < 0 || i > this.length)
          )
            throw new RangeError("out of range index");
          if (r >= i && e >= n) return 0;
          if (r >= i) return -1;
          if (e >= n) return 1;
          if (this === t) return 0;
          for (
            var a = (i >>>= 0) - (r >>>= 0),
              o = (n >>>= 0) - (e >>>= 0),
              s = Math.min(a, o),
              c = this.slice(r, i),
              l = t.slice(e, n),
              p = 0;
            p < s;
            ++p
          )
            if (c[p] !== l[p]) {
              (a = c[p]), (o = l[p]);
              break;
            }
          return a < o ? -1 : o < a ? 1 : 0;
        }),
        (u.prototype.includes = function (t, e, n) {
          return -1 !== this.indexOf(t, e, n);
        }),
        (u.prototype.indexOf = function (t, e, n) {
          return g(this, t, e, n, !0);
        }),
        (u.prototype.lastIndexOf = function (t, e, n) {
          return g(this, t, e, n, !1);
        }),
        (u.prototype.write = function (t, e, n, r) {
          if (void 0 === e) (r = "utf8"), (n = this.length), (e = 0);
          else if (void 0 === n && "string" == typeof e)
            (r = e), (n = this.length), (e = 0);
          else {
            if (!isFinite(e))
              throw new Error(
                "Buffer.write(string, encoding, offset[, length]) is no longer supported"
              );
            (e |= 0),
              isFinite(n)
                ? ((n |= 0), void 0 === r && (r = "utf8"))
                : ((r = n), (n = void 0));
          }
          var i = this.length - e;
          if (
            ((void 0 === n || n > i) && (n = i),
            (t.length > 0 && (n < 0 || e < 0)) || e > this.length)
          )
            throw new RangeError("Attempt to write outside buffer bounds");
          r || (r = "utf8");
          for (var a = !1; ; )
            switch (r) {
              case "hex":
                return b(this, t, e, n);
              case "utf8":
              case "utf-8":
                return w(this, t, e, n);
              case "ascii":
                return x(this, t, e, n);
              case "latin1":
              case "binary":
                return C(this, t, e, n);
              case "base64":
                return O(this, t, e, n);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return E(this, t, e, n);
              default:
                if (a) throw new TypeError("Unknown encoding: " + r);
                (r = ("" + r).toLowerCase()), (a = !0);
            }
        }),
        (u.prototype.toJSON = function () {
          return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0),
          };
        });
      function I(t, e, n) {
        var r = "";
        n = Math.min(t.length, n);
        for (var i = e; i < n; ++i) r += String.fromCharCode(127 & t[i]);
        return r;
      }
      function k(t, e, n) {
        var r = "";
        n = Math.min(t.length, n);
        for (var i = e; i < n; ++i) r += String.fromCharCode(t[i]);
        return r;
      }
      function _(t, e, n) {
        var r = t.length;
        (!e || e < 0) && (e = 0), (!n || n < 0 || n > r) && (n = r);
        for (var i = "", a = e; a < n; ++a) i += L(t[a]);
        return i;
      }
      function A(t, e, n) {
        for (var r = t.slice(e, n), i = "", a = 0; a < r.length; a += 2)
          i += String.fromCharCode(r[a] + 256 * r[a + 1]);
        return i;
      }
      function T(t, e, n) {
        if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint");
        if (t + e > n)
          throw new RangeError("Trying to access beyond buffer length");
      }
      function R(t, e, n, r, i, a) {
        if (!u.isBuffer(t))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (e > i || e < a)
          throw new RangeError('"value" argument is out of bounds');
        if (n + r > t.length) throw new RangeError("Index out of range");
      }
      function D(t, e, n, r) {
        e < 0 && (e = 65535 + e + 1);
        for (var i = 0, a = Math.min(t.length - n, 2); i < a; ++i)
          t[n + i] =
            (e & (255 << (8 * (r ? i : 1 - i)))) >>> (8 * (r ? i : 1 - i));
      }
      function F(t, e, n, r) {
        e < 0 && (e = 4294967295 + e + 1);
        for (var i = 0, a = Math.min(t.length - n, 4); i < a; ++i)
          t[n + i] = (e >>> (8 * (r ? i : 3 - i))) & 255;
      }
      function M(t, e, n, r, i, a) {
        if (n + r > t.length) throw new RangeError("Index out of range");
        if (n < 0) throw new RangeError("Index out of range");
      }
      function j(t, e, n, r, a) {
        return a || M(t, 0, n, 4), i.write(t, e, n, r, 23, 4), n + 4;
      }
      function P(t, e, n, r, a) {
        return a || M(t, 0, n, 8), i.write(t, e, n, r, 52, 8), n + 8;
      }
      (u.prototype.slice = function (t, e) {
        var n,
          r = this.length;
        if (
          ((t = ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r),
          (e = void 0 === e ? r : ~~e) < 0
            ? (e += r) < 0 && (e = 0)
            : e > r && (e = r),
          e < t && (e = t),
          u.TYPED_ARRAY_SUPPORT)
        )
          (n = this.subarray(t, e)).__proto__ = u.prototype;
        else {
          var i = e - t;
          n = new u(i, void 0);
          for (var a = 0; a < i; ++a) n[a] = this[a + t];
        }
        return n;
      }),
        (u.prototype.readUIntLE = function (t, e, n) {
          (t |= 0), (e |= 0), n || T(t, e, this.length);
          for (var r = this[t], i = 1, a = 0; ++a < e && (i *= 256); )
            r += this[t + a] * i;
          return r;
        }),
        (u.prototype.readUIntBE = function (t, e, n) {
          (t |= 0), (e |= 0), n || T(t, e, this.length);
          for (var r = this[t + --e], i = 1; e > 0 && (i *= 256); )
            r += this[t + --e] * i;
          return r;
        }),
        (u.prototype.readUInt8 = function (t, e) {
          return e || T(t, 1, this.length), this[t];
        }),
        (u.prototype.readUInt16LE = function (t, e) {
          return e || T(t, 2, this.length), this[t] | (this[t + 1] << 8);
        }),
        (u.prototype.readUInt16BE = function (t, e) {
          return e || T(t, 2, this.length), (this[t] << 8) | this[t + 1];
        }),
        (u.prototype.readUInt32LE = function (t, e) {
          return (
            e || T(t, 4, this.length),
            (this[t] | (this[t + 1] << 8) | (this[t + 2] << 16)) +
              16777216 * this[t + 3]
          );
        }),
        (u.prototype.readUInt32BE = function (t, e) {
          return (
            e || T(t, 4, this.length),
            16777216 * this[t] +
              ((this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3])
          );
        }),
        (u.prototype.readIntLE = function (t, e, n) {
          (t |= 0), (e |= 0), n || T(t, e, this.length);
          for (var r = this[t], i = 1, a = 0; ++a < e && (i *= 256); )
            r += this[t + a] * i;
          return r >= (i *= 128) && (r -= Math.pow(2, 8 * e)), r;
        }),
        (u.prototype.readIntBE = function (t, e, n) {
          (t |= 0), (e |= 0), n || T(t, e, this.length);
          for (var r = e, i = 1, a = this[t + --r]; r > 0 && (i *= 256); )
            a += this[t + --r] * i;
          return a >= (i *= 128) && (a -= Math.pow(2, 8 * e)), a;
        }),
        (u.prototype.readInt8 = function (t, e) {
          return (
            e || T(t, 1, this.length),
            128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
          );
        }),
        (u.prototype.readInt16LE = function (t, e) {
          e || T(t, 2, this.length);
          var n = this[t] | (this[t + 1] << 8);
          return 32768 & n ? 4294901760 | n : n;
        }),
        (u.prototype.readInt16BE = function (t, e) {
          e || T(t, 2, this.length);
          var n = this[t + 1] | (this[t] << 8);
          return 32768 & n ? 4294901760 | n : n;
        }),
        (u.prototype.readInt32LE = function (t, e) {
          return (
            e || T(t, 4, this.length),
            this[t] |
              (this[t + 1] << 8) |
              (this[t + 2] << 16) |
              (this[t + 3] << 24)
          );
        }),
        (u.prototype.readInt32BE = function (t, e) {
          return (
            e || T(t, 4, this.length),
            (this[t] << 24) |
              (this[t + 1] << 16) |
              (this[t + 2] << 8) |
              this[t + 3]
          );
        }),
        (u.prototype.readFloatLE = function (t, e) {
          return e || T(t, 4, this.length), i.read(this, t, !0, 23, 4);
        }),
        (u.prototype.readFloatBE = function (t, e) {
          return e || T(t, 4, this.length), i.read(this, t, !1, 23, 4);
        }),
        (u.prototype.readDoubleLE = function (t, e) {
          return e || T(t, 8, this.length), i.read(this, t, !0, 52, 8);
        }),
        (u.prototype.readDoubleBE = function (t, e) {
          return e || T(t, 8, this.length), i.read(this, t, !1, 52, 8);
        }),
        (u.prototype.writeUIntLE = function (t, e, n, r) {
          ((t = +t), (e |= 0), (n |= 0), r) ||
            R(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
          var i = 1,
            a = 0;
          for (this[e] = 255 & t; ++a < n && (i *= 256); )
            this[e + a] = (t / i) & 255;
          return e + n;
        }),
        (u.prototype.writeUIntBE = function (t, e, n, r) {
          ((t = +t), (e |= 0), (n |= 0), r) ||
            R(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
          var i = n - 1,
            a = 1;
          for (this[e + i] = 255 & t; --i >= 0 && (a *= 256); )
            this[e + i] = (t / a) & 255;
          return e + n;
        }),
        (u.prototype.writeUInt8 = function (t, e, n) {
          return (
            (t = +t),
            (e |= 0),
            n || R(this, t, e, 1, 255, 0),
            u.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
            (this[e] = 255 & t),
            e + 1
          );
        }),
        (u.prototype.writeUInt16LE = function (t, e, n) {
          return (
            (t = +t),
            (e |= 0),
            n || R(this, t, e, 2, 65535, 0),
            u.TYPED_ARRAY_SUPPORT
              ? ((this[e] = 255 & t), (this[e + 1] = t >>> 8))
              : D(this, t, e, !0),
            e + 2
          );
        }),
        (u.prototype.writeUInt16BE = function (t, e, n) {
          return (
            (t = +t),
            (e |= 0),
            n || R(this, t, e, 2, 65535, 0),
            u.TYPED_ARRAY_SUPPORT
              ? ((this[e] = t >>> 8), (this[e + 1] = 255 & t))
              : D(this, t, e, !1),
            e + 2
          );
        }),
        (u.prototype.writeUInt32LE = function (t, e, n) {
          return (
            (t = +t),
            (e |= 0),
            n || R(this, t, e, 4, 4294967295, 0),
            u.TYPED_ARRAY_SUPPORT
              ? ((this[e + 3] = t >>> 24),
                (this[e + 2] = t >>> 16),
                (this[e + 1] = t >>> 8),
                (this[e] = 255 & t))
              : F(this, t, e, !0),
            e + 4
          );
        }),
        (u.prototype.writeUInt32BE = function (t, e, n) {
          return (
            (t = +t),
            (e |= 0),
            n || R(this, t, e, 4, 4294967295, 0),
            u.TYPED_ARRAY_SUPPORT
              ? ((this[e] = t >>> 24),
                (this[e + 1] = t >>> 16),
                (this[e + 2] = t >>> 8),
                (this[e + 3] = 255 & t))
              : F(this, t, e, !1),
            e + 4
          );
        }),
        (u.prototype.writeIntLE = function (t, e, n, r) {
          if (((t = +t), (e |= 0), !r)) {
            var i = Math.pow(2, 8 * n - 1);
            R(this, t, e, n, i - 1, -i);
          }
          var a = 0,
            o = 1,
            s = 0;
          for (this[e] = 255 & t; ++a < n && (o *= 256); )
            t < 0 && 0 === s && 0 !== this[e + a - 1] && (s = 1),
              (this[e + a] = (((t / o) >> 0) - s) & 255);
          return e + n;
        }),
        (u.prototype.writeIntBE = function (t, e, n, r) {
          if (((t = +t), (e |= 0), !r)) {
            var i = Math.pow(2, 8 * n - 1);
            R(this, t, e, n, i - 1, -i);
          }
          var a = n - 1,
            o = 1,
            s = 0;
          for (this[e + a] = 255 & t; --a >= 0 && (o *= 256); )
            t < 0 && 0 === s && 0 !== this[e + a + 1] && (s = 1),
              (this[e + a] = (((t / o) >> 0) - s) & 255);
          return e + n;
        }),
        (u.prototype.writeInt8 = function (t, e, n) {
          return (
            (t = +t),
            (e |= 0),
            n || R(this, t, e, 1, 127, -128),
            u.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
            t < 0 && (t = 255 + t + 1),
            (this[e] = 255 & t),
            e + 1
          );
        }),
        (u.prototype.writeInt16LE = function (t, e, n) {
          return (
            (t = +t),
            (e |= 0),
            n || R(this, t, e, 2, 32767, -32768),
            u.TYPED_ARRAY_SUPPORT
              ? ((this[e] = 255 & t), (this[e + 1] = t >>> 8))
              : D(this, t, e, !0),
            e + 2
          );
        }),
        (u.prototype.writeInt16BE = function (t, e, n) {
          return (
            (t = +t),
            (e |= 0),
            n || R(this, t, e, 2, 32767, -32768),
            u.TYPED_ARRAY_SUPPORT
              ? ((this[e] = t >>> 8), (this[e + 1] = 255 & t))
              : D(this, t, e, !1),
            e + 2
          );
        }),
        (u.prototype.writeInt32LE = function (t, e, n) {
          return (
            (t = +t),
            (e |= 0),
            n || R(this, t, e, 4, 2147483647, -2147483648),
            u.TYPED_ARRAY_SUPPORT
              ? ((this[e] = 255 & t),
                (this[e + 1] = t >>> 8),
                (this[e + 2] = t >>> 16),
                (this[e + 3] = t >>> 24))
              : F(this, t, e, !0),
            e + 4
          );
        }),
        (u.prototype.writeInt32BE = function (t, e, n) {
          return (
            (t = +t),
            (e |= 0),
            n || R(this, t, e, 4, 2147483647, -2147483648),
            t < 0 && (t = 4294967295 + t + 1),
            u.TYPED_ARRAY_SUPPORT
              ? ((this[e] = t >>> 24),
                (this[e + 1] = t >>> 16),
                (this[e + 2] = t >>> 8),
                (this[e + 3] = 255 & t))
              : F(this, t, e, !1),
            e + 4
          );
        }),
        (u.prototype.writeFloatLE = function (t, e, n) {
          return j(this, t, e, !0, n);
        }),
        (u.prototype.writeFloatBE = function (t, e, n) {
          return j(this, t, e, !1, n);
        }),
        (u.prototype.writeDoubleLE = function (t, e, n) {
          return P(this, t, e, !0, n);
        }),
        (u.prototype.writeDoubleBE = function (t, e, n) {
          return P(this, t, e, !1, n);
        }),
        (u.prototype.copy = function (t, e, n, r) {
          if (
            (n || (n = 0),
            r || 0 === r || (r = this.length),
            e >= t.length && (e = t.length),
            e || (e = 0),
            r > 0 && r < n && (r = n),
            r === n)
          )
            return 0;
          if (0 === t.length || 0 === this.length) return 0;
          if (e < 0) throw new RangeError("targetStart out of bounds");
          if (n < 0 || n >= this.length)
            throw new RangeError("sourceStart out of bounds");
          if (r < 0) throw new RangeError("sourceEnd out of bounds");
          r > this.length && (r = this.length),
            t.length - e < r - n && (r = t.length - e + n);
          var i,
            a = r - n;
          if (this === t && n < e && e < r)
            for (i = a - 1; i >= 0; --i) t[i + e] = this[i + n];
          else if (a < 1e3 || !u.TYPED_ARRAY_SUPPORT)
            for (i = 0; i < a; ++i) t[i + e] = this[i + n];
          else Uint8Array.prototype.set.call(t, this.subarray(n, n + a), e);
          return a;
        }),
        (u.prototype.fill = function (t, e, n, r) {
          if ("string" == typeof t) {
            if (
              ("string" == typeof e
                ? ((r = e), (e = 0), (n = this.length))
                : "string" == typeof n && ((r = n), (n = this.length)),
              1 === t.length)
            ) {
              var i = t.charCodeAt(0);
              i < 256 && (t = i);
            }
            if (void 0 !== r && "string" != typeof r)
              throw new TypeError("encoding must be a string");
            if ("string" == typeof r && !u.isEncoding(r))
              throw new TypeError("Unknown encoding: " + r);
          } else "number" == typeof t && (t &= 255);
          if (e < 0 || this.length < e || this.length < n)
            throw new RangeError("Out of range index");
          if (n <= e) return this;
          var a;
          if (
            ((e >>>= 0),
            (n = void 0 === n ? this.length : n >>> 0),
            t || (t = 0),
            "number" == typeof t)
          )
            for (a = e; a < n; ++a) this[a] = t;
          else {
            var o = u.isBuffer(t) ? t : B(new u(t, r).toString()),
              s = o.length;
            for (a = 0; a < n - e; ++a) this[a + e] = o[a % s];
          }
          return this;
        });
      var z = /[^+\/0-9A-Za-z-_]/g;
      function L(t) {
        return t < 16 ? "0" + t.toString(16) : t.toString(16);
      }
      function B(t, e) {
        var n;
        e = e || 1 / 0;
        for (var r = t.length, i = null, a = [], o = 0; o < r; ++o) {
          if ((n = t.charCodeAt(o)) > 55295 && n < 57344) {
            if (!i) {
              if (n > 56319) {
                (e -= 3) > -1 && a.push(239, 191, 189);
                continue;
              }
              if (o + 1 === r) {
                (e -= 3) > -1 && a.push(239, 191, 189);
                continue;
              }
              i = n;
              continue;
            }
            if (n < 56320) {
              (e -= 3) > -1 && a.push(239, 191, 189), (i = n);
              continue;
            }
            n = 65536 + (((i - 55296) << 10) | (n - 56320));
          } else i && (e -= 3) > -1 && a.push(239, 191, 189);
          if (((i = null), n < 128)) {
            if ((e -= 1) < 0) break;
            a.push(n);
          } else if (n < 2048) {
            if ((e -= 2) < 0) break;
            a.push((n >> 6) | 192, (63 & n) | 128);
          } else if (n < 65536) {
            if ((e -= 3) < 0) break;
            a.push((n >> 12) | 224, ((n >> 6) & 63) | 128, (63 & n) | 128);
          } else {
            if (!(n < 1114112)) throw new Error("Invalid code point");
            if ((e -= 4) < 0) break;
            a.push(
              (n >> 18) | 240,
              ((n >> 12) & 63) | 128,
              ((n >> 6) & 63) | 128,
              (63 & n) | 128
            );
          }
        }
        return a;
      }
      function W(t) {
        return r.toByteArray(
          (function (t) {
            if (
              (t = (function (t) {
                return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "");
              })(t).replace(z, "")).length < 2
            )
              return "";
            for (; t.length % 4 != 0; ) t += "=";
            return t;
          })(t)
        );
      }
      function U(t, e, n, r) {
        for (var i = 0; i < r && !(i + n >= e.length || i >= t.length); ++i)
          e[i + n] = t[i];
        return i;
      }
    }.call(this, n(2)));
  },
  function (t, e, n) {
    "use strict";
    (function (t) {
      n.d(e, "a", function () {
        return a;
      });
      var r = n(1),
        i = n(5);
      function a() {
        var e = t.Canvas || t.HTMLCanvasElement,
          n = t.Image || t.HTMLImageElement,
          a =
            t.fetch ||
            function () {
              throw new Error(
                "fetch - missing fetch implementation for nodejs environment"
              );
            },
          o = Object(i.a)();
        return Object(r.a)(
          {
            Canvas: e || function () {},
            CanvasRenderingContext2D:
              t.CanvasRenderingContext2D || function () {},
            Image: n || function () {},
            ImageData: t.ImageData || function () {},
            Video: t.HTMLVideoElement || function () {},
            createCanvasElement: function () {
              if (e) return new e();
              throw new Error(
                "createCanvasElement - missing Canvas implementation for nodejs environment"
              );
            },
            createImageElement: function () {
              if (n) return new n();
              throw new Error(
                "createImageElement - missing Image implementation for nodejs environment"
              );
            },
            fetch: a,
          },
          o
        );
      }
    }.call(this, n(2)));
  },
  function (t, e, n) {
    "use strict";
    (function (r, i) {
      function a() {
        return (
          "object" == typeof r && void 0 !== t && void 0 !== i && !!i.version
        );
      }
      n.d(e, "a", function () {
        return a;
      });
    }.call(this, n(2), n(6)));
  },
  function (t, e, n) {
    const r = n(11);
    (e.parseFont = r),
      (e.createCanvas = function (t, e) {
        return Object.assign(document.createElement("canvas"), {
          width: t,
          height: e,
        });
      }),
      (e.createImageData = function (t, e, n) {
        switch (arguments.length) {
          case 0:
            return new ImageData();
          case 1:
            return new ImageData(t);
          case 2:
            return new ImageData(t, e);
          default:
            return new ImageData(t, e, n);
        }
      }),
      (e.loadImage = function (t, e) {
        return new Promise(function (n, r) {
          const i = Object.assign(document.createElement("img"), e);
          function a() {
            (i.onload = null), (i.onerror = null);
          }
          (i.onload = function () {
            a(), n(i);
          }),
            (i.onerror = function () {
              a(), r(new Error('Failed to load the image "' + t + '"'));
            }),
            (i.src = t);
        });
      });
  },
  function (t, e, n) {
    "use strict";
    const r = "'([^']+)'|\"([^\"]+)\"|[\\w\\s-]+",
      i = new RegExp("(bold|bolder|lighter|[1-9]00) +", "i"),
      a = new RegExp("(italic|oblique) +", "i"),
      o = new RegExp("(small-caps) +", "i"),
      s = new RegExp(
        "(ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded) +",
        "i"
      ),
      u = new RegExp(
        "([\\d\\.]+)(px|pt|pc|in|cm|mm|%|em|ex|ch|rem|q) *((?:" +
          r +
          ")( *, *(?:" +
          r +
          "))*)"
      ),
      c = {};
    t.exports = function (t) {
      if (c[t]) return c[t];
      const e = u.exec(t);
      if (!e) return;
      const n = {
        weight: "normal",
        style: "normal",
        stretch: "normal",
        variant: "normal",
        size: parseFloat(e[1]),
        unit: e[2],
        family: e[3].replace(/["']/g, "").replace(/ *, */g, ","),
      };
      let r,
        l,
        p,
        h,
        f = t.substring(0, e.index);
      switch (
        ((r = i.exec(f)) && (n.weight = r[1]),
        (l = a.exec(f)) && (n.style = l[1]),
        (p = o.exec(f)) && (n.variant = p[1]),
        (h = s.exec(f)) && (n.stretch = h[1]),
        n.unit)
      ) {
        case "pt":
          n.size /= 0.75;
          break;
        case "pc":
          n.size *= 16;
          break;
        case "in":
          n.size *= 96;
          break;
        case "cm":
          n.size *= 96 / 2.54;
          break;
        case "mm":
          n.size *= 96 / 25.4;
          break;
        case "%":
          break;
        case "em":
        case "rem":
          n.size *= 16 / 0.75;
          break;
        case "q":
          n.size *= 96 / 25.4 / 4;
      }
      return (c[t] = n);
    };
  },
  function (t, e, n) {
    "use strict";
    (e.byteLength = function (t) {
      var e = c(t),
        n = e[0],
        r = e[1];
      return (3 * (n + r)) / 4 - r;
    }),
      (e.toByteArray = function (t) {
        var e,
          n,
          r = c(t),
          o = r[0],
          s = r[1],
          u = new a(
            (function (t, e, n) {
              return (3 * (e + n)) / 4 - n;
            })(0, o, s)
          ),
          l = 0,
          p = s > 0 ? o - 4 : o;
        for (n = 0; n < p; n += 4)
          (e =
            (i[t.charCodeAt(n)] << 18) |
            (i[t.charCodeAt(n + 1)] << 12) |
            (i[t.charCodeAt(n + 2)] << 6) |
            i[t.charCodeAt(n + 3)]),
            (u[l++] = (e >> 16) & 255),
            (u[l++] = (e >> 8) & 255),
            (u[l++] = 255 & e);
        2 === s &&
          ((e = (i[t.charCodeAt(n)] << 2) | (i[t.charCodeAt(n + 1)] >> 4)),
          (u[l++] = 255 & e));
        1 === s &&
          ((e =
            (i[t.charCodeAt(n)] << 10) |
            (i[t.charCodeAt(n + 1)] << 4) |
            (i[t.charCodeAt(n + 2)] >> 2)),
          (u[l++] = (e >> 8) & 255),
          (u[l++] = 255 & e));
        return u;
      }),
      (e.fromByteArray = function (t) {
        for (
          var e, n = t.length, i = n % 3, a = [], o = 0, s = n - i;
          o < s;
          o += 16383
        )
          a.push(l(t, o, o + 16383 > s ? s : o + 16383));
        1 === i
          ? ((e = t[n - 1]), a.push(r[e >> 2] + r[(e << 4) & 63] + "=="))
          : 2 === i &&
            ((e = (t[n - 2] << 8) + t[n - 1]),
            a.push(r[e >> 10] + r[(e >> 4) & 63] + r[(e << 2) & 63] + "="));
        return a.join("");
      });
    for (
      var r = [],
        i = [],
        a = "undefined" != typeof Uint8Array ? Uint8Array : Array,
        o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        s = 0,
        u = o.length;
      s < u;
      ++s
    )
      (r[s] = o[s]), (i[o.charCodeAt(s)] = s);
    function c(t) {
      var e = t.length;
      if (e % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var n = t.indexOf("=");
      return -1 === n && (n = e), [n, n === e ? 0 : 4 - (n % 4)];
    }
    function l(t, e, n) {
      for (var i, a, o = [], s = e; s < n; s += 3)
        (i =
          ((t[s] << 16) & 16711680) +
          ((t[s + 1] << 8) & 65280) +
          (255 & t[s + 2])),
          o.push(
            r[((a = i) >> 18) & 63] +
              r[(a >> 12) & 63] +
              r[(a >> 6) & 63] +
              r[63 & a]
          );
      return o.join("");
    }
    (i["-".charCodeAt(0)] = 62), (i["_".charCodeAt(0)] = 63);
  },
  function (t, e) {
    (e.read = function (t, e, n, r, i) {
      var a,
        o,
        s = 8 * i - r - 1,
        u = (1 << s) - 1,
        c = u >> 1,
        l = -7,
        p = n ? i - 1 : 0,
        h = n ? -1 : 1,
        f = t[e + p];
      for (
        p += h, a = f & ((1 << -l) - 1), f >>= -l, l += s;
        l > 0;
        a = 256 * a + t[e + p], p += h, l -= 8
      );
      for (
        o = a & ((1 << -l) - 1), a >>= -l, l += r;
        l > 0;
        o = 256 * o + t[e + p], p += h, l -= 8
      );
      if (0 === a) a = 1 - c;
      else {
        if (a === u) return o ? NaN : (1 / 0) * (f ? -1 : 1);
        (o += Math.pow(2, r)), (a -= c);
      }
      return (f ? -1 : 1) * o * Math.pow(2, a - r);
    }),
      (e.write = function (t, e, n, r, i, a) {
        var o,
          s,
          u,
          c = 8 * a - i - 1,
          l = (1 << c) - 1,
          p = l >> 1,
          h = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
          f = r ? 0 : a - 1,
          d = r ? 1 : -1,
          m = e < 0 || (0 === e && 1 / e < 0) ? 1 : 0;
        for (
          e = Math.abs(e),
            isNaN(e) || e === 1 / 0
              ? ((s = isNaN(e) ? 1 : 0), (o = l))
              : ((o = Math.floor(Math.log(e) / Math.LN2)),
                e * (u = Math.pow(2, -o)) < 1 && (o--, (u *= 2)),
                (e += o + p >= 1 ? h / u : h * Math.pow(2, 1 - p)) * u >= 2 &&
                  (o++, (u /= 2)),
                o + p >= l
                  ? ((s = 0), (o = l))
                  : o + p >= 1
                  ? ((s = (e * u - 1) * Math.pow(2, i)), (o += p))
                  : ((s = e * Math.pow(2, p - 1) * Math.pow(2, i)), (o = 0)));
          i >= 8;
          t[n + f] = 255 & s, f += d, s /= 256, i -= 8
        );
        for (
          o = (o << i) | s, c += i;
          c > 0;
          t[n + f] = 255 & o, f += d, o /= 256, c -= 8
        );
        t[n + f - d] |= 128 * m;
      });
  },
  function (t, e) {
    var n = {}.toString;
    t.exports =
      Array.isArray ||
      function (t) {
        return "[object Array]" == n.call(t);
      };
  },
  function (t, e, n) {
    (function (t) {
      var r =
          (void 0 !== t && t) || ("undefined" != typeof self && self) || window,
        i = Function.prototype.apply;
      function a(t, e) {
        (this._id = t), (this._clearFn = e);
      }
      (e.setTimeout = function () {
        return new a(i.call(setTimeout, r, arguments), clearTimeout);
      }),
        (e.setInterval = function () {
          return new a(i.call(setInterval, r, arguments), clearInterval);
        }),
        (e.clearTimeout = e.clearInterval = function (t) {
          t && t.close();
        }),
        (a.prototype.unref = a.prototype.ref = function () {}),
        (a.prototype.close = function () {
          this._clearFn.call(r, this._id);
        }),
        (e.enroll = function (t, e) {
          clearTimeout(t._idleTimeoutId), (t._idleTimeout = e);
        }),
        (e.unenroll = function (t) {
          clearTimeout(t._idleTimeoutId), (t._idleTimeout = -1);
        }),
        (e._unrefActive = e.active = function (t) {
          clearTimeout(t._idleTimeoutId);
          var e = t._idleTimeout;
          e >= 0 &&
            (t._idleTimeoutId = setTimeout(function () {
              t._onTimeout && t._onTimeout();
            }, e));
        }),
        n(16),
        (e.setImmediate =
          ("undefined" != typeof self && self.setImmediate) ||
          (void 0 !== t && t.setImmediate) ||
          (this && this.setImmediate)),
        (e.clearImmediate =
          ("undefined" != typeof self && self.clearImmediate) ||
          (void 0 !== t && t.clearImmediate) ||
          (this && this.clearImmediate));
    }.call(this, n(2)));
  },
  function (t, e, n) {
    (function (t, e) {
      !(function (t, n) {
        "use strict";
        if (!t.setImmediate) {
          var r,
            i,
            a,
            o,
            s,
            u = 1,
            c = {},
            l = !1,
            p = t.document,
            h = Object.getPrototypeOf && Object.getPrototypeOf(t);
          (h = h && h.setTimeout ? h : t),
            "[object process]" === {}.toString.call(t.process)
              ? (r = function (t) {
                  e.nextTick(function () {
                    d(t);
                  });
                })
              : !(function () {
                  if (t.postMessage && !t.importScripts) {
                    var e = !0,
                      n = t.onmessage;
                    return (
                      (t.onmessage = function () {
                        e = !1;
                      }),
                      t.postMessage("", "*"),
                      (t.onmessage = n),
                      e
                    );
                  }
                })()
              ? t.MessageChannel
                ? (((a = new MessageChannel()).port1.onmessage = function (t) {
                    d(t.data);
                  }),
                  (r = function (t) {
                    a.port2.postMessage(t);
                  }))
                : p && "onreadystatechange" in p.createElement("script")
                ? ((i = p.documentElement),
                  (r = function (t) {
                    var e = p.createElement("script");
                    (e.onreadystatechange = function () {
                      d(t),
                        (e.onreadystatechange = null),
                        i.removeChild(e),
                        (e = null);
                    }),
                      i.appendChild(e);
                  }))
                : (r = function (t) {
                    setTimeout(d, 0, t);
                  })
              : ((o = "setImmediate$" + Math.random() + "$"),
                (s = function (e) {
                  e.source === t &&
                    "string" == typeof e.data &&
                    0 === e.data.indexOf(o) &&
                    d(+e.data.slice(o.length));
                }),
                t.addEventListener
                  ? t.addEventListener("message", s, !1)
                  : t.attachEvent("onmessage", s),
                (r = function (e) {
                  t.postMessage(o + e, "*");
                })),
            (h.setImmediate = function (t) {
              "function" != typeof t && (t = new Function("" + t));
              for (
                var e = new Array(arguments.length - 1), n = 0;
                n < e.length;
                n++
              )
                e[n] = arguments[n + 1];
              var i = { callback: t, args: e };
              return (c[u] = i), r(u), u++;
            }),
            (h.clearImmediate = f);
        }
        function f(t) {
          delete c[t];
        }
        function d(t) {
          if (l) setTimeout(d, 0, t);
          else {
            var e = c[t];
            if (e) {
              l = !0;
              try {
                !(function (t) {
                  var e = t.callback,
                    n = t.args;
                  switch (n.length) {
                    case 0:
                      e();
                      break;
                    case 1:
                      e(n[0]);
                      break;
                    case 2:
                      e(n[0], n[1]);
                      break;
                    case 3:
                      e(n[0], n[1], n[2]);
                      break;
                    default:
                      e.apply(void 0, n);
                  }
                })(e);
              } finally {
                f(t), (l = !1);
              }
            }
          }
        }
      })("undefined" == typeof self ? (void 0 === t ? this : t) : self);
    }.call(this, n(2), n(6)));
  },
  function (t, e) {},
  function (t, e) {},
  function (t, e) {},
  function (t, e) {},
  function (t, e) {},
  function (t, e) {},
  function (t, e) {},
  function (t, e, n) {
    "use strict";
    n.r(e);
    var r = {};
    n.r(r),
      n.d(r, "drawContour", function () {
        return o;
      }),
      n.d(r, "drawDetections", function () {
        return Q;
      }),
      n.d(r, "drawFaceExpressions", function () {
        return zt;
      }),
      n.d(r, "DrawBoxOptions", function () {
        return J;
      }),
      n.d(r, "DrawBox", function () {
        return $;
      }),
      n.d(r, "DrawFaceLandmarksOptions", function () {
        return Wt;
      }),
      n.d(r, "DrawFaceLandmarks", function () {
        return Ut;
      }),
      n.d(r, "drawFaceLandmarks", function () {
        return Vt;
      }),
      n.d(r, "AnchorPosition", function () {
        return H;
      }),
      n.d(r, "DrawTextFieldOptions", function () {
        return X;
      }),
      n.d(r, "DrawTextField", function () {
        return Y;
      });
    var i = n(10),
      a = n(0);
    function o(t, e, n) {
      if (
        (void 0 === n && (n = !1),
        t.beginPath(),
        e.slice(1).forEach(function (n, r) {
          var i = n.x,
            a = n.y,
            o = e[r];
          t.moveTo(o.x, o.y), t.lineTo(i, a);
        }),
        n)
      ) {
        var r = e[e.length - 1],
          i = e[0];
        if (!r || !i) return;
        t.moveTo(r.x, r.y), t.lineTo(i.x, i.y);
      }
      t.stroke();
    }
    var s = n(1),
      u = (function () {
        function t(t, e) {
          if (!g(t) || !g(e))
            throw new Error(
              "Dimensions.constructor - expected width and height to be valid numbers, instead have " +
                JSON.stringify({ width: t, height: e })
            );
          (this._width = t), (this._height = e);
        }
        return (
          Object.defineProperty(t.prototype, "width", {
            get: function () {
              return this._width;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "height", {
            get: function () {
              return this._height;
            },
            enumerable: !0,
            configurable: !0,
          }),
          (t.prototype.reverse = function () {
            return new t(1 / this.width, 1 / this.height);
          }),
          t
        );
      })();
    function c(t, e) {
      return t instanceof a.b && t.shape.length === e;
    }
    function l(t) {
      return c(t, 3);
    }
    function p(t) {
      return c(t, 4);
    }
    function h(t) {
      return t % 2 == 0;
    }
    function f(t, e) {
      void 0 === e && (e = 2);
      var n = Math.pow(10, e);
      return Math.floor(t * n) / n;
    }
    function d(t) {
      return t && t.width && t.height;
    }
    function m(t) {
      return t
        .reduce(function (t, e) {
          return t.add(e);
        }, new b(0, 0))
        .div(new b(t.length, t.length));
    }
    function v(t, e, n) {
      return Array(t)
        .fill(0)
        .map(function (t, r) {
          return e + r * n;
        });
    }
    function g(t) {
      return (!!t && t !== 1 / 0 && t !== -1 / 0 && !isNaN(t)) || 0 === t;
    }
    function y(t) {
      return g(t) && 0 <= t && t <= 1;
    }
    var b = (function () {
        function t(t, e) {
          (this._x = t), (this._y = e);
        }
        return (
          Object.defineProperty(t.prototype, "x", {
            get: function () {
              return this._x;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "y", {
            get: function () {
              return this._y;
            },
            enumerable: !0,
            configurable: !0,
          }),
          (t.prototype.add = function (e) {
            return new t(this.x + e.x, this.y + e.y);
          }),
          (t.prototype.sub = function (e) {
            return new t(this.x - e.x, this.y - e.y);
          }),
          (t.prototype.mul = function (e) {
            return new t(this.x * e.x, this.y * e.y);
          }),
          (t.prototype.div = function (e) {
            return new t(this.x / e.x, this.y / e.y);
          }),
          (t.prototype.abs = function () {
            return new t(Math.abs(this.x), Math.abs(this.y));
          }),
          (t.prototype.magnitude = function () {
            return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));
          }),
          (t.prototype.floor = function () {
            return new t(Math.floor(this.x), Math.floor(this.y));
          }),
          t
        );
      })(),
      w = (function () {
        function t(e, n) {
          void 0 === n && (n = !0);
          var r = e || {},
            i = [r.left, r.top, r.right, r.bottom].every(g),
            a = [r.x, r.y, r.width, r.height].every(g);
          if (!a && !i)
            throw new Error(
              "Box.constructor - expected box to be IBoundingBox | IRect, instead have " +
                JSON.stringify(r)
            );
          var o = a
              ? [r.x, r.y, r.width, r.height]
              : [r.left, r.top, r.right - r.left, r.bottom - r.top],
            s = o[0],
            u = o[1],
            c = o[2],
            l = o[3];
          t.assertIsValidBox(
            { x: s, y: u, width: c, height: l },
            "Box.constructor",
            n
          ),
            (this._x = s),
            (this._y = u),
            (this._width = c),
            (this._height = l);
        }
        return (
          (t.isRect = function (t) {
            return !!t && [t.x, t.y, t.width, t.height].every(g);
          }),
          (t.assertIsValidBox = function (e, n, r) {
            if ((void 0 === r && (r = !1), !t.isRect(e)))
              throw new Error(
                n +
                  " - invalid box: " +
                  JSON.stringify(e) +
                  ", expected object with properties x, y, width, height"
              );
            if (!r && (e.width < 0 || e.height < 0))
              throw new Error(
                n +
                  " - width (" +
                  e.width +
                  ") and height (" +
                  e.height +
                  ") must be positive numbers"
              );
          }),
          Object.defineProperty(t.prototype, "x", {
            get: function () {
              return this._x;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "y", {
            get: function () {
              return this._y;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "width", {
            get: function () {
              return this._width;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "height", {
            get: function () {
              return this._height;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "left", {
            get: function () {
              return this.x;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "top", {
            get: function () {
              return this.y;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "right", {
            get: function () {
              return this.x + this.width;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "bottom", {
            get: function () {
              return this.y + this.height;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "area", {
            get: function () {
              return this.width * this.height;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "topLeft", {
            get: function () {
              return new b(this.left, this.top);
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "topRight", {
            get: function () {
              return new b(this.right, this.top);
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "bottomLeft", {
            get: function () {
              return new b(this.left, this.bottom);
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "bottomRight", {
            get: function () {
              return new b(this.right, this.bottom);
            },
            enumerable: !0,
            configurable: !0,
          }),
          (t.prototype.round = function () {
            var e = [this.x, this.y, this.width, this.height].map(function (t) {
              return Math.round(t);
            });
            return new t({ x: e[0], y: e[1], width: e[2], height: e[3] });
          }),
          (t.prototype.floor = function () {
            var e = [this.x, this.y, this.width, this.height].map(function (t) {
              return Math.floor(t);
            });
            return new t({ x: e[0], y: e[1], width: e[2], height: e[3] });
          }),
          (t.prototype.toSquare = function () {
            var e = this.x,
              n = this.y,
              r = this.width,
              i = this.height,
              a = Math.abs(r - i);
            return (
              r < i && ((e -= a / 2), (r += a)),
              i < r && ((n -= a / 2), (i += a)),
              new t({ x: e, y: n, width: r, height: i })
            );
          }),
          (t.prototype.rescale = function (e) {
            var n = d(e) ? e.width : e,
              r = d(e) ? e.height : e;
            return new t({
              x: this.x * n,
              y: this.y * r,
              width: this.width * n,
              height: this.height * r,
            });
          }),
          (t.prototype.pad = function (e, n) {
            var r = [
              this.x - e / 2,
              this.y - n / 2,
              this.width + e,
              this.height + n,
            ];
            return new t({ x: r[0], y: r[1], width: r[2], height: r[3] });
          }),
          (t.prototype.clipAtImageBorders = function (e, n) {
            var r = this.x,
              i = this.y,
              a = this.right,
              o = this.bottom,
              s = Math.max(r, 0),
              u = Math.max(i, 0),
              c = a - s,
              l = o - u;
            return new t({
              x: s,
              y: u,
              width: Math.min(c, e - s),
              height: Math.min(l, n - u),
            }).floor();
          }),
          (t.prototype.shift = function (e, n) {
            var r = this.width,
              i = this.height;
            return new t({ x: this.x + e, y: this.y + n, width: r, height: i });
          }),
          (t.prototype.padAtBorders = function (t, e) {
            var n = this.width + 1,
              r = this.height + 1,
              i = n,
              a = r,
              o = this.left,
              s = this.top,
              u = this.right,
              c = this.bottom;
            return (
              u > e && ((i = -u + e + n), (u = e)),
              c > t && ((a = -c + t + r), (c = t)),
              o < 1 && ((a = 2 - o), (o = 1)),
              s < 1 && ((a = 2 - s), (s = 1)),
              {
                dy: 1,
                edy: a,
                dx: 1,
                edx: i,
                y: s,
                ey: c,
                x: o,
                ex: u,
                w: n,
                h: r,
              }
            );
          }),
          (t.prototype.calibrate = function (e) {
            return new t({
              left: this.left + e.left * this.width,
              top: this.top + e.top * this.height,
              right: this.right + e.right * this.width,
              bottom: this.bottom + e.bottom * this.height,
            })
              .toSquare()
              .round();
          }),
          t
        );
      })(),
      x = (function (t) {
        function e(e, n, r, i, a) {
          return (
            void 0 === a && (a = !1),
            t.call(this, { left: e, top: n, right: r, bottom: i }, a) || this
          );
        }
        return Object(s.c)(e, t), e;
      })(w),
      C = (function () {
        function t(t, e, n, r, i) {
          (this._imageDims = new u(i.width, i.height)),
            (this._score = t),
            (this._classScore = e),
            (this._className = n),
            (this._box = new w(r).rescale(this._imageDims));
        }
        return (
          Object.defineProperty(t.prototype, "score", {
            get: function () {
              return this._score;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "classScore", {
            get: function () {
              return this._classScore;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "className", {
            get: function () {
              return this._className;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "box", {
            get: function () {
              return this._box;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "imageDims", {
            get: function () {
              return this._imageDims;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "imageWidth", {
            get: function () {
              return this.imageDims.width;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "imageHeight", {
            get: function () {
              return this.imageDims.height;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "relativeBox", {
            get: function () {
              return new w(this._box).rescale(this.imageDims.reverse());
            },
            enumerable: !0,
            configurable: !0,
          }),
          (t.prototype.forSize = function (e, n) {
            return new t(
              this.score,
              this.classScore,
              this.className,
              this.relativeBox,
              { width: e, height: n }
            );
          }),
          t
        );
      })(),
      O = (function (t) {
        function e(e, n, r) {
          return t.call(this, e, e, "", n, r) || this;
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.forSize = function (n, r) {
            var i = t.prototype.forSize.call(this, n, r);
            return new e(i.score, i.relativeBox, i.imageDims);
          }),
          e
        );
      })(C);
    function E(t, e, n) {
      void 0 === n && (n = !0);
      var r =
        Math.max(0, Math.min(t.right, e.right) - Math.max(t.left, e.left)) *
        Math.max(0, Math.min(t.bottom, e.bottom) - Math.max(t.top, e.top));
      return n ? r / (t.area + e.area - r) : r / Math.min(t.area, e.area);
    }
    function S(t, e, n, r) {
      void 0 === r && (r = !0);
      for (
        var i = e
            .map(function (t, e) {
              return { score: t, boxIndex: e };
            })
            .sort(function (t, e) {
              return t.score - e.score;
            })
            .map(function (t) {
              return t.boxIndex;
            }),
          a = [],
          o = function () {
            var e = i.pop();
            a.push(e);
            for (var o = i, s = [], u = 0; u < o.length; u++) {
              var c = o[u],
                l = t[e],
                p = t[c];
              s.push(E(l, p, r));
            }
            i = i.filter(function (t, e) {
              return s[e] <= n;
            });
          };
        i.length > 0;

      )
        o();
      return a;
    }
    function N(t, e) {
      return a.Zc(function () {
        var n = e[0],
          r = e[1],
          i = e[2],
          o = a.gb(Object(s.e)(t.shape.slice(0, 3), [1]), n),
          u = a.gb(Object(s.e)(t.shape.slice(0, 3), [1]), r),
          c = a.gb(Object(s.e)(t.shape.slice(0, 3), [1]), i),
          l = a.E([o, u, c], 3);
        return a.Pc(t, l);
      });
    }
    function I(t) {
      return 1 / (1 + Math.exp(-t));
    }
    var k = (function (t) {
        function e(e, n, r, i, a) {
          return (
            void 0 === a && (a = !1),
            t.call(this, { x: e, y: n, width: r, height: i }, a) || this
          );
        }
        return Object(s.c)(e, t), e;
      })(w),
      _ = (function () {
        function t(t, e, n) {
          void 0 === n && (n = new b(0, 0));
          var r = e.width,
            i = e.height;
          (this._imgDims = new u(r, i)),
            (this._shift = n),
            (this._positions = t.map(function (t) {
              return t.mul(new b(r, i)).add(n);
            }));
        }
        return (
          Object.defineProperty(t.prototype, "shift", {
            get: function () {
              return new b(this._shift.x, this._shift.y);
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "imageWidth", {
            get: function () {
              return this._imgDims.width;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "imageHeight", {
            get: function () {
              return this._imgDims.height;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "positions", {
            get: function () {
              return this._positions;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "relativePositions", {
            get: function () {
              var t = this;
              return this._positions.map(function (e) {
                return e.sub(t._shift).div(new b(t.imageWidth, t.imageHeight));
              });
            },
            enumerable: !0,
            configurable: !0,
          }),
          (t.prototype.forSize = function (t, e) {
            return new this.constructor(this.relativePositions, {
              width: t,
              height: e,
            });
          }),
          (t.prototype.shiftBy = function (t, e) {
            return new this.constructor(
              this.relativePositions,
              this._imgDims,
              new b(t, e)
            );
          }),
          (t.prototype.shiftByPoint = function (t) {
            return this.shiftBy(t.x, t.y);
          }),
          (t.prototype.align = function (t, e) {
            if ((void 0 === e && (e = {}), t)) {
              var n = t instanceof O ? t.box.floor() : new w(t);
              return this.shiftBy(n.x, n.y).align(null, e);
            }
            var r = Object.assign(
                {},
                { useDlibAlignment: !1, minBoxPadding: 0.2 },
                e
              ),
              i = r.useDlibAlignment,
              a = r.minBoxPadding;
            return i ? this.alignDlib() : this.alignMinBbox(a);
          }),
          (t.prototype.alignDlib = function () {
            var t = this.getRefPointsForAlignment(),
              e = t[0],
              n = t[1],
              r = t[2],
              i = function (t) {
                return r.sub(t).magnitude();
              },
              a = (i(e) + i(n)) / 2,
              o = Math.floor(a / 0.45),
              s = m(t),
              u = Math.floor(Math.max(0, s.x - 0.5 * o)),
              c = Math.floor(Math.max(0, s.y - 0.43 * o));
            return new k(
              u,
              c,
              Math.min(o, this.imageWidth + u),
              Math.min(o, this.imageHeight + c)
            );
          }),
          (t.prototype.alignMinBbox = function (t) {
            var e,
              n,
              r,
              i,
              a,
              o,
              s,
              u =
                ((e = this.positions),
                (n = e.map(function (t) {
                  return t.x;
                })),
                (r = e.map(function (t) {
                  return t.y;
                })),
                (i = n.reduce(function (t, e) {
                  return e < t ? e : t;
                }, 1 / 0)),
                (a = r.reduce(function (t, e) {
                  return e < t ? e : t;
                }, 1 / 0)),
                (o = n.reduce(function (t, e) {
                  return t < e ? e : t;
                }, 0)),
                (s = r.reduce(function (t, e) {
                  return t < e ? e : t;
                }, 0)),
                new x(i, a, o, s));
            return u.pad(u.width * t, u.height * t);
          }),
          (t.prototype.getRefPointsForAlignment = function () {
            throw new Error(
              "getRefPointsForAlignment not implemented by base class"
            );
          }),
          t
        );
      })(),
      A = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.getRefPointsForAlignment = function () {
            var t = this.positions;
            return [t[0], t[1], m([t[3], t[4]])];
          }),
          e
        );
      })(_),
      T = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.getJawOutline = function () {
            return this.positions.slice(0, 17);
          }),
          (e.prototype.getLeftEyeBrow = function () {
            return this.positions.slice(17, 22);
          }),
          (e.prototype.getRightEyeBrow = function () {
            return this.positions.slice(22, 27);
          }),
          (e.prototype.getNose = function () {
            return this.positions.slice(27, 36);
          }),
          (e.prototype.getLeftEye = function () {
            return this.positions.slice(36, 42);
          }),
          (e.prototype.getRightEye = function () {
            return this.positions.slice(42, 48);
          }),
          (e.prototype.getMouth = function () {
            return this.positions.slice(48, 68);
          }),
          (e.prototype.getRefPointsForAlignment = function () {
            return [this.getLeftEye(), this.getRightEye(), this.getMouth()].map(
              m
            );
          }),
          e
        );
      })(_),
      R = (function () {
        function t(t, e) {
          (this._label = t), (this._distance = e);
        }
        return (
          Object.defineProperty(t.prototype, "label", {
            get: function () {
              return this._label;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "distance", {
            get: function () {
              return this._distance;
            },
            enumerable: !0,
            configurable: !0,
          }),
          (t.prototype.toString = function (t) {
            return (
              void 0 === t && (t = !0),
              this.label + (t ? " (" + f(this.distance) + ")" : "")
            );
          }),
          t
        );
      })(),
      D = (function (t) {
        function e(e, n) {
          var r = t.call(this, e) || this;
          return (r._label = n), r;
        }
        return (
          Object(s.c)(e, t),
          (e.assertIsValidLabeledBox = function (t, e) {
            if ((w.assertIsValidBox(t, e), !g(t.label)))
              throw new Error(
                e +
                  " - expected property label (" +
                  t.label +
                  ") to be a number"
              );
          }),
          Object.defineProperty(e.prototype, "label", {
            get: function () {
              return this._label;
            },
            enumerable: !0,
            configurable: !0,
          }),
          e
        );
      })(w),
      F = (function () {
        function t(t, e) {
          if ("string" != typeof t)
            throw new Error(
              "LabeledFaceDescriptors - constructor expected label to be a string"
            );
          if (
            !Array.isArray(e) ||
            e.some(function (t) {
              return !(t instanceof Float32Array);
            })
          )
            throw new Error(
              "LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array"
            );
          (this._label = t), (this._descriptors = e);
        }
        return (
          Object.defineProperty(t.prototype, "label", {
            get: function () {
              return this._label;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "descriptors", {
            get: function () {
              return this._descriptors;
            },
            enumerable: !0,
            configurable: !0,
          }),
          (t.prototype.toJSON = function () {
            return {
              label: this.label,
              descriptors: this.descriptors.map(function (t) {
                return Array.from(t);
              }),
            };
          }),
          (t.fromJSON = function (e) {
            var n = e.descriptors.map(function (t) {
              return new Float32Array(t);
            });
            return new t(e.label, n);
          }),
          t
        );
      })();
    !(function (t) {
      function e(e, n, r, i) {
        var a = t.call(this, e, n) || this;
        return (a._score = r), (a._classScore = i), a;
      }
      Object(s.c)(e, t),
        (e.assertIsValidPredictedBox = function (t, e) {
          if (
            (D.assertIsValidLabeledBox(t, e), !y(t.score) || !y(t.classScore))
          )
            throw new Error(
              e +
                " - expected properties score (" +
                t.score +
                ") and (" +
                t.classScore +
                ") to be a number between [0, 1]"
            );
        }),
        Object.defineProperty(e.prototype, "score", {
          get: function () {
            return this._score;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "classScore", {
          get: function () {
            return this._classScore;
          },
          enumerable: !0,
          configurable: !0,
        });
    })(D);
    function M(t) {
      return t.detection instanceof O;
    }
    function j(t, e) {
      var n = { detection: e };
      return Object.assign({}, t, n);
    }
    function P() {
      var t =
        window.fetch ||
        function () {
          throw new Error(
            "fetch - missing fetch implementation for browser environment"
          );
        };
      return {
        Canvas: HTMLCanvasElement,
        CanvasRenderingContext2D: CanvasRenderingContext2D,
        Image: HTMLImageElement,
        ImageData: ImageData,
        Video: HTMLVideoElement,
        createCanvasElement: function () {
          return document.createElement("canvas");
        },
        createImageElement: function () {
          return document.createElement("img");
        },
        fetch: t,
        readFile: function () {
          throw new Error(
            "readFile - filesystem not available for browser environment"
          );
        },
      };
    }
    var z = n(5),
      L = n(8);
    function B() {
      return (
        "object" == typeof window &&
        "undefined" != typeof document &&
        "undefined" != typeof HTMLImageElement &&
        "undefined" != typeof HTMLCanvasElement &&
        "undefined" != typeof HTMLVideoElement &&
        "undefined" != typeof ImageData &&
        "undefined" != typeof CanvasRenderingContext2D
      );
    }
    var W,
      U = n(9);
    function V(t) {
      W = t;
    }
    function G() {
      B() && V(P()), Object(U.a)() && V(Object(L.a)());
    }
    var H,
      q = {
        getEnv: function () {
          if (!W)
            throw new Error(
              "getEnv - environment is not defined, check isNodejs() and isBrowser()"
            );
          return W;
        },
        setEnv: V,
        initialize: G,
        createBrowserEnv: P,
        createFileSystem: z.a,
        createNodejsEnv: L.a,
        monkeyPatch: function (t) {
          if ((W || G(), !W))
            throw new Error(
              "monkeyPatch - environment is not defined, check isNodejs() and isBrowser()"
            );
          var e = t.Canvas,
            n = void 0 === e ? W.Canvas : e,
            r = t.Image,
            i = void 0 === r ? W.Image : r;
          (W.Canvas = n),
            (W.Image = i),
            (W.createCanvasElement =
              t.createCanvasElement ||
              function () {
                return new n();
              }),
            (W.createImageElement =
              t.createImageElement ||
              function () {
                return new i();
              }),
            (W.ImageData = t.ImageData || W.ImageData),
            (W.Video = t.Video || W.Video),
            (W.fetch = t.fetch || W.fetch),
            (W.readFile = t.readFile || W.readFile);
        },
        isBrowser: B,
        isNodejs: U.a,
      };
    function K(t) {
      return q.isNodejs() || "string" != typeof t
        ? t
        : document.getElementById(t);
    }
    function Z(t) {
      var e = q.getEnv(),
        n = e.Canvas;
      if (t instanceof e.CanvasRenderingContext2D) return t;
      var r = K(t);
      if (!(r instanceof n))
        throw new Error(
          "resolveContext2d - expected canvas to be of instance of Canvas"
        );
      var i = r.getContext("2d");
      if (!i) throw new Error("resolveContext2d - canvas 2d context is null");
      return i;
    }
    G(),
      (function (t) {
        (t.TOP_LEFT = "TOP_LEFT"),
          (t.TOP_RIGHT = "TOP_RIGHT"),
          (t.BOTTOM_LEFT = "BOTTOM_LEFT"),
          (t.BOTTOM_RIGHT = "BOTTOM_RIGHT");
      })(H || (H = {}));
    var X = function (t) {
        void 0 === t && (t = {});
        var e = t.anchorPosition,
          n = t.backgroundColor,
          r = t.fontColor,
          i = t.fontSize,
          a = t.fontStyle,
          o = t.padding;
        (this.anchorPosition = e || H.TOP_LEFT),
          (this.backgroundColor = n || "rgba(0, 0, 0, 0.5)"),
          (this.fontColor = r || "rgba(255, 255, 255, 1)"),
          (this.fontSize = i || 14),
          (this.fontStyle = a || "Georgia"),
          (this.padding = o || 4);
      },
      Y = (function () {
        function t(e, n, r) {
          void 0 === r && (r = {}),
            (this.text =
              "string" == typeof e ? [e] : e instanceof t ? e.text : e),
            (this.anchor = n),
            (this.options = new X(r));
        }
        return (
          (t.prototype.measureWidth = function (t) {
            var e = this.options.padding;
            return (
              this.text
                .map(function (e) {
                  return t.measureText(e).width;
                })
                .reduce(function (t, e) {
                  return t < e ? e : t;
                }, 0) +
              2 * e
            );
          }),
          (t.prototype.measureHeight = function () {
            var t = this.options,
              e = t.fontSize,
              n = t.padding;
            return this.text.length * e + 2 * n;
          }),
          (t.prototype.getUpperLeft = function (t, e) {
            var n = this.options.anchorPosition,
              r = n === H.BOTTOM_RIGHT || n === H.TOP_RIGHT,
              i = n === H.BOTTOM_LEFT || n === H.BOTTOM_RIGHT,
              a = this.measureWidth(t),
              o = this.measureHeight(),
              s = r ? this.anchor.x - a : this.anchor.x,
              u = i ? this.anchor.y - o : this.anchor.y;
            if (e) {
              var c = e.width,
                l = e.height;
              return {
                x: Math.max(Math.min(s, c - a), 0),
                y: Math.max(Math.min(u, l - o), 0),
              };
            }
            return { x: s, y: u };
          }),
          (t.prototype.draw = function (t) {
            var e = K(t),
              n = Z(e),
              r = this.options,
              i = r.backgroundColor,
              a = r.fontColor,
              o = r.fontSize,
              s = r.fontStyle,
              u = r.padding;
            n.font = o + "px " + s;
            var c = this.measureWidth(n),
              l = this.measureHeight();
            n.fillStyle = i;
            var p = this.getUpperLeft(n, e);
            n.fillRect(p.x, p.y, c, l),
              (n.fillStyle = a),
              this.text.forEach(function (t, e) {
                var r = u + p.x,
                  i = u + p.y + (e + 1) * o;
                n.fillText(t, r, i);
              });
          }),
          t
        );
      })(),
      J = function (t) {
        void 0 === t && (t = {});
        var e = t.boxColor,
          n = t.lineWidth,
          r = t.label,
          i = t.drawLabelOptions;
        (this.boxColor = e || "rgba(0, 0, 255, 1)"),
          (this.lineWidth = n || 2),
          (this.label = r);
        var a = {
          anchorPosition: H.BOTTOM_LEFT,
          backgroundColor: this.boxColor,
        };
        this.drawLabelOptions = new X(Object.assign({}, a, i));
      },
      $ = (function () {
        function t(t, e) {
          void 0 === e && (e = {}),
            (this.box = new w(t)),
            (this.options = new J(e));
        }
        return (
          (t.prototype.draw = function (t) {
            var e = Z(t),
              n = this.options,
              r = n.boxColor,
              i = n.lineWidth,
              a = this.box,
              o = a.x,
              s = a.y,
              u = a.width,
              c = a.height;
            (e.strokeStyle = r), (e.lineWidth = i), e.strokeRect(o, s, u, c);
            var l = this.options.label;
            l &&
              new Y(
                [l],
                { x: o - i / 2, y: s },
                this.options.drawLabelOptions
              ).draw(t);
          }),
          t
        );
      })();
    function Q(t, e) {
      (Array.isArray(e) ? e : [e]).forEach(function (e) {
        var n = e instanceof O ? e.score : M(e) ? e.detection.score : void 0,
          r = e instanceof O ? e.box : M(e) ? e.detection.box : new w(e),
          i = n ? "" + f(n) : void 0;
        new $(r, { label: i }).draw(t);
      });
    }
    function tt(t) {
      var e = q.getEnv(),
        n = e.Image,
        r = e.Video;
      return (
        (t instanceof n && t.complete) || (t instanceof r && t.readyState >= 3)
      );
    }
    function et(t) {
      var e = q.getEnv(),
        n = e.Image,
        r = e.Video;
      return t instanceof n
        ? new u(t.naturalWidth, t.naturalHeight)
        : t instanceof r
        ? new u(t.videoWidth, t.videoHeight)
        : new u(t.width, t.height);
    }
    function nt(t) {
      var e = t.width,
        n = t.height,
        r = (0, q.getEnv().createCanvasElement)();
      return (r.width = e), (r.height = n), r;
    }
    function rt(t, e) {
      var n = q.getEnv().ImageData;
      if (!(t instanceof n || tt(t)))
        throw new Error(
          "createCanvasFromMedia - media has not finished loading yet"
        );
      var r = e || et(t),
        i = r.width,
        a = r.height,
        o = nt({ width: i, height: a });
      return (
        t instanceof n
          ? Z(o).putImageData(t, 0, 0)
          : Z(o).drawImage(t, 0, 0, i, a),
        o
      );
    }
    function it(t, e) {
      return Object(s.b)(this, void 0, void 0, function () {
        var n, r, i, o, u, c;
        return Object(s.d)(this, function (s) {
          switch (s.label) {
            case 0:
              return (
                (n = e || q.getEnv().createCanvasElement()),
                (r = t.shape.slice(p(t) ? 1 : 0)),
                (i = r[0]),
                (o = r[1]),
                (u = r[2]),
                (c = a.Zc(function () {
                  return t.as3D(i, o, u).toInt();
                })),
                [4, a.z.toPixels(c, n)]
              );
            case 1:
              return s.sent(), c.dispose(), [2, n];
          }
        });
      });
    }
    function at(t) {
      var e = q.getEnv(),
        n = e.Image,
        r = e.Canvas,
        i = e.Video;
      return t instanceof n || t instanceof r || t instanceof i;
    }
    var ot = (function () {
      function t(t, e) {
        var n = this;
        if (
          (void 0 === e && (e = !1),
          (this._imageTensors = []),
          (this._canvases = []),
          (this._treatAsBatchInput = !1),
          (this._inputDimensions = []),
          !Array.isArray(t))
        )
          throw new Error(
            "NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have " +
              t
          );
        (this._treatAsBatchInput = e),
          (this._batchSize = t.length),
          t.forEach(function (t, e) {
            if (l(t))
              return (
                (n._imageTensors[e] = t), void (n._inputDimensions[e] = t.shape)
              );
            if (p(t)) {
              var r = t.shape[0];
              if (1 !== r)
                throw new Error(
                  "NetInput - tf.Tensor4D with batchSize " +
                    r +
                    " passed, but not supported in input array"
                );
              return (
                (n._imageTensors[e] = t),
                void (n._inputDimensions[e] = t.shape.slice(1))
              );
            }
            var i = t instanceof q.getEnv().Canvas ? t : rt(t);
            (n._canvases[e] = i),
              (n._inputDimensions[e] = [i.height, i.width, 3]);
          });
      }
      return (
        Object.defineProperty(t.prototype, "imageTensors", {
          get: function () {
            return this._imageTensors;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "canvases", {
          get: function () {
            return this._canvases;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "isBatchInput", {
          get: function () {
            return this.batchSize > 1 || this._treatAsBatchInput;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "batchSize", {
          get: function () {
            return this._batchSize;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "inputDimensions", {
          get: function () {
            return this._inputDimensions;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "inputSize", {
          get: function () {
            return this._inputSize;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "reshapedInputDimensions", {
          get: function () {
            var t = this;
            return v(this.batchSize, 0, 1).map(function (e, n) {
              return t.getReshapedInputDimensions(n);
            });
          },
          enumerable: !0,
          configurable: !0,
        }),
        (t.prototype.getInput = function (t) {
          return this.canvases[t] || this.imageTensors[t];
        }),
        (t.prototype.getInputDimensions = function (t) {
          return this._inputDimensions[t];
        }),
        (t.prototype.getInputHeight = function (t) {
          return this._inputDimensions[t][0];
        }),
        (t.prototype.getInputWidth = function (t) {
          return this._inputDimensions[t][1];
        }),
        (t.prototype.getReshapedInputDimensions = function (t) {
          if ("number" != typeof this.inputSize)
            throw new Error(
              "getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet"
            );
          return (function (t, e) {
            var n = t.width,
              r = t.height,
              i = e / Math.max(r, n);
            return new u(Math.round(n * i), Math.round(r * i));
          })(
            { width: this.getInputWidth(t), height: this.getInputHeight(t) },
            this.inputSize
          );
        }),
        (t.prototype.toBatchTensor = function (t, e) {
          var n = this;
          return (
            void 0 === e && (e = !0),
            (this._inputSize = t),
            a.Zc(function () {
              var r = v(n.batchSize, 0, 1).map(function (r) {
                var i = n.getInput(r);
                if (i instanceof a.b) {
                  var o = p(i) ? i : i.expandDims();
                  return (
                    ((o = (function (t, e) {
                      return (
                        void 0 === e && (e = !1),
                        a.Zc(function () {
                          var n = t.shape.slice(1),
                            r = n[0],
                            i = n[1];
                          if (r === i) return t;
                          var o = Math.abs(r - i),
                            s = Math.round(o * (e ? 0.5 : 1)),
                            u = r > i ? 2 : 1,
                            c = function (e) {
                              var n = t.shape.slice();
                              return (n[u] = e), a.gb(n, 0);
                            },
                            l = c(s),
                            p = o - l.shape[u],
                            h = [e && p ? c(p) : null, t, l]
                              .filter(function (t) {
                                return !!t;
                              })
                              .map(function (t) {
                                return t.toFloat();
                              });
                          return a.E(h, u);
                        })
                      );
                    })(o, e)).shape[1] === t &&
                      o.shape[2] === t) ||
                      (o = a.qb.resizeBilinear(o, [t, t])),
                    o.as3D(t, t, 3)
                  );
                }
                if (i instanceof q.getEnv().Canvas)
                  return a.z.fromPixels(
                    (function (t, e, n) {
                      void 0 === n && (n = !1);
                      var r = q.getEnv(),
                        i = r.Image,
                        a = r.Canvas;
                      if (!(t instanceof i || t instanceof a))
                        throw new Error(
                          "imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement"
                        );
                      var o = et(t),
                        s = e / Math.max(o.height, o.width),
                        u = s * o.width,
                        c = s * o.height,
                        l = nt({ width: e, height: e }),
                        p = t instanceof a ? t : rt(t),
                        h = Math.abs(u - c) / 2,
                        f = n && u < c ? h : 0,
                        d = n && c < u ? h : 0;
                      return Z(l).drawImage(p, f, d, u, c), l;
                    })(i, t, e)
                  );
                throw new Error(
                  "toBatchTensor - at batchIdx " +
                    r +
                    ", expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have " +
                    i
                );
              });
              return a
                .Nc(
                  r.map(function (t) {
                    return t.toFloat();
                  })
                )
                .as4D(n.batchSize, t, t, 3);
            })
          );
        }),
        t
      );
    })();
    function st(t) {
      return Object(s.b)(this, void 0, void 0, function () {
        var e, n, r;
        return Object(s.d)(this, function (i) {
          switch (i.label) {
            case 0:
              if (t instanceof ot) return [2, t];
              if (!(e = Array.isArray(t) ? t : [t]).length)
                throw new Error("toNetInput - empty array passed as input");
              return (
                (n = function (e) {
                  return Array.isArray(t) ? " at input index " + e + ":" : "";
                }),
                (r = e.map(K)).forEach(function (t, r) {
                  if (!at(t) && !l(t) && !p(t)) {
                    if ("string" == typeof e[r])
                      throw new Error(
                        "toNetInput -" +
                          n(r) +
                          " string passed, but could not resolve HTMLElement for element id " +
                          e[r]
                      );
                    throw new Error(
                      "toNetInput -" +
                        n(r) +
                        " expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id"
                    );
                  }
                  if (p(t)) {
                    var i = t.shape[0];
                    if (1 !== i)
                      throw new Error(
                        "toNetInput -" +
                          n(r) +
                          " tf.Tensor4D with batchSize " +
                          i +
                          " passed, but not supported in input array"
                      );
                  }
                }),
                [
                  4,
                  Promise.all(
                    r.map(function (t) {
                      return (
                        at(t) &&
                        ((e = t),
                        new Promise(function (t, n) {
                          if (e instanceof q.getEnv().Canvas || tt(e))
                            return t();
                          function r(e) {
                            e.currentTarget &&
                              (e.currentTarget.removeEventListener("load", r),
                              e.currentTarget.removeEventListener("error", i),
                              t(e));
                          }
                          function i(t) {
                            t.currentTarget &&
                              (t.currentTarget.removeEventListener("load", r),
                              t.currentTarget.removeEventListener("error", i),
                              n(t));
                          }
                          e.addEventListener("load", r),
                            e.addEventListener("error", i);
                        }))
                      );
                      var e;
                    })
                  ),
                ]
              );
            case 1:
              return i.sent(), [2, new ot(r, Array.isArray(t))];
          }
        });
      });
    }
    function ut(t, e) {
      return Object(s.b)(this, void 0, void 0, function () {
        var n, r, i, a, o, u;
        return Object(s.d)(this, function (s) {
          switch (s.label) {
            case 0:
              return (
                (n = q.getEnv().Canvas),
                (r = t),
                t instanceof n ? [3, 5] : [4, st(t)]
              );
            case 1:
              if ((i = s.sent()).batchSize > 1)
                throw new Error("extractFaces - batchSize > 1 not supported");
              return (a = i.getInput(0)) instanceof n
                ? ((o = a), [3, 4])
                : [3, 2];
            case 2:
              return [4, it(a)];
            case 3:
              (o = s.sent()), (s.label = 4);
            case 4:
              (r = o), (s.label = 5);
            case 5:
              return (
                (u = Z(r)),
                [
                  2,
                  e
                    .map(function (t) {
                      return t instanceof O
                        ? t.forSize(r.width, r.height).box.floor()
                        : t;
                    })
                    .map(function (t) {
                      return t.clipAtImageBorders(r.width, r.height);
                    })
                    .map(function (t) {
                      var e = t.x,
                        n = t.y,
                        r = t.width,
                        i = t.height,
                        a = nt({ width: r, height: i });
                      return (
                        Z(a).putImageData(u.getImageData(e, n, r, i), 0, 0), a
                      );
                    }),
                ]
              );
          }
        });
      });
    }
    function ct(t, e) {
      return Object(s.b)(this, void 0, void 0, function () {
        return Object(s.d)(this, function (n) {
          if (!l(t) && !p(t))
            throw new Error(
              "extractFaceTensors - expected image tensor to be 3D or 4D"
            );
          if (p(t) && t.shape[0] > 1)
            throw new Error("extractFaceTensors - batchSize > 1 not supported");
          return [
            2,
            a.Zc(function () {
              var n = t.shape.slice(p(t) ? 1 : 0),
                r = n[0],
                i = n[1],
                o = n[2];
              return e
                .map(function (t) {
                  return t instanceof O ? t.forSize(i, r).box : t;
                })
                .map(function (t) {
                  return t.clipAtImageBorders(i, r);
                })
                .map(function (e) {
                  var n = e.x,
                    s = e.y,
                    u = e.width,
                    c = e.height;
                  return a.Cc(t.as3D(r, i, o), [s, n, 0], [c, u, o]);
                });
            }),
          ];
        });
      });
    }
    function lt(t, e) {
      return Object(s.b)(this, void 0, void 0, function () {
        var n;
        return Object(s.d)(this, function (r) {
          switch (r.label) {
            case 0:
              return [4, (0, q.getEnv().fetch)(t, e)];
            case 1:
              if (!((n = r.sent()).status < 400))
                throw new Error(
                  "failed to fetch: (" +
                    n.status +
                    ") " +
                    n.statusText +
                    ", from url: " +
                    n.url
                );
              return [2, n];
          }
        });
      });
    }
    function pt(t) {
      return Object(s.b)(this, void 0, void 0, function () {
        return Object(s.d)(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, lt(t)];
            case 1:
              return [2, e.sent().json()];
          }
        });
      });
    }
    function ht(t, e) {
      var n = e + "-weights_manifest.json";
      if (!t) return { modelBaseUri: "", manifestUri: n };
      if ("/" === t) return { modelBaseUri: "/", manifestUri: "/" + n };
      var r = t.startsWith("http://")
          ? "http://"
          : t.startsWith("https://")
          ? "https://"
          : "",
        i = (t = t.replace(r, "")).split("/").filter(function (t) {
          return t;
        }),
        a = t.endsWith(".json") ? i[i.length - 1] : n,
        o = r + (t.endsWith(".json") ? i.slice(0, i.length - 1) : i).join("/");
      return {
        modelBaseUri: (o = t.startsWith("/") ? "/" + o : o),
        manifestUri: "/" === o ? "/" + a : o + "/" + a,
      };
    }
    function ft(t, e) {
      return Object(s.b)(this, void 0, void 0, function () {
        var n, r, i, o;
        return Object(s.d)(this, function (s) {
          switch (s.label) {
            case 0:
              return (
                (n = ht(t, e)),
                (r = n.manifestUri),
                (i = n.modelBaseUri),
                [4, pt(r)]
              );
            case 1:
              return (o = s.sent()), [2, a.rb.loadWeights(o, i)];
          }
        });
      });
    }
    var dt = (function () {
      function t(t) {
        (this._name = t), (this._params = void 0), (this._paramMappings = []);
      }
      return (
        Object.defineProperty(t.prototype, "params", {
          get: function () {
            return this._params;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "paramMappings", {
          get: function () {
            return this._paramMappings;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "isLoaded", {
          get: function () {
            return !!this.params;
          },
          enumerable: !0,
          configurable: !0,
        }),
        (t.prototype.getParamFromPath = function (t) {
          var e = this.traversePropertyPath(t);
          return e.obj[e.objProp];
        }),
        (t.prototype.reassignParamFromPath = function (t, e) {
          var n = this.traversePropertyPath(t),
            r = n.obj,
            i = n.objProp;
          r[i].dispose(), (r[i] = e);
        }),
        (t.prototype.getParamList = function () {
          var t = this;
          return this._paramMappings.map(function (e) {
            var n = e.paramPath;
            return { path: n, tensor: t.getParamFromPath(n) };
          });
        }),
        (t.prototype.getTrainableParams = function () {
          return this.getParamList().filter(function (t) {
            return t.tensor instanceof a.c;
          });
        }),
        (t.prototype.getFrozenParams = function () {
          return this.getParamList().filter(function (t) {
            return !(t.tensor instanceof a.c);
          });
        }),
        (t.prototype.variable = function () {
          var t = this;
          this.getFrozenParams().forEach(function (e) {
            var n = e.path,
              r = e.tensor;
            t.reassignParamFromPath(n, r.variable());
          });
        }),
        (t.prototype.freeze = function () {
          var t = this;
          this.getTrainableParams().forEach(function (e) {
            var n = e.path,
              r = e.tensor,
              i = a.Tc(r.dataSync());
            r.dispose(), t.reassignParamFromPath(n, i);
          });
        }),
        (t.prototype.dispose = function (t) {
          void 0 === t && (t = !0),
            this.getParamList().forEach(function (e) {
              if (t && e.tensor.isDisposed)
                throw new Error(
                  "param tensor has already been disposed for path " + e.path
                );
              e.tensor.dispose();
            }),
            (this._params = void 0);
        }),
        (t.prototype.serializeParams = function () {
          return new Float32Array(
            this.getParamList()
              .map(function (t) {
                var e = t.tensor;
                return Array.from(e.dataSync());
              })
              .reduce(function (t, e) {
                return t.concat(e);
              })
          );
        }),
        (t.prototype.load = function (t) {
          return Object(s.b)(this, void 0, void 0, function () {
            return Object(s.d)(this, function (e) {
              switch (e.label) {
                case 0:
                  return t instanceof Float32Array
                    ? (this.extractWeights(t), [2])
                    : [4, this.loadFromUri(t)];
                case 1:
                  return e.sent(), [2];
              }
            });
          });
        }),
        (t.prototype.loadFromUri = function (t) {
          return Object(s.b)(this, void 0, void 0, function () {
            var e;
            return Object(s.d)(this, function (n) {
              switch (n.label) {
                case 0:
                  if (t && "string" != typeof t)
                    throw new Error(
                      this._name + ".loadFromUri - expected model uri"
                    );
                  return [4, ft(t, this.getDefaultModelName())];
                case 1:
                  return (e = n.sent()), this.loadFromWeightMap(e), [2];
              }
            });
          });
        }),
        (t.prototype.loadFromDisk = function (t) {
          return Object(s.b)(this, void 0, void 0, function () {
            var e, n, r, i, o, u, c, l, p, h;
            return Object(s.d)(this, function (s) {
              switch (s.label) {
                case 0:
                  if (t && "string" != typeof t)
                    throw new Error(
                      this._name + ".loadFromDisk - expected model file path"
                    );
                  return (
                    (e = q.getEnv().readFile),
                    (n = ht(t, this.getDefaultModelName())),
                    (r = n.manifestUri),
                    (i = n.modelBaseUri),
                    (o = function (t) {
                      return Promise.all(
                        t.map(function (t) {
                          return e(t).then(function (t) {
                            return t.buffer;
                          });
                        })
                      );
                    }),
                    (u = a.rb.weightsLoaderFactory(o)),
                    (p = (l = JSON).parse),
                    [4, e(r)]
                  );
                case 1:
                  return (c = p.apply(l, [s.sent().toString()])), [4, u(c, i)];
                case 2:
                  return (h = s.sent()), this.loadFromWeightMap(h), [2];
              }
            });
          });
        }),
        (t.prototype.loadFromWeightMap = function (t) {
          var e = this.extractParamsFromWeigthMap(t),
            n = e.paramMappings,
            r = e.params;
          (this._paramMappings = n), (this._params = r);
        }),
        (t.prototype.extractWeights = function (t) {
          var e = this.extractParams(t),
            n = e.paramMappings,
            r = e.params;
          (this._paramMappings = n), (this._params = r);
        }),
        (t.prototype.traversePropertyPath = function (t) {
          if (!this.params)
            throw new Error(
              "traversePropertyPath - model has no loaded params"
            );
          var e = t.split("/").reduce(
              function (e, n) {
                if (!e.nextObj.hasOwnProperty(n))
                  throw new Error(
                    "traversePropertyPath - object does not have property " +
                      n +
                      ", for path " +
                      t
                  );
                return { obj: e.nextObj, objProp: n, nextObj: e.nextObj[n] };
              },
              { nextObj: this.params }
            ),
            n = e.obj,
            r = e.objProp;
          if (!(n && r && n[r] instanceof a.b))
            throw new Error(
              "traversePropertyPath - parameter is not a tensor, for path " + t
            );
          return { obj: n, objProp: r };
        }),
        t
      );
    })();
    function mt(t, e, n) {
      return a.Zc(function () {
        var r = a.sc(t, e.depthwise_filter, e.pointwise_filter, n, "same");
        return (r = a.g(r, e.bias));
      });
    }
    function vt(t, e, n) {
      return (
        void 0 === n && (n = !1),
        a.Zc(function () {
          var r = a.jc(
              n
                ? a.g(a.K(t, e.conv0.filters, [2, 2], "same"), e.conv0.bias)
                : mt(t, e.conv0, [2, 2])
            ),
            i = mt(r, e.conv1, [1, 1]),
            o = mt(a.jc(a.g(r, i)), e.conv2, [1, 1]);
          return a.jc(a.g(r, a.g(i, o)));
        })
      );
    }
    function gt(t, e, n, r) {
      return (
        void 0 === n && (n = !1),
        void 0 === r && (r = !0),
        a.Zc(function () {
          var i = a.jc(
              n
                ? a.g(
                    a.K(t, e.conv0.filters, r ? [2, 2] : [1, 1], "same"),
                    e.conv0.bias
                  )
                : mt(t, e.conv0, r ? [2, 2] : [1, 1])
            ),
            o = mt(i, e.conv1, [1, 1]),
            s = mt(a.jc(a.g(i, o)), e.conv2, [1, 1]),
            u = mt(a.jc(a.g(i, a.g(o, s))), e.conv3, [1, 1]);
          return a.jc(a.g(i, a.g(o, a.g(s, u))));
        })
      );
    }
    function yt(t, e, n, r) {
      return (
        void 0 === n && (n = "same"),
        void 0 === r && (r = !1),
        a.Zc(function () {
          var i = a.g(a.K(t, e.filters, [1, 1], n), e.bias);
          return r ? a.jc(i) : i;
        })
      );
    }
    function bt(t, e) {
      Object.keys(t).forEach(function (n) {
        e.some(function (t) {
          return t.originalPath === n;
        }) || t[n].dispose();
      });
    }
    function wt(t, e) {
      return function (n, r, i, o) {
        var s = a.Xc(t(n * r * i * i), [i, i, n, r]),
          u = a.Uc(t(r));
        return (
          e.push({ paramPath: o + "/filters" }, { paramPath: o + "/bias" }),
          { filters: s, bias: u }
        );
      };
    }
    function xt(t, e) {
      return function (n, r, i) {
        var o = a.Vc(t(n * r), [n, r]),
          s = a.Uc(t(r));
        return (
          e.push({ paramPath: i + "/weights" }, { paramPath: i + "/bias" }),
          { weights: o, bias: s }
        );
      };
    }
    var Ct = function (t, e, n) {
      (this.depthwise_filter = t), (this.pointwise_filter = e), (this.bias = n);
    };
    function Ot(t, e) {
      return function (n, r, i) {
        var o = a.Xc(t(9 * n), [3, 3, n, 1]),
          s = a.Xc(t(n * r), [1, 1, n, r]),
          u = a.Uc(t(r));
        return (
          e.push(
            { paramPath: i + "/depthwise_filter" },
            { paramPath: i + "/pointwise_filter" },
            { paramPath: i + "/bias" }
          ),
          new Ct(o, s, u)
        );
      };
    }
    function Et(t) {
      return function (e) {
        var n = t(e + "/depthwise_filter", 4),
          r = t(e + "/pointwise_filter", 4),
          i = t(e + "/bias", 1);
        return new Ct(n, r, i);
      };
    }
    function St(t, e) {
      return function (n, r, i) {
        var a = t[n];
        if (!c(a, r))
          throw new Error(
            "expected weightMap[" +
              n +
              "] to be a Tensor" +
              r +
              "D, instead have " +
              a
          );
        return e.push({ originalPath: n, paramPath: i || n }), a;
      };
    }
    function Nt(t) {
      var e = t;
      return {
        extractWeights: function (t) {
          var n = e.slice(0, t);
          return (e = e.slice(t)), n;
        },
        getRemainingWeights: function () {
          return e;
        },
      };
    }
    function It(t, e) {
      var n = wt(t, e),
        r = Ot(t, e);
      function i(t, e, i, a) {
        return (
          void 0 === a && (a = !1),
          {
            conv0: a ? n(t, e, 3, i + "/conv0") : r(t, e, i + "/conv0"),
            conv1: r(e, e, i + "/conv1"),
            conv2: r(e, e, i + "/conv2"),
          }
        );
      }
      return {
        extractDenseBlock3Params: i,
        extractDenseBlock4Params: function (t, e, n, a) {
          void 0 === a && (a = !1);
          var o = i(t, e, n, a);
          return {
            conv0: o.conv0,
            conv1: o.conv1,
            conv2: o.conv2,
            conv3: r(e, e, n + "/conv3"),
          };
        },
      };
    }
    function kt(t) {
      return function (e) {
        return { filters: t(e + "/filters", 4), bias: t(e + "/bias", 1) };
      };
    }
    function _t(t, e) {
      var n = St(t, e),
        r = kt(n),
        i = Et(n);
      return {
        extractDenseBlock3Params: function (t, e) {
          return (
            void 0 === e && (e = !1),
            {
              conv0: e ? r(t + "/conv0") : i(t + "/conv0"),
              conv1: i(t + "/conv1"),
              conv2: i(t + "/conv2"),
            }
          );
        },
        extractDenseBlock4Params: function (t, e) {
          return (
            void 0 === e && (e = !1),
            {
              conv0: e ? r(t + "/conv0") : i(t + "/conv0"),
              conv1: i(t + "/conv1"),
              conv2: i(t + "/conv2"),
              conv3: i(t + "/conv3"),
            }
          );
        },
      };
    }
    var At = (function (t) {
      function e() {
        return t.call(this, "FaceFeatureExtractor") || this;
      }
      return (
        Object(s.c)(e, t),
        (e.prototype.forwardInput = function (t) {
          var e = this.params;
          if (!e)
            throw new Error(
              "FaceFeatureExtractor - load model before inference"
            );
          return a.Zc(function () {
            var n = gt(
              N(t.toBatchTensor(112, !0), [122.782, 117.001, 104.298]).div(
                a.pc(255)
              ),
              e.dense0,
              !0
            );
            return (
              (n = gt(n, e.dense1)),
              (n = gt(n, e.dense2)),
              (n = gt(n, e.dense3)),
              (n = a.r(n, [7, 7], [2, 2], "valid"))
            );
          });
        }),
        (e.prototype.forward = function (t) {
          return Object(s.b)(this, void 0, void 0, function () {
            var e;
            return Object(s.d)(this, function (n) {
              switch (n.label) {
                case 0:
                  return (e = this.forwardInput), [4, st(t)];
                case 1:
                  return [2, e.apply(this, [n.sent()])];
              }
            });
          });
        }),
        (e.prototype.getDefaultModelName = function () {
          return "face_feature_extractor_model";
        }),
        (e.prototype.extractParamsFromWeigthMap = function (t) {
          return (function (t) {
            var e = [],
              n = _t(t, e).extractDenseBlock4Params,
              r = {
                dense0: n("dense0", !0),
                dense1: n("dense1"),
                dense2: n("dense2"),
                dense3: n("dense3"),
              };
            return bt(t, e), { params: r, paramMappings: e };
          })(t);
        }),
        (e.prototype.extractParams = function (t) {
          return (function (t) {
            var e = [],
              n = Nt(t),
              r = n.extractWeights,
              i = n.getRemainingWeights,
              a = It(r, e).extractDenseBlock4Params,
              o = a(3, 32, "dense0", !0),
              s = a(32, 64, "dense1"),
              u = a(64, 128, "dense2"),
              c = a(128, 256, "dense3");
            if (0 !== i().length)
              throw new Error("weights remaing after extract: " + i().length);
            return {
              paramMappings: e,
              params: { dense0: o, dense1: s, dense2: u, dense3: c },
            };
          })(t);
        }),
        e
      );
    })(dt);
    function Tt(t, e) {
      return a.Zc(function () {
        return a.g(a.Gb(t, e.weights), e.bias);
      });
    }
    function Rt(t) {
      var e = {},
        n = {};
      return (
        Object.keys(t).forEach(function (r) {
          (r.startsWith("fc") ? n : e)[r] = t[r];
        }),
        { featureExtractorMap: e, classifierMap: n }
      );
    }
    var Dt = (function (t) {
        function e(e, n) {
          var r = t.call(this, e) || this;
          return (r._faceFeatureExtractor = n), r;
        }
        return (
          Object(s.c)(e, t),
          Object.defineProperty(e.prototype, "faceFeatureExtractor", {
            get: function () {
              return this._faceFeatureExtractor;
            },
            enumerable: !0,
            configurable: !0,
          }),
          (e.prototype.runNet = function (t) {
            var e = this,
              n = this.params;
            if (!n)
              throw new Error(this._name + " - load model before inference");
            return a.Zc(function () {
              var r =
                t instanceof ot ? e.faceFeatureExtractor.forwardInput(t) : t;
              return Tt(r.as2D(r.shape[0], -1), n.fc);
            });
          }),
          (e.prototype.dispose = function (e) {
            void 0 === e && (e = !0),
              this.faceFeatureExtractor.dispose(e),
              t.prototype.dispose.call(this, e);
          }),
          (e.prototype.loadClassifierParams = function (t) {
            var e = this.extractClassifierParams(t),
              n = e.params,
              r = e.paramMappings;
            (this._params = n), (this._paramMappings = r);
          }),
          (e.prototype.extractClassifierParams = function (t) {
            return (function (t, e, n) {
              var r = [],
                i = Nt(t),
                a = i.extractWeights,
                o = i.getRemainingWeights,
                s = xt(a, r)(e, n, "fc");
              if (0 !== o().length)
                throw new Error("weights remaing after extract: " + o().length);
              return { paramMappings: r, params: { fc: s } };
            })(
              t,
              this.getClassifierChannelsIn(),
              this.getClassifierChannelsOut()
            );
          }),
          (e.prototype.extractParamsFromWeigthMap = function (t) {
            var e = Rt(t),
              n = e.featureExtractorMap,
              r = e.classifierMap;
            return (
              this.faceFeatureExtractor.loadFromWeightMap(n),
              (function (t) {
                var e,
                  n = [],
                  r = St(t, n),
                  i = {
                    fc:
                      ((e = "fc"),
                      {
                        weights: r(e + "/weights", 2),
                        bias: r(e + "/bias", 1),
                      }),
                  };
                return bt(t, n), { params: i, paramMappings: n };
              })(r)
            );
          }),
          (e.prototype.extractParams = function (t) {
            var e = this.getClassifierChannelsIn(),
              n = this.getClassifierChannelsOut(),
              r = n * e + n,
              i = t.slice(0, t.length - r),
              a = t.slice(t.length - r);
            return (
              this.faceFeatureExtractor.extractWeights(i),
              this.extractClassifierParams(a)
            );
          }),
          e
        );
      })(dt),
      Ft = [
        "neutral",
        "happy",
        "sad",
        "angry",
        "fearful",
        "disgusted",
        "surprised",
      ],
      Mt = (function () {
        function t(t) {
          var e = this;
          if (7 !== t.length)
            throw new Error(
              "FaceExpressions.constructor - expected probabilities.length to be 7, have: " +
                t.length
            );
          Ft.forEach(function (n, r) {
            e[n] = t[r];
          });
        }
        return (
          (t.prototype.asSortedArray = function () {
            var t = this;
            return Ft.map(function (e) {
              return { expression: e, probability: t[e] };
            }).sort(function (t, e) {
              return e.probability - t.probability;
            });
          }),
          t
        );
      })(),
      jt = (function (t) {
        function e(e) {
          return (
            void 0 === e && (e = new At()),
            t.call(this, "FaceExpressionNet", e) || this
          );
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.forwardInput = function (t) {
            var e = this;
            return a.Zc(function () {
              return a.Ec(e.runNet(t));
            });
          }),
          (e.prototype.forward = function (t) {
            return Object(s.b)(this, void 0, void 0, function () {
              var e;
              return Object(s.d)(this, function (n) {
                switch (n.label) {
                  case 0:
                    return (e = this.forwardInput), [4, st(t)];
                  case 1:
                    return [2, e.apply(this, [n.sent()])];
                }
              });
            });
          }),
          (e.prototype.predictExpressions = function (t) {
            return Object(s.b)(this, void 0, void 0, function () {
              var e,
                n,
                r,
                i,
                o = this;
              return Object(s.d)(this, function (u) {
                switch (u.label) {
                  case 0:
                    return [4, st(t)];
                  case 1:
                    return (e = u.sent()), [4, this.forwardInput(e)];
                  case 2:
                    return (
                      (n = u.sent()),
                      [
                        4,
                        Promise.all(
                          a.fd(n).map(function (t) {
                            return Object(s.b)(o, void 0, void 0, function () {
                              var e;
                              return Object(s.d)(this, function (n) {
                                switch (n.label) {
                                  case 0:
                                    return [4, t.data()];
                                  case 1:
                                    return (e = n.sent()), t.dispose(), [2, e];
                                }
                              });
                            });
                          })
                        ),
                      ]
                    );
                  case 3:
                    return (
                      (r = u.sent()),
                      n.dispose(),
                      (i = r.map(function (t) {
                        return new Mt(t);
                      })),
                      [2, e.isBatchInput ? i : i[0]]
                    );
                }
              });
            });
          }),
          (e.prototype.getDefaultModelName = function () {
            return "face_expression_model";
          }),
          (e.prototype.getClassifierChannelsIn = function () {
            return 256;
          }),
          (e.prototype.getClassifierChannelsOut = function () {
            return 7;
          }),
          e
        );
      })(Dt);
    function Pt(t, e) {
      var n = { expressions: e };
      return Object.assign({}, t, n);
    }
    function zt(t, e, n, r) {
      void 0 === n && (n = 0.1),
        (Array.isArray(e) ? e : [e]).forEach(function (e) {
          var i =
            e instanceof Mt
              ? e
              : e.expressions instanceof Mt
              ? e.expressions
              : void 0;
          if (!i)
            throw new Error(
              "drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof"
            );
          var a = i.asSortedArray().filter(function (t) {
              return t.probability > n;
            }),
            o = M(e) ? e.detection.box.bottomLeft : r || new b(0, 0);
          new Y(
            a.map(function (t) {
              return t.expression + " (" + f(t.probability) + ")";
            }),
            o
          ).draw(t);
        });
    }
    function Lt(t) {
      return (
        M(t) &&
        t.landmarks instanceof _ &&
        t.unshiftedLandmarks instanceof _ &&
        t.alignedRect instanceof O
      );
    }
    function Bt(t, e) {
      var n = t.detection.box,
        r = e.shiftBy(n.x, n.y),
        i = r.align(),
        a = t.detection.imageDims,
        o = {
          landmarks: r,
          unshiftedLandmarks: e,
          alignedRect: new O(t.detection.score, i.rescale(a.reverse()), a),
        };
      return Object.assign({}, t, o);
    }
    var Wt = function (t) {
        void 0 === t && (t = {});
        var e = t.drawLines,
          n = void 0 === e || e,
          r = t.drawPoints,
          i = void 0 === r || r,
          a = t.lineWidth,
          o = t.lineColor,
          s = t.pointSize,
          u = t.pointColor;
        (this.drawLines = n),
          (this.drawPoints = i),
          (this.lineWidth = a || 1),
          (this.pointSize = s || 2),
          (this.lineColor = o || "rgba(0, 255, 255, 1)"),
          (this.pointColor = u || "rgba(255, 0, 255, 1)");
      },
      Ut = (function () {
        function t(t, e) {
          void 0 === e && (e = {}),
            (this.faceLandmarks = t),
            (this.options = new Wt(e));
        }
        return (
          (t.prototype.draw = function (t) {
            var e = Z(t),
              n = this.options,
              r = n.drawLines,
              i = n.drawPoints,
              a = n.lineWidth,
              s = n.lineColor,
              u = n.pointSize,
              c = n.pointColor;
            if (
              (r &&
                this.faceLandmarks instanceof T &&
                ((e.strokeStyle = s),
                (e.lineWidth = a),
                o(e, this.faceLandmarks.getJawOutline()),
                o(e, this.faceLandmarks.getLeftEyeBrow()),
                o(e, this.faceLandmarks.getRightEyeBrow()),
                o(e, this.faceLandmarks.getNose()),
                o(e, this.faceLandmarks.getLeftEye(), !0),
                o(e, this.faceLandmarks.getRightEye(), !0),
                o(e, this.faceLandmarks.getMouth(), !0)),
              i)
            ) {
              (e.strokeStyle = c), (e.fillStyle = c);
              this.faceLandmarks.positions.forEach(function (t) {
                e.beginPath(), e.arc(t.x, t.y, u, 0, 2 * Math.PI), e.fill();
              });
            }
          }),
          t
        );
      })();
    function Vt(t, e) {
      (Array.isArray(e) ? e : [e]).forEach(function (e) {
        var n = e instanceof _ ? e : Lt(e) ? e.landmarks : void 0;
        if (!n)
          throw new Error(
            "drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof"
          );
        new Ut(n).draw(t);
      });
    }
    function Gt(t, e) {
      var n = [],
        r = Nt(t),
        i = r.extractWeights,
        a = r.getRemainingWeights,
        o = (function (t, e) {
          var n = wt(t, e),
            r = Ot(t, e);
          return {
            extractConvParams: n,
            extractSeparableConvParams: r,
            extractReductionBlockParams: function (t, e, i) {
              return {
                separable_conv0: r(t, e, i + "/separable_conv0"),
                separable_conv1: r(e, e, i + "/separable_conv1"),
                expansion_conv: n(t, e, 1, i + "/expansion_conv"),
              };
            },
            extractMainBlockParams: function (t, e) {
              return {
                separable_conv0: r(t, t, e + "/separable_conv0"),
                separable_conv1: r(t, t, e + "/separable_conv1"),
                separable_conv2: r(t, t, e + "/separable_conv2"),
              };
            },
          };
        })(i, n),
        s = o.extractConvParams,
        u = o.extractSeparableConvParams,
        c = o.extractReductionBlockParams,
        l = o.extractMainBlockParams,
        p = {
          conv_in: s(3, 32, 3, "entry_flow/conv_in"),
          reduction_block_0: c(32, 64, "entry_flow/reduction_block_0"),
          reduction_block_1: c(64, 128, "entry_flow/reduction_block_1"),
        },
        h = {};
      v(e, 0, 1).forEach(function (t) {
        h["main_block_" + t] = l(128, "middle_flow/main_block_" + t);
      });
      var f = {
        reduction_block: c(128, 256, "exit_flow/reduction_block"),
        separable_conv: u(256, 512, "exit_flow/separable_conv"),
      };
      if (0 !== a().length)
        throw new Error("weights remaing after extract: " + a().length);
      return {
        paramMappings: n,
        params: { entry_flow: p, middle_flow: h, exit_flow: f },
      };
    }
    function Ht(t, e) {
      var n = [],
        r = (function (t, e) {
          var n = St(t, e),
            r = kt(n),
            i = Et(n);
          return {
            extractConvParams: r,
            extractSeparableConvParams: i,
            extractReductionBlockParams: function (t) {
              return {
                separable_conv0: i(t + "/separable_conv0"),
                separable_conv1: i(t + "/separable_conv1"),
                expansion_conv: r(t + "/expansion_conv"),
              };
            },
            extractMainBlockParams: function (t) {
              return {
                separable_conv0: i(t + "/separable_conv0"),
                separable_conv1: i(t + "/separable_conv1"),
                separable_conv2: i(t + "/separable_conv2"),
              };
            },
          };
        })(t, n),
        i = r.extractConvParams,
        a = r.extractSeparableConvParams,
        o = r.extractReductionBlockParams,
        s = r.extractMainBlockParams,
        u = {
          conv_in: i("entry_flow/conv_in"),
          reduction_block_0: o("entry_flow/reduction_block_0"),
          reduction_block_1: o("entry_flow/reduction_block_1"),
        },
        c = {};
      v(e, 0, 1).forEach(function (t) {
        c["main_block_" + t] = s("middle_flow/main_block_" + t);
      });
      var l = {
        reduction_block: o("exit_flow/reduction_block"),
        separable_conv: a("exit_flow/separable_conv"),
      };
      return (
        bt(t, n),
        {
          params: { entry_flow: u, middle_flow: c, exit_flow: l },
          paramMappings: n,
        }
      );
    }
    function qt(t, e, n) {
      return a.g(a.K(t, e.filters, n, "same"), e.bias);
    }
    function Kt(t, e, n) {
      void 0 === n && (n = !0);
      var r = n ? a.jc(t) : t;
      return (
        (r = mt(r, e.separable_conv0, [1, 1])),
        (r = mt(a.jc(r), e.separable_conv1, [1, 1])),
        (r = a.Ib(r, [3, 3], [2, 2], "same")),
        (r = a.g(r, qt(t, e.expansion_conv, [2, 2])))
      );
    }
    var Zt,
      Xt = (function (t) {
        function e(e) {
          var n = t.call(this, "TinyXception") || this;
          return (n._numMainBlocks = e), n;
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.forwardInput = function (t) {
            var e = this,
              n = this.params;
            if (!n)
              throw new Error("TinyXception - load model before inference");
            return a.Zc(function () {
              var r = N(t.toBatchTensor(112, !0), [
                  122.782,
                  117.001,
                  104.298,
                ]).div(a.pc(256)),
                i = a.jc(qt(r, n.entry_flow.conv_in, [2, 2]));
              return (
                (i = Kt(i, n.entry_flow.reduction_block_0, !1)),
                (i = Kt(i, n.entry_flow.reduction_block_1)),
                v(e._numMainBlocks, 0, 1).forEach(function (t) {
                  i = (function (t, e) {
                    var n = mt(a.jc(t), e.separable_conv0, [1, 1]);
                    return (
                      (n = mt(a.jc(n), e.separable_conv1, [1, 1])),
                      (n = mt(a.jc(n), e.separable_conv2, [1, 1])),
                      (n = a.g(n, t))
                    );
                  })(i, n.middle_flow["main_block_" + t]);
                }),
                (i = Kt(i, n.exit_flow.reduction_block)),
                (i = a.jc(mt(i, n.exit_flow.separable_conv, [1, 1])))
              );
            });
          }),
          (e.prototype.forward = function (t) {
            return Object(s.b)(this, void 0, void 0, function () {
              var e;
              return Object(s.d)(this, function (n) {
                switch (n.label) {
                  case 0:
                    return (e = this.forwardInput), [4, st(t)];
                  case 1:
                    return [2, e.apply(this, [n.sent()])];
                }
              });
            });
          }),
          (e.prototype.getDefaultModelName = function () {
            return "tiny_xception_model";
          }),
          (e.prototype.extractParamsFromWeigthMap = function (t) {
            return Ht(t, this._numMainBlocks);
          }),
          (e.prototype.extractParams = function (t) {
            return Gt(t, this._numMainBlocks);
          }),
          e
        );
      })(dt);
    !(function (t) {
      (t.FEMALE = "female"), (t.MALE = "male");
    })(Zt || (Zt = {}));
    var Yt = (function (t) {
        function e(e) {
          void 0 === e && (e = new Xt(2));
          var n = t.call(this, "AgeGenderNet") || this;
          return (n._faceFeatureExtractor = e), n;
        }
        return (
          Object(s.c)(e, t),
          Object.defineProperty(e.prototype, "faceFeatureExtractor", {
            get: function () {
              return this._faceFeatureExtractor;
            },
            enumerable: !0,
            configurable: !0,
          }),
          (e.prototype.runNet = function (t) {
            var e = this,
              n = this.params;
            if (!n)
              throw new Error(this._name + " - load model before inference");
            return a.Zc(function () {
              var r =
                  t instanceof ot ? e.faceFeatureExtractor.forwardInput(t) : t,
                i = a.r(r, [7, 7], [2, 2], "valid").as2D(r.shape[0], -1);
              return {
                age: Tt(i, n.fc.age).as1D(),
                gender: Tt(i, n.fc.gender),
              };
            });
          }),
          (e.prototype.forwardInput = function (t) {
            var e = this;
            return a.Zc(function () {
              var n = e.runNet(t),
                r = n.age,
                i = n.gender;
              return { age: r, gender: a.Ec(i) };
            });
          }),
          (e.prototype.forward = function (t) {
            return Object(s.b)(this, void 0, void 0, function () {
              var e;
              return Object(s.d)(this, function (n) {
                switch (n.label) {
                  case 0:
                    return (e = this.forwardInput), [4, st(t)];
                  case 1:
                    return [2, e.apply(this, [n.sent()])];
                }
              });
            });
          }),
          (e.prototype.predictAgeAndGender = function (t) {
            return Object(s.b)(this, void 0, void 0, function () {
              var e,
                n,
                r,
                i,
                o,
                u,
                c = this;
              return Object(s.d)(this, function (l) {
                switch (l.label) {
                  case 0:
                    return [4, st(t)];
                  case 1:
                    return (e = l.sent()), [4, this.forwardInput(e)];
                  case 2:
                    return (
                      (n = l.sent()),
                      (r = a.fd(n.age)),
                      (i = a.fd(n.gender)),
                      (o = r.map(function (t, e) {
                        return { ageTensor: t, genderTensor: i[e] };
                      })),
                      [
                        4,
                        Promise.all(
                          o.map(function (t) {
                            var e = t.ageTensor,
                              n = t.genderTensor;
                            return Object(s.b)(c, void 0, void 0, function () {
                              var t, r, i, a, o;
                              return Object(s.d)(this, function (s) {
                                switch (s.label) {
                                  case 0:
                                    return [4, e.data()];
                                  case 1:
                                    return (t = s.sent()[0]), [4, n.data()];
                                  case 2:
                                    return (
                                      (r = s.sent()[0]),
                                      (a = (i = r > 0.5) ? Zt.MALE : Zt.FEMALE),
                                      (o = i ? r : 1 - r),
                                      e.dispose(),
                                      n.dispose(),
                                      [
                                        2,
                                        {
                                          age: t,
                                          gender: a,
                                          genderProbability: o,
                                        },
                                      ]
                                    );
                                }
                              });
                            });
                          })
                        ),
                      ]
                    );
                  case 3:
                    return (
                      (u = l.sent()),
                      n.age.dispose(),
                      n.gender.dispose(),
                      [2, e.isBatchInput ? u : u[0]]
                    );
                }
              });
            });
          }),
          (e.prototype.getDefaultModelName = function () {
            return "age_gender_model";
          }),
          (e.prototype.dispose = function (e) {
            void 0 === e && (e = !0),
              this.faceFeatureExtractor.dispose(e),
              t.prototype.dispose.call(this, e);
          }),
          (e.prototype.loadClassifierParams = function (t) {
            var e = this.extractClassifierParams(t),
              n = e.params,
              r = e.paramMappings;
            (this._params = n), (this._paramMappings = r);
          }),
          (e.prototype.extractClassifierParams = function (t) {
            return (function (t) {
              var e = [],
                n = Nt(t),
                r = n.extractWeights,
                i = n.getRemainingWeights,
                a = xt(r, e),
                o = a(512, 1, "fc/age"),
                s = a(512, 2, "fc/gender");
              if (0 !== i().length)
                throw new Error("weights remaing after extract: " + i().length);
              return {
                paramMappings: e,
                params: { fc: { age: o, gender: s } },
              };
            })(t);
          }),
          (e.prototype.extractParamsFromWeigthMap = function (t) {
            var e = Rt(t),
              n = e.featureExtractorMap,
              r = e.classifierMap;
            return (
              this.faceFeatureExtractor.loadFromWeightMap(n),
              (function (t) {
                var e = [],
                  n = St(t, e);
                function r(t) {
                  return {
                    weights: n(t + "/weights", 2),
                    bias: n(t + "/bias", 1),
                  };
                }
                var i = { fc: { age: r("fc/age"), gender: r("fc/gender") } };
                return bt(t, e), { params: i, paramMappings: e };
              })(r)
            );
          }),
          (e.prototype.extractParams = function (t) {
            var e = t.slice(0, t.length - 1539),
              n = t.slice(t.length - 1539);
            return (
              this.faceFeatureExtractor.extractWeights(e),
              this.extractClassifierParams(n)
            );
          }),
          e
        );
      })(dt),
      Jt = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.postProcess = function (t, e, n) {
            var r = n.map(function (t) {
                var n = t.width,
                  r = t.height,
                  i = e / Math.max(r, n);
                return { width: n * i, height: r * i };
              }),
              i = r.length;
            return a.Zc(function () {
              var n = function (t, e) {
                  return a
                    .Nc([a.gb([68], t), a.gb([68], e)], 1)
                    .as2D(1, 136)
                    .as1D();
                },
                o = function (t, e) {
                  var n = r[t],
                    i = n.width,
                    a = n.height;
                  return e(i, a) ? Math.abs(i - a) / 2 : 0;
                };
              return t
                .mul(a.gb([i, 136], e))
                .sub(
                  a.Nc(
                    Array.from(Array(i), function (t, e) {
                      return n(
                        (function (t) {
                          return o(t, function (t, e) {
                            return t < e;
                          });
                        })(e),
                        (function (t) {
                          return o(t, function (t, e) {
                            return e < t;
                          });
                        })(e)
                      );
                    })
                  )
                )
                .div(
                  a.Nc(
                    Array.from(Array(i), function (t, e) {
                      return n(r[e].width, r[e].height);
                    })
                  )
                );
            });
          }),
          (e.prototype.forwardInput = function (t) {
            var e = this;
            return a.Zc(function () {
              var n = e.runNet(t);
              return e.postProcess(
                n,
                t.inputSize,
                t.inputDimensions.map(function (t) {
                  return { height: t[0], width: t[1] };
                })
              );
            });
          }),
          (e.prototype.forward = function (t) {
            return Object(s.b)(this, void 0, void 0, function () {
              var e;
              return Object(s.d)(this, function (n) {
                switch (n.label) {
                  case 0:
                    return (e = this.forwardInput), [4, st(t)];
                  case 1:
                    return [2, e.apply(this, [n.sent()])];
                }
              });
            });
          }),
          (e.prototype.detectLandmarks = function (t) {
            return Object(s.b)(this, void 0, void 0, function () {
              var e,
                n,
                r,
                i = this;
              return Object(s.d)(this, function (o) {
                switch (o.label) {
                  case 0:
                    return [4, st(t)];
                  case 1:
                    return (
                      (e = o.sent()),
                      (n = a.Zc(function () {
                        return a.fd(i.forwardInput(e));
                      })),
                      [
                        4,
                        Promise.all(
                          n.map(function (t, n) {
                            return Object(s.b)(i, void 0, void 0, function () {
                              var r, i, a, o, u;
                              return Object(s.d)(this, function (s) {
                                switch (s.label) {
                                  case 0:
                                    return (
                                      (a = (i = Array).from), [4, t.data()]
                                    );
                                  case 1:
                                    return (
                                      (r = a.apply(i, [s.sent()])),
                                      (o = r.filter(function (t, e) {
                                        return h(e);
                                      })),
                                      (u = r.filter(function (t, e) {
                                        return !h(e);
                                      })),
                                      [
                                        2,
                                        new T(
                                          Array(68)
                                            .fill(0)
                                            .map(function (t, e) {
                                              return new b(o[e], u[e]);
                                            }),
                                          {
                                            height: e.getInputHeight(n),
                                            width: e.getInputWidth(n),
                                          }
                                        ),
                                      ]
                                    );
                                }
                              });
                            });
                          })
                        ),
                      ]
                    );
                  case 2:
                    return (
                      (r = o.sent()),
                      n.forEach(function (t) {
                        return t.dispose();
                      }),
                      [2, e.isBatchInput ? r : r[0]]
                    );
                }
              });
            });
          }),
          (e.prototype.getClassifierChannelsOut = function () {
            return 136;
          }),
          e
        );
      })(Dt),
      $t = (function (t) {
        function e(e) {
          return (
            void 0 === e && (e = new At()),
            t.call(this, "FaceLandmark68Net", e) || this
          );
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.getDefaultModelName = function () {
            return "face_landmark_68_model";
          }),
          (e.prototype.getClassifierChannelsIn = function () {
            return 256;
          }),
          e
        );
      })(Jt);
    var Qt = (function (t) {
        function e() {
          return t.call(this, "TinyFaceFeatureExtractor") || this;
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.forwardInput = function (t) {
            var e = this.params;
            if (!e)
              throw new Error(
                "TinyFaceFeatureExtractor - load model before inference"
              );
            return a.Zc(function () {
              var n = vt(
                N(t.toBatchTensor(112, !0), [122.782, 117.001, 104.298]).div(
                  a.pc(255)
                ),
                e.dense0,
                !0
              );
              return (
                (n = vt(n, e.dense1)),
                (n = vt(n, e.dense2)),
                (n = a.r(n, [14, 14], [2, 2], "valid"))
              );
            });
          }),
          (e.prototype.forward = function (t) {
            return Object(s.b)(this, void 0, void 0, function () {
              var e;
              return Object(s.d)(this, function (n) {
                switch (n.label) {
                  case 0:
                    return (e = this.forwardInput), [4, st(t)];
                  case 1:
                    return [2, e.apply(this, [n.sent()])];
                }
              });
            });
          }),
          (e.prototype.getDefaultModelName = function () {
            return "face_feature_extractor_tiny_model";
          }),
          (e.prototype.extractParamsFromWeigthMap = function (t) {
            return (function (t) {
              var e = [],
                n = _t(t, e).extractDenseBlock3Params,
                r = {
                  dense0: n("dense0", !0),
                  dense1: n("dense1"),
                  dense2: n("dense2"),
                };
              return bt(t, e), { params: r, paramMappings: e };
            })(t);
          }),
          (e.prototype.extractParams = function (t) {
            return (function (t) {
              var e = [],
                n = Nt(t),
                r = n.extractWeights,
                i = n.getRemainingWeights,
                a = It(r, e).extractDenseBlock3Params,
                o = a(3, 32, "dense0", !0),
                s = a(32, 64, "dense1"),
                u = a(64, 128, "dense2");
              if (0 !== i().length)
                throw new Error("weights remaing after extract: " + i().length);
              return {
                paramMappings: e,
                params: { dense0: o, dense1: s, dense2: u },
              };
            })(t);
          }),
          e
        );
      })(dt),
      te = (function (t) {
        function e(e) {
          return (
            void 0 === e && (e = new Qt()),
            t.call(this, "FaceLandmark68TinyNet", e) || this
          );
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.getDefaultModelName = function () {
            return "face_landmark_68_tiny_model";
          }),
          (e.prototype.getClassifierChannelsIn = function () {
            return 128;
          }),
          e
        );
      })(Jt);
    !(function (t) {
      function e() {
        return (null !== t && t.apply(this, arguments)) || this;
      }
      Object(s.c)(e, t);
    })($t);
    function ee(t, e, n, r, i) {
      void 0 === i && (i = "same");
      var o = e.conv,
        s = o.filters,
        u = o.bias,
        c = a.K(t, s, n, i);
      return (
        (c = (function (t, e) {
          return a.g(a.Rb(t, e.weights), e.biases);
        })((c = a.g(c, u)), e.scale)),
        r ? a.jc(c) : c
      );
    }
    function ne(t, e) {
      return ee(t, e, [1, 1], !1);
    }
    function re(t, e) {
      return ee(t, e, [2, 2], !0, "valid");
    }
    function ie(t, e) {
      function n(n, r, i, o) {
        var s = (function (e, n, r) {
            var i = t(e),
              o = i.length / (n * r * r);
            if (o % 1 != 0)
              throw new Error(
                "depth has to be an integer: " +
                  o +
                  ", weights.length: " +
                  i.length +
                  ", numFilters: " +
                  n +
                  ", filterSize: " +
                  r
              );
            return a.Zc(function () {
              return a.dd(a.Xc(i, [n, o, r, r]), [2, 3, 1, 0]);
            });
          })(n, r, i),
          u = a.Uc(t(r));
        return (
          e.push({ paramPath: o + "/filters" }, { paramPath: o + "/bias" }),
          { filters: s, bias: u }
        );
      }
      function r(r, i, o, s) {
        return {
          conv: n(r, i, o, s + "/conv"),
          scale: (function (n, r) {
            var i = a.Uc(t(n)),
              o = a.Uc(t(n));
            return (
              e.push(
                { paramPath: r + "/weights" },
                { paramPath: r + "/biases" }
              ),
              { weights: i, biases: o }
            );
          })(i, s + "/scale"),
        };
      }
      return {
        extractConvLayerParams: r,
        extractResidualLayerParams: function (t, e, n, i, a) {
          return (
            void 0 === a && (a = !1),
            {
              conv1: r((a ? 0.5 : 1) * t, e, n, i + "/conv1"),
              conv2: r(t, e, n, i + "/conv2"),
            }
          );
        },
      };
    }
    function ae(t, e) {
      var n = St(t, e);
      function r(t) {
        return {
          conv: {
            filters: n(t + "/conv/filters", 4),
            bias: n(t + "/conv/bias", 1),
          },
          scale: (function (t) {
            return {
              weights: n(t + "/scale/weights", 1),
              biases: n(t + "/scale/biases", 1),
            };
          })(t),
        };
      }
      return {
        extractConvLayerParams: r,
        extractResidualLayerParams: function (t) {
          return { conv1: r(t + "/conv1"), conv2: r(t + "/conv2") };
        },
      };
    }
    function oe(t) {
      var e = [],
        n = ae(t, e),
        r = n.extractConvLayerParams,
        i = n.extractResidualLayerParams,
        a = r("conv32_down"),
        o = i("conv32_1"),
        s = i("conv32_2"),
        u = i("conv32_3"),
        l = i("conv64_down"),
        p = i("conv64_1"),
        h = i("conv64_2"),
        f = i("conv64_3"),
        d = i("conv128_down"),
        m = i("conv128_1"),
        v = i("conv128_2"),
        g = i("conv256_down"),
        y = i("conv256_1"),
        b = i("conv256_2"),
        w = i("conv256_down_out"),
        x = t.fc;
      if ((e.push({ originalPath: "fc", paramPath: "fc" }), !c(x, 2)))
        throw new Error(
          "expected weightMap[fc] to be a Tensor2D, instead have " + x
        );
      var C = {
        conv32_down: a,
        conv32_1: o,
        conv32_2: s,
        conv32_3: u,
        conv64_down: l,
        conv64_1: p,
        conv64_2: h,
        conv64_3: f,
        conv128_down: d,
        conv128_1: m,
        conv128_2: v,
        conv256_down: g,
        conv256_1: y,
        conv256_2: b,
        conv256_down_out: w,
        fc: x,
      };
      return bt(t, e), { params: C, paramMappings: e };
    }
    function se(t, e) {
      var n = (function (t, e) {
        return ee(t, e, [1, 1], !0);
      })(t, e.conv1);
      return (n = ne(n, e.conv2)), (n = a.g(n, t)), (n = a.jc(n));
    }
    function ue(t, e) {
      var n = re(t, e.conv1);
      n = ne(n, e.conv2);
      var r = a.r(t, 2, 2, "valid"),
        i = a.ld(r.shape),
        o = r.shape[3] !== n.shape[3];
      if (r.shape[1] !== n.shape[1] || r.shape[2] !== n.shape[2]) {
        var u = Object(s.e)(n.shape);
        u[1] = 1;
        var c = a.ld(u);
        n = a.E([n, c], 1);
        var l = Object(s.e)(n.shape);
        l[2] = 1;
        var p = a.ld(l);
        n = a.E([n, p], 2);
      }
      return (r = o ? a.E([r, i], 3) : r), (n = a.g(r, n)), (n = a.jc(n));
    }
    var ce = (function (t) {
      function e() {
        return t.call(this, "FaceRecognitionNet") || this;
      }
      return (
        Object(s.c)(e, t),
        (e.prototype.forwardInput = function (t) {
          var e = this.params;
          if (!e)
            throw new Error("FaceRecognitionNet - load model before inference");
          return a.Zc(function () {
            var n = re(
              N(t.toBatchTensor(150, !0).toFloat(), [
                122.782,
                117.001,
                104.298,
              ]).div(a.pc(256)),
              e.conv32_down
            );
            (n = se((n = a.Ib(n, 3, 2, "valid")), e.conv32_1)),
              (n = se(n, e.conv32_2)),
              (n = se(n, e.conv32_3)),
              (n = se((n = ue(n, e.conv64_down)), e.conv64_1)),
              (n = se(n, e.conv64_2)),
              (n = se(n, e.conv64_3)),
              (n = se((n = ue(n, e.conv128_down)), e.conv128_1)),
              (n = se(n, e.conv128_2)),
              (n = se((n = ue(n, e.conv256_down)), e.conv256_1));
            var r = (n = ue(
              (n = se(n, e.conv256_2)),
              e.conv256_down_out
            )).mean([1, 2]);
            return a.Gb(r, e.fc);
          });
        }),
        (e.prototype.forward = function (t) {
          return Object(s.b)(this, void 0, void 0, function () {
            var e;
            return Object(s.d)(this, function (n) {
              switch (n.label) {
                case 0:
                  return (e = this.forwardInput), [4, st(t)];
                case 1:
                  return [2, e.apply(this, [n.sent()])];
              }
            });
          });
        }),
        (e.prototype.computeFaceDescriptor = function (t) {
          return Object(s.b)(this, void 0, void 0, function () {
            var e,
              n,
              r,
              i = this;
            return Object(s.d)(this, function (o) {
              switch (o.label) {
                case 0:
                  return [4, st(t)];
                case 1:
                  return (
                    (e = o.sent()),
                    (n = a.Zc(function () {
                      return a.fd(i.forwardInput(e));
                    })),
                    [
                      4,
                      Promise.all(
                        n.map(function (t) {
                          return t.data();
                        })
                      ),
                    ]
                  );
                case 2:
                  return (
                    (r = o.sent()),
                    n.forEach(function (t) {
                      return t.dispose();
                    }),
                    [2, e.isBatchInput ? r : r[0]]
                  );
              }
            });
          });
        }),
        (e.prototype.getDefaultModelName = function () {
          return "face_recognition_model";
        }),
        (e.prototype.extractParamsFromWeigthMap = function (t) {
          return oe(t);
        }),
        (e.prototype.extractParams = function (t) {
          return (function (t) {
            var e = Nt(t),
              n = e.extractWeights,
              r = e.getRemainingWeights,
              i = [],
              o = ie(n, i),
              s = o.extractConvLayerParams,
              u = o.extractResidualLayerParams,
              c = s(4704, 32, 7, "conv32_down"),
              l = u(9216, 32, 3, "conv32_1"),
              p = u(9216, 32, 3, "conv32_2"),
              h = u(9216, 32, 3, "conv32_3"),
              f = u(36864, 64, 3, "conv64_down", !0),
              d = u(36864, 64, 3, "conv64_1"),
              m = u(36864, 64, 3, "conv64_2"),
              v = u(36864, 64, 3, "conv64_3"),
              g = u(147456, 128, 3, "conv128_down", !0),
              y = u(147456, 128, 3, "conv128_1"),
              b = u(147456, 128, 3, "conv128_2"),
              w = u(589824, 256, 3, "conv256_down", !0),
              x = u(589824, 256, 3, "conv256_1"),
              C = u(589824, 256, 3, "conv256_2"),
              O = u(589824, 256, 3, "conv256_down_out"),
              E = a.Zc(function () {
                return a.dd(a.Vc(n(32768), [128, 256]), [1, 0]);
              });
            if ((i.push({ paramPath: "fc" }), 0 !== r().length))
              throw new Error("weights remaing after extract: " + r().length);
            return {
              params: {
                conv32_down: c,
                conv32_1: l,
                conv32_2: p,
                conv32_3: h,
                conv64_down: f,
                conv64_1: d,
                conv64_2: m,
                conv64_3: v,
                conv128_down: g,
                conv128_1: y,
                conv128_2: b,
                conv256_down: w,
                conv256_1: x,
                conv256_2: C,
                conv256_down_out: O,
                fc: E,
              },
              paramMappings: i,
            };
          })(t);
        }),
        e
      );
    })(dt);
    function le(t, e) {
      var n = { descriptor: e };
      return Object.assign({}, t, n);
    }
    function pe(t, e) {
      var n = { age: e };
      return Object.assign({}, t, n);
    }
    function he(t, e, n) {
      var r = { gender: e, genderProbability: n };
      return Object.assign({}, t, r);
    }
    var fe = (function () {
      function t(t) {
        var e = void 0 === t ? {} : t,
          n = e.minFaceSize,
          r = e.scaleFactor,
          i = e.maxNumScales,
          a = e.scoreThresholds,
          o = e.scaleSteps;
        if (
          ((this._name = "MtcnnOptions"),
          (this._minFaceSize = n || 20),
          (this._scaleFactor = r || 0.709),
          (this._maxNumScales = i || 10),
          (this._scoreThresholds = a || [0.6, 0.7, 0.7]),
          (this._scaleSteps = o),
          "number" != typeof this._minFaceSize || this._minFaceSize < 0)
        )
          throw new Error(
            this._name + " - expected minFaceSize to be a number > 0"
          );
        if (
          "number" != typeof this._scaleFactor ||
          this._scaleFactor <= 0 ||
          this._scaleFactor >= 1
        )
          throw new Error(
            this._name +
              " - expected scaleFactor to be a number between 0 and 1"
          );
        if ("number" != typeof this._maxNumScales || this._maxNumScales < 0)
          throw new Error(
            this._name + " - expected maxNumScales to be a number > 0"
          );
        if (
          !Array.isArray(this._scoreThresholds) ||
          3 !== this._scoreThresholds.length ||
          this._scoreThresholds.some(function (t) {
            return "number" != typeof t;
          })
        )
          throw new Error(
            this._name +
              " - expected scoreThresholds to be an array of numbers of length 3"
          );
        if (
          this._scaleSteps &&
          (!Array.isArray(this._scaleSteps) ||
            this._scaleSteps.some(function (t) {
              return "number" != typeof t;
            }))
        )
          throw new Error(
            this._name + " - expected scaleSteps to be an array of numbers"
          );
      }
      return (
        Object.defineProperty(t.prototype, "minFaceSize", {
          get: function () {
            return this._minFaceSize;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "scaleFactor", {
          get: function () {
            return this._scaleFactor;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "maxNumScales", {
          get: function () {
            return this._maxNumScales;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "scoreThresholds", {
          get: function () {
            return this._scoreThresholds;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, "scaleSteps", {
          get: function () {
            return this._scaleSteps;
          },
          enumerable: !0,
          configurable: !0,
        }),
        t
      );
    })();
    function de(t, e) {
      function n(n, r, i, o, s) {
        var u = a.Xc(t(n * r * i * i), [i, i, n, r]),
          c = a.Uc(t(r));
        return (
          e.push(
            { paramPath: o + "/filters" },
            { paramPath: o + "/" + (s ? "batch_norm_offset" : "bias") }
          ),
          { filters: u, bias: c }
        );
      }
      function r(t, e, r, i) {
        var a = n(t, e, r, i, !0);
        return { filters: a.filters, batch_norm_offset: a.bias };
      }
      function i(n, i, o) {
        return {
          depthwise_conv: (function (n, r) {
            var i = a.Xc(t(9 * n), [3, 3, n, 1]),
              o = a.Uc(t(n)),
              s = a.Uc(t(n)),
              u = a.Uc(t(n)),
              c = a.Uc(t(n));
            return (
              e.push(
                { paramPath: r + "/filters" },
                { paramPath: r + "/batch_norm_scale" },
                { paramPath: r + "/batch_norm_offset" },
                { paramPath: r + "/batch_norm_mean" },
                { paramPath: r + "/batch_norm_variance" }
              ),
              {
                filters: i,
                batch_norm_scale: o,
                batch_norm_offset: s,
                batch_norm_mean: u,
                batch_norm_variance: c,
              }
            );
          })(n, o + "/depthwise_conv"),
          pointwise_conv: r(n, i, 1, o + "/pointwise_conv"),
        };
      }
      return {
        extractMobilenetV1Params: function () {
          return {
            conv_0: r(3, 32, 3, "mobilenetv1/conv_0"),
            conv_1: i(32, 64, "mobilenetv1/conv_1"),
            conv_2: i(64, 128, "mobilenetv1/conv_2"),
            conv_3: i(128, 128, "mobilenetv1/conv_3"),
            conv_4: i(128, 256, "mobilenetv1/conv_4"),
            conv_5: i(256, 256, "mobilenetv1/conv_5"),
            conv_6: i(256, 512, "mobilenetv1/conv_6"),
            conv_7: i(512, 512, "mobilenetv1/conv_7"),
            conv_8: i(512, 512, "mobilenetv1/conv_8"),
            conv_9: i(512, 512, "mobilenetv1/conv_9"),
            conv_10: i(512, 512, "mobilenetv1/conv_10"),
            conv_11: i(512, 512, "mobilenetv1/conv_11"),
            conv_12: i(512, 1024, "mobilenetv1/conv_12"),
            conv_13: i(1024, 1024, "mobilenetv1/conv_13"),
          };
        },
        extractPredictionLayerParams: function () {
          return {
            conv_0: r(1024, 256, 1, "prediction_layer/conv_0"),
            conv_1: r(256, 512, 3, "prediction_layer/conv_1"),
            conv_2: r(512, 128, 1, "prediction_layer/conv_2"),
            conv_3: r(128, 256, 3, "prediction_layer/conv_3"),
            conv_4: r(256, 128, 1, "prediction_layer/conv_4"),
            conv_5: r(128, 256, 3, "prediction_layer/conv_5"),
            conv_6: r(256, 64, 1, "prediction_layer/conv_6"),
            conv_7: r(64, 128, 3, "prediction_layer/conv_7"),
            box_predictor_0: {
              box_encoding_predictor: n(
                512,
                12,
                1,
                "prediction_layer/box_predictor_0/box_encoding_predictor"
              ),
              class_predictor: n(
                512,
                9,
                1,
                "prediction_layer/box_predictor_0/class_predictor"
              ),
            },
            box_predictor_1: {
              box_encoding_predictor: n(
                1024,
                24,
                1,
                "prediction_layer/box_predictor_1/box_encoding_predictor"
              ),
              class_predictor: n(
                1024,
                18,
                1,
                "prediction_layer/box_predictor_1/class_predictor"
              ),
            },
            box_predictor_2: {
              box_encoding_predictor: n(
                512,
                24,
                1,
                "prediction_layer/box_predictor_2/box_encoding_predictor"
              ),
              class_predictor: n(
                512,
                18,
                1,
                "prediction_layer/box_predictor_2/class_predictor"
              ),
            },
            box_predictor_3: {
              box_encoding_predictor: n(
                256,
                24,
                1,
                "prediction_layer/box_predictor_3/box_encoding_predictor"
              ),
              class_predictor: n(
                256,
                18,
                1,
                "prediction_layer/box_predictor_3/class_predictor"
              ),
            },
            box_predictor_4: {
              box_encoding_predictor: n(
                256,
                24,
                1,
                "prediction_layer/box_predictor_4/box_encoding_predictor"
              ),
              class_predictor: n(
                256,
                18,
                1,
                "prediction_layer/box_predictor_4/class_predictor"
              ),
            },
            box_predictor_5: {
              box_encoding_predictor: n(
                128,
                24,
                1,
                "prediction_layer/box_predictor_5/box_encoding_predictor"
              ),
              class_predictor: n(
                128,
                18,
                1,
                "prediction_layer/box_predictor_5/class_predictor"
              ),
            },
          };
        },
      };
    }
    function me(t) {
      var e = [],
        n = (function (t, e) {
          var n = St(t, e);
          function r(t, e, r) {
            return {
              filters: n(
                t + "/Conv2d_" + e + "_pointwise/weights",
                4,
                r + "/filters"
              ),
              batch_norm_offset: n(
                t + "/Conv2d_" + e + "_pointwise/convolution_bn_offset",
                1,
                r + "/batch_norm_offset"
              ),
            };
          }
          function i(t) {
            var e = "mobilenetv1/conv_" + t,
              i = "MobilenetV1/Conv2d_" + t + "_depthwise",
              a = e + "/depthwise_conv",
              o = e + "/pointwise_conv";
            return {
              depthwise_conv: {
                filters: n(i + "/depthwise_weights", 4, a + "/filters"),
                batch_norm_scale: n(
                  i + "/BatchNorm/gamma",
                  1,
                  a + "/batch_norm_scale"
                ),
                batch_norm_offset: n(
                  i + "/BatchNorm/beta",
                  1,
                  a + "/batch_norm_offset"
                ),
                batch_norm_mean: n(
                  i + "/BatchNorm/moving_mean",
                  1,
                  a + "/batch_norm_mean"
                ),
                batch_norm_variance: n(
                  i + "/BatchNorm/moving_variance",
                  1,
                  a + "/batch_norm_variance"
                ),
              },
              pointwise_conv: r("MobilenetV1", t, o),
            };
          }
          function a(t, e) {
            return {
              filters: n(t + "/weights", 4, e + "/filters"),
              bias: n(t + "/biases", 1, e + "/bias"),
            };
          }
          function o(t) {
            return {
              box_encoding_predictor: a(
                "Prediction/BoxPredictor_" + t + "/BoxEncodingPredictor",
                "prediction_layer/box_predictor_" +
                  t +
                  "/box_encoding_predictor"
              ),
              class_predictor: a(
                "Prediction/BoxPredictor_" + t + "/ClassPredictor",
                "prediction_layer/box_predictor_" + t + "/class_predictor"
              ),
            };
          }
          return {
            extractMobilenetV1Params: function () {
              return {
                conv_0: r("MobilenetV1", 0, "mobilenetv1/conv_0"),
                conv_1: i(1),
                conv_2: i(2),
                conv_3: i(3),
                conv_4: i(4),
                conv_5: i(5),
                conv_6: i(6),
                conv_7: i(7),
                conv_8: i(8),
                conv_9: i(9),
                conv_10: i(10),
                conv_11: i(11),
                conv_12: i(12),
                conv_13: i(13),
              };
            },
            extractPredictionLayerParams: function () {
              return {
                conv_0: r("Prediction", 0, "prediction_layer/conv_0"),
                conv_1: r("Prediction", 1, "prediction_layer/conv_1"),
                conv_2: r("Prediction", 2, "prediction_layer/conv_2"),
                conv_3: r("Prediction", 3, "prediction_layer/conv_3"),
                conv_4: r("Prediction", 4, "prediction_layer/conv_4"),
                conv_5: r("Prediction", 5, "prediction_layer/conv_5"),
                conv_6: r("Prediction", 6, "prediction_layer/conv_6"),
                conv_7: r("Prediction", 7, "prediction_layer/conv_7"),
                box_predictor_0: o(0),
                box_predictor_1: o(1),
                box_predictor_2: o(2),
                box_predictor_3: o(3),
                box_predictor_4: o(4),
                box_predictor_5: o(5),
              };
            },
          };
        })(t, e),
        r = n.extractMobilenetV1Params,
        i = n.extractPredictionLayerParams,
        a = t["Output/extra_dim"];
      if (
        (e.push({
          originalPath: "Output/extra_dim",
          paramPath: "output_layer/extra_dim",
        }),
        !l(a))
      )
        throw new Error(
          "expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have " +
            a
        );
      var o = {
        mobilenetv1: r(),
        prediction_layer: i(),
        output_layer: { extra_dim: a },
      };
      return bt(t, e), { params: o, paramMappings: e };
    }
    function ve(t, e, n) {
      return a.Zc(function () {
        var r = a.K(t, e.filters, n, "same");
        return (r = a.g(r, e.batch_norm_offset)), a.C(r, 0, 6);
      });
    }
    function ge(t, e) {
      return a.Zc(function () {
        var n = null,
          r = ve(t, e.conv_0, [2, 2]);
        if (
          ([
            e.conv_1,
            e.conv_2,
            e.conv_3,
            e.conv_4,
            e.conv_5,
            e.conv_6,
            e.conv_7,
            e.conv_8,
            e.conv_9,
            e.conv_10,
            e.conv_11,
            e.conv_12,
            e.conv_13,
          ].forEach(function (t, e) {
            var i = e + 1,
              o = (function (t) {
                return [2, 4, 6, 12].some(function (e) {
                  return e === t;
                })
                  ? [2, 2]
                  : [1, 1];
              })(i);
            (r = ve(
              (r = (function (t, e, n) {
                return a.Zc(function () {
                  var r = a.R(t, e.filters, n, "same");
                  return (
                    (r = a.u(
                      r,
                      e.batch_norm_mean,
                      e.batch_norm_variance,
                      e.batch_norm_offset,
                      e.batch_norm_scale,
                      0.0010000000474974513
                    )),
                    a.C(r, 0, 6)
                  );
                });
              })(r, t.depthwise_conv, o)),
              t.pointwise_conv,
              [1, 1]
            )),
              11 === i && (n = r);
          }),
          null === n)
        )
          throw new Error("mobileNetV1 - output of conv layer 11 is null");
        return { out: r, conv11: n };
      });
    }
    function ye(t, e, n) {
      var r = t.arraySync(),
        i = Math.min(r[e][0], r[e][2]),
        a = Math.min(r[e][1], r[e][3]),
        o = Math.max(r[e][0], r[e][2]),
        s = Math.max(r[e][1], r[e][3]),
        u = Math.min(r[n][0], r[n][2]),
        c = Math.min(r[n][1], r[n][3]),
        l = Math.max(r[n][0], r[n][2]),
        p = Math.max(r[n][1], r[n][3]),
        h = (o - i) * (s - a),
        f = (l - u) * (p - c);
      if (h <= 0 || f <= 0) return 0;
      var d = Math.max(i, u),
        m = Math.max(a, c),
        v = Math.min(o, l),
        g = Math.min(s, p),
        y = Math.max(v - d, 0) * Math.max(g - m, 0);
      return y / (h + f - y);
    }
    function be(t, e) {
      var n = (function (t) {
          var e = a.fd(a.dd(t, [1, 0])),
            n = [a.Pc(e[2], e[0]), a.Pc(e[3], e[1])];
          return {
            sizes: n,
            centers: [
              a.g(e[0], a.T(n[0], a.pc(2))),
              a.g(e[1], a.T(n[1], a.pc(2))),
            ],
          };
        })(t),
        r = n.sizes,
        i = n.centers,
        o = a.fd(a.dd(e, [1, 0])),
        s = a.T(a.Rb(a.bb(a.T(o[2], a.pc(5))), r[0]), a.pc(2)),
        u = a.g(a.Rb(a.T(o[0], a.pc(10)), r[0]), i[0]),
        c = a.T(a.Rb(a.bb(a.T(o[3], a.pc(5))), r[1]), a.pc(2)),
        l = a.g(a.Rb(a.T(o[1], a.pc(10)), r[1]), i[1]);
      return a.dd(a.Nc([a.Pc(u, s), a.Pc(l, c), a.g(u, s), a.g(l, c)]), [1, 0]);
    }
    function we(t, e) {
      return a.Zc(function () {
        var n = t.shape[0];
        return {
          boxPredictionEncoding: a.kc(yt(t, e.box_encoding_predictor), [
            n,
            -1,
            1,
            4,
          ]),
          classPrediction: a.kc(yt(t, e.class_predictor), [n, -1, 3]),
        };
      });
    }
    var xe = (function () {
        function t(t) {
          var e = void 0 === t ? {} : t,
            n = e.minConfidence,
            r = e.maxResults;
          if (
            ((this._name = "SsdMobilenetv1Options"),
            (this._minConfidence = n || 0.5),
            (this._maxResults = r || 100),
            "number" != typeof this._minConfidence ||
              this._minConfidence <= 0 ||
              this._minConfidence >= 1)
          )
            throw new Error(
              this._name +
                " - expected minConfidence to be a number between 0 and 1"
            );
          if ("number" != typeof this._maxResults)
            throw new Error(
              this._name + " - expected maxResults to be a number"
            );
        }
        return (
          Object.defineProperty(t.prototype, "minConfidence", {
            get: function () {
              return this._minConfidence;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "maxResults", {
            get: function () {
              return this._maxResults;
            },
            enumerable: !0,
            configurable: !0,
          }),
          t
        );
      })(),
      Ce = (function (t) {
        function e() {
          return t.call(this, "SsdMobilenetv1") || this;
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.forwardInput = function (t) {
            var e = this.params;
            if (!e)
              throw new Error("SsdMobilenetv1 - load model before inference");
            return a.Zc(function () {
              var n = t.toBatchTensor(512, !1).toFloat(),
                r = ge(
                  a.Pc(a.Rb(n, a.pc(0.007843137718737125)), a.pc(1)),
                  e.mobilenetv1
                ),
                i = (function (t, e, n) {
                  return a.Zc(function () {
                    var r = ve(t, n.conv_0, [1, 1]),
                      i = ve(r, n.conv_1, [2, 2]),
                      o = ve(i, n.conv_2, [1, 1]),
                      s = ve(o, n.conv_3, [2, 2]),
                      u = ve(s, n.conv_4, [1, 1]),
                      c = ve(u, n.conv_5, [2, 2]),
                      l = ve(c, n.conv_6, [1, 1]),
                      p = ve(l, n.conv_7, [2, 2]),
                      h = we(e, n.box_predictor_0),
                      f = we(t, n.box_predictor_1),
                      d = we(i, n.box_predictor_2),
                      m = we(s, n.box_predictor_3),
                      v = we(c, n.box_predictor_4),
                      g = we(p, n.box_predictor_5);
                    return {
                      boxPredictions: a.E(
                        [
                          h.boxPredictionEncoding,
                          f.boxPredictionEncoding,
                          d.boxPredictionEncoding,
                          m.boxPredictionEncoding,
                          v.boxPredictionEncoding,
                          g.boxPredictionEncoding,
                        ],
                        1
                      ),
                      classPredictions: a.E(
                        [
                          h.classPrediction,
                          f.classPrediction,
                          d.classPrediction,
                          m.classPrediction,
                          v.classPrediction,
                          g.classPrediction,
                        ],
                        1
                      ),
                    };
                  });
                })(r.out, r.conv11, e.prediction_layer);
              return (function (t, e, n) {
                return a.Zc(function () {
                  var r = t.shape[0],
                    i = be(
                      a.kc(a.ad(n.extra_dim, [r, 1, 1]), [-1, 4]),
                      a.kc(t, [-1, 4])
                    );
                  i = a.kc(i, [r, i.shape[0] / r, 4]);
                  var o = a.vc(a.zc(e, [0, 0, 1], [-1, -1, -1])),
                    s = a.zc(o, [0, 0, 0], [-1, -1, 1]);
                  return (
                    (s = a.kc(s, [r, s.shape[1]])),
                    { boxes: a.fd(i), scores: a.fd(s) }
                  );
                });
              })(i.boxPredictions, i.classPredictions, e.output_layer);
            });
          }),
          (e.prototype.forward = function (t) {
            return Object(s.b)(this, void 0, void 0, function () {
              var e;
              return Object(s.d)(this, function (n) {
                switch (n.label) {
                  case 0:
                    return (e = this.forwardInput), [4, st(t)];
                  case 1:
                    return [2, e.apply(this, [n.sent()])];
                }
              });
            });
          }),
          (e.prototype.locateFaces = function (t, e) {
            return (
              void 0 === e && (e = {}),
              Object(s.b)(this, void 0, void 0, function () {
                var n, r, i, a, o, u, c, l, p, h, f, d, m, v, g, y, b, w, x, C;
                return Object(s.d)(this, function (s) {
                  switch (s.label) {
                    case 0:
                      return (
                        (n = new xe(e)),
                        (r = n.maxResults),
                        (i = n.minConfidence),
                        [4, st(t)]
                      );
                    case 1:
                      for (
                        a = s.sent(),
                          o = this.forwardInput(a),
                          u = o.boxes,
                          c = o.scores,
                          l = u[0],
                          p = c[0],
                          h = 1;
                        h < u.length;
                        h++
                      )
                        u[h].dispose(), c[h].dispose();
                      return (m = (d = Array).from), [4, p.data()];
                    case 2:
                      return (
                        (f = m.apply(d, [s.sent()])),
                        0.5,
                        (v = (function (t, e, n, r, i) {
                          var a = t.shape[0],
                            o = Math.min(n, a),
                            s = e
                              .map(function (t, e) {
                                return { score: t, boxIndex: e };
                              })
                              .filter(function (t) {
                                return t.score > i;
                              })
                              .sort(function (t, e) {
                                return e.score - t.score;
                              }),
                            u = [];
                          return (
                            s.forEach(function (e) {
                              if (!(u.length >= o)) {
                                for (
                                  var n = e.score, a = u.length - 1;
                                  a >= 0;
                                  --a
                                ) {
                                  var s = ye(t, e.boxIndex, u[a]);
                                  if (
                                    0 !== s &&
                                    ((e.score *= s <= r ? 1 : 0), e.score <= i)
                                  )
                                    break;
                                }
                                n === e.score && u.push(e.boxIndex);
                              }
                            }),
                            u
                          );
                        })(l, f, r, 0.5, i)),
                        (g = a.getReshapedInputDimensions(0)),
                        (y = a.inputSize),
                        (b = y / g.width),
                        (w = y / g.height),
                        (x = l.arraySync()),
                        (C = v.map(function (t) {
                          var e = [
                              Math.max(0, x[t][0]),
                              Math.min(1, x[t][2]),
                            ].map(function (t) {
                              return t * w;
                            }),
                            n = e[0],
                            r = e[1],
                            i = [
                              Math.max(0, x[t][1]),
                              Math.min(1, x[t][3]),
                            ].map(function (t) {
                              return t * b;
                            }),
                            o = i[0],
                            s = i[1];
                          return new O(f[t], new k(o, n, s - o, r - n), {
                            height: a.getInputHeight(0),
                            width: a.getInputWidth(0),
                          });
                        })),
                        l.dispose(),
                        p.dispose(),
                        [2, C]
                      );
                  }
                });
              })
            );
          }),
          (e.prototype.getDefaultModelName = function () {
            return "ssd_mobilenetv1_model";
          }),
          (e.prototype.extractParamsFromWeigthMap = function (t) {
            return me(t);
          }),
          (e.prototype.extractParams = function (t) {
            return (function (t) {
              var e = [],
                n = Nt(t),
                r = n.extractWeights,
                i = n.getRemainingWeights,
                o = de(r, e),
                s = o.extractMobilenetV1Params,
                u = o.extractPredictionLayerParams,
                c = s(),
                l = u(),
                p = { extra_dim: a.Wc(r(20472), [1, 5118, 4]) };
              if (
                (e.push({ paramPath: "output_layer/extra_dim" }),
                0 !== i().length)
              )
                throw new Error("weights remaing after extract: " + i().length);
              return {
                params: {
                  mobilenetv1: c,
                  prediction_layer: l,
                  output_layer: p,
                },
                paramMappings: e,
              };
            })(t);
          }),
          e
        );
      })(dt);
    !(function (t) {
      function e() {
        return (null !== t && t.apply(this, arguments)) || this;
      }
      Object(s.c)(e, t);
    })(Ce);
    var Oe,
      Ee = [
        new b(0.738768, 0.874946),
        new b(2.42204, 2.65704),
        new b(4.30971, 7.04493),
        new b(10.246, 4.59428),
        new b(12.6868, 11.8741),
      ],
      Se = [
        new b(1.603231, 2.094468),
        new b(6.041143, 7.080126),
        new b(2.882459, 3.518061),
        new b(4.266906, 5.178857),
        new b(9.041765, 10.66308),
      ],
      Ne = [117.001, 114.697, 97.404],
      Ie = function (t) {
        return "number" == typeof t;
      };
    function ke(t) {
      return a.Zc(function () {
        var e = a.Rb(t, a.pc(0.10000000149011612));
        return a.g(a.jc(a.Pc(t, e)), e);
      });
    }
    function _e(t, e) {
      return a.Zc(function () {
        var n = a.ac(t, [
          [0, 0],
          [1, 1],
          [1, 1],
          [0, 0],
        ]);
        return (
          (n = a.K(n, e.conv.filters, [1, 1], "valid")),
          (n = a.Pc(n, e.bn.sub)),
          (n = a.Rb(n, e.bn.truediv)),
          ke((n = a.g(n, e.conv.bias)))
        );
      });
    }
    function Ae(t, e) {
      return a.Zc(function () {
        var n = a.ac(t, [
          [0, 0],
          [1, 1],
          [1, 1],
          [0, 0],
        ]);
        return (
          (n = a.sc(
            n,
            e.depthwise_filter,
            e.pointwise_filter,
            [1, 1],
            "valid"
          )),
          ke((n = a.g(n, e.bias)))
        );
      });
    }
    function Te(t, e) {
      var n = wt(t, e);
      var r = Ot(t, e);
      return {
        extractConvParams: n,
        extractConvWithBatchNormParams: function (r, i, o) {
          return {
            conv: n(r, i, 3, o + "/conv"),
            bn: (function (n, r) {
              var i = a.Uc(t(n)),
                o = a.Uc(t(n));
              return (
                e.push(
                  { paramPath: r + "/sub" },
                  { paramPath: r + "/truediv" }
                ),
                { sub: i, truediv: o }
              );
            })(i, o + "/bn"),
          };
        },
        extractSeparableConvParams: r,
      };
    }
    function Re(t, e) {
      var n = St(t, e);
      function r(t) {
        return { filters: n(t + "/filters", 4), bias: n(t + "/bias", 1) };
      }
      return {
        extractConvParams: r,
        extractConvWithBatchNormParams: function (t) {
          return {
            conv: r(t + "/conv"),
            bn: (function (t) {
              return { sub: n(t + "/sub", 1), truediv: n(t + "/truediv", 1) };
            })(t + "/bn"),
          };
        },
        extractSeparableConvParams: Et(n),
      };
    }
    !(function (t) {
      (t[(t.XS = 224)] = "XS"),
        (t[(t.SM = 320)] = "SM"),
        (t[(t.MD = 416)] = "MD"),
        (t[(t.LG = 608)] = "LG");
    })(Oe || (Oe = {}));
    var De = (function () {
        function t(t) {
          var e = void 0 === t ? {} : t,
            n = e.inputSize,
            r = e.scoreThreshold;
          if (
            ((this._name = "TinyYolov2Options"),
            (this._inputSize = n || 416),
            (this._scoreThreshold = r || 0.5),
            "number" != typeof this._inputSize || this._inputSize % 32 != 0)
          )
            throw new Error(
              this._name +
                " - expected inputSize to be a number divisible by 32"
            );
          if (
            "number" != typeof this._scoreThreshold ||
            this._scoreThreshold <= 0 ||
            this._scoreThreshold >= 1
          )
            throw new Error(
              this._name +
                " - expected scoreThreshold to be a number between 0 and 1"
            );
        }
        return (
          Object.defineProperty(t.prototype, "inputSize", {
            get: function () {
              return this._inputSize;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "scoreThreshold", {
            get: function () {
              return this._scoreThreshold;
            },
            enumerable: !0,
            configurable: !0,
          }),
          t
        );
      })(),
      Fe = (function (t) {
        function e(e) {
          var n = t.call(this, "TinyYolov2") || this;
          return (
            (function (t) {
              if (!t) throw new Error("invalid config: " + t);
              if ("boolean" != typeof t.withSeparableConvs)
                throw new Error(
                  "config.withSeparableConvs has to be a boolean, have: " +
                    t.withSeparableConvs
                );
              if (
                !Ie(t.iouThreshold) ||
                t.iouThreshold < 0 ||
                t.iouThreshold > 1
              )
                throw new Error(
                  "config.iouThreshold has to be a number between [0, 1], have: " +
                    t.iouThreshold
                );
              if (
                !Array.isArray(t.classes) ||
                !t.classes.length ||
                !t.classes.every(function (t) {
                  return "string" == typeof t;
                })
              )
                throw new Error(
                  "config.classes has to be an array class names: string[], have: " +
                    JSON.stringify(t.classes)
                );
              if (
                !Array.isArray(t.anchors) ||
                !t.anchors.length ||
                !t.anchors
                  .map(function (t) {
                    return t || {};
                  })
                  .every(function (t) {
                    return Ie(t.x) && Ie(t.y);
                  })
              )
                throw new Error(
                  "config.anchors has to be an array of { x: number, y: number }, have: " +
                    JSON.stringify(t.anchors)
                );
              if (
                t.meanRgb &&
                (!Array.isArray(t.meanRgb) ||
                  3 !== t.meanRgb.length ||
                  !t.meanRgb.every(Ie))
              )
                throw new Error(
                  "config.meanRgb has to be an array of shape [number, number, number], have: " +
                    JSON.stringify(t.meanRgb)
                );
            })(e),
            (n._config = e),
            n
          );
        }
        return (
          Object(s.c)(e, t),
          Object.defineProperty(e.prototype, "config", {
            get: function () {
              return this._config;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(e.prototype, "withClassScores", {
            get: function () {
              return (
                this.config.withClassScores || this.config.classes.length > 1
              );
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(e.prototype, "boxEncodingSize", {
            get: function () {
              return (
                5 + (this.withClassScores ? this.config.classes.length : 0)
              );
            },
            enumerable: !0,
            configurable: !0,
          }),
          (e.prototype.runTinyYolov2 = function (t, e) {
            var n = _e(t, e.conv0);
            return (
              (n = _e((n = a.Ib(n, [2, 2], [2, 2], "same")), e.conv1)),
              (n = _e((n = a.Ib(n, [2, 2], [2, 2], "same")), e.conv2)),
              (n = _e((n = a.Ib(n, [2, 2], [2, 2], "same")), e.conv3)),
              (n = _e((n = a.Ib(n, [2, 2], [2, 2], "same")), e.conv4)),
              (n = _e((n = a.Ib(n, [2, 2], [2, 2], "same")), e.conv5)),
              (n = _e((n = a.Ib(n, [2, 2], [1, 1], "same")), e.conv6)),
              yt((n = _e(n, e.conv7)), e.conv8, "valid", !1)
            );
          }),
          (e.prototype.runMobilenet = function (t, e) {
            var n = this.config.isFirstLayerConv2d
              ? ke(yt(t, e.conv0, "valid", !1))
              : Ae(t, e.conv0);
            return (
              (n = Ae((n = a.Ib(n, [2, 2], [2, 2], "same")), e.conv1)),
              (n = Ae((n = a.Ib(n, [2, 2], [2, 2], "same")), e.conv2)),
              (n = Ae((n = a.Ib(n, [2, 2], [2, 2], "same")), e.conv3)),
              (n = Ae((n = a.Ib(n, [2, 2], [2, 2], "same")), e.conv4)),
              (n = Ae((n = a.Ib(n, [2, 2], [2, 2], "same")), e.conv5)),
              (n = a.Ib(n, [2, 2], [1, 1], "same")),
              (n = e.conv6 ? Ae(n, e.conv6) : n),
              yt((n = e.conv7 ? Ae(n, e.conv7) : n), e.conv8, "valid", !1)
            );
          }),
          (e.prototype.forwardInput = function (t, e) {
            var n = this,
              r = this.params;
            if (!r) throw new Error("TinyYolov2 - load model before inference");
            return a.Zc(function () {
              var i = t.toBatchTensor(e, !1).toFloat();
              return (
                (i = (i = n.config.meanRgb ? N(i, n.config.meanRgb) : i).div(
                  a.pc(256)
                )),
                n.config.withSeparableConvs
                  ? n.runMobilenet(i, r)
                  : n.runTinyYolov2(i, r)
              );
            });
          }),
          (e.prototype.forward = function (t, e) {
            return Object(s.b)(this, void 0, void 0, function () {
              var n;
              return Object(s.d)(this, function (r) {
                switch (r.label) {
                  case 0:
                    return (n = this.forwardInput), [4, st(t)];
                  case 1:
                    return [4, n.apply(this, [r.sent(), e])];
                  case 2:
                    return [2, r.sent()];
                }
              });
            });
          }),
          (e.prototype.detect = function (t, e) {
            return (
              void 0 === e && (e = {}),
              Object(s.b)(this, void 0, void 0, function () {
                var n,
                  r,
                  i,
                  o,
                  u,
                  c,
                  l,
                  p,
                  h,
                  f,
                  d,
                  m,
                  v,
                  g = this;
                return Object(s.d)(this, function (s) {
                  switch (s.label) {
                    case 0:
                      return (
                        (n = new De(e)),
                        (r = n.inputSize),
                        (i = n.scoreThreshold),
                        [4, st(t)]
                      );
                    case 1:
                      return (o = s.sent()), [4, this.forwardInput(o, r)];
                    case 2:
                      return (
                        (u = s.sent()),
                        (c = a.Zc(function () {
                          return a.fd(u)[0].expandDims();
                        })),
                        (l = {
                          width: o.getInputWidth(0),
                          height: o.getInputHeight(0),
                        }),
                        [
                          4,
                          this.extractBoxes(
                            c,
                            o.getReshapedInputDimensions(0),
                            i
                          ),
                        ]
                      );
                    case 3:
                      return (
                        (p = s.sent()),
                        u.dispose(),
                        c.dispose(),
                        (h = p.map(function (t) {
                          return t.box;
                        })),
                        (f = p.map(function (t) {
                          return t.score;
                        })),
                        (d = p.map(function (t) {
                          return t.classScore;
                        })),
                        (m = p.map(function (t) {
                          return g.config.classes[t.label];
                        })),
                        (v = S(
                          h.map(function (t) {
                            return t.rescale(r);
                          }),
                          f,
                          this.config.iouThreshold,
                          !0
                        )),
                        [
                          2,
                          v.map(function (t) {
                            return new C(f[t], d[t], m[t], h[t], l);
                          }),
                        ]
                      );
                  }
                });
              })
            );
          }),
          (e.prototype.getDefaultModelName = function () {
            return "";
          }),
          (e.prototype.extractParamsFromWeigthMap = function (t) {
            return (function (t, e) {
              var n,
                r = [],
                i = Re(t, r),
                a = i.extractConvParams,
                o = i.extractConvWithBatchNormParams,
                s = i.extractSeparableConvParams;
              if (e.withSeparableConvs) {
                var u = (e.filterSizes && e.filterSizes.length) || 9;
                n = {
                  conv0: e.isFirstLayerConv2d ? a("conv0") : s("conv0"),
                  conv1: s("conv1"),
                  conv2: s("conv2"),
                  conv3: s("conv3"),
                  conv4: s("conv4"),
                  conv5: s("conv5"),
                  conv6: u > 7 ? s("conv6") : void 0,
                  conv7: u > 8 ? s("conv7") : void 0,
                  conv8: a("conv8"),
                };
              } else
                n = {
                  conv0: o("conv0"),
                  conv1: o("conv1"),
                  conv2: o("conv2"),
                  conv3: o("conv3"),
                  conv4: o("conv4"),
                  conv5: o("conv5"),
                  conv6: o("conv6"),
                  conv7: o("conv7"),
                  conv8: a("conv8"),
                };
              return bt(t, r), { params: n, paramMappings: r };
            })(t, this.config);
          }),
          (e.prototype.extractParams = function (t) {
            var n = this.config.filterSizes || e.DEFAULT_FILTER_SIZES,
              r = n ? n.length : void 0;
            if (7 !== r && 8 !== r && 9 !== r)
              throw new Error(
                "TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found " +
                  r +
                  " filterSizes in config"
              );
            return (function (t, e, n, r) {
              var i,
                a = Nt(t),
                o = a.extractWeights,
                s = a.getRemainingWeights,
                u = [],
                c = Te(o, u),
                l = c.extractConvParams,
                p = c.extractConvWithBatchNormParams,
                h = c.extractSeparableConvParams;
              if (e.withSeparableConvs) {
                var f = r[0],
                  d = r[1],
                  m = r[2],
                  v = r[3],
                  g = r[4],
                  y = r[5],
                  b = r[6],
                  w = r[7],
                  x = r[8];
                i = {
                  conv0: e.isFirstLayerConv2d
                    ? l(f, d, 3, "conv0")
                    : h(f, d, "conv0"),
                  conv1: h(d, m, "conv1"),
                  conv2: h(m, v, "conv2"),
                  conv3: h(v, g, "conv3"),
                  conv4: h(g, y, "conv4"),
                  conv5: h(y, b, "conv5"),
                  conv6: w ? h(b, w, "conv6") : void 0,
                  conv7: x ? h(w, x, "conv7") : void 0,
                  conv8: l(x || w || b, 5 * n, 1, "conv8"),
                };
              } else {
                (f = r[0]),
                  (d = r[1]),
                  (m = r[2]),
                  (v = r[3]),
                  (g = r[4]),
                  (y = r[5]),
                  (b = r[6]),
                  (w = r[7]),
                  (x = r[8]);
                i = {
                  conv0: p(f, d, "conv0"),
                  conv1: p(d, m, "conv1"),
                  conv2: p(m, v, "conv2"),
                  conv3: p(v, g, "conv3"),
                  conv4: p(g, y, "conv4"),
                  conv5: p(y, b, "conv5"),
                  conv6: p(b, w, "conv6"),
                  conv7: p(w, x, "conv7"),
                  conv8: l(x, 5 * n, 1, "conv8"),
                };
              }
              if (0 !== s().length)
                throw new Error("weights remaing after extract: " + s().length);
              return { params: i, paramMappings: u };
            })(t, this.config, this.boxEncodingSize, n);
          }),
          (e.prototype.extractBoxes = function (t, e, n) {
            return Object(s.b)(this, void 0, void 0, function () {
              var r,
                i,
                o,
                u,
                c,
                l,
                p,
                h,
                f,
                d,
                m,
                v,
                g,
                y,
                b,
                w,
                C,
                O,
                E,
                S,
                N,
                k,
                _,
                A,
                T,
                R,
                D,
                F,
                M,
                j = this;
              return Object(s.d)(this, function (P) {
                switch (P.label) {
                  case 0:
                    return (
                      (r = e.width),
                      (i = e.height),
                      (o = Math.max(r, i)),
                      (u = o / r),
                      (c = o / i),
                      (l = t.shape[1]),
                      (p = this.config.anchors.length),
                      (h = a.Zc(function () {
                        var e = t.reshape([l, l, p, j.boxEncodingSize]);
                        return [
                          e.slice([0, 0, 0, 0], [l, l, p, 4]),
                          e.slice([0, 0, 0, 4], [l, l, p, 1]),
                          j.withClassScores
                            ? a.Ec(
                                e.slice(
                                  [0, 0, 0, 5],
                                  [l, l, p, j.config.classes.length]
                                ),
                                3
                              )
                            : a.pc(0),
                        ];
                      })),
                      (f = h[0]),
                      (d = h[1]),
                      (m = h[2]),
                      (v = []),
                      [4, d.array()]
                    );
                  case 1:
                    return (g = P.sent()), [4, f.array()];
                  case 2:
                    (y = P.sent()), (b = 0), (P.label = 3);
                  case 3:
                    if (!(b < l)) return [3, 12];
                    (w = 0), (P.label = 4);
                  case 4:
                    if (!(w < l)) return [3, 11];
                    (C = 0), (P.label = 5);
                  case 5:
                    return C < p
                      ? ((O = I(g[b][w][C][0])),
                        !n || O > n
                          ? ((E = ((w + I(y[b][w][C][0])) / l) * u),
                            (S = ((b + I(y[b][w][C][1])) / l) * c),
                            (N =
                              ((Math.exp(y[b][w][C][2]) *
                                this.config.anchors[C].x) /
                                l) *
                              u),
                            (k =
                              ((Math.exp(y[b][w][C][3]) *
                                this.config.anchors[C].y) /
                                l) *
                              c),
                            (_ = E - N / 2),
                            (A = S - k / 2),
                            (T = { row: b, col: w, anchor: C }),
                            this.withClassScores
                              ? [4, this.extractPredictedClass(m, T)]
                              : [3, 7])
                          : [3, 9])
                      : [3, 10];
                  case 6:
                    return (M = P.sent()), [3, 8];
                  case 7:
                    (M = { classScore: 1, label: 0 }), (P.label = 8);
                  case 8:
                    (D = (R = M).classScore),
                      (F = R.label),
                      v.push(
                        Object(s.a)(
                          {
                            box: new x(_, A, _ + N, A + k),
                            score: O,
                            classScore: O * D,
                            label: F,
                          },
                          T
                        )
                      ),
                      (P.label = 9);
                  case 9:
                    return C++, [3, 5];
                  case 10:
                    return w++, [3, 4];
                  case 11:
                    return b++, [3, 3];
                  case 12:
                    return f.dispose(), d.dispose(), m.dispose(), [2, v];
                }
              });
            });
          }),
          (e.prototype.extractPredictedClass = function (t, e) {
            return Object(s.b)(this, void 0, void 0, function () {
              var n, r, i, a;
              return Object(s.d)(this, function (o) {
                switch (o.label) {
                  case 0:
                    return (
                      (n = e.row), (r = e.col), (i = e.anchor), [4, t.array()]
                    );
                  case 1:
                    return (
                      (a = o.sent()),
                      [
                        2,
                        Array(this.config.classes.length)
                          .fill(0)
                          .map(function (t, e) {
                            return a[n][r][i][e];
                          })
                          .map(function (t, e) {
                            return { classScore: t, label: e };
                          })
                          .reduce(function (t, e) {
                            return t.classScore > e.classScore ? t : e;
                          }),
                      ]
                    );
                }
              });
            });
          }),
          (e.DEFAULT_FILTER_SIZES = [3, 16, 32, 64, 128, 256, 512, 1024, 1024]),
          e
        );
      })(dt),
      Me = (function (t) {
        function e(e) {
          void 0 === e && (e = !0);
          var n = Object.assign(
            {},
            { withSeparableConvs: e, iouThreshold: 0.4, classes: ["face"] },
            e
              ? { anchors: Se, meanRgb: Ne }
              : { anchors: Ee, withClassScores: !0 }
          );
          return t.call(this, n) || this;
        }
        return (
          Object(s.c)(e, t),
          Object.defineProperty(e.prototype, "withSeparableConvs", {
            get: function () {
              return this.config.withSeparableConvs;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(e.prototype, "anchors", {
            get: function () {
              return this.config.anchors;
            },
            enumerable: !0,
            configurable: !0,
          }),
          (e.prototype.locateFaces = function (t, e) {
            return Object(s.b)(this, void 0, void 0, function () {
              return Object(s.d)(this, function (n) {
                switch (n.label) {
                  case 0:
                    return [4, this.detect(t, e)];
                  case 1:
                    return [
                      2,
                      n.sent().map(function (t) {
                        return new O(t.score, t.relativeBox, {
                          width: t.imageWidth,
                          height: t.imageHeight,
                        });
                      }),
                    ];
                }
              });
            });
          }),
          (e.prototype.getDefaultModelName = function () {
            return this.withSeparableConvs
              ? "tiny_yolov2_separable_conv_model"
              : "tiny_yolov2_model";
          }),
          (e.prototype.extractParamsFromWeigthMap = function (e) {
            return t.prototype.extractParamsFromWeigthMap.call(this, e);
          }),
          e
        );
      })(Fe);
    var je = (function (t) {
        function e() {
          var e = (null !== t && t.apply(this, arguments)) || this;
          return (e._name = "TinyFaceDetectorOptions"), e;
        }
        return Object(s.c)(e, t), e;
      })(De),
      Pe = (function () {
        function t() {}
        return (
          (t.prototype.then = function (t) {
            return Object(s.b)(this, void 0, void 0, function () {
              var e;
              return Object(s.d)(this, function (n) {
                switch (n.label) {
                  case 0:
                    return (e = t), [4, this.run()];
                  case 1:
                    return [2, e.apply(void 0, [n.sent()])];
                }
              });
            });
          }),
          (t.prototype.run = function () {
            return Object(s.b)(this, void 0, void 0, function () {
              return Object(s.d)(this, function (t) {
                throw new Error("ComposableTask - run is not implemented");
              });
            });
          }),
          t
        );
      })();
    function ze(t, e, n, r, i) {
      return (
        void 0 === i &&
          (i = function (t) {
            return t.alignedRect;
          }),
        Object(s.b)(this, void 0, void 0, function () {
          var o, u, c, l, p;
          return Object(s.d)(this, function (s) {
            switch (s.label) {
              case 0:
                return (
                  (o = t.map(function (t) {
                    return Lt(t) ? i(t) : t.detection;
                  })),
                  (c = r) ? [3, 5] : e instanceof a.b ? [4, ct(e, o)] : [3, 2]
                );
              case 1:
                return (l = s.sent()), [3, 4];
              case 2:
                return [4, ut(e, o)];
              case 3:
                (l = s.sent()), (s.label = 4);
              case 4:
                (c = l), (s.label = 5);
              case 5:
                return [4, n((u = c))];
              case 6:
                return (
                  (p = s.sent()),
                  u.forEach(function (t) {
                    return t instanceof a.b && t.dispose();
                  }),
                  [2, p]
                );
            }
          });
        })
      );
    }
    function Le(t, e, n, r, i) {
      return Object(s.b)(this, void 0, void 0, function () {
        var a = this;
        return Object(s.d)(this, function (o) {
          return [
            2,
            ze(
              [t],
              e,
              function (t) {
                return Object(s.b)(a, void 0, void 0, function () {
                  return Object(s.d)(this, function (e) {
                    return [2, n(t[0])];
                  });
                });
              },
              r,
              i
            ),
          ];
        });
      });
    }
    function Be(t) {
      var e = Nt(t),
        n = e.extractWeights,
        r = e.getRemainingWeights,
        i = [],
        o = (function (t, e) {
          var n = wt(t, e),
            r = xt(t, e);
          function i(n, r) {
            var i = a.Uc(t(n));
            return e.push({ paramPath: r }), i;
          }
          function o(t, e, r) {
            return (
              void 0 === r && (r = !1),
              {
                conv1: n(t[0], t[1], 3, e + "/conv1"),
                prelu1_alpha: i(t[1], e + "/prelu1_alpha"),
                conv2: n(t[1], t[2], 3, e + "/conv2"),
                prelu2_alpha: i(t[2], e + "/prelu2_alpha"),
                conv3: n(t[2], t[3], r ? 2 : 3, e + "/conv3"),
                prelu3_alpha: i(t[3], e + "/prelu3_alpha"),
              }
            );
          }
          return {
            extractPNetParams: function () {
              var t = o([3, 10, 16, 32], "pnet"),
                e = n(32, 2, 1, "pnet/conv4_1"),
                r = n(32, 4, 1, "pnet/conv4_2");
              return Object(s.a)(Object(s.a)({}, t), {
                conv4_1: e,
                conv4_2: r,
              });
            },
            extractRNetParams: function () {
              var t = o([3, 28, 48, 64], "rnet", !0),
                e = r(576, 128, "rnet/fc1"),
                n = i(128, "rnet/prelu4_alpha"),
                a = r(128, 2, "rnet/fc2_1"),
                u = r(128, 4, "rnet/fc2_2");
              return Object(s.a)(Object(s.a)({}, t), {
                fc1: e,
                prelu4_alpha: n,
                fc2_1: a,
                fc2_2: u,
              });
            },
            extractONetParams: function () {
              var t = o([3, 32, 64, 64], "onet"),
                e = n(64, 128, 2, "onet/conv4"),
                a = i(128, "onet/prelu4_alpha"),
                u = r(1152, 256, "onet/fc1"),
                c = i(256, "onet/prelu5_alpha"),
                l = r(256, 2, "onet/fc2_1"),
                p = r(256, 4, "onet/fc2_2"),
                h = r(256, 10, "onet/fc2_3");
              return Object(s.a)(Object(s.a)({}, t), {
                conv4: e,
                prelu4_alpha: a,
                fc1: u,
                prelu5_alpha: c,
                fc2_1: l,
                fc2_2: p,
                fc2_3: h,
              });
            },
          };
        })(n, i),
        u = o.extractPNetParams,
        c = o.extractRNetParams,
        l = o.extractONetParams,
        p = u(),
        h = c(),
        f = l();
      if (0 !== r().length)
        throw new Error("weights remaing after extract: " + r().length);
      return { params: { pnet: p, rnet: h, onet: f }, paramMappings: i };
    }
    function We(t) {
      var e = [],
        n = (function (t, e) {
          var n = St(t, e);
          function r(t) {
            return {
              filters: n(t + "/weights", 4, t + "/filters"),
              bias: n(t + "/bias", 1),
            };
          }
          function i(t) {
            return { weights: n(t + "/weights", 2), bias: n(t + "/bias", 1) };
          }
          function a(t) {
            return n(t, 1);
          }
          function o(t) {
            return {
              conv1: r(t + "/conv1"),
              prelu1_alpha: a(t + "/prelu1_alpha"),
              conv2: r(t + "/conv2"),
              prelu2_alpha: a(t + "/prelu2_alpha"),
              conv3: r(t + "/conv3"),
              prelu3_alpha: a(t + "/prelu3_alpha"),
            };
          }
          return {
            extractPNetParams: function () {
              var t = o("pnet"),
                e = r("pnet/conv4_1"),
                n = r("pnet/conv4_2");
              return Object(s.a)(Object(s.a)({}, t), {
                conv4_1: e,
                conv4_2: n,
              });
            },
            extractRNetParams: function () {
              var t = o("rnet"),
                e = i("rnet/fc1"),
                n = a("rnet/prelu4_alpha"),
                r = i("rnet/fc2_1"),
                u = i("rnet/fc2_2");
              return Object(s.a)(Object(s.a)({}, t), {
                fc1: e,
                prelu4_alpha: n,
                fc2_1: r,
                fc2_2: u,
              });
            },
            extractONetParams: function () {
              var t = o("onet"),
                e = r("onet/conv4"),
                n = a("onet/prelu4_alpha"),
                u = i("onet/fc1"),
                c = a("onet/prelu5_alpha"),
                l = i("onet/fc2_1"),
                p = i("onet/fc2_2"),
                h = i("onet/fc2_3");
              return Object(s.a)(Object(s.a)({}, t), {
                conv4: e,
                prelu4_alpha: n,
                fc1: u,
                prelu5_alpha: c,
                fc2_1: l,
                fc2_2: p,
                fc2_3: h,
              });
            },
          };
        })(t, e),
        r = n.extractPNetParams,
        i = n.extractRNetParams,
        a = n.extractONetParams,
        o = r(),
        u = i(),
        c = a();
      return (
        bt(t, e), { params: { pnet: o, rnet: u, onet: c }, paramMappings: e }
      );
    }
    function Ue(t, e) {
      var n = e[0],
        r = e[1];
      return { height: Math.floor(n * t), width: Math.floor(r * t) };
    }
    var Ve = (function (t) {
      function e(e, n, r, i) {
        return (
          t.call(this, { left: e, top: n, right: r, bottom: i }, !0) || this
        );
      }
      return Object(s.c)(e, t), e;
    })(w);
    function Ge(t) {
      return a.Zc(function () {
        return a.Rb(a.Pc(t, a.pc(127.5)), a.pc(0.0078125));
      });
    }
    function He(t, e) {
      return a.Zc(function () {
        return a.g(a.jc(t), a.Rb(e, a.Ub(a.jc(a.Ub(t)))));
      });
    }
    function qe(t, e, n) {
      return (
        void 0 === n && (n = !1),
        a.Zc(function () {
          var r = yt(t, e.conv1, "valid");
          return (
            (r = He(r, e.prelu1_alpha)),
            (r = He(
              (r = yt(
                (r = a.Ib(r, n ? [2, 2] : [3, 3], [2, 2], "same")),
                e.conv2,
                "valid"
              )),
              e.prelu2_alpha
            )),
            (r = He(
              (r = yt(
                (r = n ? r : a.Ib(r, [3, 3], [2, 2], "valid")),
                e.conv3,
                "valid"
              )),
              e.prelu3_alpha
            ))
          );
        })
      );
    }
    function Ke(t, e, n, r, i) {
      i.stage1 = [];
      var o = e
          .map(function (e) {
            return a.Zc(function () {
              var n = { scale: e },
                i = (function (t, e) {
                  return a.Zc(function () {
                    var n = Ue(e, t.shape.slice(1)),
                      r = n.height,
                      i = n.width,
                      o = Ge(a.qb.resizeBilinear(t, [r, i]));
                    return a.dd(o, [0, 2, 1, 3]);
                  });
                })(t, e),
                o = Date.now(),
                s = (function (t, e) {
                  return a.Zc(function () {
                    var n = qe(t, e, !0),
                      r = yt(n, e.conv4_1, "valid"),
                      i = a.cb(a.Hb(r, 3), 3);
                    return {
                      prob: a.Ec(a.Pc(r, i), 3),
                      regions: yt(n, e.conv4_2, "valid"),
                    };
                  });
                })(i, r),
                u = s.prob,
                c = s.regions;
              return (
                (n.pnet = Date.now() - o),
                {
                  scoresTensor: a.fd(a.fd(u, 3)[1])[0],
                  regionsTensor: a.fd(c)[0],
                  scale: e,
                  statsForScale: n,
                }
              );
            });
          })
          .map(function (t) {
            var e = t.scoresTensor,
              r = t.regionsTensor,
              a = t.scale,
              o = t.statsForScale,
              s = (function (t, e, n, r) {
                for (var i = [], a = t.arraySync(), o = 0; o < t.shape[0]; o++)
                  for (var s = 0; s < t.shape[1]; s++)
                    a[o][s] >= r && i.push(new b(s, o));
                return i.map(function (t) {
                  var r = new x(
                      Math.round((2 * t.y + 1) / n),
                      Math.round((2 * t.x + 1) / n),
                      Math.round((2 * t.y + 12) / n),
                      Math.round((2 * t.x + 12) / n)
                    ),
                    i = a[t.y][t.x],
                    o = e.arraySync();
                  return {
                    cell: r,
                    score: i,
                    region: new Ve(
                      o[t.y][t.x][0],
                      o[t.y][t.x][1],
                      o[t.y][t.x][2],
                      o[t.y][t.x][3]
                    ),
                  };
                });
              })(e, r, a, n);
            if ((e.dispose(), r.dispose(), !s.length))
              return i.stage1.push(o), [];
            var u = Date.now(),
              c = S(
                s.map(function (t) {
                  return t.cell;
                }),
                s.map(function (t) {
                  return t.score;
                }),
                0.5
              );
            return (
              (o.nms = Date.now() - u),
              (o.numBoxes = c.length),
              i.stage1.push(o),
              c.map(function (t) {
                return s[t];
              })
            );
          })
          .reduce(function (t, e) {
            return t.concat(e);
          }, []),
        s = [],
        u = [];
      if (o.length > 0) {
        var c = Date.now(),
          l = S(
            o.map(function (t) {
              return t.cell;
            }),
            o.map(function (t) {
              return t.score;
            }),
            0.7
          );
        (i.stage1_nms = Date.now() - c),
          (u = l.map(function (t) {
            return o[t].score;
          })),
          (s = l
            .map(function (t) {
              return o[t];
            })
            .map(function (t) {
              var e = t.cell,
                n = t.region;
              return new x(
                e.left + n.left * e.width,
                e.top + n.top * e.height,
                e.right + n.right * e.width,
                e.bottom + n.bottom * e.height
              )
                .toSquare()
                .round();
            }));
      }
      return { boxes: s, scores: u };
    }
    function Ze(t, e, n) {
      var r = n.width,
        i = n.height;
      return Object(s.b)(this, void 0, void 0, function () {
        var n,
          o,
          u,
          c = this;
        return Object(s.d)(this, function (l) {
          switch (l.label) {
            case 0:
              return (
                (n = Z(t)),
                [
                  4,
                  Promise.all(
                    e.map(function (e) {
                      return Object(s.b)(c, void 0, void 0, function () {
                        var r, i, a, o, u, c, l, p;
                        return Object(s.d)(this, function (s) {
                          return (
                            (r = e.padAtBorders(t.height, t.width)),
                            (i = r.y),
                            (a = r.ey),
                            (o = r.x),
                            (u = r.ex),
                            (c = o - 1),
                            (l = i - 1),
                            (p = n.getImageData(c, l, u - c, a - l)),
                            [2, q.isNodejs() ? rt(p) : createImageBitmap(p)]
                          );
                        });
                      });
                    })
                  ),
                ]
              );
            case 1:
              return (
                (o = l.sent()),
                (u = []),
                o.forEach(function (t) {
                  var e = Z(nt({ width: r, height: i }));
                  e.drawImage(t, 0, 0, r, i);
                  for (
                    var n = e.getImageData(0, 0, r, i).data, a = [], o = 0;
                    o < n.length;
                    o += 4
                  )
                    a.push(n[o + 2]), a.push(n[o + 1]), a.push(n[o]);
                  u.push(a);
                }),
                [
                  2,
                  u.map(function (t) {
                    return a.Zc(function () {
                      return Ge(
                        a.dd(a.Xc(t, [1, r, i, 3]), [0, 2, 1, 3]).toFloat()
                      );
                    });
                  }),
                ]
              );
          }
        });
      });
    }
    function Xe(t, e, n, r, i) {
      return Object(s.b)(this, void 0, void 0, function () {
        var o, u, c, l, p, h, f, d, m, v, g, y, b, w;
        return Object(s.d)(this, function (s) {
          switch (s.label) {
            case 0:
              return (o = Date.now()), [4, Ze(t, e, { width: 24, height: 24 })];
            case 1:
              return (
                (u = s.sent()),
                (i.stage2_extractImagePatches = Date.now() - o),
                (o = Date.now()),
                (c = u.map(function (t) {
                  var e = (function (t, e) {
                    return a.Zc(function () {
                      var n = qe(t, e),
                        r = He(
                          Tt(
                            a.kc(n, [n.shape[0], e.fc1.weights.shape[0]]),
                            e.fc1
                          ),
                          e.prelu4_alpha
                        ),
                        i = Tt(r, e.fc2_1),
                        o = a.cb(a.Hb(i, 1), 1),
                        s = a.Ec(a.Pc(i, o), 1),
                        u = Tt(r, e.fc2_2);
                      return { scores: a.fd(s, 1)[1], regions: u };
                    });
                  })(t, r);
                  return t.dispose(), e;
                })),
                (i.stage2_rnet = Date.now() - o),
                (l =
                  c.length > 1
                    ? a.E(
                        c.map(function (t) {
                          return t.scores;
                        })
                      )
                    : c[0].scores),
                (f = (h = Array).from),
                [4, l.data()]
              );
            case 2:
              return (
                (p = f.apply(h, [s.sent()])),
                l.dispose(),
                (d = p
                  .map(function (t, e) {
                    return { score: t, idx: e };
                  })
                  .filter(function (t) {
                    return t.score > n;
                  })
                  .map(function (t) {
                    return t.idx;
                  })),
                (m = d.map(function (t) {
                  return e[t];
                })),
                (v = d.map(function (t) {
                  return p[t];
                })),
                (g = []),
                (y = []),
                m.length > 0 &&
                  ((o = Date.now()),
                  (b = S(m, v, 0.7)),
                  (i.stage2_nms = Date.now() - o),
                  (w = b.map(function (t) {
                    var e = c[d[t]].regions.arraySync();
                    return new Ve(e[0][0], e[0][1], e[0][2], e[0][3]);
                  })),
                  (y = b.map(function (t) {
                    return v[t];
                  })),
                  (g = b.map(function (t, e) {
                    return m[t].calibrate(w[e]);
                  }))),
                c.forEach(function (t) {
                  t.regions.dispose(), t.scores.dispose();
                }),
                [2, { boxes: g, scores: y }]
              );
          }
        });
      });
    }
    function Ye(t, e, n, r, i) {
      return Object(s.b)(this, void 0, void 0, function () {
        var o, u, c, l, p, h, f, d, m, v, g, y, w, x, C;
        return Object(s.d)(this, function (s) {
          switch (s.label) {
            case 0:
              return (o = Date.now()), [4, Ze(t, e, { width: 48, height: 48 })];
            case 1:
              return (
                (u = s.sent()),
                (i.stage3_extractImagePatches = Date.now() - o),
                (o = Date.now()),
                (c = u.map(function (t) {
                  var e = (function (t, e) {
                    return a.Zc(function () {
                      var n = qe(t, e);
                      n = He(
                        (n = yt(
                          (n = a.Ib(n, [2, 2], [2, 2], "same")),
                          e.conv4,
                          "valid"
                        )),
                        e.prelu4_alpha
                      );
                      var r = He(
                          Tt(
                            a.kc(n, [n.shape[0], e.fc1.weights.shape[0]]),
                            e.fc1
                          ),
                          e.prelu5_alpha
                        ),
                        i = Tt(r, e.fc2_1),
                        o = a.cb(a.Hb(i, 1), 1),
                        s = a.Ec(a.Pc(i, o), 1),
                        u = Tt(r, e.fc2_2),
                        c = Tt(r, e.fc2_3);
                      return { scores: a.fd(s, 1)[1], regions: u, points: c };
                    });
                  })(t, r);
                  return t.dispose(), e;
                })),
                (i.stage3_onet = Date.now() - o),
                (l =
                  c.length > 1
                    ? a.E(
                        c.map(function (t) {
                          return t.scores;
                        })
                      )
                    : c[0].scores),
                (f = (h = Array).from),
                [4, l.data()]
              );
            case 2:
              return (
                (p = f.apply(h, [s.sent()])),
                l.dispose(),
                (d = p
                  .map(function (t, e) {
                    return { score: t, idx: e };
                  })
                  .filter(function (t) {
                    return t.score > n;
                  })
                  .map(function (t) {
                    return t.idx;
                  })),
                (m = d.map(function (t) {
                  var e = c[t].regions.arraySync();
                  return new Ve(e[0][0], e[0][1], e[0][2], e[0][3]);
                })),
                (v = d.map(function (t, n) {
                  return e[t].calibrate(m[n]);
                })),
                (g = d.map(function (t) {
                  return p[t];
                })),
                (y = []),
                (w = []),
                (x = []),
                v.length > 0 &&
                  ((o = Date.now()),
                  (C = S(v, g, 0.7, !1)),
                  (i.stage3_nms = Date.now() - o),
                  (y = C.map(function (t) {
                    return v[t];
                  })),
                  (w = C.map(function (t) {
                    return g[t];
                  })),
                  (x = C.map(function (t, e) {
                    return Array(5)
                      .fill(0)
                      .map(function (n, r) {
                        var i = c[t].points.arraySync();
                        return new b(
                          i[0][r] * (y[e].width + 1) + y[e].left,
                          i[0][r + 5] * (y[e].height + 1) + y[e].top
                        );
                      });
                  }))),
                c.forEach(function (t) {
                  t.regions.dispose(), t.scores.dispose(), t.points.dispose();
                }),
                [2, { boxes: y, scores: w, points: x }]
              );
          }
        });
      });
    }
    var Je = (function (t) {
        function e() {
          return t.call(this, "Mtcnn") || this;
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.load = function (e) {
            return Object(s.b)(this, void 0, void 0, function () {
              return Object(s.d)(this, function (n) {
                return (
                  console.warn("mtcnn is deprecated and will be removed soon"),
                  [2, t.prototype.load.call(this, e)]
                );
              });
            });
          }),
          (e.prototype.loadFromDisk = function (e) {
            return Object(s.b)(this, void 0, void 0, function () {
              return Object(s.d)(this, function (n) {
                return (
                  console.warn("mtcnn is deprecated and will be removed soon"),
                  [2, t.prototype.loadFromDisk.call(this, e)]
                );
              });
            });
          }),
          (e.prototype.forwardInput = function (t, e) {
            return (
              void 0 === e && (e = {}),
              Object(s.b)(this, void 0, void 0, function () {
                var n,
                  r,
                  i,
                  o,
                  u,
                  c,
                  l,
                  p,
                  h,
                  f,
                  d,
                  m,
                  v,
                  g,
                  y,
                  w,
                  x,
                  C,
                  E,
                  S,
                  N;
                return Object(s.d)(this, function (s) {
                  switch (s.label) {
                    case 0:
                      if (!(n = this.params))
                        throw new Error("Mtcnn - load model before inference");
                      if (!(r = t.canvases[0]))
                        throw new Error(
                          "Mtcnn - inputCanvas is not defined, note that passing tensors into Mtcnn.forwardInput is not supported yet."
                        );
                      return (
                        (i = {}),
                        (o = Date.now()),
                        (u = a.Zc(function () {
                          return (
                            (t = a.cb(a.z.fromPixels(r)).toFloat()),
                            a.Zc(function () {
                              return a.Nc(a.fd(t, 3).reverse(), 3);
                            })
                          );
                          var t;
                        })),
                        (c = function (t) {
                          return u.dispose(), (i.total = Date.now() - o), t;
                        }),
                        (l = u.shape.slice(1)),
                        (p = l[0]),
                        (h = l[1]),
                        (f = new fe(e)),
                        (d = f.minFaceSize),
                        (m = f.scaleFactor),
                        (v = f.maxNumScales),
                        (g = f.scoreThresholds),
                        (y = f.scaleSteps),
                        (w = (
                          y ||
                          (function (t, e, n) {
                            for (
                              var r = n[0],
                                i = n[1],
                                a = 12 / t,
                                o = [],
                                s = Math.min(r, i) * a,
                                u = 0;
                              s >= 12;

                            )
                              o.push(a * Math.pow(e, u)), (s *= e), (u += 1);
                            return o;
                          })(d, m, [p, h])
                        )
                          .filter(function (t) {
                            var e = Ue(t, [p, h]);
                            return Math.min(e.width, e.height) > 12;
                          })
                          .slice(0, v)),
                        (i.scales = w),
                        (i.pyramid = w.map(function (t) {
                          return Ue(t, [p, h]);
                        })),
                        (x = Date.now()),
                        [4, Ke(u, w, g[0], n.pnet, i)]
                      );
                    case 1:
                      return (
                        (C = s.sent()),
                        (i.total_stage1 = Date.now() - x),
                        C.boxes.length
                          ? ((i.stage2_numInputBoxes = C.boxes.length),
                            (x = Date.now()),
                            [4, Xe(r, C.boxes, g[1], n.rnet, i)])
                          : [2, c({ results: [], stats: i })]
                      );
                    case 2:
                      return (
                        (E = s.sent()),
                        (i.total_stage2 = Date.now() - x),
                        E.boxes.length
                          ? ((i.stage3_numInputBoxes = E.boxes.length),
                            (x = Date.now()),
                            [4, Ye(r, E.boxes, g[2], n.onet, i)])
                          : [2, c({ results: [], stats: i })]
                      );
                    case 3:
                      return (
                        (S = s.sent()),
                        (i.total_stage3 = Date.now() - x),
                        (N = S.boxes.map(function (t, e) {
                          return Bt(
                            j(
                              {},
                              new O(
                                S.scores[e],
                                new k(
                                  t.left / h,
                                  t.top / p,
                                  t.width / h,
                                  t.height / p
                                ),
                                { height: p, width: h }
                              )
                            ),
                            new A(
                              S.points[e].map(function (e) {
                                return e
                                  .sub(new b(t.left, t.top))
                                  .div(new b(t.width, t.height));
                              }),
                              { width: t.width, height: t.height }
                            )
                          );
                        })),
                        [2, c({ results: N, stats: i })]
                      );
                  }
                });
              })
            );
          }),
          (e.prototype.forward = function (t, e) {
            return (
              void 0 === e && (e = {}),
              Object(s.b)(this, void 0, void 0, function () {
                var n;
                return Object(s.d)(this, function (r) {
                  switch (r.label) {
                    case 0:
                      return (n = this.forwardInput), [4, st(t)];
                    case 1:
                      return [4, n.apply(this, [r.sent(), e])];
                    case 2:
                      return [2, r.sent().results];
                  }
                });
              })
            );
          }),
          (e.prototype.forwardWithStats = function (t, e) {
            return (
              void 0 === e && (e = {}),
              Object(s.b)(this, void 0, void 0, function () {
                var n;
                return Object(s.d)(this, function (r) {
                  switch (r.label) {
                    case 0:
                      return (n = this.forwardInput), [4, st(t)];
                    case 1:
                      return [2, n.apply(this, [r.sent(), e])];
                  }
                });
              })
            );
          }),
          (e.prototype.getDefaultModelName = function () {
            return "mtcnn_model";
          }),
          (e.prototype.extractParamsFromWeigthMap = function (t) {
            return We(t);
          }),
          (e.prototype.extractParams = function (t) {
            return Be(t);
          }),
          e
        );
      })(dt),
      $e = [
        new b(1.603231, 2.094468),
        new b(6.041143, 7.080126),
        new b(2.882459, 3.518061),
        new b(4.266906, 5.178857),
        new b(9.041765, 10.66308),
      ],
      Qe = [117.001, 114.697, 97.404],
      tn = (function (t) {
        function e() {
          var e = {
            withSeparableConvs: !0,
            iouThreshold: 0.4,
            classes: ["face"],
            anchors: $e,
            meanRgb: Qe,
            isFirstLayerConv2d: !0,
            filterSizes: [3, 16, 32, 64, 128, 256, 512],
          };
          return t.call(this, e) || this;
        }
        return (
          Object(s.c)(e, t),
          Object.defineProperty(e.prototype, "anchors", {
            get: function () {
              return this.config.anchors;
            },
            enumerable: !0,
            configurable: !0,
          }),
          (e.prototype.locateFaces = function (t, e) {
            return Object(s.b)(this, void 0, void 0, function () {
              return Object(s.d)(this, function (n) {
                switch (n.label) {
                  case 0:
                    return [4, this.detect(t, e)];
                  case 1:
                    return [
                      2,
                      n.sent().map(function (t) {
                        return new O(t.score, t.relativeBox, {
                          width: t.imageWidth,
                          height: t.imageHeight,
                        });
                      }),
                    ];
                }
              });
            });
          }),
          (e.prototype.getDefaultModelName = function () {
            return "tiny_face_detector_model";
          }),
          (e.prototype.extractParamsFromWeigthMap = function (e) {
            return t.prototype.extractParamsFromWeigthMap.call(this, e);
          }),
          e
        );
      })(Fe),
      en = {
        ssdMobilenetv1: new Ce(),
        tinyFaceDetector: new tn(),
        tinyYolov2: new Me(),
        mtcnn: new Je(),
        faceLandmark68Net: new $t(),
        faceLandmark68TinyNet: new te(),
        faceRecognitionNet: new ce(),
        faceExpressionNet: new jt(),
        ageGenderNet: new Yt(),
      },
      nn = (function (t) {
        function e(e, n, r) {
          var i = t.call(this) || this;
          return (i.parentTask = e), (i.input = n), (i.extractedFaces = r), i;
        }
        return Object(s.c)(e, t), e;
      })(Pe),
      rn = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.run = function () {
            return Object(s.b)(this, void 0, void 0, function () {
              var t,
                e,
                n = this;
              return Object(s.d)(this, function (r) {
                switch (r.label) {
                  case 0:
                    return [4, this.parentTask];
                  case 1:
                    return [
                      4,
                      ze(
                        (t = r.sent()),
                        this.input,
                        function (t) {
                          return Object(s.b)(n, void 0, void 0, function () {
                            return Object(s.d)(this, function (e) {
                              switch (e.label) {
                                case 0:
                                  return [
                                    4,
                                    Promise.all(
                                      t.map(function (t) {
                                        return en.faceExpressionNet.predictExpressions(
                                          t
                                        );
                                      })
                                    ),
                                  ];
                                case 1:
                                  return [2, e.sent()];
                              }
                            });
                          });
                        },
                        this.extractedFaces
                      ),
                    ];
                  case 2:
                    return (
                      (e = r.sent()),
                      [
                        2,
                        t.map(function (t, n) {
                          return Pt(t, e[n]);
                        }),
                      ]
                    );
                }
              });
            });
          }),
          (e.prototype.withAgeAndGender = function () {
            return new cn(this, this.input);
          }),
          e
        );
      })(nn),
      an = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.run = function () {
            return Object(s.b)(this, void 0, void 0, function () {
              var t, e;
              return Object(s.d)(this, function (n) {
                switch (n.label) {
                  case 0:
                    return [4, this.parentTask];
                  case 1:
                    return (t = n.sent())
                      ? [
                          4,
                          Le(
                            t,
                            this.input,
                            function (t) {
                              return en.faceExpressionNet.predictExpressions(t);
                            },
                            this.extractedFaces
                          ),
                        ]
                      : [2];
                  case 2:
                    return (e = n.sent()), [2, Pt(t, e)];
                }
              });
            });
          }),
          (e.prototype.withAgeAndGender = function () {
            return new ln(this, this.input);
          }),
          e
        );
      })(nn),
      on = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.withAgeAndGender = function () {
            return new pn(this, this.input);
          }),
          (e.prototype.withFaceDescriptors = function () {
            return new dn(this, this.input);
          }),
          e
        );
      })(rn),
      sn = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.withAgeAndGender = function () {
            return new hn(this, this.input);
          }),
          (e.prototype.withFaceDescriptor = function () {
            return new mn(this, this.input);
          }),
          e
        );
      })(an),
      un = (function (t) {
        function e(e, n, r) {
          var i = t.call(this) || this;
          return (i.parentTask = e), (i.input = n), (i.extractedFaces = r), i;
        }
        return Object(s.c)(e, t), e;
      })(Pe),
      cn = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.run = function () {
            return Object(s.b)(this, void 0, void 0, function () {
              var t,
                e,
                n = this;
              return Object(s.d)(this, function (r) {
                switch (r.label) {
                  case 0:
                    return [4, this.parentTask];
                  case 1:
                    return [
                      4,
                      ze(
                        (t = r.sent()),
                        this.input,
                        function (t) {
                          return Object(s.b)(n, void 0, void 0, function () {
                            return Object(s.d)(this, function (e) {
                              switch (e.label) {
                                case 0:
                                  return [
                                    4,
                                    Promise.all(
                                      t.map(function (t) {
                                        return en.ageGenderNet.predictAgeAndGender(
                                          t
                                        );
                                      })
                                    ),
                                  ];
                                case 1:
                                  return [2, e.sent()];
                              }
                            });
                          });
                        },
                        this.extractedFaces
                      ),
                    ];
                  case 2:
                    return (
                      (e = r.sent()),
                      [
                        2,
                        t.map(function (t, n) {
                          var r = e[n],
                            i = r.age;
                          return pe(he(t, r.gender, r.genderProbability), i);
                        }),
                      ]
                    );
                }
              });
            });
          }),
          (e.prototype.withFaceExpressions = function () {
            return new rn(this, this.input);
          }),
          e
        );
      })(un),
      ln = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.run = function () {
            return Object(s.b)(this, void 0, void 0, function () {
              var t, e, n, r, i;
              return Object(s.d)(this, function (a) {
                switch (a.label) {
                  case 0:
                    return [4, this.parentTask];
                  case 1:
                    return (t = a.sent())
                      ? [
                          4,
                          Le(
                            t,
                            this.input,
                            function (t) {
                              return en.ageGenderNet.predictAgeAndGender(t);
                            },
                            this.extractedFaces
                          ),
                        ]
                      : [2];
                  case 2:
                    return (
                      (e = a.sent()),
                      (n = e.age),
                      (r = e.gender),
                      (i = e.genderProbability),
                      [2, pe(he(t, r, i), n)]
                    );
                }
              });
            });
          }),
          (e.prototype.withFaceExpressions = function () {
            return new an(this, this.input);
          }),
          e
        );
      })(un),
      pn = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.withFaceExpressions = function () {
            return new on(this, this.input);
          }),
          (e.prototype.withFaceDescriptors = function () {
            return new dn(this, this.input);
          }),
          e
        );
      })(cn),
      hn = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.withFaceExpressions = function () {
            return new sn(this, this.input);
          }),
          (e.prototype.withFaceDescriptor = function () {
            return new mn(this, this.input);
          }),
          e
        );
      })(ln),
      fn = (function (t) {
        function e(e, n) {
          var r = t.call(this) || this;
          return (r.parentTask = e), (r.input = n), r;
        }
        return Object(s.c)(e, t), e;
      })(Pe),
      dn = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.run = function () {
            return Object(s.b)(this, void 0, void 0, function () {
              var t;
              return Object(s.d)(this, function (e) {
                switch (e.label) {
                  case 0:
                    return [4, this.parentTask];
                  case 1:
                    return [
                      4,
                      ze(
                        (t = e.sent()),
                        this.input,
                        function (t) {
                          return Promise.all(
                            t.map(function (t) {
                              return en.faceRecognitionNet.computeFaceDescriptor(
                                t
                              );
                            })
                          );
                        },
                        null,
                        function (t) {
                          return t.landmarks.align(null, {
                            useDlibAlignment: !0,
                          });
                        }
                      ),
                    ];
                  case 2:
                    return [
                      2,
                      e.sent().map(function (e, n) {
                        return le(t[n], e);
                      }),
                    ];
                }
              });
            });
          }),
          (e.prototype.withFaceExpressions = function () {
            return new on(this, this.input);
          }),
          (e.prototype.withAgeAndGender = function () {
            return new pn(this, this.input);
          }),
          e
        );
      })(fn),
      mn = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.run = function () {
            return Object(s.b)(this, void 0, void 0, function () {
              var t, e;
              return Object(s.d)(this, function (n) {
                switch (n.label) {
                  case 0:
                    return [4, this.parentTask];
                  case 1:
                    return (t = n.sent())
                      ? [
                          4,
                          Le(
                            t,
                            this.input,
                            function (t) {
                              return en.faceRecognitionNet.computeFaceDescriptor(
                                t
                              );
                            },
                            null,
                            function (t) {
                              return t.landmarks.align(null, {
                                useDlibAlignment: !0,
                              });
                            }
                          ),
                        ]
                      : [2];
                  case 2:
                    return (e = n.sent()), [2, le(t, e)];
                }
              });
            });
          }),
          (e.prototype.withFaceExpressions = function () {
            return new sn(this, this.input);
          }),
          (e.prototype.withAgeAndGender = function () {
            return new hn(this, this.input);
          }),
          e
        );
      })(fn),
      vn = (function (t) {
        function e(e, n, r) {
          var i = t.call(this) || this;
          return (
            (i.parentTask = e), (i.input = n), (i.useTinyLandmarkNet = r), i
          );
        }
        return (
          Object(s.c)(e, t),
          Object.defineProperty(e.prototype, "landmarkNet", {
            get: function () {
              return this.useTinyLandmarkNet
                ? en.faceLandmark68TinyNet
                : en.faceLandmark68Net;
            },
            enumerable: !0,
            configurable: !0,
          }),
          e
        );
      })(Pe),
      gn = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.run = function () {
            return Object(s.b)(this, void 0, void 0, function () {
              var t,
                e,
                n,
                r,
                i,
                o = this;
              return Object(s.d)(this, function (s) {
                switch (s.label) {
                  case 0:
                    return [4, this.parentTask];
                  case 1:
                    return (
                      (t = s.sent()),
                      (e = t.map(function (t) {
                        return t.detection;
                      })),
                      this.input instanceof a.b
                        ? [4, ct(this.input, e)]
                        : [3, 3]
                    );
                  case 2:
                    return (r = s.sent()), [3, 5];
                  case 3:
                    return [4, ut(this.input, e)];
                  case 4:
                    (r = s.sent()), (s.label = 5);
                  case 5:
                    return (
                      (n = r),
                      [
                        4,
                        Promise.all(
                          n.map(function (t) {
                            return o.landmarkNet.detectLandmarks(t);
                          })
                        ),
                      ]
                    );
                  case 6:
                    return (
                      (i = s.sent()),
                      n.forEach(function (t) {
                        return t instanceof a.b && t.dispose();
                      }),
                      [
                        2,
                        t.map(function (t, e) {
                          return Bt(t, i[e]);
                        }),
                      ]
                    );
                }
              });
            });
          }),
          (e.prototype.withFaceExpressions = function () {
            return new on(this, this.input);
          }),
          (e.prototype.withAgeAndGender = function () {
            return new pn(this, this.input);
          }),
          (e.prototype.withFaceDescriptors = function () {
            return new dn(this, this.input);
          }),
          e
        );
      })(vn),
      yn = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.run = function () {
            return Object(s.b)(this, void 0, void 0, function () {
              var t, e, n, r, i;
              return Object(s.d)(this, function (o) {
                switch (o.label) {
                  case 0:
                    return [4, this.parentTask];
                  case 1:
                    return (t = o.sent())
                      ? ((e = t.detection),
                        this.input instanceof a.b
                          ? [4, ct(this.input, [e])]
                          : [3, 3])
                      : [2];
                  case 2:
                    return (r = o.sent()), [3, 5];
                  case 3:
                    return [4, ut(this.input, [e])];
                  case 4:
                    (r = o.sent()), (o.label = 5);
                  case 5:
                    return (n = r), [4, this.landmarkNet.detectLandmarks(n[0])];
                  case 6:
                    return (
                      (i = o.sent()),
                      n.forEach(function (t) {
                        return t instanceof a.b && t.dispose();
                      }),
                      [2, Bt(t, i)]
                    );
                }
              });
            });
          }),
          (e.prototype.withFaceExpressions = function () {
            return new sn(this, this.input);
          }),
          (e.prototype.withAgeAndGender = function () {
            return new hn(this, this.input);
          }),
          (e.prototype.withFaceDescriptor = function () {
            return new mn(this, this.input);
          }),
          e
        );
      })(vn),
      bn = (function (t) {
        function e(e, n) {
          void 0 === n && (n = new xe());
          var r = t.call(this) || this;
          return (r.input = e), (r.options = n), r;
        }
        return Object(s.c)(e, t), e;
      })(Pe),
      wn = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.run = function () {
            return Object(s.b)(this, void 0, void 0, function () {
              var t, e, n, r;
              return Object(s.d)(this, function (i) {
                switch (i.label) {
                  case 0:
                    return (
                      (e = (t = this).input),
                      (n = t.options) instanceof fe
                        ? [4, en.mtcnn.forward(e, n)]
                        : [3, 2]
                    );
                  case 1:
                    return [
                      2,
                      i.sent().map(function (t) {
                        return t.detection;
                      }),
                    ];
                  case 2:
                    if (
                      !(r =
                        n instanceof je
                          ? function (t) {
                              return en.tinyFaceDetector.locateFaces(t, n);
                            }
                          : n instanceof xe
                          ? function (t) {
                              return en.ssdMobilenetv1.locateFaces(t, n);
                            }
                          : n instanceof De
                          ? function (t) {
                              return en.tinyYolov2.locateFaces(t, n);
                            }
                          : null)
                    )
                      throw new Error(
                        "detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | MtcnnOptions | TinyYolov2Options"
                      );
                    return [2, r(e)];
                }
              });
            });
          }),
          (e.prototype.runAndExtendWithFaceDetections = function () {
            var t = this;
            return new Promise(function (e) {
              return Object(s.b)(t, void 0, void 0, function () {
                var t;
                return Object(s.d)(this, function (n) {
                  switch (n.label) {
                    case 0:
                      return [4, this.run()];
                    case 1:
                      return (
                        (t = n.sent()),
                        [
                          2,
                          e(
                            t.map(function (t) {
                              return j({}, t);
                            })
                          ),
                        ]
                      );
                  }
                });
              });
            });
          }),
          (e.prototype.withFaceLandmarks = function (t) {
            return (
              void 0 === t && (t = !1),
              new gn(this.runAndExtendWithFaceDetections(), this.input, t)
            );
          }),
          (e.prototype.withFaceExpressions = function () {
            return new rn(this.runAndExtendWithFaceDetections(), this.input);
          }),
          (e.prototype.withAgeAndGender = function () {
            return new cn(this.runAndExtendWithFaceDetections(), this.input);
          }),
          e
        );
      })(bn),
      xn = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          Object(s.c)(e, t),
          (e.prototype.run = function () {
            return Object(s.b)(this, void 0, void 0, function () {
              var t, e;
              return Object(s.d)(this, function (n) {
                switch (n.label) {
                  case 0:
                    return [4, new wn(this.input, this.options)];
                  case 1:
                    return (
                      (t = n.sent()),
                      (e = t[0]),
                      t.forEach(function (t) {
                        t.score > e.score && (e = t);
                      }),
                      [2, e]
                    );
                }
              });
            });
          }),
          (e.prototype.runAndExtendWithFaceDetection = function () {
            var t = this;
            return new Promise(function (e) {
              return Object(s.b)(t, void 0, void 0, function () {
                var t;
                return Object(s.d)(this, function (n) {
                  switch (n.label) {
                    case 0:
                      return [4, this.run()];
                    case 1:
                      return (t = n.sent()), [2, e(t ? j({}, t) : void 0)];
                  }
                });
              });
            });
          }),
          (e.prototype.withFaceLandmarks = function (t) {
            return (
              void 0 === t && (t = !1),
              new yn(this.runAndExtendWithFaceDetection(), this.input, t)
            );
          }),
          (e.prototype.withFaceExpressions = function () {
            return new an(this.runAndExtendWithFaceDetection(), this.input);
          }),
          (e.prototype.withAgeAndGender = function () {
            return new ln(this.runAndExtendWithFaceDetection(), this.input);
          }),
          e
        );
      })(bn);
    !(function () {
      function t(t, e) {
        void 0 === e && (e = 0.6), (this._distanceThreshold = e);
        var n = Array.isArray(t) ? t : [t];
        if (!n.length)
          throw new Error(
            "FaceRecognizer.constructor - expected atleast one input"
          );
        var r = 1,
          i = function () {
            return "person " + r++;
          };
        this._labeledDescriptors = n.map(function (t) {
          if (t instanceof F) return t;
          if (t instanceof Float32Array) return new F(i(), [t]);
          if (t.descriptor && t.descriptor instanceof Float32Array)
            return new F(i(), [t.descriptor]);
          throw new Error(
            "FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>"
          );
        });
      }
      Object.defineProperty(t.prototype, "labeledDescriptors", {
        get: function () {
          return this._labeledDescriptors;
        },
        enumerable: !0,
        configurable: !0,
      }),
        Object.defineProperty(t.prototype, "distanceThreshold", {
          get: function () {
            return this._distanceThreshold;
          },
          enumerable: !0,
          configurable: !0,
        }),
        (t.prototype.computeMeanDistance = function (t, e) {
          return (
            e
              .map(function (e) {
                return (function (t, e) {
                  if (t.length !== e.length)
                    throw new Error(
                      "euclideanDistance: arr1.length !== arr2.length"
                    );
                  var n = Array.from(t),
                    r = Array.from(e);
                  return Math.sqrt(
                    n
                      .map(function (t, e) {
                        return t - r[e];
                      })
                      .reduce(function (t, e) {
                        return t + Math.pow(e, 2);
                      }, 0)
                  );
                })(e, t);
              })
              .reduce(function (t, e) {
                return t + e;
              }, 0) / (e.length || 1)
          );
        }),
        (t.prototype.matchDescriptor = function (t) {
          var e = this;
          return this.labeledDescriptors
            .map(function (n) {
              var r = n.descriptors,
                i = n.label;
              return new R(i, e.computeMeanDistance(t, r));
            })
            .reduce(function (t, e) {
              return t.distance < e.distance ? t : e;
            });
        }),
        (t.prototype.findBestMatch = function (t) {
          var e = this.matchDescriptor(t);
          return e.distance < this.distanceThreshold
            ? e
            : new R("unknown", e.distance);
        }),
        (t.prototype.toJSON = function () {
          return {
            distanceThreshold: this.distanceThreshold,
            labeledDescriptors: this.labeledDescriptors.map(function (t) {
              return t.toJSON();
            }),
          };
        }),
        (t.fromJSON = function (e) {
          return new t(
            e.labeledDescriptors.map(function (t) {
              return F.fromJSON(t);
            }),
            e.distanceThreshold
          );
        });
    })();
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    var Cn = function (t, e) {
      return (Cn =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (t, e) {
            t.__proto__ = e;
          }) ||
        function (t, e) {
          for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
        })(t, e);
    };
    function On(t, e) {
      function n() {
        this.constructor = t;
      }
      Cn(t, e),
        (t.prototype =
          null === e
            ? Object.create(e)
            : ((n.prototype = e.prototype), new n()));
    }
    var En,
      Sn = function () {
        return (Sn =
          Object.assign ||
          function (t) {
            for (var e, n = 1, r = arguments.length; n < r; n++)
              for (var i in (e = arguments[n]))
                Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
            return t;
          }).apply(this, arguments);
      };
    function Nn(t, e, n, r) {
      return new (n || (n = Promise))(function (i, a) {
        function o(t) {
          try {
            u(r.next(t));
          } catch (t) {
            a(t);
          }
        }
        function s(t) {
          try {
            u(r.throw(t));
          } catch (t) {
            a(t);
          }
        }
        function u(t) {
          t.done
            ? i(t.value)
            : new n(function (e) {
                e(t.value);
              }).then(o, s);
        }
        u((r = r.apply(t, e || [])).next());
      });
    }
    function In(t, e) {
      var n,
        r,
        i,
        a,
        o = {
          label: 0,
          sent: function () {
            if (1 & i[0]) throw i[1];
            return i[1];
          },
          trys: [],
          ops: [],
        };
      return (
        (a = { next: s(0), throw: s(1), return: s(2) }),
        "function" == typeof Symbol &&
          (a[Symbol.iterator] = function () {
            return this;
          }),
        a
      );
      function s(a) {
        return function (s) {
          return (function (a) {
            if (n) throw new TypeError("Generator is already executing.");
            for (; o; )
              try {
                if (
                  ((n = 1),
                  r &&
                    (i =
                      2 & a[0]
                        ? r.return
                        : a[0]
                        ? r.throw || ((i = r.return) && i.call(r), 0)
                        : r.next) &&
                    !(i = i.call(r, a[1])).done)
                )
                  return i;
                switch (((r = 0), i && (a = [2 & a[0], i.value]), a[0])) {
                  case 0:
                  case 1:
                    i = a;
                    break;
                  case 4:
                    return o.label++, { value: a[1], done: !1 };
                  case 5:
                    o.label++, (r = a[1]), (a = [0]);
                    continue;
                  case 7:
                    (a = o.ops.pop()), o.trys.pop();
                    continue;
                  default:
                    if (
                      !(i = (i = o.trys).length > 0 && i[i.length - 1]) &&
                      (6 === a[0] || 2 === a[0])
                    ) {
                      o = 0;
                      continue;
                    }
                    if (3 === a[0] && (!i || (a[1] > i[0] && a[1] < i[3]))) {
                      o.label = a[1];
                      break;
                    }
                    if (6 === a[0] && o.label < i[1]) {
                      (o.label = i[1]), (i = a);
                      break;
                    }
                    if (i && o.label < i[2]) {
                      (o.label = i[2]), o.ops.push(a);
                      break;
                    }
                    i[2] && o.ops.pop(), o.trys.pop();
                    continue;
                }
                a = e.call(t, o);
              } catch (t) {
                (a = [6, t]), (r = 0);
              } finally {
                n = i = 0;
              }
            if (5 & a[0]) throw a[1];
            return { value: a[0] ? a[1] : void 0, done: !0 };
          })([a, s]);
        };
      }
    }
    function kn() {
      return null == En && (En = Object(a.t)().epsilon()), En;
    }
    var _n = (function (t) {
        function e(n) {
          var r = t.call(this, n) || this;
          return Object.setPrototypeOf(r, e.prototype), r;
        }
        return On(e, t), e;
      })(Error),
      An = (function (t) {
        function e(n) {
          var r = t.call(this, n) || this;
          return Object.setPrototypeOf(r, e.prototype), r;
        }
        return On(e, t), e;
      })(Error),
      Tn = (function (t) {
        function e(n) {
          var r = t.call(this, n) || this;
          return Object.setPrototypeOf(r, e.prototype), r;
        }
        return On(e, t), e;
      })(Error),
      Rn = (function (t) {
        function e(n) {
          var r = t.call(this, n) || this;
          return Object.setPrototypeOf(r, e.prototype), r;
        }
        return On(e, t), e;
      })(Error),
      Dn = (function (t) {
        function e(n) {
          var r = t.call(this, n) || this;
          return Object.setPrototypeOf(r, e.prototype), r;
        }
        return On(e, t), e;
      })(Error);
    !(function (t) {
      function e(n) {
        var r = t.call(this, n) || this;
        return Object.setPrototypeOf(r, e.prototype), r;
      }
      On(e, t);
    })(Error);
    function Fn(t, e) {
      if (Array.isArray(t)) {
        for (var n = [], r = 0; r < e; r++) n = n.concat(t);
        return n;
      }
      return (n = new Array(e)).fill(t), n;
    }
    function Mn(t, e) {
      if (!t) throw new Dn(e);
    }
    function jn(t, e) {
      for (var n = 0, r = 0, i = t; r < i.length; r++) i[r] === e && n++;
      return n;
    }
    function Pn(t) {
      return 1 === t.length ? t[0] : t;
    }
    function zn(t) {
      return Array.isArray(t) ? t : [t];
    }
    function Ln(t) {
      var e = t
        .replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2")
        .replace(/([a-z])([A-Z])/g, "$1_$2")
        .toLowerCase();
      return "_" !== e[0] ? e : "private" + e;
    }
    function Bn(t) {
      return t.length <= 1 || -1 === t.indexOf("_")
        ? t
        : t.replace(/[_]+(\w|$)/g, function (t, e) {
            return e.toUpperCase();
          });
    }
    var Wn = {};
    function Un(t) {
      if (null == t) return null;
      var e = {};
      return (e.className = t.getClassName()), (e.config = t.getConfig()), e;
    }
    function Vn(t, e, n, r, i) {
      var a, o, s;
      if (
        (void 0 === e && (e = {}),
        void 0 === n && (n = {}),
        void 0 === r && (r = "object"),
        void 0 === i && (i = !1),
        "string" == typeof t)
      ) {
        var u = t,
          c = void 0;
        if (u in n) c = n[u];
        else if (u in Wn) c = Wn[u];
        else if (null == (c = e[u]))
          throw new Tn(
            "Unknown " +
              r +
              ": " +
              t +
              ". This may be due to one of the following reasons:\n1. The " +
              r +
              " is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom " +
              r +
              " is defined in JavaScript, but is not registered properly with tf.serialization.registerClass()."
          );
        return c;
      }
      var l = t;
      if (null == l.className || null == l.config)
        throw new Tn(
          r +
            ": Improper config format: " +
            JSON.stringify(l) +
            ".\n'className' and 'config' must set."
        );
      var p = l.className,
        h = void 0,
        f = void 0;
      if (
        (p in n
          ? ((h = (a = n[p])[0]), (f = a[1]))
          : p in Wn
          ? ((h = (o = Wn.className)[0]), (f = o[1]))
          : p in e && ((h = (s = e[p])[0]), (f = s[1])),
        null == h)
      )
        throw new Tn(
          "Unknown " +
            r +
            ": " +
            p +
            ". This may be due to one of the following reasons:\n1. The " +
            r +
            " is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom " +
            r +
            " is defined in JavaScript, but is not registered properly with tf.serialization.registerClass()."
        );
      if (null != f) {
        for (var d = {}, m = 0, v = Object.keys(Wn); m < v.length; m++)
          d[(C = v[m])] = Wn[C];
        for (var g = 0, y = Object.keys(n); g < y.length; g++)
          d[(C = y[g])] = n[C];
        l.config.customObjects = d;
        for (var b = Sn({}, Wn), w = 0, x = Object.keys(n); w < x.length; w++) {
          var C = x[w];
          Wn[C] = n[C];
        }
        !(function t(e) {
          if (null != e && "object" == typeof e)
            if (Array.isArray(e))
              e.forEach(function (e) {
                return t(e);
              });
            else
              for (var n = 0, r = Object.keys(e); n < r.length; n++) {
                var i = r[n],
                  a = e[i];
                null != a &&
                  "object" == typeof a &&
                  (Array.isArray(a) ||
                  "ndarray" !== a.type ||
                  "number" != typeof a.value
                    ? t(a)
                    : (e[i] = a.value));
              }
        })(l.config);
        var O = f(h, l.config, n, i);
        return (Wn = Sn({}, b)), O;
      }
      b = Sn({}, Wn);
      for (var E = 0, S = Object.keys(n); E < S.length; E++)
        (C = S[E]), (Wn[C] = n[C]);
      return (O = new h(l.config)), (Wn = Sn({}, b)), O;
    }
    function Gn(t, e) {
      return (
        -1 *
        (function (t, e) {
          return t < e ? -1 : t > e ? 1 : 0;
        })(t, e)
      );
    }
    function Hn(t) {
      if (null == t) return t;
      for (var e = [], n = 0, r = t; n < r.length; n++) {
        var i = r[n];
        -1 === e.indexOf(i) && e.push(i);
      }
      return e;
    }
    function qn(t) {
      if (null == t) throw new Tn("Invalid value in obj: " + JSON.stringify(t));
      for (var e in t) if (t.hasOwnProperty(e)) return !1;
      return !0;
    }
    function Kn(t, e, n) {
      if (null != n && t.indexOf(n) < 0)
        throw new Tn(
          n +
            " is not a valid " +
            e +
            ".  Valid values are " +
            t +
            " or null/undefined."
        );
    }
    function Zn(t, e, n, r) {
      return (
        void 0 === n && (n = 0),
        void 0 === r && (r = 1 / 0),
        Mn(n >= 0),
        Mn(r >= n),
        Array.isArray(t) &&
          t.length >= n &&
          t.length <= r &&
          t.every(function (t) {
            return typeof t === e;
          })
      );
    }
    function Xn(t, e) {
      Array.isArray(t)
        ? (a.gd.assert(t.length > 0, function () {
            return e + " is unexpectedly an empty array.";
          }),
          t.forEach(function (t, n) {
            return Xn(t, "element " + (n + 1) + " of " + e);
          }))
        : a.gd.assert(Number.isInteger(t) && t > 0, function () {
            return (
              "Expected " +
              e +
              " to be a positive integer, but got " +
              (function t(e) {
                return null === e
                  ? "null"
                  : Array.isArray(e)
                  ? "[" +
                    e
                      .map(function (e) {
                        return t(e);
                      })
                      .join(",") +
                    "]"
                  : "string" == typeof e
                  ? '"' + e + '"'
                  : "" + e;
              })(t) +
              "."
            );
          });
    }
    function Yn(t) {
      return "relu" === t
        ? "relu"
        : "linear" === t
        ? "linear"
        : "elu" === t
        ? "elu"
        : null;
    }
    function Jn(t, e) {
      return Object(a.Zc)(function () {
        return Object(a.Jc)(Object(a.Qc)(Object(a.Sb)(t, t), e, !0));
      });
    }
    var $n = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          On(e, t),
          (e.prototype.getConfig = function () {
            return {};
          }),
          e
        );
      })(a.tc.Serializable),
      Qn = (function (t) {
        function e(e) {
          var n = t.call(this) || this;
          return (
            (n.defaultMaxValue = 2),
            (n.defaultAxis = 0),
            (n.maxValue = null != e.maxValue ? e.maxValue : n.defaultMaxValue),
            (n.axis = null != e.axis ? e.axis : n.defaultAxis),
            n
          );
        }
        return (
          On(e, t),
          (e.prototype.apply = function (t) {
            var e = this;
            return Object(a.Zc)(function () {
              var n = Jn(t, e.axis),
                r = Object(a.C)(n, 0, e.maxValue);
              return Object(a.Rb)(t, Object(a.T)(r, Object(a.g)(kn(), n)));
            });
          }),
          (e.prototype.getConfig = function () {
            return { maxValue: this.maxValue, axis: this.axis };
          }),
          (e.className = "MaxNorm"),
          e
        );
      })($n);
    a.tc.registerClass(Qn);
    var tr = (function (t) {
      function e(e) {
        var n = t.call(this) || this;
        return (
          (n.defaultAxis = 0),
          (n.axis = null != e.axis ? e.axis : n.defaultAxis),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype.apply = function (t) {
          var e = this;
          return Object(a.Zc)(function () {
            return Object(a.T)(t, Object(a.g)(kn(), Jn(t, e.axis)));
          });
        }),
        (e.prototype.getConfig = function () {
          return { axis: this.axis };
        }),
        (e.className = "UnitNorm"),
        e
      );
    })($n);
    a.tc.registerClass(tr);
    var er = (function (t) {
      function e() {
        return (null !== t && t.apply(this, arguments)) || this;
      }
      return (
        On(e, t),
        (e.prototype.apply = function (t) {
          return Object(a.jc)(t);
        }),
        (e.className = "NonNeg"),
        e
      );
    })($n);
    a.tc.registerClass(er);
    var nr = (function (t) {
      function e(e) {
        var n = t.call(this) || this;
        return (
          (n.defaultMinValue = 0),
          (n.defaultMaxValue = 1),
          (n.defaultRate = 1),
          (n.defaultAxis = 0),
          (n.minValue = null != e.minValue ? e.minValue : n.defaultMinValue),
          (n.maxValue = null != e.maxValue ? e.maxValue : n.defaultMaxValue),
          (n.rate = null != e.rate ? e.rate : n.defaultRate),
          (n.axis = null != e.axis ? e.axis : n.defaultAxis),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype.apply = function (t) {
          var e = this;
          return Object(a.Zc)(function () {
            var n = Jn(t, e.axis),
              r = Object(a.g)(
                Object(a.Rb)(e.rate, Object(a.C)(n, e.minValue, e.maxValue)),
                Object(a.Rb)(1 - e.rate, n)
              );
            return Object(a.Rb)(t, Object(a.T)(r, Object(a.g)(kn(), n)));
          });
        }),
        (e.prototype.getConfig = function () {
          return {
            minValue: this.minValue,
            maxValue: this.maxValue,
            rate: this.rate,
            axis: this.axis,
          };
        }),
        (e.className = "MinMaxNorm"),
        e
      );
    })($n);
    a.tc.registerClass(nr);
    var rr = {
      maxNorm: "MaxNorm",
      minMaxNorm: "MinMaxNorm",
      nonNeg: "NonNeg",
      unitNorm: "UnitNorm",
    };
    function ir(t) {
      return Un(t);
    }
    function ar(t, e) {
      return (
        void 0 === e && (e = {}),
        Vn(t, a.tc.SerializationMap.getMap().classNameMap, e, "constraint")
      );
    }
    function or(t) {
      return null == t
        ? null
        : "string" == typeof t
        ? ar({ className: t in rr ? rr[t] : t, config: {} })
        : t instanceof $n
        ? t
        : ar(t);
    }
    Object.freeze({
      maxNorm: function (t) {
        return new Qn(t);
      },
      unitNorm: function (t) {
        return new tr(t);
      },
      nonNeg: function () {
        return new er();
      },
      minMaxNorm: function (t) {
        return new nr(t);
      },
    });
    var sr = ["channelsFirst", "channelsLast"],
      ur = ["valid", "same", "causal"],
      cr = ["max", "avg"],
      lr = ["sum", "mul", "concat", "ave"],
      pr = new Map();
    function hr(t) {
      Kn(sr, "DataFormat", t);
    }
    function fr(t) {
      Kn(ur, "PaddingMode", t);
    }
    function dr(t) {
      Kn(cr, "PoolMode", t);
    }
    var mr = [];
    function vr(t, e) {
      mr.push(t);
      try {
        var n = e();
        return mr.pop(), n;
      } catch (t) {
        throw (mr.pop(), t);
      }
    }
    function gr(t) {
      if (!wr(t)) throw new Error("Not a valid tensor name: '" + t + "'");
      return (0 === mr.length ? "" : mr.join("/") + "/") + t;
    }
    function yr(t) {
      if (!wr(t)) throw new Error("Not a valid tensor name: '" + t + "'");
      pr.has(t) || pr.set(t, 0);
      var e = pr.get(t);
      if ((pr.set(t, pr.get(t) + 1), e > 0)) {
        var n = t + "_" + e;
        return pr.set(n, 1), n;
      }
      return t;
    }
    var br = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);
    function wr(t) {
      return !!t.match(br);
    }
    function xr(t) {
      return t === parseInt(t.toString(), 10);
    }
    function Cr(t, e, n) {
      null == e && (e = 0), null == n && (n = t.length);
      for (var r = 1, i = e; i < n; ++i) r *= t[i];
      return r;
    }
    function Or(t) {
      return (t = Array.isArray(t) ? new Float32Array(t) : t), Object(a.Uc)(t);
    }
    function Er(t) {
      return Object(a.Nb)(Or(t)).dataSync()[0];
    }
    function Sr(t) {
      return Object(a.Hb)(Or(t)).dataSync()[0];
    }
    function Nr(t, e) {
      if (e < t)
        throw new Tn("end (" + e + ") < begin (" + t + ") is forbidden.");
      for (var n = [], r = t; r < e; ++r) n.push(r);
      return n;
    }
    function Ir(t, e) {
      return t.asType(e);
    }
    function kr(t, e) {
      void 0 === e && (e = -1);
      var n = t.shape.slice();
      return e < 0 && (e = n.length + e + 1), n.splice(e, 0, 1), t.reshape(n);
    }
    function _r(t, e, n) {
      return Object(a.Zc)(function () {
        switch (t.rank) {
          case 1:
            return Object(a.Ac)(t, e, n);
          case 2:
            return Object(a.Bc)(t, [e, 0], [n, t.shape[1]]);
          case 3:
            return Object(a.Cc)(t, [e, 0, 0], [n, t.shape[1], t.shape[2]]);
          case 4:
            return Object(a.Dc)(
              t,
              [e, 0, 0, 0],
              [n, t.shape[1], t.shape[2], t.shape[3]]
            );
          case 5:
            return Object(a.zc)(
              t,
              [e, 0, 0, 0, 0],
              [n, t.shape[1], t.shape[2], t.shape[3], t.shape[4]]
            );
          case 6:
            return Object(a.zc)(
              t,
              [e, 0, 0, 0, 0, 0],
              [n, t.shape[1], t.shape[2], t.shape[3], t.shape[4], t.shape[5]]
            );
          default:
            throw new Tn(
              "sliceAlongFirstAxis() received an unsupported tensor rank: " +
                t.rank
            );
        }
      });
    }
    function Ar(t, e, n) {
      return Object(a.Zc)(function () {
        switch (t.rank) {
          case 1:
            return Object(a.Ac)(t, e, n);
          case 2:
            return Object(a.Bc)(t, [0, e], [t.shape[0], n]);
          case 3:
            return Object(a.Cc)(t, [0, 0, e], [t.shape[0], t.shape[1], n]);
          case 4:
            return Object(a.Dc)(
              t,
              [0, 0, 0, e],
              [t.shape[0], t.shape[1], t.shape[2], n]
            );
          default:
            throw new Tn(
              "sliceAlongLastAxis() received an unsupported tensor rank: " +
                t.rank
            );
        }
      });
    }
    function Tr(t, e, n, r) {
      return Object(a.Zc)(function () {
        switch (t.rank) {
          case 1:
            return Object(a.Ac)(t, e, n);
          case 2:
            switch (r) {
              case 1:
                return _r(t, e, n);
              case 2:
                return Ar(t, e, n);
              default:
                throw new Tn(
                  "The axis is not within the rank of the tensor " + r
                );
            }
          case 3:
            switch (r) {
              case 1:
                return _r(t, e, n);
              case 2:
                return Object(a.Cc)(t, [0, e, 0], [t.shape[0], n, t.shape[2]]);
              case 3:
                return Ar(t, e, n);
              default:
                throw new Tn(
                  "The axis is not within the rank of the tensor " + r
                );
            }
          case 4:
            switch (r) {
              case 1:
                return _r(t, e, n);
              case 2:
                return Object(a.Dc)(
                  t,
                  [0, e, 0, 0],
                  [t.shape[0], n, t.shape[2], t.shape[3]]
                );
              case 3:
                return Object(a.Dc)(
                  t,
                  [0, 0, e, 0],
                  [t.shape[0], t.shape[1], n, t.shape[3]]
                );
              case 4:
                return Ar(t, e, n);
              default:
                throw new Tn(
                  "The axis is not within the rank of the tensor " + r
                );
            }
          default:
            throw new Tn(
              "sliceAlongLastAxis() received an unsupported tensor rank: " +
                t.rank
            );
        }
      });
    }
    function Rr(t, e) {
      var n;
      return (
        void 0 === e && (e = -1),
        e < 0 && (e = 0 !== (n = t[0].rank) ? n : 0),
        e === t[0].rank && (e = -1),
        Object(a.E)(t, e)
      );
    }
    function Dr(t, e) {
      switch (t.rank) {
        case 1:
          return Object(a.F)([t, e]);
        case 2:
          return Object(a.G)([t, e], 0);
        case 3:
          return Object(a.H)([t, e], 0);
        case 4:
          return Object(a.I)([t, e], 0);
        default:
          throw new Tn(
            "concatAlongFirstAxis() received an unsupported tensor rank: " +
              t.rank
          );
      }
    }
    function Fr(t, e) {
      if ((Array.isArray(e) || (e = [e]), t.rank !== e.length))
        throw new Tn(
          "The length of input n (" +
            e.length +
            ") does not match the number of dimensions in input x (" +
            t.rank +
            ")"
        );
      return Object(a.ad)(t, e);
    }
    function Mr(t, e, n, r, i) {
      return (
        void 0 === e && (e = 0),
        void 0 === n && (n = 1),
        Object(a.ec)(t, e, n, r, i)
      );
    }
    function jr(t, e, n, r) {
      if (t.rank < 2 || e.rank < 2)
        throw new Rn(
          "dot requires both inputs to be rank >= 2 but got x shape = " +
            t.shape +
            " and y shape = " +
            e.shape
        );
      if (e.rank >= 3 && t.shape.slice(-1)[0] !== (p = e.shape.slice(-2)[0]))
        throw new Rn(
          "If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = " +
            t.shape +
            " and  y shape = " +
            e.shape
        );
      if (2 === t.rank && 2 === e.rank) {
        var i = !1,
          o = !1;
        return a.jb.matMul({
          a: t,
          b: e,
          transposeA: i,
          transposeB: o,
          bias: r ? Lr(t.rank, r, "channelsLast") : null,
          activation: n,
        });
      }
      var s = t.shape.slice(),
        u = s.pop();
      t = t.reshape([-1, u]);
      var c = e.shape.slice(),
        l = c.pop(),
        p = c.pop(),
        h = c.concat([l]),
        f = Array.from({ length: e.rank }, function (t, n) {
          return 0 === n ? e.rank - 2 : n <= e.rank - 2 ? n - 1 : n;
        });
      e = e.transpose(f).reshape([p, -1]);
      var d = s.concat(h);
      return (
        (i = !1),
        (o = !1),
        a.jb
          .matMul({
            a: t,
            b: e,
            transposeA: i,
            transposeB: o,
            bias: r ? Lr(t.rank, r, "channelsLast") : null,
            activation: n,
          })
          .reshape(d)
      );
    }
    function Pr(t, e, n) {
      return Object(a.Zc)(function () {
        return (
          (e = Array.isArray(e) ? Object(a.Uc)(e, "int32") : e.toInt()),
          Object(a.kb)(t, e, n)
        );
      });
    }
    function zr(t) {
      return Object(a.Sb)(t, t);
    }
    function Lr(t, e, n) {
      var r = e.shape;
      if (1 !== e.rank && e.rank !== t)
        throw new Tn(
          "Unexpected bias dimensions: " +
            e.rank +
            "; expected it to be 1 or " +
            t
        );
      if (5 === t) {
        if ("channelsFirst" === n)
          return 1 === r.length
            ? e.reshape([1, r[0], 1, 1, 1])
            : e.reshape([1, r[3], r[0], r[1], r[2]]);
        if ("channelsLast" === n)
          return 1 === r.length
            ? e.reshape([1, 1, 1, 1, r[0]])
            : e.reshape([1].concat(r));
      } else if (4 === t) {
        if ("channelsFirst" === n)
          return 1 === r.length
            ? e.reshape([1, r[0], 1, 1])
            : e.reshape([1, r[2], r[0], r[1]]);
        if ("channelsLast" === n)
          return 1 === r.length
            ? e.reshape([1, 1, 1, r[0]])
            : e.reshape([1].concat(r));
      } else if (3 === t) {
        if ("channelsFirst" === n)
          return 1 === r.length
            ? e.reshape([1, r[0], 1])
            : e.reshape([1, r[1], r[0]]);
        if ("channelsLast" === n)
          return 1 === r.length
            ? e.reshape([1, 1, r[0]])
            : e.reshape([1].concat(r));
      } else if (t < 3) return e;
      throw new Tn("Unsupported input rank by biasAdd: " + e.rank);
    }
    function Br(t, e, n) {
      return Object(a.Zc)(function () {
        return (
          null == n && (n = "channelsLast"), hr(n), t.add(Lr(t.rank, e, n))
        );
      });
    }
    function Wr(t, e, n, r) {
      return Object(a.Zc)(function () {
        return Object(a.V)(t, e, n, r);
      });
    }
    function Ur(t, e, n) {
      return void 0 === n && (n = !1), n ? t() : e();
    }
    var Vr = ["fanIn", "fanOut", "fanAvg"],
      Gr = ["normal", "uniform", "truncatedNormal"];
    var Hr = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          On(e, t),
          (e.prototype.fromConfigUsesCustomObjects = function () {
            return !1;
          }),
          (e.prototype.getConfig = function () {
            return {};
          }),
          e
        );
      })(a.tc.Serializable),
      qr = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          On(e, t),
          (e.prototype.apply = function (t, e) {
            return Object(a.ld)(t, e);
          }),
          (e.className = "Zeros"),
          e
        );
      })(Hr);
    a.tc.registerClass(qr);
    var Kr = (function (t) {
      function e() {
        return (null !== t && t.apply(this, arguments)) || this;
      }
      return (
        On(e, t),
        (e.prototype.apply = function (t, e) {
          return Object(a.Yb)(t, e);
        }),
        (e.className = "Ones"),
        e
      );
    })(Hr);
    a.tc.registerClass(Kr);
    var Zr = (function (t) {
      function e(e) {
        var n = t.call(this) || this;
        if ("object" != typeof e)
          throw new Tn("Expected argument of type ConstantConfig but got " + e);
        if (void 0 === e.value)
          throw new Tn("config must have value set but got " + e);
        return (n.value = e.value), n;
      }
      return (
        On(e, t),
        (e.prototype.apply = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            return Object(a.Rb)(Object(a.pc)(n.value), Object(a.Yb)(t, e));
          });
        }),
        (e.prototype.getConfig = function () {
          return { value: this.value };
        }),
        (e.className = "Constant"),
        e
      );
    })(Hr);
    a.tc.registerClass(Zr);
    var Xr = (function (t) {
      function e(e) {
        var n = t.call(this) || this;
        return (
          (n.DEFAULT_MINVAL = -0.05),
          (n.DEFAULT_MAXVAL = 0.05),
          (n.minval = e.minval || n.DEFAULT_MINVAL),
          (n.maxval = e.maxval || n.DEFAULT_MAXVAL),
          (n.seed = e.seed),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype.apply = function (t, e) {
          return Object(a.fc)(t, this.minval, this.maxval, e);
        }),
        (e.prototype.getConfig = function () {
          return { minval: this.minval, maxval: this.maxval, seed: this.seed };
        }),
        (e.className = "RandomUniform"),
        e
      );
    })(Hr);
    a.tc.registerClass(Xr);
    var Yr = (function (t) {
      function e(e) {
        var n = t.call(this) || this;
        return (
          (n.DEFAULT_MEAN = 0),
          (n.DEFAULT_STDDEV = 0.05),
          (n.mean = e.mean || n.DEFAULT_MEAN),
          (n.stddev = e.stddev || n.DEFAULT_STDDEV),
          (n.seed = e.seed),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype.apply = function (t, e) {
          if ("float32" !== (e = e || "float32") && "int32" !== e)
            throw new Rn("randomNormal does not support dType " + e + ".");
          return Mr(t, this.mean, this.stddev, e, this.seed);
        }),
        (e.prototype.getConfig = function () {
          return { mean: this.mean, stddev: this.stddev, seed: this.seed };
        }),
        (e.className = "RandomNormal"),
        e
      );
    })(Hr);
    a.tc.registerClass(Yr);
    var Jr = (function (t) {
      function e(e) {
        var n = t.call(this) || this;
        return (
          (n.DEFAULT_MEAN = 0),
          (n.DEFAULT_STDDEV = 0.05),
          (n.mean = e.mean || n.DEFAULT_MEAN),
          (n.stddev = e.stddev || n.DEFAULT_STDDEV),
          (n.seed = e.seed),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype.apply = function (t, e) {
          if ("float32" !== (e = e || "float32") && "int32" !== e)
            throw new Rn("truncatedNormal does not support dType " + e + ".");
          return Object(a.ed)(t, this.mean, this.stddev, e, this.seed);
        }),
        (e.prototype.getConfig = function () {
          return { mean: this.mean, stddev: this.stddev, seed: this.seed };
        }),
        (e.className = "TruncatedNormal"),
        e
      );
    })(Hr);
    a.tc.registerClass(Jr);
    var $r = (function (t) {
      function e(e) {
        var n = t.call(this) || this;
        return (n.gain = null != e.gain ? e.gain : 1), n;
      }
      return (
        On(e, t),
        (e.prototype.apply = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            if (2 !== t.length || t[0] !== t[1])
              throw new Tn(
                "Identity matrix initializer can only be used for 2D square matrices."
              );
            return Object(a.Rb)(n.gain, Object(a.eb)(t[0]));
          });
        }),
        (e.prototype.getConfig = function () {
          return { gain: this.gain };
        }),
        (e.className = "Identity"),
        e
      );
    })(Hr);
    a.tc.registerClass($r);
    var Qr = (function (t) {
      function e(e) {
        var n = t.call(this) || this;
        if (e.scale < 0)
          throw new Tn("scale must be a positive float. Got: " + e.scale);
        return (
          (n.scale = null == e.scale ? 1 : e.scale),
          (n.mode = null == e.mode ? "fanIn" : e.mode),
          (function (t) {
            Kn(Vr, "FanMode", t);
          })(n.mode),
          (n.distribution = null == e.distribution ? "normal" : e.distribution),
          (function (t) {
            Kn(Gr, "Distribution", t);
          })(n.distribution),
          (n.seed = e.seed),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype.apply = function (t, e) {
          var n = (function (t, e) {
              var n, r;
              if ((void 0 === e && (e = "channelsLast"), hr(e), 2 === t.length))
                (n = t[0]), (r = t[1]);
              else if (-1 !== [3, 4, 5].indexOf(t.length))
                if ("channelsFirst" === e) {
                  var i = Cr(t, 2);
                  (n = t[1] * i), (r = t[0] * i);
                } else
                  "channelsLast" === e &&
                    ((i = Cr(t, 0, t.length - 2)),
                    (n = t[t.length - 2] * i),
                    (r = t[t.length - 1] * i));
              else {
                var a = Cr(t);
                (n = Math.sqrt(a)), (r = Math.sqrt(a));
              }
              return [n, r];
            })(t),
            r = n[0],
            i = n[1],
            o = this.scale;
          if (
            ("fanIn" === this.mode
              ? (o /= Math.max(1, r))
              : "fanOut" === this.mode
              ? (o /= Math.max(1, i))
              : (o /= Math.max(1, (r + i) / 2)),
            "normal" === this.distribution)
          ) {
            var s = Math.sqrt(o);
            if ("float32" !== (e = e || "float32") && "int32" !== e)
              throw new Rn(
                this.getClassName() + " does not support dType " + e + "."
              );
            return Object(a.ed)(t, 0, s, e, this.seed);
          }
          var u = Math.sqrt(3 * o);
          return Object(a.fc)(t, -u, u, e);
        }),
        (e.prototype.getConfig = function () {
          return {
            scale: this.scale,
            mode: this.mode,
            distribution: this.distribution,
            seed: this.seed,
          };
        }),
        (e.className = "VarianceScaling"),
        e
      );
    })(Hr);
    a.tc.registerClass(Qr);
    var ti = (function (t) {
      function e(e) {
        return (
          t.call(this, {
            scale: 1,
            mode: "fanAvg",
            distribution: "uniform",
            seed: null == e ? null : e.seed,
          }) || this
        );
      }
      return (
        On(e, t),
        (e.prototype.getClassName = function () {
          return Qr.className;
        }),
        (e.className = "GlorotUniform"),
        e
      );
    })(Qr);
    a.tc.registerClass(ti);
    var ei = (function (t) {
      function e(e) {
        return (
          t.call(this, {
            scale: 1,
            mode: "fanAvg",
            distribution: "normal",
            seed: null == e ? null : e.seed,
          }) || this
        );
      }
      return (
        On(e, t),
        (e.prototype.getClassName = function () {
          return Qr.className;
        }),
        (e.className = "GlorotNormal"),
        e
      );
    })(Qr);
    a.tc.registerClass(ei);
    var ni = (function (t) {
      function e(e) {
        return (
          t.call(this, {
            scale: 2,
            mode: "fanIn",
            distribution: "normal",
            seed: null == e ? null : e.seed,
          }) || this
        );
      }
      return (
        On(e, t),
        (e.prototype.getClassName = function () {
          return Qr.className;
        }),
        (e.className = "HeNormal"),
        e
      );
    })(Qr);
    a.tc.registerClass(ni);
    var ri = (function (t) {
      function e(e) {
        return (
          t.call(this, {
            scale: 2,
            mode: "fanIn",
            distribution: "uniform",
            seed: null == e ? null : e.seed,
          }) || this
        );
      }
      return (
        On(e, t),
        (e.prototype.getClassName = function () {
          return Qr.className;
        }),
        (e.className = "HeUniform"),
        e
      );
    })(Qr);
    a.tc.registerClass(ri);
    var ii = (function (t) {
      function e(e) {
        return (
          t.call(this, {
            scale: 1,
            mode: "fanIn",
            distribution: "normal",
            seed: null == e ? null : e.seed,
          }) || this
        );
      }
      return (
        On(e, t),
        (e.prototype.getClassName = function () {
          return Qr.className;
        }),
        (e.className = "LeCunNormal"),
        e
      );
    })(Qr);
    a.tc.registerClass(ii);
    var ai = (function (t) {
      function e(e) {
        return (
          t.call(this, {
            scale: 1,
            mode: "fanIn",
            distribution: "uniform",
            seed: null == e ? null : e.seed,
          }) || this
        );
      }
      return (
        On(e, t),
        (e.prototype.getClassName = function () {
          return Qr.className;
        }),
        (e.className = "LeCunNormal"),
        e
      );
    })(Qr);
    a.tc.registerClass(ai);
    var oi = (function (t) {
      function e(e) {
        var n = t.call(this) || this;
        if (
          ((n.DEFAULT_GAIN = 1),
          (n.gain = null == e.gain ? n.DEFAULT_GAIN : e.gain),
          (n.seed = e.seed),
          null != n.seed)
        )
          throw new Rn(
            "Random seed is not implemented for Orthogonal Initializer yet."
          );
        return n;
      }
      return (
        On(e, t),
        (e.prototype.apply = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            if (2 !== t.length)
              throw new Rn(
                "The Orthogonal Initializer does not support non-2D shapes yet."
              );
            t[0] * t[1] > 2e3 &&
              console.warn(
                "Orthogonal initializer is being called on a matrix with more than 2000 (" +
                  t[0] * t[1] +
                  ") elements: Slowness may result."
              );
            var e = Mr(t[0] > t[1] ? [t[1], t[0]] : t, 0, 1, "float32"),
              r = a.xb.gramSchmidt(e);
            return t[0] > t[1] && (r = r.transpose()), Object(a.Rb)(n.gain, r);
          });
        }),
        (e.prototype.getConfig = function () {
          return { gain: this.gain, seed: this.seed };
        }),
        (e.className = "Orthogonal"),
        e
      );
    })(Hr);
    a.tc.registerClass(oi);
    var si = {
      constant: "Constant",
      glorotNormal: "GlorotNormal",
      glorotUniform: "GlorotUniform",
      heNormal: "HeNormal",
      heUniform: "HeUniform",
      identity: "Identity",
      leCunNormal: "LeCunNormal",
      leCunUniform: "LeCunUniform",
      ones: "Ones",
      orthogonal: "Orthogonal",
      randomNormal: "RandomNormal",
      randomUniform: "RandomUniform",
      truncatedNormal: "TruncatedNormal",
      varianceScaling: "VarianceScaling",
      zeros: "Zeros",
    };
    function ui(t, e) {
      return (
        void 0 === e && (e = {}),
        Vn(t, a.tc.SerializationMap.getMap().classNameMap, e, "initializer")
      );
    }
    function ci(t) {
      return Un(t);
    }
    function li(t) {
      if ("string" == typeof t) {
        var e = t in si ? si[t] : t;
        if ("GlorotNormal" === e) return new ei();
        if ("GlorotUniform" === e) return new ti();
        if ("HeNormal" === e) return new ni();
        if ("HeUniform" === e) return new ri();
        if ("LeCunNormal" === e) return new ii();
        if ("LeCunUniform" === e) return new ai();
        var n = {};
        return (n.className = e), (n.config = {}), ui(n);
      }
      return t instanceof Hr ? t : ui(t);
    }
    Object.freeze({
      zeros: function () {
        return new qr();
      },
      ones: function () {
        return new Kr();
      },
      constant: function (t) {
        return new Zr(t);
      },
      randomUniform: function (t) {
        return new Xr(t);
      },
      randomNormal: function (t) {
        return new Yr(t);
      },
      truncatedNormal: function (t) {
        return new Jr(t);
      },
      identity: function (t) {
        return new $r(t);
      },
      varianceScaling: function (t) {
        return new Qr(t);
      },
      glorotUniform: function (t) {
        return new ti(t);
      },
      glorotNormal: function (t) {
        return new ei(t);
      },
      heNormal: function (t) {
        return new ni(t);
      },
      heUniform: function (t) {
        return new ri(t);
      },
      leCunNormal: function (t) {
        return new ii(t);
      },
      leCunUniform: function (t) {
        return new ai(t);
      },
      orthogonal: function (t) {
        return new oi(t);
      },
    });
    var pi = 0;
    function hi() {
      return pi++;
    }
    var fi = {};
    function di(t) {
      return (
        void 0 === t && (t = ""),
        t in fi || (fi[t] = 0),
        (fi[t] += 1),
        t + fi[t].toString()
      );
    }
    function mi(t) {
      return Array.isArray(t) && Array.isArray(t[0]);
    }
    function vi(t) {
      return 0 === t.length ? [] : Array.isArray(t[0]) ? t : [t];
    }
    function gi(t) {
      var e;
      if (Array.isArray(t)) {
        if (1 !== t.length)
          throw new Tn("Expected Tensor length to be 1; got " + t.length);
        e = t[0];
      } else e = t;
      return e;
    }
    function yi(t) {
      if (Array.isArray(t) && Array.isArray(t[0])) {
        if (1 === t.length) return (t = t)[0];
        throw new Tn("Expected exactly 1 Shape; got " + t.length);
      }
      return t;
    }
    function bi(t) {
      for (var e = 0, n = 0, r = t; n < r.length; n++) {
        var i = r[n];
        0 === i.shape.length
          ? (e += 1)
          : (e += i.shape.reduce(function (t, e) {
              return t * e;
            }));
      }
      return e;
    }
    var wi = (function () {
      function t(t, e, n, r, i) {
        void 0 === e && (e = "float32"),
          void 0 === n && (n = "Variable"),
          void 0 === r && (r = !0),
          void 0 === i && (i = null),
          (this.dtype = null == e ? "float32" : e),
          (this.shape = t.shape),
          (this.id = hi()),
          (n = null == n ? "Variable" : n),
          (this.originalName = gr(n)),
          (this.name = yr(this.originalName)),
          (this.trainable_ = r),
          (this.constraint = i),
          (this.val = Object(a.hd)(t, this.trainable_, this.name, this.dtype));
      }
      return (
        (t.prototype.read = function () {
          return this.assertNotDisposed(), this.val;
        }),
        (t.prototype.write = function (t) {
          return (
            this.assertNotDisposed(),
            (function (t, e) {
              if (t.shape.toString() !== e.shape.toString())
                throw new Error(
                  "Shape mismatch: " +
                    JSON.stringify(t.shape) +
                    " vs. " +
                    JSON.stringify(e.shape)
                );
            })(this.val, t),
            this.val.id !== t.id &&
              (this.val.assign(t),
              null != this.constraint &&
                this.val.assign(this.constraint.apply(this.val))),
            this
          );
        }),
        (t.prototype.dispose = function () {
          this.assertNotDisposed(), this.val.dispose();
        }),
        (t.prototype.assertNotDisposed = function () {
          if (this.val.isDisposed)
            throw new Error(
              "LayersVariable " + this.name + " is already disposed."
            );
        }),
        Object.defineProperty(t.prototype, "trainable", {
          get: function () {
            return this.trainable_;
          },
          set: function (t) {
            (this.trainable_ = t), (this.val.trainable = t);
          },
          enumerable: !0,
          configurable: !0,
        }),
        t
      );
    })();
    function xi(t) {
      return t.map(function (t) {
        return t.read();
      });
    }
    function Ci(t) {
      t.forEach(function (t) {
        t[0].write(t[1]);
      });
    }
    var Oi = function (t) {
        (this.dtype = t.dtype),
          (this.shape = t.shape),
          null != t.shape ? (this.ndim = t.shape.length) : (this.ndim = t.ndim),
          (this.maxNDim = t.maxNDim),
          (this.minNDim = t.minNDim),
          (this.axes = t.axes || {});
      },
      Ei = function (t, e, n, r, i, a, o) {
        (this.dtype = t),
          (this.shape = e),
          (this.sourceLayer = n),
          (this.inputs = r),
          (this.callArgs = i),
          (this.outputTensorIndex = o),
          (this.id = hi()),
          null != a &&
            ((this.originalName = gr(a)), (this.name = yr(this.originalName))),
          (this.rank = e.length);
      },
      Si = 0,
      Ni = (function () {
        function t(t, e) {
          (this.callArgs = e),
            (this.id = Si++),
            (this.outboundLayer = t.outboundLayer),
            (this.inboundLayers = t.inboundLayers),
            (this.nodeIndices = t.nodeIndices),
            (this.tensorIndices = t.tensorIndices),
            (this.inputTensors = t.inputTensors),
            (this.outputTensors = t.outputTensors),
            (this.inputMasks = t.inputMasks),
            (this.outputMasks = t.outputMasks),
            (this.inputShapes = t.inputShapes),
            (this.outputShapes = t.outputShapes);
          for (var n = 0, r = t.inboundLayers; n < r.length; n++) {
            var i = r[n];
            null != i && i.outboundNodes.push(this);
          }
          t.outboundLayer.inboundNodes.push(this);
        }
        return (
          (t.prototype.getConfig = function () {
            for (var t = [], e = 0, n = this.inboundLayers; e < n.length; e++) {
              var r = n[e];
              null != r ? t.push(r.name) : t.push(null);
            }
            return {
              outboundLayer: this.outboundLayer
                ? this.outboundLayer.name
                : null,
              inboundLayers: t,
              nodeIndices: this.nodeIndices,
              tensorIndices: this.tensorIndices,
            };
          }),
          t
        );
      })(),
      Ii = 0,
      ki = (function (t) {
        function e(e) {
          var n = t.call(this) || this;
          (n._callHook = null),
            (n._addedWeightNames = []),
            (n._stateful = !1),
            (n.id = Ii++),
            (n.activityRegularizer = null),
            (n.inputSpec = null),
            (n.supportsMasking = !1),
            (n._trainableWeights = []),
            (n._nonTrainableWeights = []),
            (n._losses = []),
            (n._updates = []),
            (n._built = !1),
            (n.inboundNodes = []),
            (n.outboundNodes = []);
          var r = e.name;
          if (!r) {
            var i = n.getClassName();
            r = Ln(i) + "_" + di(i);
          }
          if (
            ((n.name = r),
            (n.trainable_ = null == e.trainable || e.trainable),
            null != e.inputShape || null != e.batchInputShape)
          ) {
            var a = void 0;
            if (null != e.batchInputShape) a = e.batchInputShape;
            else if (null != e.inputShape) {
              var o = null;
              null != e.batchSize && (o = e.batchSize),
                (a = [o].concat(e.inputShape));
            }
            n.batchInputShape = a;
            var s = e.dtype;
            null == s && (s = e.inputDType),
              null == s && (s = "float32"),
              (n.dtype = s);
          }
          return (
            null != e.weights
              ? (n.initialWeights = e.weights)
              : (n.initialWeights = null),
            (n._refCount = null),
            (n.fastWeightInitDuringBuild = !1),
            n
          );
        }
        return (
          On(e, t),
          (e.nodeKey = function (t, e) {
            return t.name + "_ib-" + e.toString();
          }),
          (e.prototype.getNodeAtIndex = function (t, e) {
            if (0 === this.inboundNodes.length)
              throw new An(
                "The layer has never been called and thus has no defined " +
                  e +
                  "."
              );
            if (this.inboundNodes.length <= t)
              throw new Tn(
                "Asked to get " +
                  e +
                  " at node " +
                  t +
                  ", but the layer has only " +
                  this.inboundNodes.length +
                  " inbound nodes."
              );
            return this.inboundNodes[t];
          }),
          (e.prototype.getInputAt = function (t) {
            return Pn(this.getNodeAtIndex(t, "input").inputTensors);
          }),
          (e.prototype.getOutputAt = function (t) {
            return Pn(this.getNodeAtIndex(t, "output").outputTensors);
          }),
          Object.defineProperty(e.prototype, "input", {
            get: function () {
              if (this.inboundNodes.length > 1)
                throw new _n(
                  "Layer " +
                    this.name +
                    ' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.'
                );
              if (0 === this.inboundNodes.length)
                throw new _n(
                  "Layer " +
                    this.name +
                    " is not connected, no input to return."
                );
              return Pn(this.getNodeAtIndex(0, "input").inputTensors);
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(e.prototype, "output", {
            get: function () {
              if (0 === this.inboundNodes.length)
                throw new _n("Layer " + this.name + " has no inbound nodes.");
              if (this.inboundNodes.length > 1)
                throw new _n(
                  "Layer " +
                    this.name +
                    ' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.'
                );
              return Pn(this.getNodeAtIndex(0, "output").outputTensors);
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(e.prototype, "losses", {
            get: function () {
              return this._losses;
            },
            enumerable: !0,
            configurable: !0,
          }),
          (e.prototype.calculateLosses = function () {
            return this.losses.map(function (t) {
              return t();
            });
          }),
          Object.defineProperty(e.prototype, "updates", {
            get: function () {
              return this._updates;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(e.prototype, "built", {
            get: function () {
              return this._built;
            },
            set: function (t) {
              this._built = t;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(e.prototype, "trainable", {
            get: function () {
              return this.trainable_;
            },
            set: function (t) {
              this._trainableWeights.forEach(function (e) {
                return (e.trainable = t);
              }),
                (this.trainable_ = t);
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(e.prototype, "trainableWeights", {
            get: function () {
              return this.trainable_
                ? this._trainableWeights.filter(function (t) {
                    return t.trainable;
                  })
                : [];
            },
            set: function (t) {
              this._trainableWeights = t;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(e.prototype, "nonTrainableWeights", {
            get: function () {
              return this.trainable
                ? this._trainableWeights
                    .filter(function (t) {
                      return !t.trainable;
                    })
                    .concat(this._nonTrainableWeights)
                : this._trainableWeights.concat(this._nonTrainableWeights);
            },
            set: function (t) {
              this._nonTrainableWeights = t;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(e.prototype, "weights", {
            get: function () {
              return this.trainableWeights.concat(this.nonTrainableWeights);
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(e.prototype, "stateful", {
            get: function () {
              return this._stateful;
            },
            enumerable: !0,
            configurable: !0,
          }),
          (e.prototype.resetStates = function () {
            if (!this.stateful)
              throw new Error(
                "Cannot call the resetStates() method of a non-stateful Layer object."
              );
          }),
          (e.prototype.assertInputCompatibility = function (t) {
            if (
              ((t = zn(t)),
              null != this.inputSpec && 0 !== this.inputSpec.length)
            ) {
              var e = zn(this.inputSpec);
              if (t.length !== e.length)
                throw new Tn(
                  "Layer " +
                    this.name +
                    " expects " +
                    e.length +
                    " inputs, but it received " +
                    t.length +
                    " input tensors. Input received: " +
                    t
                );
              for (var n = 0; n < t.length; n++) {
                var r = t[n],
                  i = e[n];
                if (null != i) {
                  var a = r.rank;
                  if (null != i.ndim && a !== i.ndim)
                    throw new Tn(
                      "Input " +
                        n +
                        " is incompatible with layer " +
                        this.name +
                        ": expected ndim=" +
                        i.ndim +
                        ", found ndim=" +
                        a
                    );
                  if (null != i.maxNDim && a > i.maxNDim)
                    throw new Tn(
                      "Input " +
                        n +
                        " is incompatible with layer " +
                        this.name +
                        ": expected max_ndim=" +
                        i.maxNDim +
                        ", found ndim=" +
                        a
                    );
                  if (null != i.minNDim && a < i.minNDim)
                    throw new Tn(
                      "Input " +
                        n +
                        " is incompatible with layer " +
                        this.name +
                        ": expected min_ndim=" +
                        i.minNDim +
                        ", found ndim=" +
                        a +
                        "."
                    );
                  if (null != i.dtype && r.dtype !== i.dtype)
                    throw new Tn(
                      "Input " +
                        n +
                        " is incompatible with layer " +
                        this.name +
                        " : expected dtype=" +
                        i.dtype +
                        ", found dtype=" +
                        r.dtype +
                        "."
                    );
                  if (i.axes) {
                    var o = r.shape;
                    for (var s in i.axes) {
                      var u = Number(s),
                        c = i.axes[s],
                        l = u >= 0 ? o[u] : o[o.length + u];
                      if (null != c && -1 === [c, null].indexOf(l))
                        throw new Tn(
                          "Input " +
                            n +
                            " is incompatible with layer " +
                            this.name +
                            ": expected axis " +
                            u +
                            " of input shape to have value " +
                            c +
                            " but got shape " +
                            o +
                            "."
                        );
                    }
                  }
                  if (null != i.shape)
                    for (var p = 0; p < i.shape.length; ++p) {
                      var h = i.shape[p],
                        f = r.shape[p];
                      if (null != h && null != f && h !== f)
                        throw new Tn(
                          "Input " +
                            n +
                            " is incompatible with layer " +
                            this.name +
                            ": expected shape=" +
                            i.shape +
                            ", found shape=" +
                            r.shape +
                            "."
                        );
                    }
                }
              }
            }
          }),
          (e.prototype.call = function (t, e) {
            return t;
          }),
          (e.prototype.invokeCallHook = function (t, e) {
            null != this._callHook && this._callHook(t, e);
          }),
          (e.prototype.setCallHook = function (t) {
            this._callHook = t;
          }),
          (e.prototype.clearCallHook = function () {
            this._callHook = null;
          }),
          (e.prototype.apply = function (t, e) {
            var n = this;
            (e = e || {}), this.assertNotDisposed();
            for (var r = zn(t), i = !0, a = 0, o = r; a < o.length; a++)
              if (!(o[a] instanceof Ei)) {
                i = !1;
                break;
              }
            for (var s = !0, u = 0, c = r; u < c.length; u++)
              if (c[u] instanceof Ei) {
                s = !1;
                break;
              }
            if (i === s)
              throw new Tn(
                "Arguments to apply() must be all SymbolicTensors or all Tensors"
              );
            return vr(this.name, function () {
              if (!n.built) {
                n.assertInputCompatibility(t);
                for (var i = [], a = 0, o = zn(t); a < o.length; a++) {
                  var u = o[a];
                  i.push(u.shape);
                }
                n.build(Pn(i)),
                  (n.built = !0),
                  n.initialWeights && n.setWeights(n.initialWeights),
                  null === n._refCount && s && (n._refCount = 1);
              }
              if ((n.assertInputCompatibility(t), s)) {
                for (
                  var c = [], l = 0, p = zn((m = n.call(t, e)));
                  l < p.length;
                  l++
                ) {
                  var h = p[l];
                  -1 !== r.indexOf(h) && (h = h.clone()), c.push(h);
                }
                if (((m = Pn(c)), null != n.activityRegularizer))
                  throw new Rn(
                    "Layer invocation in the presence of activity regularizer(s) is not supported yet."
                  );
                return m;
              }
              var f = (function (t) {
                  for (var e = [], n = 0, r = (t = zn(t)); n < r.length; n++) {
                    var i = r[n];
                    e.push(i.shape);
                  }
                  return Pn(e);
                })(t),
                d = n.computeOutputShape(f),
                m = void 0,
                v = "float32";
              if (
                (n.warnOnIncompatibleInputShape(Array.isArray(t) ? f[0] : f),
                (m =
                  null != d && d.length > 0 && Array.isArray(d[0])
                    ? d.map(function (r, i) {
                        return new Ei(v, r, n, zn(t), e, n.name, i);
                      })
                    : new Ei(v, d, n, zn(t), e, n.name)),
                n.addInboundNode(t, m, null, null, f, d, e),
                n._refCount++,
                null != n.activityRegularizer)
              )
                throw new Rn(
                  "Layer invocation in the presence of activity regularizer(s) is not supported yet."
                );
              return m;
            });
          }),
          (e.prototype.warnOnIncompatibleInputShape = function (t) {
            if (null != this.batchInputShape)
              if (t.length !== this.batchInputShape.length)
                console.warn(
                  "The rank of the input tensor provided (shape: " +
                    JSON.stringify(t) +
                    ") does not match that of the batchInputShape (" +
                    JSON.stringify(this.batchInputShape) +
                    ") of the layer " +
                    this.name
                );
              else {
                var e = !1;
                this.batchInputShape.forEach(function (n, r) {
                  null != n && null != t[r] && t[r] !== n && (e = !0);
                }),
                  e &&
                    console.warn(
                      "The shape of the input tensor (" +
                        JSON.stringify(t) +
                        ") does not match the expectation of layer " +
                        this.name +
                        ": " +
                        JSON.stringify(this.batchInputShape)
                    );
              }
          }),
          Object.defineProperty(e.prototype, "outputShape", {
            get: function () {
              if (null == this.inboundNodes || 0 === this.inboundNodes.length)
                throw new _n(
                  "The layer " +
                    this.name +
                    " has never been called and thus has no defined output shape."
                );
              for (
                var t = [], e = 0, n = this.inboundNodes;
                e < n.length;
                e++
              ) {
                var r = n[e],
                  i = JSON.stringify(r.outputShapes);
                -1 === t.indexOf(i) && t.push(i);
              }
              if (1 === t.length) {
                var a = this.inboundNodes[0].outputShapes;
                return Array.isArray(a) && Array.isArray(a[0]) && 1 === a.length
                  ? a[0]
                  : a;
              }
              throw new _n(
                "The layer " +
                  this.name +
                  ' has multiple inbound nodes with different output shapes. Hence the notion of "outut shape" is ill-defined for the layer.'
              );
            },
            enumerable: !0,
            configurable: !0,
          }),
          (e.prototype.countParams = function () {
            if (!this.built)
              throw new An(
                "You tried to call countParams() on " +
                  this.name +
                  ", but the layer is not built yet. Build it first by calling build(batchInputShape)."
              );
            return bi(this.weights);
          }),
          (e.prototype.build = function (t) {
            this.built = !0;
          }),
          (e.prototype.getWeights = function (t) {
            return (
              void 0 === t && (t = !1),
              xi(t ? this.trainableWeights : this.weights)
            );
          }),
          (e.prototype.setWeights = function (t) {
            var e = this;
            Object(a.Zc)(function () {
              var n = e.weights;
              if (n.length !== t.length)
                throw new Tn(
                  'You called setWeights(weights) on layer "' +
                    e.name +
                    '" with a weight list of length ' +
                    t.length +
                    ", but the layer was expecting " +
                    n.length +
                    " weights. Provided weights: " +
                    t +
                    "..."
                );
              if (0 !== n.length) {
                for (var r = [], i = xi(n), o = 0; o < i.length; ++o) {
                  var s = i[o],
                    u = n[o],
                    c = t[o];
                  if (!a.gd.arraysEqual(s.shape, c.shape))
                    throw new Tn(
                      "Layer weight shape " +
                        s.shape +
                        " not compatible with provided weight shape " +
                        c.shape
                    );
                  r.push([u, c]);
                }
                Ci(r);
              }
            });
          }),
          (e.prototype.addWeight = function (t, e, n, r, i, a, o) {
            if (-1 !== this._addedWeightNames.indexOf(t))
              throw new Tn(
                "Duplicate weight name " + t + " for layer " + this.name
              );
            this._addedWeightNames.push(t),
              null == n && (n = "float32"),
              this.fastWeightInitDuringBuild && (r = li("zeros"));
            var s = r.apply(e, n),
              u = new wi(s, n, t, a, o);
            return (
              s.dispose(),
              null != i &&
                this.addLoss(function () {
                  return i.apply(u.read());
                }),
              null == a && (a = !0),
              a
                ? this._trainableWeights.push(u)
                : this._nonTrainableWeights.push(u),
              u
            );
          }),
          (e.prototype.setFastWeightInitDuringBuild = function (t) {
            this.fastWeightInitDuringBuild = t;
          }),
          (e.prototype.addLoss = function (t) {
            var e;
            null == t ||
              (Array.isArray(t) && 0 === t.length) ||
              ((t = zn(t)),
              void 0 !== this._losses &&
                null !== this._losses &&
                (e = this.losses).push.apply(e, t));
          }),
          (e.prototype.computeOutputShape = function (t) {
            return t;
          }),
          (e.prototype.computeMask = function (t, e) {
            var n = this;
            if (!this.supportsMasking) {
              if (null != e) {
                if (!Array.isArray(e))
                  throw new TypeError(
                    "Layer " +
                      this.name +
                      " does not support masking, but was passed an inputMask."
                  );
                e.forEach(function (t) {
                  if (null != t)
                    throw new TypeError(
                      "Layer " +
                        n.name +
                        " does not support masking, but was passed an inputMask."
                    );
                });
              }
              return null;
            }
            return e;
          }),
          (e.prototype.addInboundNode = function (t, e, n, r, i, a, o) {
            void 0 === o && (o = null);
            var s = zn(t);
            (e = zn(e)), (n = zn(n)), (r = zn(r)), (i = vi(i)), (a = vi(a));
            for (var u = [], c = [], l = [], p = 0, h = s; p < h.length; p++) {
              var f = h[p];
              u.push(f.sourceLayer), c.push(f.nodeIndex), l.push(f.tensorIndex);
            }
            new Ni(
              {
                outboundLayer: this,
                inboundLayers: u,
                nodeIndices: c,
                tensorIndices: l,
                inputTensors: s,
                outputTensors: e,
                inputMasks: n,
                outputMasks: r,
                inputShapes: i,
                outputShapes: a,
              },
              o
            );
            for (var d = 0; d < e.length; d++)
              (e[d].sourceLayer = this),
                (e[d].nodeIndex = this.inboundNodes.length - 1),
                (e[d].tensorIndex = d);
          }),
          (e.prototype.getConfig = function () {
            var t = { name: this.name, trainable: this.trainable };
            return (
              null != this.batchInputShape &&
                (t.batchInputShape = this.batchInputShape),
              null != this.dtype && (t.dtype = this.dtype),
              t
            );
          }),
          (e.prototype.disposeWeights = function () {
            return (
              this.weights.forEach(function (t) {
                return t.dispose();
              }),
              this.weights.length
            );
          }),
          (e.prototype.assertNotDisposed = function () {
            if (0 === this._refCount)
              throw new Error("Layer '" + this.name + "' is already disposed.");
          }),
          (e.prototype.dispose = function () {
            if (!this.built)
              throw new Error(
                "Cannot dispose Layer " +
                  this.name +
                  " because it has not been built yet."
              );
            if (null === this._refCount)
              throw new Error(
                "Cannot dispose Layer " +
                  this.name +
                  " because it has not been used yet."
              );
            this.assertNotDisposed();
            var t = 0;
            return (
              0 == --this._refCount && (t = this.disposeWeights()),
              { refCountAfterDispose: this._refCount, numDisposedVariables: t }
            );
          }),
          e
        );
      })(a.tc.Serializable);
    var _i,
      Ai,
      Ti = (function (t) {
        function e(e) {
          var n =
            t.call(this, {
              dtype: e.dtype,
              name: null != e.name ? e.name : di("input").toString(),
            }) || this;
          if (
            (null == e.batchSize && (e.batchSize = null),
            null == e.sparse && (e.sparse = !1),
            (n.trainable = !1),
            (n.built = !0),
            (n.sparse = e.sparse),
            null != e.inputShape && null != e.batchInputShape)
          )
            throw new Tn(
              "Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time."
            );
          var r = e.batchInputShape;
          if (null == r) {
            if (null == e.inputShape)
              throw new Tn(
                "An InputLayer should be passed either a `batchInputShape` or an `inputShape`."
              );
            r = [e.batchSize].concat(e.inputShape);
          } else if (null != e.batchSize)
            throw new Tn(
              "Cannot specify batchSize if batchInputShape is specified when creating an InputLayer."
            );
          var i = e.dtype || "float32";
          (n.batchInputShape = r),
            (n.dtype = i),
            (n.inputSpec = [{ shape: r }]);
          var a = new Ei(n.dtype, n.batchInputShape, n, [], {}, n.name);
          return (
            (a.nodeIndex = 0),
            (a.tensorIndex = 0),
            new Ni({
              outboundLayer: n,
              inboundLayers: [],
              nodeIndices: [],
              tensorIndices: [],
              inputTensors: [a],
              outputTensors: [a],
              inputMasks: [null],
              outputMasks: [null],
              inputShapes: [r],
              outputShapes: [r],
            }),
            n
          );
        }
        return (
          On(e, t),
          (e.prototype.apply = function (t, e) {
            throw new Tn(
              "Cannot pass any input to an InputLayer's apply() method. InputLayer name: " +
                this.name
            );
          }),
          (e.prototype.dispose = function () {
            return {
              refCountAfterDispose: this._refCount,
              numDisposedVariables: 0,
            };
          }),
          (e.prototype.getConfig = function () {
            return {
              batchInputShape: this.batchInputShape,
              dtype: this.dtype,
              sparse: this.sparse,
              name: this.name,
            };
          }),
          (e.className = "InputLayer"),
          e
        );
      })(ki);
    function Ri(t) {
      if (null == t.batchShape && null == t.shape)
        throw new Error(
          "Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension."
        );
      if (null != t.batchShape && null != t.shape)
        throw new Tn(
          "Please provide either a `shape` or `batchShape` argument to Input, but not both."
        );
      var e = t.batchShape;
      null != t.shape && null == e && (e = [null].concat(t.shape));
      var n = t.dtype;
      return (
        null == n && (n = "float32"),
        new Ti({ batchInputShape: e, name: t.name, dtype: n, sparse: t.sparse })
          .inboundNodes[0].outputTensors[0]
      );
    }
    function Di(t) {
      return Nn(this, void 0, void 0, function () {
        var e, n, r, i, o, s, u, c;
        return In(this, function (l) {
          switch (l.label) {
            case 0:
              if (null == t) return [2];
              for (i in ((e = []), (n = []), (r = []), t))
                "number" != typeof (o = t[i]) &&
                  ((s = o), e.push(s.data()), n.push(i), r.push(s));
              return e.length > 0 ? [4, Promise.all(e)] : [3, 2];
            case 1:
              for (u = l.sent(), c = 0; c < u.length; ++c) t[n[c]] = u[c][0];
              Object(a.S)(r), (l.label = 2);
            case 2:
              return [2];
          }
        });
      });
    }
    function Fi(t) {
      if (null != t)
        for (var e in t) {
          var n = t[e];
          "number" != typeof n && n.dispose();
        }
    }
    a.tc.registerClass(Ti),
      ((Ai = _i || (_i = {}))[(Ai.SILENT = 0)] = "SILENT"),
      (Ai[(Ai.VERBOSE = 1)] = "VERBOSE");
    var Mi = (function () {
        function t() {
          this.validationData = null;
        }
        return (
          (t.prototype.setParams = function (t) {
            this.params = t;
          }),
          (t.prototype.onEpochBegin = function (t, e) {
            return Nn(this, void 0, void 0, function () {
              return In(this, function (t) {
                return [2];
              });
            });
          }),
          (t.prototype.onEpochEnd = function (t, e) {
            return Nn(this, void 0, void 0, function () {
              return In(this, function (t) {
                return [2];
              });
            });
          }),
          (t.prototype.onBatchBegin = function (t, e) {
            return Nn(this, void 0, void 0, function () {
              return In(this, function (t) {
                return [2];
              });
            });
          }),
          (t.prototype.onBatchEnd = function (t, e) {
            return Nn(this, void 0, void 0, function () {
              return In(this, function (t) {
                return [2];
              });
            });
          }),
          (t.prototype.onTrainBegin = function (t) {
            return Nn(this, void 0, void 0, function () {
              return In(this, function (t) {
                return [2];
              });
            });
          }),
          (t.prototype.onTrainEnd = function (t) {
            return Nn(this, void 0, void 0, function () {
              return In(this, function (t) {
                return [2];
              });
            });
          }),
          (t.prototype.setModel = function (t) {}),
          t
        );
      })(),
      ji = (function () {
        function t(t, e) {
          void 0 === e && (e = 10),
            null == t && (t = []),
            (this.callbacks = t),
            (this.queueLength = e);
        }
        return (
          (t.prototype.append = function (t) {
            this.callbacks.push(t);
          }),
          (t.prototype.setParams = function (t) {
            for (var e = 0, n = this.callbacks; e < n.length; e++)
              n[e].setParams(t);
          }),
          (t.prototype.setModel = function (t) {
            for (var e = 0, n = this.callbacks; e < n.length; e++)
              n[e].setModel(t);
          }),
          (t.prototype.onEpochBegin = function (t, e) {
            return Nn(this, void 0, void 0, function () {
              var n, r;
              return In(this, function (i) {
                switch (i.label) {
                  case 0:
                    null == e && (e = {}),
                      (n = 0),
                      (r = this.callbacks),
                      (i.label = 1);
                  case 1:
                    return n < r.length ? [4, r[n].onEpochBegin(t, e)] : [3, 4];
                  case 2:
                    i.sent(), (i.label = 3);
                  case 3:
                    return n++, [3, 1];
                  case 4:
                    return [2];
                }
              });
            });
          }),
          (t.prototype.onEpochEnd = function (t, e) {
            return Nn(this, void 0, void 0, function () {
              var n, r;
              return In(this, function (i) {
                switch (i.label) {
                  case 0:
                    null == e && (e = {}),
                      (n = 0),
                      (r = this.callbacks),
                      (i.label = 1);
                  case 1:
                    return n < r.length ? [4, r[n].onEpochEnd(t, e)] : [3, 4];
                  case 2:
                    i.sent(), (i.label = 3);
                  case 3:
                    return n++, [3, 1];
                  case 4:
                    return [2];
                }
              });
            });
          }),
          (t.prototype.onBatchBegin = function (t, e) {
            return Nn(this, void 0, void 0, function () {
              var n, r;
              return In(this, function (i) {
                switch (i.label) {
                  case 0:
                    null == e && (e = {}),
                      (n = 0),
                      (r = this.callbacks),
                      (i.label = 1);
                  case 1:
                    return n < r.length ? [4, r[n].onBatchBegin(t, e)] : [3, 4];
                  case 2:
                    i.sent(), (i.label = 3);
                  case 3:
                    return n++, [3, 1];
                  case 4:
                    return [2];
                }
              });
            });
          }),
          (t.prototype.onBatchEnd = function (t, e) {
            return Nn(this, void 0, void 0, function () {
              var n, r;
              return In(this, function (i) {
                switch (i.label) {
                  case 0:
                    null == e && (e = {}),
                      (n = 0),
                      (r = this.callbacks),
                      (i.label = 1);
                  case 1:
                    return n < r.length ? [4, r[n].onBatchEnd(t, e)] : [3, 4];
                  case 2:
                    i.sent(), (i.label = 3);
                  case 3:
                    return n++, [3, 1];
                  case 4:
                    return [2];
                }
              });
            });
          }),
          (t.prototype.onTrainBegin = function (t) {
            return Nn(this, void 0, void 0, function () {
              var e, n;
              return In(this, function (r) {
                switch (r.label) {
                  case 0:
                    null == t && (t = {}),
                      (e = 0),
                      (n = this.callbacks),
                      (r.label = 1);
                  case 1:
                    return e < n.length ? [4, n[e].onTrainBegin(t)] : [3, 4];
                  case 2:
                    r.sent(), (r.label = 3);
                  case 3:
                    return e++, [3, 1];
                  case 4:
                    return [2];
                }
              });
            });
          }),
          (t.prototype.onTrainEnd = function (t) {
            return Nn(this, void 0, void 0, function () {
              var e, n;
              return In(this, function (r) {
                switch (r.label) {
                  case 0:
                    null == t && (t = {}),
                      (e = 0),
                      (n = this.callbacks),
                      (r.label = 1);
                  case 1:
                    return e < n.length ? [4, n[e].onTrainEnd(t)] : [3, 4];
                  case 2:
                    r.sent(), (r.label = 3);
                  case 3:
                    return e++, [3, 1];
                  case 4:
                    return [2];
                }
              });
            });
          }),
          t
        );
      })(),
      Pi = (function (t) {
        function e() {
          return t.call(this) || this;
        }
        return (
          On(e, t),
          (e.prototype.onEpochBegin = function (t) {
            return Nn(this, void 0, void 0, function () {
              return In(this, function (t) {
                return (this.seen = 0), (this.totals = {}), [2];
              });
            });
          }),
          (e.prototype.onBatchEnd = function (t, e) {
            return Nn(this, void 0, void 0, function () {
              var t,
                n,
                r,
                i,
                o = this;
              return In(this, function (s) {
                for (i in (null == e && (e = {}),
                (t = null == e.size ? 0 : e.size),
                (this.seen += t),
                (n = function (n) {
                  var i = e[n];
                  if ("number" == typeof i)
                    r.totals.hasOwnProperty(n) || (r.totals[n] = 0),
                      (r.totals[n] = r.totals[n] + i * t);
                  else {
                    var s = void 0;
                    n in r.totals ? (s = r.totals[n]) : (r.totals[n] = 0);
                    var u = Object(a.Zc)(function () {
                      return Object(a.g)(o.totals[n], Object(a.Rb)(i, t));
                    });
                    (r.totals[n] = u), null != s && s.dispose();
                  }
                }),
                (r = this),
                e))
                  n(i);
                return [2];
              });
            });
          }),
          (e.prototype.onEpochEnd = function (t, e) {
            return Nn(this, void 0, void 0, function () {
              var t,
                n,
                r,
                i,
                o,
                s = this;
              return In(this, function (u) {
                if (null != e)
                  for (
                    t = function (t) {
                      if (null == n.totals[t]) return "continue";
                      "number" == typeof n.totals[t]
                        ? (e[t] = n.totals[t] / n.seen)
                        : Object(a.Zc)(function () {
                            var n = Object(a.Rb)(
                              Object(a.T)(1, s.seen),
                              s.totals[t]
                            );
                            (e[t] = n),
                              s.totals[t].dispose(),
                              Object(a.tb)(e[t]);
                          });
                    },
                      n = this,
                      r = 0,
                      i = this.params.metrics;
                    r < i.length;
                    r++
                  )
                    (o = i[r]), t(o);
                return [2];
              });
            });
          }),
          e
        );
      })(Mi),
      zi = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          On(e, t),
          (e.prototype.onTrainBegin = function (t) {
            return Nn(this, void 0, void 0, function () {
              return In(this, function (t) {
                return (this.epoch = []), (this.history = {}), [2];
              });
            });
          }),
          (e.prototype.onEpochEnd = function (t, e) {
            return Nn(this, void 0, void 0, function () {
              var n;
              return In(this, function (r) {
                for (n in (null == e && (e = {}), this.epoch.push(t), e))
                  null == this.history[n] && (this.history[n] = []),
                    this.history[n].push(e[n]);
                return [2];
              });
            });
          }),
          (e.prototype.syncData = function () {
            return Nn(this, void 0, void 0, function () {
              var t, e, n, r, i, a, o, s, u;
              return In(this, function (c) {
                switch (c.label) {
                  case 0:
                    for (r in ((t = []), (e = []), (n = []), this.history))
                      for (i = this.history[r], a = 0; a < i.length; ++a)
                        "number" != typeof i[a] &&
                          ((o = i[a]), t.push(o.data()), e.push(r), n.push(a));
                    return [4, Promise.all(t)];
                  case 1:
                    for (s = c.sent(), u = 0; u < s.length; ++u)
                      this.history[e[u]][n[u]].dispose(),
                        (this.history[e[u]][n[u]] = s[u][0]);
                    return [2];
                }
              });
            });
          }),
          e
        );
      })(Mi),
      Li = (function (t) {
        function e(e, n) {
          var r = t.call(this) || this;
          if (
            ((r.currentEpoch = 0),
            (r.yieldEvery = n || "auto"),
            "auto" === r.yieldEvery && (r.yieldEvery = 125),
            "never" === r.yieldEvery && null != e.onYield)
          )
            throw new Error(
              "yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback"
            );
          return (
            a.gd.isNumber(r.yieldEvery) &&
              (r.maybeWait = (function (t, e) {
                var n,
                  r = a.gd.now();
                return function () {
                  for (var i = [], o = 0; o < arguments.length; o++)
                    i[o] = arguments[o];
                  var s = a.gd.now();
                  return s - r < e ? n : ((r = s), (n = t.apply(void 0, i)));
                };
              })(r.maybeWait.bind(r), r.yieldEvery)),
            (r.trainBegin = e.onTrainBegin),
            (r.trainEnd = e.onTrainEnd),
            (r.epochBegin = e.onEpochBegin),
            (r.epochEnd = e.onEpochEnd),
            (r.batchBegin = e.onBatchBegin),
            (r.batchEnd = e.onBatchEnd),
            (r.yield = e.onYield),
            r
          );
        }
        return (
          On(e, t),
          (e.prototype.maybeWait = function (t, e, n) {
            return Nn(this, void 0, void 0, function () {
              var r;
              return In(this, function (i) {
                switch (i.label) {
                  case 0:
                    return (r = []), null == this.yield ? [3, 2] : [4, Di(n)];
                  case 1:
                    i.sent(), r.push(this.yield(t, e, n)), (i.label = 2);
                  case 2:
                    return r.push(Object(a.Vb)()), [4, Promise.all(r)];
                  case 3:
                    return i.sent(), [2];
                }
              });
            });
          }),
          (e.prototype.onEpochBegin = function (t, e) {
            return Nn(this, void 0, void 0, function () {
              return In(this, function (n) {
                switch (n.label) {
                  case 0:
                    return (
                      (this.currentEpoch = t),
                      null == this.epochBegin ? [3, 3] : [4, Di(e)]
                    );
                  case 1:
                    return n.sent(), [4, this.epochBegin(t, e)];
                  case 2:
                    n.sent(), (n.label = 3);
                  case 3:
                    return [2];
                }
              });
            });
          }),
          (e.prototype.onEpochEnd = function (t, e) {
            return Nn(this, void 0, void 0, function () {
              var n;
              return In(this, function (r) {
                switch (r.label) {
                  case 0:
                    return (
                      (n = []), null == this.epochEnd ? [3, 2] : [4, Di(e)]
                    );
                  case 1:
                    r.sent(), n.push(this.epochEnd(t, e)), (r.label = 2);
                  case 2:
                    return (
                      "epoch" === this.yieldEvery && n.push(Object(a.Vb)()),
                      [4, Promise.all(n)]
                    );
                  case 3:
                    return r.sent(), [2];
                }
              });
            });
          }),
          (e.prototype.onBatchBegin = function (t, e) {
            return Nn(this, void 0, void 0, function () {
              return In(this, function (n) {
                switch (n.label) {
                  case 0:
                    return null == this.batchBegin ? [3, 3] : [4, Di(e)];
                  case 1:
                    return n.sent(), [4, this.batchBegin(t, e)];
                  case 2:
                    n.sent(), (n.label = 3);
                  case 3:
                    return [2];
                }
              });
            });
          }),
          (e.prototype.onBatchEnd = function (t, e) {
            return Nn(this, void 0, void 0, function () {
              var n;
              return In(this, function (r) {
                switch (r.label) {
                  case 0:
                    return (
                      (n = []), null == this.batchEnd ? [3, 2] : [4, Di(e)]
                    );
                  case 1:
                    r.sent(), n.push(this.batchEnd(t, e)), (r.label = 2);
                  case 2:
                    return (
                      "batch" === this.yieldEvery
                        ? n.push(Object(a.Vb)())
                        : a.gd.isNumber(this.yieldEvery) &&
                          n.push(this.maybeWait(this.currentEpoch, t, e)),
                      [4, Promise.all(n)]
                    );
                  case 3:
                    return r.sent(), [2];
                }
              });
            });
          }),
          (e.prototype.onTrainBegin = function (t) {
            return Nn(this, void 0, void 0, function () {
              return In(this, function (e) {
                switch (e.label) {
                  case 0:
                    return null == this.trainBegin ? [3, 3] : [4, Di(t)];
                  case 1:
                    return e.sent(), [4, this.trainBegin(t)];
                  case 2:
                    e.sent(), (e.label = 3);
                  case 3:
                    return [2];
                }
              });
            });
          }),
          (e.prototype.onTrainEnd = function (t) {
            return Nn(this, void 0, void 0, function () {
              return In(this, function (e) {
                switch (e.label) {
                  case 0:
                    return null == this.trainEnd ? [3, 3] : [4, Di(t)];
                  case 1:
                    return e.sent(), [4, this.trainEnd(t)];
                  case 2:
                    e.sent(), (e.label = 3);
                  case 3:
                    return [2];
                }
              });
            });
          }),
          e
        );
      })(Mi);
    function Bi(t, e) {
      return (
        null == t && (t = {}),
        t instanceof Mi
          ? [t]
          : Array.isArray(t) && t[0] instanceof Mi
          ? t
          : zn(t).map(function (t) {
              return new Li(t, e);
            })
      );
    }
    var Wi = (function () {
      function t() {}
      return (
        (t.registerCallbackConstructor = function (e, n) {
          a.gd.assert(e >= 0 && Number.isInteger(e), function () {
            return (
              "Verbosity level is expected to be an integer >= 0, but got " + e
            );
          }),
            t.checkForDuplicate(n),
            null == t.constructors[e] && (t.constructors[e] = []),
            t.constructors[e].push(n);
        }),
        (t.checkForDuplicate = function (e) {
          for (var n in t.constructors)
            t.constructors[+n].forEach(function (t) {
              if (t === e) throw new Tn("Duplicate callback constructor.");
            });
        }),
        (t.clear = function () {
          t.constructors = {};
        }),
        (t.createCallbacks = function (e) {
          var n = [];
          for (var r in t.constructors) {
            var i = +r;
            e >= i && n.push.apply(n, t.constructors[i]);
          }
          return n.map(function (t) {
            return new t();
          });
        }),
        (t.constructors = {}),
        t
      );
    })();
    function Ui(t, e, n, r, i, a, o, s, u) {
      var c = new zi(),
        l = [new Pi()].concat(Wi.createCallbacks(e));
      null != t && l.push.apply(l, t), l.push(c);
      var p = new ji(l);
      return (
        p.setParams({
          epochs: n,
          initialEpoch: r,
          samples: i,
          steps: a,
          batchSize: o,
          verbose: e,
          doValidation: s,
          metrics: u,
        }),
        { callbackList: p, history: c }
      );
    }
    function Vi(t, e, n) {
      return (
        void 0 === e && (e = {}),
        void 0 === n && (n = !1),
        Vn(t, a.tc.SerializationMap.getMap().classNameMap, e, "layer", n)
      );
    }
    function Gi(t, e) {
      return Object(a.Zc)(function () {
        "float32" !== t.dtype && (t = t.asType("float32"));
        var n = Object(a.Qc)(zr(t), e, !0),
          r = Object(a.gb)(n.shape, kn()),
          i = Object(a.Jc)(Object(a.Kb)(n, r));
        return Object(a.T)(t, i);
      });
    }
    function Hi(t, e) {
      return Object(a.Zc)(function () {
        return Object(a.Lb)(zr(Object(a.Pc)(e, t)), -1);
      });
    }
    function qi(t, e) {
      return Object(a.Zc)(function () {
        return Object(a.Lb)(Object(a.d)(Object(a.Pc)(e, t)), -1);
      });
    }
    function Ki(t, e) {
      return Object(a.Zc)(function () {
        var n = Object(a.Pc)(t, e),
          r = Object(a.C)(Object(a.d)(t), kn(), Number.MAX_VALUE),
          i = Object(a.d)(Object(a.T)(n, r));
        return Object(a.Rb)(100, Object(a.Lb)(i, -1));
      });
    }
    function Zi(t, e, n) {
      return (
        void 0 === n && (n = !1),
        Object(a.Zc)(function () {
          if (n) e = Object(a.Ec)(e);
          else {
            var r = Object(a.Qc)(e, e.shape.length - 1, !0);
            e = Object(a.T)(e, r);
          }
          return (
            (e = Object(a.C)(e, kn(), 1 - kn())),
            Object(a.Ub)(
              Object(a.Qc)(
                Object(a.Rb)(t.toFloat(), Object(a.Ab)(e)),
                e.shape.length - 1
              )
            )
          );
        })
      );
    }
    function Xi(t, e) {
      return Object(a.Zc)(function () {
        var n = Object(a.hb)(
            (function (t) {
              var e = [Cr(t.shape)];
              return t.reshape(e);
            })(t)
          ).toInt(),
          r = (e = Object(a.C)(e, kn(), 1 - kn())).shape;
        return Zi(Object(a.Xb)(n, r[r.length - 1]).reshape(r), e, !1);
      });
    }
    function Yi(t, e) {
      return Object(a.Zc)(function () {
        var n;
        return (
          (n = Object(a.C)(e, kn(), 1 - kn())),
          (n = Object(a.Ab)(Object(a.T)(n, Object(a.Pc)(1, n)))),
          Object(a.Lb)(
            (function (t, e) {
              if (!a.gd.arraysEqual(t.shape, e.shape))
                throw new Tn(
                  "logits and labels must have the same shape, but got shapes " +
                    JSON.stringify(t.shape) +
                    " and " +
                    JSON.stringify(e.shape)
                );
              return Object(a.Zc)(function () {
                var n = e.relu(),
                  r = e.abs().neg();
                return n.sub(e.mul(t)).add(r.exp().log1p());
              });
            })(t, n),
            -1
          )
        );
      });
    }
    function Ji(t, e) {
      return Object(a.Zc)(function () {
        var n = Gi(t, -1),
          r = Gi(e, -1),
          i = Object(a.Rb)(n, r);
        return Object(a.Ub)(Object(a.Qc)(i, -1));
      });
    }
    var $i = {
      meanSquaredError: Hi,
      meanAbsoluteError: qi,
      meanAbsolutePercentageError: Ki,
      meanSquaredLogarithmicError: function (t, e) {
        return Object(a.Zc)(function () {
          var n = Object(a.C)(e, kn(), Number.MAX_VALUE),
            r = Object(a.Ab)(Object(a.g)(1, n)),
            i = Object(a.C)(t, kn(), Number.MAX_VALUE),
            o = Object(a.Ab)(Object(a.g)(1, i));
          return Object(a.Lb)(zr(Object(a.Pc)(r, o)), -1);
        });
      },
      squaredHinge: function (t, e) {
        return Object(a.Zc)(function () {
          var n = Object(a.Kb)(0, Object(a.Pc)(1, Object(a.Rb)(t, e)));
          return Object(a.Lb)(zr(n), -1);
        });
      },
      hinge: function (t, e) {
        return Object(a.Zc)(function () {
          var n = Object(a.Kb)(0, Object(a.Pc)(1, Object(a.Rb)(t, e)));
          return Object(a.Lb)(n, -1);
        });
      },
      categoricalHinge: function (t, e) {
        return Object(a.Zc)(function () {
          var n = Object(a.Qc)(Object(a.Rb)(t, e), -1),
            r = Object(a.Hb)(Object(a.Rb)(Object(a.Pc)(1, t), e), -1);
          return Object(a.Kb)(0, Object(a.g)(1, Object(a.Pc)(r, n)));
        });
      },
      logcosh: function (t, e) {
        return Object(a.Zc)(function () {
          var n = Math.log(2),
            r = Object(a.Pc)(e, t),
            i = Object(a.Pc)(
              Object(a.g)(r, Object(a.Fc)(Object(a.Rb)(-2, r))),
              n
            );
          return Object(a.Lb)(i, -1);
        });
      },
      categoricalCrossentropy: Zi,
      sparseCategoricalCrossentropy: Xi,
      binaryCrossentropy: Yi,
      kullbackLeiblerDivergence: function (t, e) {
        return Object(a.Zc)(function () {
          var n = Object(a.C)(t, kn(), 1),
            r = Object(a.C)(e, kn(), 1);
          return Object(a.Qc)(
            Object(a.Rb)(t, Object(a.Ab)(Object(a.T)(n, r))),
            -1
          );
        });
      },
      poisson: function (t, e) {
        return Object(a.Zc)(function () {
          var n = Object(a.Ab)(Object(a.g)(kn(), e));
          return Object(a.Lb)(Object(a.Pc)(e, Object(a.Rb)(t, n)), -1);
        });
      },
      cosineProximity: Ji,
    };
    function Qi(t) {
      if ("string" == typeof t) {
        if (t in $i) return $i[t];
        var e = "Unknown loss " + t;
        throw (
          (t.toLowerCase().includes("softmaxcrossentropy") &&
            (e =
              "Unknown loss " +
              t +
              '. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),
          new Tn(e))
        );
      }
      return t;
    }
    function ta(t, e) {
      return Object(a.Zc)(function () {
        var n = Object(a.Rb)(0.5, Object(a.Zb)(e)),
          r = Ir(Object(a.mb)(e, n), t.dtype);
        return Object(a.Lb)(Object(a.Z)(t, r), -1);
      });
    }
    function ea(t, e) {
      return Object(a.Zc)(function () {
        return Ir(
          Object(a.Z)(Object(a.k)(t, -1), Object(a.k)(e, -1)),
          "float32"
        );
      });
    }
    function na(t, e) {
      return Object(a.Zc)(function () {
        return Object(a.Db)(t.equal(1), e.equal(1)).sum().cast("float32");
      });
    }
    function ra(t, e) {
      return Object(a.Zc)(function () {
        var n = na(t, e),
          r = (function (t, e) {
            return Object(a.Zc)(function () {
              return Object(a.Db)(t.equal(0), e.equal(1)).sum().cast("float32");
            });
          })(t, e),
          i = n.add(r);
        return Object(a.jd)(Object(a.mb)(i, 0), n.div(i), 0).cast("float32");
      });
    }
    function ia(t, e) {
      return Object(a.Zc)(function () {
        var n = na(t, e),
          r = (function (t, e) {
            return Object(a.Zc)(function () {
              return Object(a.Db)(t.equal(1), e.equal(0)).sum().cast("float32");
            });
          })(t, e),
          i = n.add(r);
        return Object(a.jd)(Object(a.mb)(i, 0), n.div(i), 0).cast("float32");
      });
    }
    function aa(t, e) {
      return Yi(t, e);
    }
    function oa(t, e) {
      return (
        t.rank === e.rank && (t = t.squeeze([t.rank - 1])),
        (e = e.argMax(-1)).dtype !== t.dtype && (e = e.asType(t.dtype)),
        Object(a.Z)(t, e).asType("float32")
      );
    }
    var sa = Zi,
      ua = Xi,
      ca = {
        binaryAccuracy: ta,
        categoricalAccuracy: ea,
        precision: ra,
        categoricalCrossentropy: sa,
        sparseCategoricalCrossentropy: ua,
        mse: Hi,
        MSE: Hi,
        mae: qi,
        MAE: qi,
        mape: Ki,
        MAPE: Ki,
        cosine: Ji,
      };
    function la(t) {
      if ((Mn(null !== t, "Unknown LossOrMetricFn " + t), "string" == typeof t))
        return t;
      for (var e = void 0, n = 0, r = Object.keys($i); n < r.length; n++) {
        var i = r[n];
        if ($i[i] === t) {
          e = i;
          break;
        }
      }
      if (void 0 !== e) return e;
      for (var a = 0, o = Object.keys(ca); a < o.length; a++)
        if (((i = o[a]), ca[i] === t)) {
          e = i;
          break;
        }
      return void 0 !== e ? e : t.name;
    }
    function pa(t, e, n) {
      if (
        (void 0 === n && (n = !1),
        null == t ||
          "object" != typeof t ||
          Object.getPrototypeOf(t) !== Object.prototype ||
          !(function t(e) {
            if (null === e) return !0;
            if ("object" == typeof e) {
              if (Object.getPrototypeOf(e) === Object.prototype) {
                for (var n = 0, r = Object.keys(e); n < r.length; n++) {
                  var i = r[n];
                  if ("string" != typeof i) return !1;
                  if (!t(e[i])) return !1;
                }
                return !0;
              }
              if (Array.isArray(e)) {
                for (var a = 0, o = e; a < o.length; a++)
                  if (!t(o[a])) return !1;
                return !0;
              }
              return !1;
            }
            var s = typeof e;
            return "string" === s || "number" === s || "boolean" === s;
          })(t))
      )
        throw new Error(
          "User-defined metadata is expected to be a JSON object, but is not."
        );
      if (n) {
        var r = JSON.stringify(t);
        r.length > 1048576 &&
          console.warn(
            'User-defined metadata of model "' +
              e +
              '" is too large in size (length=' +
              r.length +
              " when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576."
          );
      }
    }
    function ha(t, e, n, r) {
      void 0 === r && (r = console.log);
      var i,
        a = (function (t) {
          var e = !0,
            n = [],
            r = [];
          for (var i in t.nodesByDepth) n.push(t.nodesByDepth[i]);
          for (var a = 0, o = n; a < o.length; a++) {
            var s = o[a];
            if (
              s.length > 1 ||
              (1 === s.length && s[0].inboundLayers.length > 1)
            ) {
              e = !1;
              break;
            }
            r.push.apply(r, s);
          }
          if (e)
            for (var u = 0, c = t.layers; u < c.length; u++) {
              for (
                var l = !1, p = 0, h = c[u].inboundNodes;
                p < h.length;
                p++
              ) {
                var f = h[p];
                if (-1 !== r.indexOf(f)) {
                  if (l) {
                    e = !1;
                    break;
                  }
                  l = !0;
                }
              }
              if (!e) break;
            }
          return e;
        })(t),
        o = ["Layer (type)", "Output shape", "Param #"];
      if (
        (a
          ? ((e = e || 65), (n = n || [0.45, 0.85, 1]))
          : ((e = e || 98), (n = n || [0.33, 0.55, 0.67, 1])),
        n[n.length - 1] <= 1 &&
          (n = n.map(function (t) {
            return Math.floor(e * t);
          })),
        !a)
      )
        for (var s in (o.push("Receives inputs"), (i = []), t.nodesByDepth))
          i.push.apply(i, t.nodesByDepth[s]);
      r("_".repeat(e)), fa(o, n, r), r("=".repeat(e));
      for (var u = t.layers, c = 0; c < u.length; ++c)
        a ? da(u[c], n, r) : ma(u[c], n, i, r),
          r((c === u.length - 1 ? "=" : "_").repeat(e));
      t.checkTrainableWeightsConsistency();
      var l = (function (t) {
          return null != t.collectedTrainableWeights
            ? bi(t.collectedTrainableWeights)
            : bi(t.trainableWeights);
        })(t),
        p = bi(t.nonTrainableWeights);
      r("Total params: " + (l + p)),
        r("Trainable params: " + l),
        r("Non-trainable params: " + p),
        r("_".repeat(e));
    }
    function fa(t, e, n) {
      void 0 === n && (n = console.log);
      for (var r = "", i = 0; i < t.length; ++i)
        i > 0 && (r = r.slice(0, r.length - 1) + " "),
          (r = (r += t[i]).slice(0, e[i])),
          (r += " ".repeat(e[i] - r.length));
      n(r);
    }
    function da(t, e, n) {
      var r;
      try {
        r = JSON.stringify(t.outputShape);
      } catch (t) {
        r = "multiple";
      }
      fa(
        [t.name + " (" + t.getClassName() + ")", r, t.countParams().toString()],
        e,
        n
      );
    }
    function ma(t, e, n, r) {
      var i;
      try {
        i = JSON.stringify(t.outputShape);
      } catch (t) {
        i = "multiple";
      }
      for (var a = [], o = 0, s = t.inboundNodes; o < s.length; o++) {
        var u = s[o];
        if (!(null != n && n.length > 0 && -1 === n.indexOf(u)))
          for (var c = 0; c < u.inboundLayers.length; ++c) {
            var l = u.inboundLayers[c].name,
              p = u.nodeIndices[c],
              h = u.tensorIndices[c];
            a.push(l + "[" + p + "][" + h + "]");
          }
      }
      var f = t.name,
        d = t.getClassName(),
        m = 0 === a.length ? "" : a[0];
      for (
        fa([f + " (" + d + ")", i, t.countParams().toString(), m], e, r), c = 1;
        c < a.length;
        ++c
      )
        fa(["", "", "", a[c]], e, r);
    }
    function va(t, e, n) {
      return (
        ("inboundNodes" === t || "outputLayers" === t || "inputLayers" === t) &&
        0 === e &&
        "string" == typeof n
      );
    }
    function ga(t, e) {
      if (null === t) return null;
      if ("string" == typeof t) return Bn(t);
      if ("number" == typeof t || "boolean" == typeof t) return t;
      if (t instanceof Array) {
        for (var n = [], r = t.length, i = 0; i < r; ++i) {
          var a = t[i];
          va(e, i, a) ? n.push(a) : n.push(ga(a, e));
        }
        return n;
      }
      for (var o = {}, s = 0, u = Object.keys(t); s < u.length; s++) {
        var c = u[s],
          l = t[c];
        if ("name" === c && "string" == typeof l) o[c] = l;
        else {
          var p = Bn(c);
          o[p] = ga(l, p);
        }
      }
      return o;
    }
    var ya = (function () {
        function t(e) {
          if (
            ((this.id2Value = {}),
            (this.id2Mask = {}),
            (this.name2Id = {}),
            e instanceof t)
          )
            for (var n in e.id2Value)
              (this.id2Value[n] = e.id2Value[n]),
                n in e.id2Mask && (this.id2Mask[n] = e.id2Mask[n]);
          else {
            if (null == e) return;
            for (var r = 0, i = e; r < i.length; r++) {
              var a = i[r];
              this.add(a.key, a.value);
            }
          }
        }
        return (
          (t.prototype.add = function (t, e, n) {
            if (null != this.id2Value[t.id])
              throw new Tn("Duplicate key: name=" + t.name + ", id=" + t.id);
            return (
              (this.id2Value[t.id] = (function (t, e) {
                if (null == t.dtype || t.dtype === e.dtype) return e;
                try {
                  return Object(a.A)(e, t.dtype);
                } catch (n) {
                  throw new Tn(
                    "The dtype of the feed (" +
                      e.dtype +
                      ") can not be cast to the dtype of the key '" +
                      t.name +
                      "' (" +
                      t.dtype +
                      ")."
                  );
                }
              })(t, e)),
              (this.name2Id[t.name] = t.id),
              null != n && (this.id2Mask[t.id] = n),
              this
            );
          }),
          (t.prototype.addFeed = function (t) {
            this.add(t.key, t.value);
          }),
          (t.prototype.hasKey = function (t) {
            return null != this.id2Value[t.id];
          }),
          (t.prototype.names = function () {
            return Object.keys(this.name2Id);
          }),
          (t.prototype.getValue = function (t) {
            if (t instanceof Ei) {
              if (null == this.id2Value[t.id])
                throw new Tn("Nonexistent key: " + t.name);
              return this.id2Value[t.id];
            }
            var e = this.name2Id[t];
            if (null == e)
              throw new Tn("Feed dict has no SymbolicTensor name: " + t);
            return this.id2Value[e];
          }),
          (t.prototype.getMask = function (t) {
            if (t instanceof Ei) {
              if (null == this.id2Value[t.id])
                throw new Tn("Nonexistent key: " + t.name);
              return this.id2Mask[t.id];
            }
            var e = this.name2Id[t];
            if (null == e)
              throw new Tn("Feed dict has no SymbolicTensor name: " + t);
            return this.id2Mask[e];
          }),
          (t.prototype.disposeMasks = function () {
            null != this.id2Mask && Object(a.S)(this.id2Mask);
          }),
          t
        );
      })(),
      ba = {},
      wa = {};
    function xa(t, e, n, r) {
      for (
        var i = null != n && n.training,
          o = Array.isArray(t),
          s = o ? t : [t],
          u = s.map(function (t) {
            return t.name;
          }),
          c = [],
          l = e.names(),
          p = 0,
          h = u;
        p < h.length;
        p++
      ) {
        var f = h[p];
        -1 !== l.indexOf(f) ? c.push(e.getValue(f)) : c.push(null);
      }
      null != r && ((r.maxNumTensors = -1 / 0), (r.minNumTensors = 1 / 0));
      var d,
        m,
        v = u.join(",") + "|" + e.names().join(",");
      if (null == ba[v]) {
        var g = (function (t, e) {
          a.gd.assert(null != t && t.length > 0, function () {
            return "Expected at least one fetch, got none";
          });
          var n = [],
            r = {};
          if (1 === t.length) {
            var i = Oa(t[0], e);
            (n = i.sorted), (r = i.recipientMap);
          } else
            for (var o = new Set(), s = 0, u = t; s < u.length; s++) {
              for (
                var c = Oa(u[s], e),
                  l = c.sorted,
                  p = c.recipientMap,
                  h = 0,
                  f = l;
                h < f.length;
                h++
              ) {
                var d = f[h];
                o.has(d.name) || (n.push(d), o.add(d.name));
              }
              var m = function (t) {
                null == r[t] && (r[t] = new Set()),
                  p[t].forEach(function (e) {
                    return r[t].add(e);
                  });
              };
              for (var v in p) m(v);
            }
          return { sorted: n, recipientCounts: Ca(r) };
        })(s, e);
        (d = g.sorted), (m = g.recipientCounts), (ba[v] = d), (wa[v] = m);
      }
      (d = ba[v]), (m = {}), i || Object.assign(m, wa[v]);
      for (var y = new ya(e), b = 0; b < d.length; ++b) {
        if (null != r) {
          var w = Object(a.Mb)().numTensors;
          w > r.maxNumTensors && (r.maxNumTensors = w),
            w < r.minNumTensors && (r.minNumTensors = w);
        }
        var x = d[b],
          C = x.sourceLayer;
        if (!(C instanceof Ti)) {
          for (
            var O = [], E = [], S = [], N = !1, I = 0, k = x.inputs;
            I < k.length;
            I++
          ) {
            var _ = k[I],
              A = y.getValue(_),
              T = y.getMask(_);
            O.push(A),
              E.push(T),
              null != T && (N = !0),
              i ||
                (m[_.name]--,
                0 !== m[_.name] ||
                  e.hasKey(_) ||
                  -1 !== u.indexOf(_.name) ||
                  A.isDisposed ||
                  !0 === _.sourceLayer.stateful ||
                  S.push(A));
          }
          N && ((n = n || {}).mask = E[0]);
          var R = zn(C.apply(O, n)),
            D = null;
          C.supportsMasking && (D = C.computeMask(O, E));
          for (
            var F = Ea(x), M = Array.isArray(F) ? F : [F], j = 0;
            j < M.length;
            ++j
          ) {
            y.hasKey(M[j]) || y.add(M[j], R[j], Array.isArray(D) ? D[0] : D);
            var P = u.indexOf(M[j].name);
            -1 !== P && (c[P] = R[j]);
          }
          i || Object(a.S)(S);
        }
      }
      return y.disposeMasks(), o ? c : c[0];
    }
    function Ca(t) {
      var e = {};
      for (var n in t) e[n] = t[n].size;
      return e;
    }
    function Oa(t, e) {
      for (
        var n = new Set(), r = [], i = {}, a = 0, o = e.names();
        a < o.length;
        a++
      ) {
        var s = o[a];
        n.add(s);
      }
      var u = [],
        c = [];
      for (u.push(t); u.length > 0; ) {
        var l = u[u.length - 1];
        if (n.has(l.name)) u.pop();
        else {
          var p = c[c.length - 1] === u.length - 1;
          if (0 === l.inputs.length || p)
            u.pop(), r.push(l), n.add(l.name), p && c.pop();
          else {
            c.push(u.length - 1);
            for (var h = 0, f = l.inputs; h < f.length; h++) {
              var d = f[h];
              null == i[d.name] && (i[d.name] = new Set()),
                i[d.name].add(l.name),
                n.has(d.name) || u.push(d);
            }
          }
        }
      }
      return { sorted: r, recipientMap: i };
    }
    function Ea(t) {
      var e;
      if (1 === t.sourceLayer.inboundNodes.length) e = t.sourceLayer.output;
      else {
        for (var n = null, r = 0; r < t.sourceLayer.inboundNodes.length; ++r)
          for (
            var i = 0, a = t.sourceLayer.inboundNodes[r].outputTensors;
            i < a.length;
            i++
          )
            if (a[i].id === t.id) {
              n = r;
              break;
            }
        e = t.sourceLayer.getOutputAt(n);
      }
      return e;
    }
    var Sa = (function (t) {
      function e(n) {
        var r = t.call(this, {}) || this;
        if (
          ((r.containerNodes = new Set()), (r.name = n.name), null == r.name)
        ) {
          var i = r.getClassName().toLowerCase();
          r.name = di(i);
        }
        if (
          ((r.supportsMasking = !1),
          (r.trainable_ = !0),
          Array.isArray(n.inputs)
            ? (r.inputs = n.inputs.slice())
            : (r.inputs = [n.inputs]),
          Array.isArray(n.outputs)
            ? (r.outputs = n.outputs.slice())
            : (r.outputs = [n.outputs]),
          Hn(r.inputs).length !== r.inputs.length)
        )
          throw new Tn(
            "The list of inputs passed to the model is redundant. All inputs should only appear once. Found: " +
              r.inputs.map(function (t) {
                return t.name;
              })
          );
        Hn(r.outputs).length !== r.outputs.length &&
          console.warn(
            "The list of outputs passed to the model is redundant. All outputs should only appear once. Found: " +
              r.outputs.map(function (t) {
                return t.name;
              })
          ),
          (r.inputLayers = []),
          (r.inputLayersNodeIndices = []),
          (r.inputLayersTensorIndices = []),
          (r.outputLayers = []),
          (r.outputLayersNodeIndices = []),
          (r.outputLayersTensorIndices = []),
          (r.layers = []),
          (r.internalContainerRefs = []);
        for (var a = 0, o = r.outputs; a < o.length; a++) {
          var s = (N = o[a]).sourceLayer,
            u = N.nodeIndex,
            c = N.tensorIndex;
          r.outputLayers.push(s),
            r.outputLayersNodeIndices.push(u),
            r.outputLayersTensorIndices.push(c);
        }
        for (var l = 0, p = r.inputs; l < p.length; l++)
          (s = (N = p[l]).sourceLayer),
            (u = N.nodeIndex),
            (c = N.tensorIndex),
            Mn(0 === u, "input layer has >1 nodes"),
            Mn(0 === c, "input layer has >1 tensors"),
            r.inputLayers.push(s),
            r.inputLayersNodeIndices.push(u),
            r.inputLayersTensorIndices.push(c);
        (r.inputNames = []),
          (r.outputNames = []),
          (r.feedInputShapes = []),
          (r.feedInputNames = []),
          (r.feedOutputNames = []);
        for (var h = 0; h < r.inputLayers.length; h++) {
          if (!((s = r.inputLayers[h]) instanceof Ti))
            throw new TypeError(
              "Input layers to a LayersModel must be InputLayer objects. Received inputs: " +
                n.inputs +
                ". Input " +
                h +
                " (0-based) originates from layer type " +
                s.getClassName() +
                "."
            );
          r.inputNames.push(s.name),
            r.feedInputShapes.push(s.batchInputShape),
            r.feedInputNames.push(s.name);
        }
        for (var f = 0, d = r.outputLayers; f < d.length; f++)
          (s = d[f]), r.outputNames.push(s.name);
        (r.internalInputShapes = r.inputs.map(function (t) {
          return t.shape;
        })),
          (r.internalOutputShapes = r.outputs.map(function (t) {
            return t.shape;
          }));
        for (
          var m = {},
            v = {},
            g = {},
            y = {},
            b = {},
            w = [],
            x = function (t, n, i, a, o, s) {
              (null != a && null != o && null != s) ||
                ((a = t.sourceLayer), (o = t.nodeIndex), (s = t.tensorIndex));
              var u = a.inboundNodes[o];
              if (-1 !== i.indexOf(u))
                throw new An(
                  "The tensor " +
                    t.name +
                    ' at layer "' +
                    a.name +
                    '" is part of a cycle.'
                );
              if (-1 === n.indexOf(u)) {
                r.containerNodes.add(e.nodeKey(a, o)),
                  (a.id in b) || (b[a.id] = Object.keys(b).length),
                  -1 === i.indexOf(u) && i.push(u);
                for (var c = u.inboundLayers.length, l = 0; l < c; l++) {
                  var p = u.inputTensors[l],
                    h = u.inboundLayers[l],
                    f = u.nodeIndices[l],
                    d = u.tensorIndices[l];
                  x(p, n, i, h, f, d);
                }
                for (n.push(u); i.indexOf(u) >= 0; ) i.splice(i.indexOf(u), 1);
                w.push(u);
              }
            },
            C = [],
            O = [],
            E = 0,
            S = r.outputs;
          E < S.length;
          E++
        ) {
          var N = S[E];
          x(N, C, O);
        }
        for (var I = 0, k = w.slice().reverse(); I < k.length; I++) {
          (v[(Y = k[I]).id] = Y), Y.id in m || (m[Y.id] = 0);
          var _ = m[Y.id],
            A = null == g[Y.outboundLayer.id] ? 0 : g[Y.outboundLayer.id];
          for (
            _ = Math.max(_, A),
              g[Y.outboundLayer.id] = _,
              y[Y.outboundLayer.id] = Y.outboundLayer,
              m[Y.id] = _,
              h = 0;
            h < Y.inboundLayers.length;
            h++
          ) {
            var T = Y.inboundLayers[h],
              R = ((u = Y.nodeIndices[h]), T.inboundNodes[u]),
              D = null == m[R.id] ? 0 : m[R.id];
            (m[R.id] = Math.max(_ + 1, D)), (v[R.id] = R);
          }
        }
        var F = {};
        for (var M in m) (_ = m[M]) in F || (F[_] = []), F[_].push(v[M]);
        var j = {};
        for (var P in g) (_ = g[P]) in j || (j[_] = []), j[_].push(y[P]);
        var z = Object.keys(j)
          .map(function (t) {
            return parseInt(t, 10);
          })
          .sort(Gn);
        r.layers = [];
        for (var L = 0, B = z; L < B.length; L++) {
          var W = j[(_ = B[L])];
          W.sort(function (t, e) {
            var n = b[t.id],
              r = b[e.id];
            return n < r ? -1 : n > r ? 1 : 0;
          });
          for (var U = 0, V = W; U < V.length; U++)
            (s = V[U]) instanceof e && r.internalContainerRefs.push(s),
              r.layers.push(s);
        }
        (r.layersByDepth = j),
          (z = Object.keys(F)
            .map(function (t) {
              return parseInt(t, 10);
            })
            .sort(Gn));
        for (var G = r.inputs.slice(), H = [], q = 0, K = z; q < K.length; q++)
          for (var Z = 0, X = F[(_ = K[q])]; Z < X.length; Z++) {
            var Y;
            if (null != (s = (Y = X[Z]).outboundLayer)) {
              for (var J = 0, $ = Y.inputTensors; J < $.length; J++)
                if (((N = $[J]), -1 === G.indexOf(N)))
                  throw new An(
                    "Graph disconnected: cannot obtain value for tensor " +
                      N +
                      ' at layer "' +
                      s.name +
                      '". The following previous layers were accessed without issue: ' +
                      H
                  );
              for (var Q = 0, tt = Y.outputTensors; Q < tt.length; Q++)
                (N = tt[Q]), G.push(N);
              H.push(s.name);
            }
          }
        r.nodesByDepth = F;
        for (
          var et = r.layers.map(function (t) {
              return t.name;
            }),
            nt = function (t) {
              var e = et.filter(function (e) {
                return e === t;
              }).length;
              if (1 !== e)
                throw new An(
                  'The name "' +
                    t +
                    '" is used ' +
                    e +
                    " times in the model. All layer names should be unique. Layer names: " +
                    JSON.stringify(et)
                );
            },
            rt = 0,
            it = et;
          rt < it.length;
          rt++
        )
          nt(it[rt]);
        return (
          (r.outboundNodes = []),
          (r.inboundNodes = []),
          new Ni({
            outboundLayer: r,
            inboundLayers: [],
            nodeIndices: [],
            tensorIndices: [],
            inputTensors: r.inputs,
            outputTensors: r.outputs,
            inputMasks: r.inputs.map(function (t) {
              return null;
            }),
            outputMasks: r.outputs.map(function (t) {
              return null;
            }),
            inputShapes: r.inputs.map(function (t) {
              return t.shape;
            }),
            outputShapes: r.outputs.map(function (t) {
              return t.shape;
            }),
          }),
          (r.built = !0),
          (r._refCount = 1),
          r
        );
      }
      return (
        On(e, t),
        (e.prototype.assertNotDisposed = function () {
          if (0 === this._refCount)
            throw new Error(
              "Container '" + this.name + "' is already disposed."
            );
        }),
        (e.prototype.dispose = function () {
          this.assertNotDisposed();
          var t = { refCountAfterDispose: null, numDisposedVariables: 0 };
          if (0 == --this._refCount) {
            for (var e = 0, n = this.layers; e < n.length; e++) {
              var r = n[e];
              t.numDisposedVariables += r.dispose().numDisposedVariables;
            }
            for (var i = 0, a = this.internalContainerRefs; i < a.length; i++) {
              var o = a[i];
              t.numDisposedVariables += o.dispose().numDisposedVariables;
            }
          }
          return (t.refCountAfterDispose = this._refCount), t;
        }),
        Object.defineProperty(e.prototype, "trainable", {
          get: function () {
            return this.trainable_;
          },
          set: function (t) {
            this.layers.forEach(function (e) {
              e._trainableWeights.forEach(function (e) {
                return (e.trainable = t);
              });
            }),
              (this.trainable_ = t);
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "trainableWeights", {
          get: function () {
            if (this._trainableWeights.length > 0)
              throw new Tn(
                "Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array."
              );
            if (!this.trainable) return [];
            for (var t = [], e = 0, n = this.layers; e < n.length; e++) {
              var r = n[e];
              t = t.concat(r.trainableWeights);
            }
            return t;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "nonTrainableWeights", {
          get: function () {
            for (var t = [], e = 0, n = this.layers; e < n.length; e++) {
              var r = n[e];
              t.push.apply(t, r.nonTrainableWeights);
            }
            if (!this.trainable) {
              for (var i = [], a = 0, o = this.layers; a < o.length; a++)
                (r = o[a]), i.push.apply(i, r.trainableWeights);
              return i.concat(t);
            }
            return t;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "weights", {
          get: function () {
            return this.trainableWeights.concat(this.nonTrainableWeights);
          },
          enumerable: !0,
          configurable: !0,
        }),
        (e.prototype.loadWeights = function (t, e) {
          void 0 === e && (e = !0);
          for (var n = {}, r = 0, i = 0, a = this.layers; i < a.length; i++)
            for (var o = 0, s = a[i].weights; o < s.length; o++) {
              var u = s[o];
              if (null != n[u.originalName])
                throw new Tn("Duplicate weight name: " + u.originalName);
              (n[u.originalName] = u), r++;
            }
          var c = [];
          for (var l in t) {
            if (null != n[l]) c.push([n[l], t[l]]);
            else if (e)
              throw new Tn("Provided weight data has no target variable: " + l);
            delete n[l];
          }
          if (e) {
            var p = [];
            for (var h in n) p.push(h);
            if (p.length > 0)
              throw new Tn(
                p.length + " of " + r + " weights are not set: " + p
              );
          }
          Ci(c);
        }),
        (e.prototype.updatedConfig = function () {
          var t = this.getConfig(),
            e = {};
          return (
            (e.className = this.getClassName()),
            (e.config = t),
            (e.kerasVersion = "tfjs-layers 1.7.0"),
            (e.backend = "TensorFlow.js"),
            e
          );
        }),
        (e.prototype.toJSON = function (t, e) {
          void 0 === e && (e = !0);
          var n = (function t(e, n) {
            if (null == e) return null;
            if ("string" == typeof e) return Ln(e);
            if ("number" == typeof e || "boolean" == typeof e) return e;
            if (e instanceof Array) {
              for (var r = [], i = e.length, a = 0; a < i; ++a) {
                var o = e[a];
                va(n, a, o) ? r.push(o) : r.push(t(o, n));
              }
              return r;
            }
            for (var s = {}, u = 0, c = Object.keys(e); u < c.length; u++) {
              var l = c[u],
                p = e[l];
              s[Ln(l)] =
                ("name" !== l && "className" !== l) || "string" != typeof p
                  ? t(p, l)
                  : p;
            }
            return s;
          })(this.updatedConfig());
          return e ? JSON.stringify(n) : n;
        }),
        (e.prototype.call = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            t = zn(t);
            for (var r = new ya(), i = 0; i < n.inputs.length; ++i)
              r.add(n.inputs[i], t[i]);
            return xa(n.outputs, r, e);
          });
        }),
        (e.prototype.computeMask = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            var r;
            return (
              (t = zn(t)),
              (r = null == e ? Fn(null, t.length) : zn(e)),
              n.runInternalGraph(t, r)[1]
            );
          });
        }),
        (e.prototype.computeOutputShape = function (t) {
          var e = vi(t);
          if (e.length !== this.inputLayers.length)
            throw new Tn(
              "Invalid inputShape argument " +
                t +
                ": model has " +
                this.inputLayers.length +
                " tensor inputs."
            );
          for (var n = {}, r = 0; r < e.length; r++) {
            var i = this.inputLayers[r],
              a = e[r];
            n[(O = i.name + "_0_0")] = a;
          }
          var o = Object.keys(this.nodesByDepth)
            .map(function (t) {
              return parseInt(t, 10);
            })
            .sort(Gn);
          if (o.length > 1)
            for (var s = 0, u = o; s < u.length; s++)
              for (
                var c = u[s], l = 0, p = this.nodesByDepth[c];
                l < p.length;
                l++
              ) {
                var h = p[l];
                if (
                  ((i = h.outboundLayer),
                  -1 ===
                    this.inputLayers
                      .map(function (t) {
                        return t.id;
                      })
                      .indexOf(i.id))
                ) {
                  for (var f = [], d = 0; d < h.inboundLayers.length; d++) {
                    var m = h.inboundLayers[d],
                      v = h.nodeIndices[d],
                      g = h.tensorIndices[d],
                      y = n[(O = m.name + "_" + v + "_" + g)];
                    f.push(y);
                  }
                  var b = vi(i.computeOutputShape(Pn(f))),
                    w = i.inboundNodes.indexOf(h);
                  for (d = 0; d < b.length; d++)
                    n[(O = i.name + "_" + w + "_" + d)] = b[d];
                }
              }
          var x = [],
            C = [];
          for (r = 0; r < this.outputLayers.length; r++) {
            (i = this.outputLayers[r]),
              (w = this.outputLayersNodeIndices[r]),
              (g = this.outputLayersTensorIndices[r]);
            var O = i.name + "_" + w + "_" + g;
            C.push(O);
          }
          for (r = 0; r < C.length; r++) {
            var E = C[r];
            Mn(E in n), x.push(n[E]);
          }
          return Pn(x);
        }),
        (e.prototype.runInternalGraph = function (t, e) {
          null == e && (e = Fn(null, t.length));
          for (var n = {}, r = 0; r < this.inputs.length; ++r) {
            var i = this.inputs[r],
              a = t[r],
              o = e[r];
            n[i.id] = [a, o];
          }
          for (
            var s = 0,
              u = Object.keys(this.nodesByDepth)
                .map(function (t) {
                  return parseInt(t, 10);
                })
                .sort(Gn);
            s < u.length;
            s++
          )
            for (
              var c = u[s], l = 0, p = this.nodesByDepth[c];
              l < p.length;
              l++
            ) {
              for (
                var h = p[l],
                  f = h.outboundLayer,
                  d = h.inputTensors,
                  m = h.outputTensors,
                  v = new Array(),
                  g = 0,
                  y = d;
                g < y.length;
                g++
              )
                (i = y[g]).id in n && v.push(n[i.id]);
              if (v.length === d.length) {
                var b = {},
                  w = void 0,
                  x = void 0,
                  C = void 0,
                  O = void 0;
                if ((null != h.callArgs && (b = h.callArgs), 1 === v.length)) {
                  var E = v[0],
                    S = E[0],
                    N = E[1];
                  null == b.mask && (b.mask = N),
                    (C = zn(f.call(S, b))),
                    (O = zn(f.computeMask(S, N))),
                    (w = [S]),
                    (x = [N]);
                } else
                  (w = v.map(function (t) {
                    return t[0];
                  })),
                    (x = v.map(function (t) {
                      return t[1];
                    })),
                    null == b.mask && (b.mask = x),
                    (C = zn(f.call(w, b))),
                    (O = zn(f.computeMask(w, x)));
                if (f.activityRegularizer)
                  throw new Rn(
                    "LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet."
                  );
                for (r = 0; r < m.length; ++r)
                  (i = m[r]), (a = C[r]), (o = O[r]), (n[i.id] = [a, o]);
              }
            }
          for (
            var I = [], k = [], _ = [], A = 0, T = this.outputs;
            A < T.length;
            A++
          ) {
            Mn(
              (i = T[A]).id in n,
              "Could not compute output " + i.name + " : " + i.id
            );
            var R = n[i.id],
              D = R[0];
            (o = R[1]), _.push(D.shape), I.push(D), k.push(o);
          }
          return [I, k, _];
        }),
        (e.prototype.buildNodeConversionMap = function (t) {
          for (var n, r = {}, i = 0, a = this.layers; i < a.length; i++) {
            var o = a[i];
            n = o instanceof e ? 1 : 0;
            for (var s = 0; s < o.inboundNodes.length; s++) {
              var u = e.nodeKey(o, s);
              this.containerNodes.has(u) && ((r[u] = n), (n += 1));
            }
          }
          return r;
        }),
        (e.prototype.getLayer = function (t, e) {
          if (null != e) {
            if (this.layers.length <= e)
              throw new Tn(
                "Was asked to retrieve layer at index " +
                  e +
                  ", but model only has " +
                  this.layers.length +
                  " layer(s)."
              );
            return this.layers[e];
          }
          if (null == t)
            throw new Tn("Provide either a layer name or layer index");
          for (var n = 0, r = this.layers; n < r.length; n++) {
            var i = r[n];
            if (i.name === t) return i;
          }
          throw new Tn("No such layer: " + t);
        }),
        (e.prototype.calculateLosses = function () {
          var t = this;
          return Object(a.Zc)(function () {
            for (var n = [], r = 0, i = t.layers; r < i.length; r++)
              for (var a = i[r], o = 0; o < a.inboundNodes.length; ++o) {
                var s = e.nodeKey(a, o);
                t.containerNodes.has(s) && n.push.apply(n, a.calculateLosses());
              }
            return n;
          });
        }),
        (e.prototype.getConfig = function () {
          for (
            var t = { name: this.name },
              n = this.buildNodeConversionMap(this.layers),
              r = [],
              i = 0,
              a = this.layers;
            i < a.length;
            i++
          ) {
            for (
              var o = (w = a[i]).getClassName(),
                s = w.getConfig(),
                u = [],
                c = 0;
              c < w.inboundNodes.length;
              c++
            ) {
              var l = w.inboundNodes[c],
                p = e.nodeKey(w, c),
                h = {};
              if (this.containerNodes.has(p)) {
                if (l.callArgs)
                  try {
                    JSON.stringify(l.callArgs), (h = l.callArgs);
                  } catch (t) {
                    console.warn(
                      "Layer " +
                        w.name +
                        " was passed non-serializable keyword arguments: " +
                        l.callArgs +
                        ". They will not be included in the serialized model (and thus will be missing at deserialization time)."
                    ),
                      (h = {});
                  }
                if (l.inboundLayers.length > 0) {
                  for (var f = [], d = 0; d < l.inboundLayers.length; d++) {
                    var m = l.inboundLayers[d],
                      v = l.nodeIndices[d],
                      g = l.tensorIndices[d];
                    null == (C = n[e.nodeKey(m, v)]) && (C = 0),
                      f.push([m.name, C, g, h]);
                  }
                  u.push(f);
                }
              }
            }
            var y = {};
            (y.name = w.name),
              (y.className = o),
              (y.config = s),
              (y.inboundNodes = u),
              r.push(y);
          }
          t.layers = r;
          var b = [];
          for (d = 0; d < this.inputLayers.length; d++) {
            var w = this.inputLayers[d];
            (v = this.inputLayersNodeIndices[d]),
              (p = e.nodeKey(w, v)),
              this.containerNodes.has(p) &&
                ((null !== (C = n[p]) && void 0 !== C) || (C = 0),
                (g = this.inputLayersTensorIndices[d]),
                b.push([w.name, C, g]));
          }
          t.inputLayers = b;
          var x = [];
          for (d = 0; d < this.outputLayers.length; d++) {
            var C;
            if (
              ((w = this.outputLayers[d]),
              (v = this.outputLayersNodeIndices[d]),
              (p = e.nodeKey(w, v)),
              this.containerNodes.has(p))
            )
              (null !== (C = n[p]) && void 0 !== C) || (C = 0),
                (g = this.outputLayersTensorIndices[d]),
                x.push([w.name, C, g]);
          }
          return (t.outputLayers = x), t;
        }),
        (e.fromConfig = function (t, e, n, r) {
          void 0 === n && (n = {}), void 0 === r && (r = !1);
          var i = {},
            a = {};
          function o(t, e) {
            t.name in a ? a[t.name].push(e) : (a[t.name] = [e]);
          }
          function s(t, e) {
            for (var n, r = [], a = 0, s = e; a < s.length; a++) {
              var u = s[a],
                c = u[0],
                l = u[1],
                p = u[2];
              if (((n = null == u[3] ? {} : u[3]), !(c in i)))
                return void o(t, e);
              var h = i[c];
              if (h.inboundNodes.length <= l) return void o(t, e);
              var f = h.inboundNodes[l];
              r.push(f.outputTensors[p]);
            }
            r.length > 0 && t.apply(Pn(r), n);
          }
          function u(t) {
            var n = t.name,
              a = Vi(t, null != e.customObjects ? e.customObjects : {});
            a.setFastWeightInitDuringBuild(r),
              (i[n] = a),
              t.inboundNodes.forEach(function (t) {
                if (!(t instanceof Array))
                  throw new Tn(
                    "Corrupted configuration, expected array for nodeData: " + t
                  );
                o(a, t);
              });
          }
          for (var c = e.name, l = e.layers, p = 0, h = l; p < h.length; p++)
            u((m = h[p]));
          for (; !qn(a); )
            for (var f = 0, d = l; f < d.length; f++) {
              var m = d[f];
              if ((_ = i[m.name]).name in a) {
                var v = a[_.name];
                delete a[_.name];
                for (var g = 0, y = v; g < y.length; g++) s(_, y[g]);
              }
            }
          for (
            var b = [], w = [], x = 0, C = e.inputLayers;
            x < C.length;
            x++
          ) {
            var O = (m = C[x])[0],
              E = m[1],
              S = m[2];
            Mn(O in i);
            var N = (_ = i[O]).inboundNodes[E].outputTensors;
            b.push(N[S]);
          }
          for (var I = 0, k = e.outputLayers; I < k.length; I++) {
            var _;
            (O = (m = k[I])[0]),
              (E = m[1]),
              (S = m[2]),
              Mn(O in i),
              (N = (_ = i[O]).inboundNodes[E].outputTensors),
              w.push(N[S]);
          }
          return new t({ inputs: b, outputs: w, name: c });
        }),
        Object.defineProperty(e.prototype, "stateful", {
          get: function () {
            if (this._stateful)
              throw new Tn(
                "Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false."
              );
            for (var t = 0, e = this.layers; t < e.length; t++)
              if (e[t].stateful) return !0;
            return !1;
          },
          enumerable: !0,
          configurable: !0,
        }),
        (e.prototype.resetStates = function () {
          var t = this;
          Object(a.Zc)(function () {
            t.layers.forEach(function (t) {
              t.stateful && t.resetStates();
            });
          });
        }),
        e
      );
    })(ki);
    function Na(t, e) {
      return (function (t, e, n) {
        var r = e.length;
        if (null == t || (Array.isArray(t) && 0 === t.length))
          return e.map(function (t) {
            return null;
          });
        if (1 === r)
          return Array.isArray(t) && 1 === t.length
            ? t
            : "object" == typeof t && e[0] in t
            ? [t[e[0]]]
            : [t];
        if (Array.isArray(t)) {
          if (t.length !== r)
            throw new Error(
              "Provided " +
                n +
                " is an array of " +
                t.length +
                " element(s), but the model has " +
                r +
                " outputs. Make sure a set of weights is provided for each model output."
            );
          return t;
        }
        if (
          "object" == typeof t &&
          Object.keys(t).length > 0 &&
          "object" == typeof t[Object.keys(t)[0]]
        ) {
          var i = [];
          return (
            e.forEach(function (e) {
              e in t ? i.push(t[e]) : i.push(null);
            }),
            i
          );
        }
        throw new Error(
          "The model has multiple (" +
            r +
            ") outputs, so " +
            n +
            " must be either an array with " +
            r +
            " elements or an object with " +
            e +
            " keys. Provided " +
            n +
            " not understood: " +
            JSON.stringify(t)
        );
      })(t, e, "classWeight");
    }
    function Ia(t, e, n, r) {
      return Nn(this, void 0, void 0, function () {
        var i, o, s, u, c;
        return In(this, function (l) {
          switch (l.label) {
            case 0:
              if (null != e || null != r)
                throw new Error("Support sampleWeight is not implemented yet");
              return null == n
                ? [3, 2]
                : ((i = Object(a.Zc)(function () {
                    if (1 === t.shape.length) return t.clone();
                    if (2 === t.shape.length) {
                      if (t.shape[1] > 1) return t.argMax(1);
                      if (1 === t.shape[1]) return t.reshape([t.shape[0]]);
                      throw new Error(
                        "Encountered unexpected last-dimension size (" +
                          t.shape[1] +
                          ") during handling of class weights. The size is expected to be >= 1."
                      );
                    }
                    throw new Error(
                      "Unexpected rank of target (y) tensor (" +
                        t.rank +
                        ") during handling of class weights. The rank is expected to be 1 or 2."
                    );
                  })),
                  (u = (s = Array).from),
                  [4, i.data()]);
            case 1:
              return (
                (o = u.apply(s, [l.sent()])),
                Object(a.S)(i),
                (c = []),
                o.forEach(function (t) {
                  if (null == n[t])
                    throw new Error(
                      "classWeight must contain all classes in the training data. The class " +
                        t +
                        " exists in the data but not in classWeight"
                    );
                  c.push(n[t]);
                }),
                [2, Object(a.Uc)(c, "float32")]
              );
            case 2:
              return [2, null];
          }
        });
      });
    }
    function ka(t, e) {
      return Object(a.Rb)(t, e);
    }
    function _a(t, e) {
      var n,
        r,
        i = e;
      (n = i.xs),
        (r = i.ys),
        a.gd.assert(null != n && null != r, function () {
          return (
            "A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates " +
            e
          );
        });
      var o = Aa("input", t.inputNames, n),
        s = Aa("output", t.outputNames, r),
        u = o[0].shape[0];
      a.gd.assert(o.length === t.inputs.length, function () {
        return (
          "LayersModel has " +
          t.inputs.length +
          " inputs, but the dataset provides " +
          o.length +
          " inputs.  (Expected input keys: " +
          JSON.stringify(t.inputNames) +
          ")"
        );
      }),
        a.gd.assert(s.length === t.outputs.length, function () {
          return (
            "LayersModel has " +
            t.outputs.length +
            " outputs, but the dataset provides " +
            s.length +
            " outputs.  (Expected output keys: " +
            JSON.stringify(t.outputNames) +
            ")"
          );
        });
      for (
        var c = function (e) {
            a.gd.assert(o[e].shape[0] === u, function () {
              return (
                "Batch size mismatch: input " +
                t.inputNames[e] +
                " has " +
                o[e].shape[0] +
                "; expected  " +
                u +
                " based on input " +
                t.inputNames[0] +
                "."
              );
            });
          },
          l = 0;
        l < o.length;
        l++
      )
        c(l);
      for (
        var p = function (e) {
            a.gd.assert(s[e].shape[0] === u, function () {
              return (
                "Batch size mismatch: output " +
                t.outputNames[e] +
                " has " +
                s[e].shape[0] +
                "; expected  " +
                u +
                " based on input " +
                t.inputNames[0] +
                "."
              );
            });
          },
          h = 0;
        h < s.length;
        h++
      )
        p(h);
      return { xs: o, ys: s };
    }
    function Aa(t, e, n) {
      if (n instanceof a.b) return [n];
      if (Array.isArray(n))
        return (
          a.gd.assert(n.length === e.length, function () {
            return (
              "Received an array of " +
              n.length +
              " Tensors, but expected " +
              e.length +
              " to match the " +
              t +
              " keys " +
              e +
              "."
            );
          }),
          n
        );
      for (var r = [], i = 0, o = e; i < o.length; i++) {
        var s = o[i];
        if (null == n[s])
          throw new Tn(
            "The feature data generated by the dataset lacks the required " +
              t +
              " key '" +
              s +
              "'."
          );
        r.push(n[s]);
      }
      return r;
    }
    function Ta(t, e, n) {
      return Nn(this, void 0, void 0, function () {
        var r,
          i,
          o,
          s,
          u,
          c,
          l,
          p,
          h,
          f,
          d,
          m,
          v,
          g,
          y,
          b,
          w,
          x,
          C,
          O,
          E,
          S,
          N,
          I,
          k,
          _,
          A,
          T,
          R,
          D,
          F,
          M,
          j,
          P;
        return In(this, function (z) {
          switch (z.label) {
            case 0:
              if (
                ((r = null != n.batchesPerEpoch),
                a.gd.assert(null != t.optimizer, function () {
                  return "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).";
                }),
                a.gd.assert(null != n, function () {
                  return "For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.";
                }),
                a.gd.assert(
                  null != n.epochs &&
                    n.epochs > 0 &&
                    Number.isInteger(n.epochs),
                  function () {
                    return (
                      "For fitDataset(), config.epochs is expected to be a positive integer, but got " +
                      n.epochs
                    );
                  }
                ),
                a.gd.assert(
                  !r ||
                    (n.batchesPerEpoch > 0 &&
                      Number.isInteger(n.batchesPerEpoch)),
                  function () {
                    return (
                      "For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got " +
                      n.batchesPerEpoch
                    );
                  }
                ),
                a.gd.assert(null == n.validationSplit, function () {
                  return "`validationSplit` is not supported by `fitDataset()`. Use validationData instead.";
                }),
                t.isTraining)
              )
                throw new Error(
                  "Cannot start training because another fit() call is ongoing."
                );
              (t.isTraining = !0), (z.label = 1);
            case 1:
              return (
                z.trys.push([1, , 26, 27]),
                (i = null != n.validationData),
                (o = void 0),
                (s = void 0),
                i &&
                  (Ra(n.validationData)
                    ? a.gd.assert(
                        null == n.validationBatches ||
                          (n.validationBatches > 0 &&
                            Number.isInteger(n.validationBatches)),
                        function () {
                          return (
                            "For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got " +
                            n.validationBatches
                          );
                        }
                      )
                    : ((u = (function (t) {
                        if (3 === t.length)
                          throw new Rn(
                            "Validation with sample weights is not implemented yet."
                          );
                        return { xs: t[0], ys: t[1] };
                      })(n.validationData)),
                      (o = u.xs),
                      (s = u.ys))),
                (c = t.makeTrainFunction()),
                (l = t.getDedupedMetricsNames()),
                void 0,
                (p = i
                  ? l.slice().concat(
                      l.map(function (t) {
                        return "val_" + t;
                      })
                    )
                  : l.slice()),
                (h = Bi(n.callbacks, n.yieldEvery)),
                (f = null == n.verbose ? 1 : n.verbose),
                (d = Ui(
                  h,
                  f,
                  n.epochs,
                  null,
                  null,
                  (function (t, e) {
                    var n = null;
                    return (
                      null != e.batchesPerEpoch
                        ? (n = e.batchesPerEpoch)
                        : Number.isFinite(t.size) && (n = t.size),
                      n
                    );
                  })(e, n),
                  null,
                  i,
                  p
                )),
                (m = d.callbackList),
                (v = d.history),
                m.setModel(t),
                (t.history = v),
                [4, m.onTrainBegin()]
              );
            case 2:
              return (
                z.sent(),
                (t.stopTraining_ = !1),
                (g = null == n.initialEpoch ? 0 : n.initialEpoch),
                [4, e.iterator()]
              );
            case 3:
              (y = z.sent()), (z.label = 4);
            case 4:
              return g < n.epochs
                ? ((b = {}), [4, m.onEpochBegin(g)])
                : [3, 23];
            case 5:
              return z.sent(), (w = 0), (x = 0), r ? [3, 7] : [4, e.iterator()];
            case 6:
              (y = z.sent()), (z.label = 7);
            case 7:
              return !r || w < n.batchesPerEpoch ? [4, y.next()] : [3, 21];
            case 8:
              return (
                (C = z.sent()),
                r && C.done
                  ? (console.warn(
                      "You provided `batchesPerEpoch` as " +
                        n.batchesPerEpoch +
                        ", but your dataset iterator ran out of data after " +
                        w +
                        " batches; interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, " +
                        n.batchesPerEpoch * n.epochs +
                        " batches). You may need to use the repeat() function when building your dataset."
                    ),
                    [3, 21])
                  : null == C.value
                  ? [3, 15]
                  : ((O = _a(t, C.value)),
                    (E = O.xs),
                    (S = O.ys),
                    ((N = {}).batch = x),
                    (N.size = E[0].shape[0]),
                    [4, m.onBatchBegin(x, N)])
              );
            case 9:
              if ((z.sent(), (I = []), null == n.classWeight)) return [3, 13];
              (k = Na(n.classWeight, t.outputNames)), (P = 0), (z.label = 10);
            case 10:
              return P < k.length
                ? ((A = (_ = I).push), [4, Ia(S[P], null, k[P])])
                : [3, 13];
            case 11:
              A.apply(_, [z.sent()]), (z.label = 12);
            case 12:
              return ++P, [3, 10];
            case 13:
              for (
                T = E.concat(S).concat(I), R = c(T), Object(a.S)(T), P = 0;
                P < l.length;
                ++P
              )
                (D = l[P]), (F = R[P]), (N[D] = F), Object(a.tb)(F);
              return [4, m.onBatchEnd(x, N)];
            case 14:
              z.sent(), Fi(N), x++, w++, (z.label = 15);
            case 15:
              return (r ? w >= n.batchesPerEpoch : C.done)
                ? i
                  ? ((M = void 0),
                    Ra(n.validationData)
                      ? ((j = zn),
                        [
                          4,
                          t.evaluateDataset(n.validationData, {
                            batches: n.validationBatches,
                          }),
                        ])
                      : [3, 17])
                  : [3, 19]
                : [3, 20];
            case 16:
              return (M = j.apply(void 0, [z.sent()])), [3, 18];
            case 17:
              (M = zn(
                t.evaluate(o, s, {
                  batchSize:
                    null == n.validationBatchSize ? 32 : n.validationBatchSize,
                  verbose: 0,
                })
              )),
                (z.label = 18);
            case 18:
              for (P = 0; P < t.metricsNames.length; ++P)
                b["val_" + t.metricsNames[P]] = M[P];
              z.label = 19;
            case 19:
              return [3, 21];
            case 20:
              return t.stopTraining_ ? [3, 21] : [3, 7];
            case 21:
              return [4, m.onEpochEnd(g, b)];
            case 22:
              return z.sent(), g++, t.stopTraining_ ? [3, 23] : [3, 4];
            case 23:
              return [4, m.onTrainEnd()];
            case 24:
              return z.sent(), [4, t.history.syncData()];
            case 25:
              return z.sent(), [2, t.history];
            case 26:
              return (t.isTraining = !1), [7];
            case 27:
              return [2];
          }
        });
      });
    }
    function Ra(t) {
      return "function" == typeof t.iterator;
    }
    function Da(t, e, n) {
      return Nn(this, void 0, void 0, function () {
        var r, i, o, s, u, c, l, p, h, f;
        return In(this, function (d) {
          switch (d.label) {
            case 0:
              if (
                ((r = null != (n = n || {}).batches),
                (i = t.testFunction),
                (o = []),
                n.verbose > 0)
              )
                throw new Rn("Verbose mode is not implemented yet.");
              return (
                a.gd.assert(
                  !r || (n.batches > 0 && Number.isInteger(n.batches)),
                  function () {
                    return (
                      "Test loop expects `batches` to be a positive integer, but received " +
                      JSON.stringify(n.batches)
                    );
                  }
                ),
                (function (t) {
                  return "function" == typeof t.next;
                })(e)
                  ? ((u = e), [3, 3])
                  : [3, 1]
              );
            case 1:
              return [4, e.iterator()];
            case 2:
              (u = d.sent()), (d.label = 3);
            case 3:
              (s = u),
                (c = 0),
                (l = 0),
                (p = function () {
                  var e;
                  return In(this, function (u) {
                    switch (u.label) {
                      case 0:
                        return [4, s.next()];
                      case 1:
                        return (
                          (e = u.sent()),
                          (o = Object(a.Zc)(function () {
                            if (e.value) {
                              var n = _a(t, e.value),
                                r = n.xs,
                                s = n.ys,
                                u = r.concat(s),
                                p = Object(a.Zc)(function () {
                                  return i(u);
                                });
                              if ((Object(a.S)(u), 0 === l))
                                for (var h = 0; h < p.length; ++h)
                                  o.push(Object(a.pc)(0));
                              var f = u[0].shape[0],
                                d = function (t) {
                                  var e = p[t],
                                    n = o[t];
                                  (o[t] = Object(a.Zc)(function () {
                                    return Object(a.g)(
                                      o[t],
                                      Object(a.Rb)(f, e)
                                    );
                                  })),
                                    l > 0 && Object(a.S)(n);
                                };
                              for (h = 0; h < p.length; ++h) d(h);
                              Object(a.S)(p), (c += f), ++l;
                            }
                            return o;
                          })),
                          e.done
                            ? (r &&
                                console.warn(
                                  "Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` batches (in this case, " +
                                    n.batches +
                                    " batches). You may need to use the repeat() function when building your dataset."
                                ),
                              [2, "break"])
                            : [2]
                        );
                    }
                  });
                }),
                (d.label = 4);
            case 4:
              return !r || l < n.batches ? [5, p()] : [3, 6];
            case 5:
              return "break" === d.sent() ? [3, 6] : [3, 4];
            case 6:
              for (h = 0; h < o.length; ++h)
                (f = o[h]), (o[h] = Object(a.T)(o[h], c)), Object(a.S)(f);
              return [2, Pn(o)];
          }
        });
      });
    }
    function Fa(t) {
      a.gd.assert(t > 0 && Number.isInteger(t), function () {
        return "batchSize is required to be a positive integer, but got " + t;
      });
    }
    function Ma(t, e, n) {
      return null == t
        ? [null]
        : Array.isArray(t)
        ? t.map(function (t) {
            return _r(t, e, n - e);
          })
        : _r(t, e, n - e);
    }
    function ja(t, e) {
      return Object(a.Zc)(function () {
        return null == t
          ? null
          : Array.isArray(t)
          ? t.map(function (t) {
              return ja(t, e);
            })
          : Pr(t, "int32" === e.dtype ? e : e.toInt());
      });
    }
    function Pa(t, e) {
      for (var n = [], r = 0, i = null; r < t; )
        (i = r + e) >= t && (i = t), n.push([r, i]), (r = i);
      return n;
    }
    function za(t, e, n, r, i, o, s, u, c, l, p, h, f, d, m) {
      return Nn(this, void 0, void 0, function () {
        var v, g, y, b, w, x, C, O;
        return In(this, function (E) {
          switch (E.label) {
            case 0:
              if (
                (null == i && (i = 32),
                null == o && (o = 1),
                null == p && (p = !0),
                null == f && (f = 0),
                (v = !1),
                null != c && null != l && (v = !0),
                null != m && ((v = !0), null == d))
              )
                throw new Tn(
                  "Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set."
                );
              return (
                null != (g = t.checkNumSamples(n, i, d, "steps_per_epoch")) &&
                  (y = Nr(0, g)),
                null == s && (s = 1),
                (b = Ui(u, s, o, f, g, d, i, v, h)),
                (w = b.callbackList),
                (x = b.history),
                w.setModel(t),
                (t.history = x),
                [4, w.onTrainBegin()]
              );
            case 1:
              E.sent(),
                (t.stopTraining_ = !1),
                (C = function (o) {
                  var s, u, h, f, m;
                  return In(this, function (b) {
                    switch (b.label) {
                      case 0:
                        return [4, w.onEpochBegin(o)];
                      case 1:
                        if ((b.sent(), (s = {}), null == d)) return [3, 2];
                        throw new Rn(
                          "stepsPerEpoch mode is not implemented yet."
                        );
                      case 2:
                        if ("batch" === p)
                          throw new Rn(
                            "batch shuffling is not implemneted yet"
                          );
                        p && a.gd.shuffle(y),
                          (u = Object(a.Uc)(y)),
                          (h = Pa(g, i)),
                          (f = function (o) {
                            var p;
                            return In(this, function (f) {
                              switch (f.label) {
                                case 0:
                                  return (p = {}), [4, w.onBatchBegin(o, p)];
                                case 1:
                                  return (
                                    f.sent(),
                                    Object(a.Zc)(function () {
                                      var f = h[o][0],
                                        d = h[o][1],
                                        m = _r(u, f, d - f);
                                      (p.batch = o), (p.size = d - f);
                                      for (
                                        var g = ja(n, m), y = e(g), b = 0;
                                        b < r.length;
                                        ++b
                                      ) {
                                        var w = r[b],
                                          x = y[b];
                                        (p[w] = x), Object(a.tb)(x);
                                      }
                                      if (o === h.length - 1 && v) {
                                        var C = t.testLoop(c, l, i);
                                        for (b = 0; b < r.length; ++b)
                                          (w = r[b]),
                                            (x = C[b]),
                                            Object(a.tb)(x),
                                            (s["val_" + w] = x);
                                      }
                                    }),
                                    [4, w.onBatchEnd(o, p)]
                                  );
                                case 2:
                                  return (
                                    f.sent(),
                                    Fi(p),
                                    t.stopTraining_ ? [2, "break"] : [2]
                                  );
                              }
                            });
                          }),
                          (m = 0),
                          (b.label = 3);
                      case 3:
                        return m < h.length ? [5, f(m)] : [3, 6];
                      case 4:
                        if ("break" === b.sent()) return [3, 6];
                        b.label = 5;
                      case 5:
                        return ++m, [3, 3];
                      case 6:
                        u.dispose(), (b.label = 7);
                      case 7:
                        return [4, w.onEpochEnd(o, s)];
                      case 8:
                        return b.sent(), t.stopTraining_ ? [2, "break"] : [2];
                    }
                  });
                }),
                (O = f),
                (E.label = 2);
            case 2:
              return O < o ? [5, C(O)] : [3, 5];
            case 3:
              if ("break" === E.sent()) return [3, 5];
              E.label = 4;
            case 4:
              return ++O, [3, 2];
            case 5:
              return [4, w.onTrainEnd()];
            case 6:
              return E.sent(), [4, t.history.syncData()];
            case 7:
              return E.sent(), [2, t.history];
          }
        });
      });
    }
    function La(t, e, n, r) {
      return (
        void 0 === r && (r = {}),
        Nn(this, void 0, void 0, function () {
          var i, o, s, u, c, l, p, h, f, d, m, v, g, y, b, w, x, C, O, E;
          return In(this, function (S) {
            switch (S.label) {
              case 0:
                if (t.isTraining)
                  throw new Error(
                    "Cannot start training because another fit() call is ongoing."
                  );
                (t.isTraining = !0), (S.label = 1);
              case 1:
                return (
                  S.trys.push([1, , 7, 8]),
                  Fa((h = null == r.batchSize ? 32 : r.batchSize)),
                  !1,
                  [
                    4,
                    t.standardizeUserData(
                      e,
                      n,
                      r.sampleWeight,
                      r.classWeight,
                      !1,
                      h
                    ),
                  ]
                );
              case 2:
                if (
                  ((f = S.sent()),
                  (i = f[0]),
                  (o = f[1]),
                  (p = f[2]),
                  (d = !1),
                  (m = void 0),
                  !(null != r.validationData && r.validationData.length > 0))
                )
                  return [3, 4];
                if (((d = !0), 2 !== r.validationData.length))
                  throw 3 === r.validationData.length
                    ? new Rn(
                        "validationData including sample weights is not supported yet."
                      )
                    : new Tn(
                        "When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; " +
                          r.validationData +
                          " is invalid."
                      );
                return (
                  (s = r.validationData[0]),
                  (u = r.validationData[1]),
                  !0,
                  [4, t.standardizeUserData(s, u, null, null, !0, h)]
                );
              case 3:
                return (
                  (v = S.sent()),
                  (c = v[0]),
                  (l = v[1]),
                  (m = c.concat(l)),
                  [3, 5]
                );
              case 4:
                null != r.validationSplit &&
                r.validationSplit > 0 &&
                r.validationSplit < 1
                  ? ((d = !0),
                    (g = Math.floor(i[0].shape[0] * (1 - r.validationSplit))),
                    (y = i[0].shape[0]),
                    (c = Ma(i, g, y)),
                    (i = Ma(i, 0, g)),
                    (l = Ma(o, g, y)),
                    (o = Ma(o, 0, g)),
                    (m = c.concat(l)))
                  : null != r.validationSteps && (d = !0),
                  (S.label = 5);
              case 5:
                return (
                  (b = i.concat(o).concat(p)),
                  t.checkTrainableWeightsConsistency(),
                  (w = t.makeTrainFunction()),
                  (x = t.getDedupedMetricsNames()),
                  (C = void 0),
                  (O = void 0),
                  d
                    ? (t.makeTestFunction(),
                      (C = t.testFunction),
                      (O = x.slice().concat(
                        x.map(function (t) {
                          return "val_" + t;
                        })
                      )))
                    : ((C = null), (m = []), (O = x.slice())),
                  (E = Bi(r.callbacks, r.yieldEvery)),
                  [
                    4,
                    za(
                      t,
                      w,
                      b,
                      x,
                      h,
                      r.epochs,
                      r.verbose,
                      E,
                      C,
                      m,
                      r.shuffle,
                      O,
                      r.initialEpoch,
                      null,
                      null
                    ),
                  ]
                );
              case 6:
                return [2, S.sent()];
              case 7:
                return (
                  (t.isTraining = !1),
                  Wa(i, e),
                  Wa(o, n),
                  Wa(c, s),
                  Wa(l, u),
                  null != p && Object(a.S)(p),
                  [7]
                );
              case 8:
                return [2];
            }
          });
        })
      );
    }
    function Ba(t) {
      var e = [];
      t instanceof a.b && (t = [t]);
      for (var n = 0; n < t.length; ++n) {
        var r = t[n];
        if (1 === r.rank) e.push(kr(r, 1));
        else {
          if (0 === r.rank)
            throw new Error(
              "Expected tensor to be at least 1D, but received a 0D tensor (scalar)."
            );
          e.push(r);
        }
      }
      return e;
    }
    function Wa(t, e) {
      if (null != t) {
        var n = [];
        if (e instanceof a.b) n.push(e.id);
        else if (Array.isArray(e))
          e.forEach(function (t) {
            return n.push(t.id);
          });
        else if (null != e)
          for (var r in e) {
            var i = e[r];
            n.push(i.id);
          }
        var o = [];
        if (t instanceof a.b) -1 === n.indexOf(t.id) && o.push(t);
        else if (Array.isArray(t))
          t.forEach(function (t) {
            -1 === n.indexOf(t.id) && o.push(t);
          });
        else if (null != t)
          for (var s in t) {
            var u = t[s];
            -1 === n.indexOf(u.id) && o.push(u);
          }
        o.forEach(function (t) {
          t.isDisposed || t.dispose();
        });
      }
    }
    function Ua(t) {
      return Array.isArray(t);
    }
    function Va(t) {
      return (
        !(function (t) {
          return t instanceof a.b;
        })(t) && !Ua(t)
      );
    }
    function Ga(t, e, n, r, i) {
      if (
        (void 0 === r && (r = !0),
        void 0 === i && (i = ""),
        null == e || 0 === e.length)
      ) {
        if (null != t) {
          var a = !1;
          if (Ua(t) && t.length > 0) a = !0;
          else if (Va(t)) {
            for (var o in t)
              if (t.hasOwnProperty(o)) {
                a = !0;
                break;
              }
          } else a = !0;
          if (a)
            throw new Tn(
              "Error when checking model " +
                i +
                " expected no data, but got " +
                t
            );
        }
        return [];
      }
      if (null == t)
        return e.map(function (t) {
          return null;
        });
      var s;
      if (Va(t)) {
        (t = t), (s = []);
        for (var u = 0, c = e; u < c.length; u++) {
          var l = c[u];
          if (null == t[l])
            throw new Tn(
              'No data provided for "' +
                l +
                '". Need data for each key in: ' +
                e
            );
          s.push(t[l]);
        }
      } else if (Ua(t)) {
        if ((t = t).length !== e.length)
          throw new Tn(
            "Error when checking model " +
              i +
              ": the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see " +
              e.length +
              " Tensor(s), but instead got the following list of Tensor(s): " +
              t
          );
        s = t;
      } else {
        if (((t = t), e.length > 1))
          throw new Tn(
            "The model " +
              i +
              " expects " +
              e.length +
              " Tensor(s), but only received one Tensor. Found: Tensor with shape " +
              t.shape
          );
        s = [t];
      }
      if (((s = Ba(s)), null != n))
        for (var p = 0; p < e.length; ++p)
          if (null != n[p]) {
            var h = s[p];
            if (h.shape.length !== n[p].length)
              throw new Tn(
                "Error when checking " +
                  i +
                  ": expected " +
                  e[p] +
                  " to have " +
                  n[p].length +
                  " dimension(s). but got array with shape " +
                  h.shape
              );
            for (var f = 0; f < n[p].length; ++f)
              if (0 !== f || r) {
                var d = h.shape[f],
                  m = n[p][f];
                if (null != m && m >= 0 && d !== m)
                  throw new Tn(
                    "Error when checking " +
                      i +
                      ": expected " +
                      e[p] +
                      " to have shape [" +
                      n[p] +
                      "], but got array with shape [" +
                      h.shape +
                      "]."
                  );
              }
          }
      return s;
    }
    function Ha(t, e, n, r, i) {
      var a;
      if (
        (void 0 === r && (r = !0), void 0 === i && (i = ""), Array.isArray(t))
      ) {
        if (t.length !== e.length)
          throw new Tn(
            "Error when checking model " +
              i +
              ": the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see " +
              e.length +
              " Tensor(s), but instead got " +
              t.length +
              " Tensors(s)."
          );
        a = t;
      } else {
        if (e.length > 1)
          throw new Tn(
            "The model expects " +
              e.length +
              " " +
              i +
              " Tensors, but only received one Tensor. Found: array with shape " +
              JSON.stringify(t.shape) +
              "."
          );
        a = [t];
      }
      if (null != n)
        for (var o = 0; o < e.length; ++o)
          if (null != n[o]) {
            var s = a[o];
            if (s.shape.length !== n[o].length)
              throw new Tn(
                "Error when checking " +
                  i +
                  ": expected " +
                  e[o] +
                  " to have " +
                  n[o].length +
                  " dimension(s), but got array with shape " +
                  JSON.stringify(s.shape)
              );
            for (var u = 0; u < n[o].length; ++u)
              if (0 !== u || r) {
                var c = s.shape[u],
                  l = n[o][u];
                if (null != l && l !== c)
                  throw new Tn(
                    "Error when checking " +
                      i +
                      ": expected " +
                      e[o] +
                      " to have shape " +
                      JSON.stringify(n[o]) +
                      " but got array with shape " +
                      JSON.stringify(s.shape) +
                      "."
                  );
              }
          }
    }
    var qa = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return (n.isTraining = !1), n;
      }
      return (
        On(e, t),
        (e.prototype.summary = function (t, e, n) {
          if ((void 0 === n && (n = console.log), !this.built))
            throw new Tn(
              "This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data)."
            );
          ha(this, t, e, n);
        }),
        (e.prototype.compile = function (t) {
          var e = this;
          if (
            (null == t.loss && (t.loss = []),
            (this.loss = t.loss),
            "string" == typeof t.optimizer)
          )
            (this.optimizer_ = (function (t) {
              var e = {
                Adagrad: function () {
                  return a.cd.adagrad(0.01);
                },
                Adadelta: function () {
                  return a.cd.adadelta(1, 0.95, kn());
                },
                Adam: function () {
                  return a.cd.adam(0.001, 0.9, 0.999, kn());
                },
                Adamax: function () {
                  return a.cd.adamax(0.002, 0.9, 0.999, kn(), 0);
                },
                RMSProp: function () {
                  return a.cd.rmsprop(0.001, 0.9, 0, kn());
                },
                SGD: function () {
                  return a.cd.sgd(0.01);
                },
              };
              if (
                ((e.adagrad = e.Adagrad),
                (e.adadelta = e.Adadelta),
                (e.adam = e.Adam),
                (e.adamax = e.Adamax),
                (e.rmsprop = e.RMSProp),
                (e.sgd = e.SGD),
                t in e)
              )
                return e[t]();
              throw new Tn("Unknown Optimizer " + t);
            })(t.optimizer)),
              (this.isOptimizerOwned = !0);
          else {
            if (!(t.optimizer instanceof a.a))
              throw new Tn(
                "User-defined optimizer must be an instance of tf.Optimizer."
              );
            (this.optimizer_ = t.optimizer), (this.isOptimizerOwned = !1);
          }
          var n = [];
          if (
            Array.isArray(t.loss) ||
            "string" == typeof t.loss ||
            "function" == typeof t.loss
          )
            if (Array.isArray(t.loss)) {
              if (t.loss.length !== this.outputs.length)
                throw new Tn(
                  "When passing an Array as loss, it should have one entry per model output. The model has " +
                    this.outputs.length +
                    " output(s), but you passed loss=" +
                    t.loss +
                    "."
                );
              var r = t.loss;
              n = r.map(function (t) {
                return Qi(t);
              });
            } else {
              var i = Qi(t.loss);
              this.outputs.forEach(function (t) {
                n.push(i);
              });
            }
          else {
            for (var o in ((t.loss = t.loss), t.loss))
              if (-1 === this.outputNames.indexOf(o))
                throw new Tn(
                  'Unknown entry in loss dictionary: "' +
                    o +
                    '". Only expected the following keys: ' +
                    this.outputNames
                );
            for (var s = 0, u = this.outputNames; s < u.length; s++) {
              var c = u[s];
              null == t.loss[c] &&
                console.warn(
                  'Output "' +
                    c +
                    '" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ' +
                    c +
                    " during training"
                ),
                n.push(Qi(t.loss[c]));
            }
          }
          (this.lossFunctions = n),
            (this.feedOutputNames = []),
            (this.feedOutputShapes = []),
            (this.feedLossFns = []);
          for (var l = 0; l < this.outputs.length; ++l) {
            var p = this.internalOutputShapes[l],
              h = this.outputNames[l];
            this.feedOutputNames.push(h),
              this.feedOutputShapes.push(p),
              this.feedLossFns.push(this.lossFunctions[l]);
          }
          var f = [];
          (this.metrics = t.metrics),
            (this.metricsNames = ["loss"]),
            (this.metricsTensors = []),
            vr("loss", function () {
              for (var t = 0; t < e.outputs.length; ++t)
                if (-1 === f.indexOf(t)) {
                  var n = e.lossFunctions[t];
                  e.outputs.length > 1 &&
                    (e.metricsTensors.push([n, t]),
                    e.metricsNames.push(e.outputNames[t] + "_loss"));
                }
            });
          var d = (function (t, e) {
            if (null == t || (Array.isArray(t) && 0 === t.length))
              return e.map(function (t) {
                return [];
              });
            var n;
            if ("string" == typeof t || "function" == typeof t) n = [t];
            else {
              if (!Array.isArray(t) && "object" != typeof t)
                throw new TypeError(
                  "Type of metrics argument not understood. Expected an string,function, Array, or Object, found: " +
                    t
                );
              n = t;
            }
            if (Array.isArray(n))
              return e.map(function (t) {
                return n;
              });
            for (var r = [], i = 0, a = e; i < a.length; i++) {
              var o = a[i],
                s = n.hasOwnProperty(o) ? n[o] : [];
              Array.isArray(s) || (s = [s]), r.push(s);
            }
            return r;
          })(t.metrics, this.outputNames);
          vr("metric", function () {
            for (
              var t = function (t) {
                  if (-1 !== f.indexOf(t)) return "continue";
                  !(function (n) {
                    for (
                      var r,
                        i,
                        a,
                        o = function (n) {
                          if (
                            "string" == typeof n &&
                            -1 !==
                              ["accuracy", "acc", "crossentropy", "ce"].indexOf(
                                n
                              )
                          ) {
                            var o = e.internalOutputShapes[t];
                            1 === o[o.length - 1] || e.lossFunctions[t] === Yi
                              ? -1 !== ["accuracy", "acc"].indexOf(n)
                                ? (i = ta)
                                : -1 !== ["crossentropy", "ce"].indexOf(n) &&
                                  (i = aa)
                              : e.lossFunctions[t] === Xi
                              ? -1 !== ["accuracy", "acc"].indexOf(n)
                                ? (i = oa)
                                : -1 !== ["crossentropy", "ce"].indexOf(n) &&
                                  (i = ua)
                              : -1 !== ["accuracy", "acc"].indexOf(n)
                              ? (i = ea)
                              : -1 !== ["crossentropy", "ce"].indexOf(n) &&
                                (i = sa);
                            var s = void 0;
                            -1 !== ["accuracy", "acc"].indexOf(n)
                              ? (s = "acc")
                              : -1 !== ["crossentropy", "ce"].indexOf(n) &&
                                (s = "ce"),
                              (a = i),
                              (r = "" + s);
                          } else {
                            var u = (function (t) {
                              if ("string" == typeof t && (t in ca))
                                return ca[t];
                              if ("string" != typeof t && null != t) return t;
                              throw new Tn("Unknown metric " + t);
                            })(n);
                            (a = u), (r = "" + la(n));
                          }
                          var c;
                          vr(r, function () {
                            c = a;
                          }),
                            (function (t, n, r) {
                              e.outputNames.length > 1 &&
                                (n = e.outputNames[t] + "_" + n),
                                e.metricsNames.push(n),
                                e.metricsTensors.push([r, t]);
                            })(t, r, c);
                        },
                        s = 0,
                        u = n;
                      s < u.length;
                      s++
                    )
                      o(u[s]);
                  })(d[t]);
                },
                n = 0;
              n < e.outputs.length;
              ++n
            )
              t(n);
          }),
            (this.collectedTrainableWeights = this.trainableWeights);
        }),
        (e.prototype.checkTrainableWeightsConsistency = function () {
          null != this.collectedTrainableWeights &&
            this.trainableWeights.length !==
              this.collectedTrainableWeights.length &&
            console.warn(
              "Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?"
            );
        }),
        (e.prototype.evaluate = function (t, e, n) {
          void 0 === n && (n = {});
          var r = null == n.batchSize ? 32 : n.batchSize;
          Fa(r);
          var i = this.standardizeUserDataXY(t, e, !0, r);
          try {
            var a = i[0].concat(i[1]);
            this.makeTestFunction();
            var o = this.testFunction;
            return Pn(this.testLoop(o, a, r, n.verbose, n.steps));
          } finally {
            Wa(i[0], t), Wa(i[1], e);
          }
        }),
        (e.prototype.evaluateDataset = function (t, e) {
          return Nn(this, void 0, void 0, function () {
            return In(this, function (n) {
              return this.makeTestFunction(), [2, Da(this, t, e)];
            });
          });
        }),
        (e.prototype.checkNumSamples = function (t, e, n, r) {
          var i;
          if ((void 0 === r && (r = "steps"), null != n)) {
            if (((i = null), null != e))
              throw new Tn(
                "If " +
                  r +
                  " is set, batchSize must be null or undefined.Got batchSize = " +
                  e
              );
          } else {
            if (null == t)
              throw new Tn(
                "Either the input data should have a defined shape, or " +
                  r +
                  " shoud be specified."
              );
            i = Array.isArray(t) ? t[0].shape[0] : t.shape[0];
          }
          return i;
        }),
        (e.prototype.execute = function (t, e) {
          if (Array.isArray(e) && 0 === e.length)
            throw new Tn("`outputs` is an empty Array, which is not allowed.");
          var n = Array.isArray(e),
            r = n ? e : [e],
            i = this.retrieveSymbolicTensors(r),
            o = new ya();
          if ((t instanceof a.b && (t = [t]), Array.isArray(t))) {
            if (t.length !== this.inputs.length)
              throw new Tn(
                "The number of inputs provided (" +
                  t.length +
                  ") does not match the number of inputs of this model (" +
                  this.inputs.length +
                  ")."
              );
            for (var s = 0; s < this.inputs.length; ++s)
              o.add(this.inputs[s], t[s]);
          } else
            for (var u = 0, c = this.inputs; u < c.length; u++) {
              var l = c[u],
                p = t[l.name];
              if (null == p)
                throw new Tn(
                  "No value is provided for the model's input " + l.name
                );
              o.add(l, p);
            }
          var h = xa(i, o);
          return n ? h : h[0];
        }),
        (e.prototype.retrieveSymbolicTensors = function (t) {
          for (
            var e = Fn(null, t.length), n = t.length, r = 0, i = this.layers;
            r < i.length;
            r++
          ) {
            for (
              var a = i[r],
                o = Array.isArray(a.output) ? a.output : [a.output],
                s = o.map(function (t) {
                  return t.name;
                }),
                u = 0;
              u < t.length;
              ++u
            ) {
              var c = s.indexOf(t[u]);
              if ((-1 !== c && ((e[u] = o[c]), n--), 0 === n)) break;
            }
            if (0 === n) break;
          }
          if (n > 0) {
            var l = [];
            throw (
              (e.forEach(function (e, n) {
                null == e && l.push(t[n]);
              }),
              new Tn(
                "Cannot find SymbolicTensors for output name(s): " +
                  JSON.stringify(l)
              ))
            );
          }
          return e;
        }),
        (e.prototype.predictLoop = function (t, e, n) {
          var r = this;
          return (
            void 0 === e && (e = 32),
            void 0 === n && (n = !1),
            Object(a.Zc)(function () {
              var i = r.checkNumSamples(t);
              if (n)
                throw new Rn("Verbose predictLoop() is not implemented yet.");
              for (
                var o = Pa(i, e),
                  s = r.outputs.map(function (t) {
                    return [];
                  }),
                  u = function (e) {
                    Object(a.Zc)(function () {
                      var n = o[e][0],
                        i = o[e][1],
                        a = Ma(t, n, i),
                        s = [];
                      if (Array.isArray(a))
                        for (var u = 0; u < a.length; ++u)
                          s.push({ key: r.inputs[u], value: a[u] });
                      else s.push({ key: r.inputs[0], value: a });
                      var c = new ya(s);
                      return xa(r.outputs, c);
                    }).forEach(function (t, e) {
                      return s[e].push(t);
                    });
                  },
                  c = 0;
                c < o.length;
                ++c
              )
                u(c);
              return Pn(
                s.map(function (t) {
                  return Object(a.E)(t, 0);
                })
              );
            })
          );
        }),
        (e.prototype.predict = function (t, e) {
          void 0 === e && (e = {});
          var n = Ba(t);
          Ha(n, this.inputNames, this.feedInputShapes, !1);
          try {
            var r = null == e.batchSize ? 32 : e.batchSize;
            return Fa(r), this.predictLoop(n, r);
          } finally {
            Wa(n, t);
          }
        }),
        (e.prototype.predictOnBatch = function (t) {
          Ha(t, this.inputNames, this.feedInputShapes, !0);
          var e = (Array.isArray(t) ? t[0] : t).shape[0];
          return this.predictLoop(t, e);
        }),
        (e.prototype.standardizeUserDataXY = function (t, e, n, r) {
          if ((void 0 === n && (n = !0), null == this.optimizer_))
            throw new An(
              "You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs)."
            );
          for (var i = [], o = 0; o < this.feedOutputShapes.length; ++o) {
            var s = this.feedOutputShapes[o];
            this.feedLossFns[o] === Xi
              ? i.push(s.slice(0, s.length - 1).concat([1]))
              : i.push(s);
          }
          if (
            ((function (t, e, n) {
              var r = Hn(
                t.map(function (t) {
                  return t.shape[0];
                })
              );
              r.sort();
              var i = Hn(
                e.map(function (t) {
                  return t.shape[0];
                })
              );
              if ((i.sort(), r.length > 1))
                throw new Tn(
                  "All input Tensors (x) should have the same number of samples. Got array shapes: " +
                    JSON.stringify(
                      t.map(function (t) {
                        return t.shape;
                      })
                    )
                );
              if (i.length > 1)
                throw new Tn(
                  "All target Tensors (y) should have the same number of samples. Got array shapes: " +
                    JSON.stringify(
                      e.map(function (t) {
                        return t.shape;
                      })
                    )
                );
              if (r.length > 0 && i.length > 0 && !a.gd.arraysEqual(r, i))
                throw new Tn(
                  "Input Tensors should have the same number of samples as target Tensors. Found " +
                    r[0] +
                    " input sample(s) and " +
                    i[0] +
                    " target sample(s)."
                );
            })(
              (t = Ga(
                t,
                this.feedInputNames,
                this.feedInputShapes,
                !1,
                "input"
              )),
              (e = Ga(e, this.feedOutputNames, i, !1, "target"))
            ),
            (function (t, e, n) {
              for (var r = [Hi, Yi, Zi], i = 0; i < t.length; ++i) {
                var a = t[i],
                  o = e[i],
                  s = n[i];
                if (null != o) {
                  if (o === Zi && 1 === a.shape[a.shape.length - 1])
                    throw new Tn(
                      "You are passing a target array of shape " +
                        a.shape +
                        " while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes]."
                    );
                  if (-1 !== r.indexOf(o))
                    for (
                      var u = a.shape.slice(1), c = s.slice(1), l = 0;
                      l < u.length;
                      ++l
                    ) {
                      var p = u[l],
                        h = c[l];
                      if (null != h && p !== h)
                        throw new Tn(
                          "A target Tensor with shape " +
                            a.shape +
                            " was passed for an output of shape " +
                            s +
                            ", while using a loss function that expects targets to have the same shape as the output."
                        );
                    }
                }
              }
            })(e, this.feedLossFns, this.feedOutputShapes),
            this.stateful && null != r && r > 0 && t[0].shape[0] % r != 0)
          )
            throw new Tn(
              "In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size " +
                r +
                ". Found: " +
                t[0].shape[0] +
                " sample(s)."
            );
          return [t, e];
        }),
        (e.prototype.standardizeUserData = function (t, e, n, r, i, a) {
          return (
            void 0 === i && (i = !0),
            Nn(this, void 0, void 0, function () {
              var o, s, u, c, l, p, h, f;
              return In(this, function (d) {
                switch (d.label) {
                  case 0:
                    if (
                      ((o = this.standardizeUserDataXY(t, e, i, a)),
                      (s = o[0]),
                      (u = o[1]),
                      null != n)
                    )
                      throw new Error("sample weight is not supported yet.");
                    if (((c = null), null == r)) return [3, 4];
                    (l = Na(r, this.outputNames)),
                      (c = []),
                      (p = 0),
                      (d.label = 1);
                  case 1:
                    return p < l.length
                      ? ((f = (h = c).push), [4, Ia(u[p], null, l[p])])
                      : [3, 4];
                  case 2:
                    f.apply(h, [d.sent()]), (d.label = 3);
                  case 3:
                    return ++p, [3, 1];
                  case 4:
                    return [2, [s, u, c]];
                }
              });
            })
          );
        }),
        (e.prototype.testLoop = function (t, e, n, r, i) {
          var o = this;
          return (
            void 0 === r && (r = 0),
            Object(a.Zc)(function () {
              var s = o.checkNumSamples(e, n, i, "steps"),
                u = [];
              if (r > 0) throw new Rn("Verbose mode is not implemented yet.");
              if (null != i)
                throw new Rn("steps mode in testLoop() is not implemented yet");
              for (
                var c = Pa(s, n), l = Object(a.Uc)(Nr(0, s)), p = 0;
                p < c.length;
                ++p
              ) {
                var h = c[p][0],
                  f = c[p][1],
                  d = _r(l, h, f - h),
                  m = ja(e, d),
                  v = t(m);
                if (0 === p)
                  for (var g = 0; g < v.length; ++g) u.push(Object(a.pc)(0));
                for (g = 0; g < v.length; ++g) {
                  var y = v[g];
                  u[g] = Object(a.g)(u[g], Object(a.Rb)(f - h, y));
                }
              }
              for (g = 0; g < u.length; ++g) u[g] = Object(a.T)(u[g], s);
              return u;
            })
          );
        }),
        (e.prototype.getDedupedMetricsNames = function () {
          for (var t = this.metricsNames, e = [], n = 0; n < t.length; ++n) {
            var r = t[n],
              i = r;
            jn(t, r) > 1 && (i += "_" + jn(t.slice(0, n), r)), e.push(i);
          }
          return e;
        }),
        (e.prototype.makeTrainFunction = function () {
          var t = this;
          return function (e) {
            var n = [],
              r = e.slice(0, t.inputs.length),
              i = e.slice(t.inputs.length, t.inputs.length + t.outputs.length),
              o = e.slice(
                t.inputs.length + t.outputs.length,
                t.inputs.length + 2 * t.outputs.length
              ),
              s = [],
              u = t.collectedTrainableWeights.map(function (t) {
                return t.read();
              });
            return [
              t.optimizer_.minimize(
                function () {
                  for (var e = [], u = 0; u < t.inputs.length; ++u)
                    e.push({ key: t.inputs[u], value: r[u] });
                  var c,
                    l = new ya(e),
                    p = xa(t.outputs, l, { training: !0 });
                  for (u = 0; u < t.lossFunctions.length; ++u) {
                    var h = (0, t.lossFunctions[u])(i[u], p[u]);
                    null != o[u] && (h = ka(h, o[u]));
                    var f = Object(a.Lb)(h);
                    n.push(f), (c = 0 === u ? h : Object(a.g)(c, h));
                  }
                  for (u = 0; u < t.metricsTensors.length; ++u) {
                    var d = void 0;
                    if (t.outputs.length > 1 && u < t.outputs.length) d = n[u];
                    else {
                      var m = t.metricsTensors[u][0],
                        v = t.metricsTensors[u][1];
                      d = Object(a.Lb)(m(i[v], p[v]));
                    }
                    Object(a.tb)(d), s.push(d);
                  }
                  return (
                    (c = Object(a.Lb)(c)),
                    t.calculateLosses().forEach(function (t) {
                      c = Object(a.g)(c, t);
                    }),
                    c
                  );
                },
                !0,
                u
              ),
            ].concat(s);
          };
        }),
        (e.prototype.makeTestFunction = function () {
          var t = this;
          this.testFunction = function (e) {
            return Object(a.Zc)(function () {
              for (
                var n,
                  r = [],
                  i = e.slice(0, t.inputs.length),
                  o = e.slice(
                    t.inputs.length,
                    t.inputs.length + t.outputs.length
                  ),
                  s = [],
                  u = 0;
                u < t.inputs.length;
                ++u
              )
                s.push({ key: t.inputs[u], value: i[u] });
              var c = new ya(s),
                l = xa(t.outputs, c);
              for (u = 0; u < t.lossFunctions.length; ++u) {
                var p = t.lossFunctions[u],
                  h = Object(a.Lb)(p(o[u], l[u]));
                (n = 0 === u ? h : Object(a.g)(n, h)), r.push(n);
              }
              for (u = 0; u < t.metricsTensors.length; ++u) {
                var f = t.metricsTensors[u][0],
                  d = t.metricsTensors[u][1],
                  m = Object(a.Lb)(f(o[d], l[d]));
                r.push(m);
              }
              return r;
            });
          };
        }),
        (e.prototype.fit = function (t, e, n) {
          return (
            void 0 === n && (n = {}),
            Nn(this, void 0, void 0, function () {
              return In(this, function (r) {
                return [2, La(this, t, e, n)];
              });
            })
          );
        }),
        (e.prototype.fitDataset = function (t, e) {
          return Nn(this, void 0, void 0, function () {
            return In(this, function (n) {
              return [2, Ta(this, t, e)];
            });
          });
        }),
        (e.prototype.trainOnBatch = function (t, e) {
          return Nn(this, void 0, void 0, function () {
            var n, r, i, o, s, u, c, l, p;
            return In(this, function (h) {
              switch (h.label) {
                case 0:
                  return [4, this.standardizeUserData(t, e)];
                case 1:
                  (n = h.sent()),
                    (r = n[0]),
                    (i = n[1]),
                    (o = this.makeTrainFunction()),
                    (s = o(r.concat(i))),
                    (u = []),
                    (c = 0),
                    (l = s),
                    (h.label = 2);
                case 2:
                  return c < l.length ? [4, l[c].data()] : [3, 5];
                case 3:
                  (p = h.sent()), u.push(p[0]), (h.label = 4);
                case 4:
                  return c++, [3, 2];
                case 5:
                  return Object(a.S)(s), [2, Pn(u)];
              }
            });
          });
        }),
        (e.prototype.getNamedWeights = function (t) {
          for (
            var e = [],
              n = null != t && t.trainableOnly,
              r = n ? this.trainableWeights : this.weights,
              i = this.getWeights(n),
              a = 0;
            a < r.length;
            ++a
          )
            (n && !r[a].trainable) ||
              e.push({ name: r[a].originalName, tensor: i[a] });
          return e;
        }),
        Object.defineProperty(e.prototype, "stopTraining", {
          get: function () {
            return this.stopTraining_;
          },
          set: function (t) {
            this.stopTraining_ = t;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "optimizer", {
          get: function () {
            return this.optimizer_;
          },
          set: function (t) {
            this.optimizer_ !== t &&
              ((this.optimizer_ = t), (this.isOptimizerOwned = !1));
          },
          enumerable: !0,
          configurable: !0,
        }),
        (e.prototype.dispose = function () {
          var e = t.prototype.dispose.call(this);
          if (
            0 === e.refCountAfterDispose &&
            null != this.optimizer &&
            this.isOptimizerOwned
          ) {
            var n = Object(a.Mb)().numTensors;
            this.optimizer_.dispose(),
              (e.numDisposedVariables += n - Object(a.Mb)().numTensors);
          }
          return e;
        }),
        (e.prototype.getLossIdentifiers = function () {
          var t;
          if ("string" == typeof this.loss) t = Ln(this.loss);
          else if (Array.isArray(this.loss)) {
            for (var e = 0, n = this.loss; e < n.length; e++)
              if ("string" != typeof n[e])
                throw new Error(
                  "Serialization of non-string loss is not supported."
                );
            t = this.loss.map(function (t) {
              return Ln(t);
            });
          } else {
            var r = Object.keys(this.loss);
            t = {};
            for (var i = this.loss, a = 0, o = r; a < o.length; a++) {
              var s = o[a];
              if ("string" != typeof i[s])
                throw new Error(
                  "Serialization of non-string loss is not supported."
                );
              t[s] = Ln(i[s]);
            }
          }
          return t;
        }),
        (e.prototype.getMetricIdentifiers = function () {
          if (
            "string" == typeof this.metrics ||
            "function" == typeof this.metrics
          )
            return [Ln(la(this.metrics))];
          if (Array.isArray(this.metrics))
            return this.metrics.map(function (t) {
              return Ln(la(t));
            });
          var t = {};
          for (var e in this.metrics) t[e] = Ln(la(this.metrics[e]));
          return t;
        }),
        (e.prototype.getTrainingConfig = function () {
          return {
            loss: this.getLossIdentifiers(),
            metrics: this.getMetricIdentifiers(),
            optimizer_config: {
              class_name: this.optimizer.getClassName(),
              config: this.optimizer.getConfig(),
            },
          };
        }),
        (e.prototype.loadTrainingConfig = function (t) {
          if (null != t.weighted_metrics)
            throw new Error("Loading weight_metrics is not supported yet.");
          if (null != t.loss_weights)
            throw new Error("Loading loss_weights is not supported yet.");
          if (null != t.sample_weight_mode)
            throw new Error("Loading sample_weight_mode is not supported yet.");
          var e,
            n,
            r = Vi(ga(t.optimizer_config));
          if ("string" == typeof t.loss) e = Bn(t.loss);
          else if (Array.isArray(t.loss))
            e = t.loss.map(function (t) {
              return Bn(t);
            });
          else if (null != t.loss)
            for (var i in ((e = {}), t.loss)) e[i] = Bn(t.loss[i]);
          if (Array.isArray(t.metrics))
            n = t.metrics.map(function (t) {
              return Bn(t);
            });
          else if (null != t.metrics)
            for (var i in ((n = {}), t.metrics)) n[i] = Bn(t.metrics[i]);
          this.compile({ loss: e, metrics: n, optimizer: r });
        }),
        (e.prototype.save = function (t, e) {
          return Nn(this, void 0, void 0, function () {
            var n, r, i, o, s, u, c, l, p, h, f;
            return In(this, function (d) {
              switch (d.label) {
                case 0:
                  if ("string" == typeof t) {
                    if (0 === (n = a.rb.getSaveHandlers(t)).length)
                      throw new Tn(
                        "Cannot find any save handlers for URL '" + t + "'"
                      );
                    if (n.length > 1)
                      throw new Tn(
                        "Found more than one (" +
                          n.length +
                          ") save handlers for URL '" +
                          t +
                          "'"
                      );
                    t = n[0];
                  }
                  if (null == t.save)
                    throw new Tn(
                      "LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined."
                    );
                  return [4, a.rb.encodeWeights(this.getNamedWeights(e))];
                case 1:
                  return (
                    (r = d.sent()),
                    !1,
                    null,
                    (i = this.toJSON(null, !1)),
                    (o = {
                      modelTopology: i,
                      format: "layers-model",
                      generatedBy: "TensorFlow.js tfjs-layers v1.7.0",
                      convertedBy: null,
                    }),
                    null != e && e.includeOptimizer && null != this.optimizer
                      ? ((o.trainingConfig = this.getTrainingConfig()),
                        (s = "optimizer"),
                        (h = (p = a.rb).encodeWeights),
                        [4, this.optimizer.getWeights()])
                      : [3, 4]
                  );
                case 2:
                  return [4, h.apply(p, [d.sent(), s])];
                case 3:
                  (u = d.sent()),
                    (c = u.data),
                    (l = u.specs),
                    (f = r.specs).push.apply(f, l),
                    (r.data = a.rb.concatenateArrayBuffers([r.data, c])),
                    (d.label = 4);
                case 4:
                  return (
                    null != this.userDefinedMetadata &&
                      (!0,
                      pa(this.userDefinedMetadata, this.name, !0),
                      (o.userDefinedMetadata = this.userDefinedMetadata)),
                    (o.weightData = r.data),
                    (o.weightSpecs = r.specs),
                    [2, t.save(o)]
                  );
              }
            });
          });
        }),
        (e.prototype.setUserDefinedMetadata = function (t) {
          pa(t, this.name), (this.userDefinedMetadata = t);
        }),
        (e.prototype.getUserDefinedMetadata = function () {
          return this.userDefinedMetadata;
        }),
        (e.className = "Model"),
        e
      );
    })(Sa);
    a.tc.registerClass(qa);
    var Ka = (function (t) {
      function e(e) {
        var n = t.call(this, { inputs: [], outputs: [] }) || this;
        if (
          ((e = e || {}),
          (n.trainable = !0),
          (n.built = !1),
          (n.name = null != e.name ? e.name : di("sequential_")),
          null != e.layers)
        )
          for (var r = 0, i = e.layers; r < i.length; r++) {
            var a = i[r];
            n.add(a);
          }
        return n;
      }
      return (
        On(e, t),
        (e.prototype.checkShape = function (t) {
          if (
            t.inboundNodes[0].outputTensors[0].shape.some(function (t) {
              return t < 0;
            })
          )
            throw new Tn(
              "Negative dimension size caused by adding layer " +
                t.name +
                " with input shape [" +
                t.inboundNodes[0].inputTensors[0].shape +
                "]"
            );
        }),
        (e.prototype.add = function (t) {
          var n,
            r = t instanceof e || t instanceof qa;
          if (r) {
            if (1 !== (n = t).outputs.length)
              throw new Tn(
                "All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API."
              );
            if (1 !== n.inputs.length)
              throw new Tn(
                "All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API."
              );
          }
          if (0 === this.outputs.length) {
            if (0 === t.inboundNodes.length) {
              if (null == t.batchInputShape)
                throw new Tn(
                  "The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument."
                );
              var i = Ri({
                batchShape: t.batchInputShape,
                dtype: t.dtype,
                name: t.name + "_input",
              });
              t.apply(i);
            }
            if (r) (this.outputs = n.outputs), (this.inputs = n.inputs);
            else {
              if (1 !== t.inboundNodes.length)
                throw new Tn(
                  "A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer " +
                    t.name +
                    " which has " +
                    t.inboundNodes.length +
                    " pre-existing inbound connections."
                );
              if (1 !== t.inboundNodes[0].outputTensors.length)
                throw new Tn(
                  "All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API."
                );
              this.checkShape(t),
                (this.outputs = [t.inboundNodes[0].outputTensors[0]]),
                (this.inputs = (function t(e, n, r) {
                  if (
                    ((null == n || (null != r && r > 0)) &&
                      ((n = e.sourceLayer), (r = e.nodeIndex)),
                    0 === n.inboundNodes.length)
                  )
                    return [e];
                  var i = n.inboundNodes[r];
                  if (0 === i.inboundLayers.length) return i.inputTensors;
                  for (var a = [], o = 0; o < i.inboundLayers.length; o++)
                    for (
                      var s = 0,
                        u = t(
                          i.inputTensors[o],
                          i.inboundLayers[o],
                          i.nodeIndices[o]
                        );
                      s < u.length;
                      s++
                    ) {
                      var c = u[s];
                      -1 === a.indexOf(c) && a.push(c);
                    }
                  return a;
                })(this.outputs[0]));
            }
            (this.inboundNodes = []),
              new Ni({
                outboundLayer: this,
                inboundLayers: [],
                nodeIndices: [],
                tensorIndices: [],
                inputTensors: this.inputs,
                outputTensors: this.outputs,
                inputMasks: Fn(null, this.inputs.length),
                outputMasks: [null],
                inputShapes: this.inputs.map(function (t) {
                  return t.shape;
                }),
                outputShapes: this.outputs[0].shape,
              });
          } else {
            var a = t.apply(this.outputs[0]);
            if (Array.isArray(a))
              throw new TypeError(
                "All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API."
              );
            this.checkShape(t),
              (this.outputs = [a]),
              (this.inboundNodes[0].outputTensors = this.outputs),
              (this.inboundNodes[0].outputShapes = [this.outputs[0].shape]);
          }
          this.layers.push(t), (this.built = !1);
        }),
        (e.prototype.pop = function () {
          if (0 === this.layers.length)
            throw new TypeError("There are no layers in the model.");
          if ((this.layers.pop(), 0 === this.layers.length))
            (this.outputs = []),
              (this.inboundNodes = []),
              (this.outboundNodes = []);
          else {
            var t = this.layers.length - 1;
            (this.layers[t].outboundNodes = []),
              (this.outputs = [this.layers[t].output]),
              (this.inboundNodes[0].outputTensors = this.outputs),
              (this.inboundNodes[0].outputShapes = [this.outputs[0].shape]);
          }
        }),
        (e.prototype.call = function (t, e) {
          return null == this.model && this.build(), this.model.call(t, e);
        }),
        (e.prototype.build = function (t) {
          if ((yi(t), 0 === this.inputs.length || 0 === this.outputs.length))
            throw new TypeError(
              "Sequential model cannot be built: model is empty. Add some layers first."
            );
          (this.model = new qa({
            inputs: this.inputs,
            outputs: this.outputs[0],
            name: this.name + "_model",
          })),
            (this.model.trainable = this.trainable),
            (this.supportsMasking = this.model.supportsMasking),
            (this.inputLayers = this.model.inputLayers),
            (this.inputLayersNodeIndices = this.model.inputLayersNodeIndices),
            (this.inputLayersTensorIndices = this.model.inputLayersTensorIndices),
            (this.outputLayers = this.model.outputLayers),
            (this.outputLayersNodeIndices = this.model.outputLayersNodeIndices),
            (this.outputLayersTensorIndices = this.model.outputLayersTensorIndices),
            (this.nodesByDepth = this.model.nodesByDepth),
            (this.containerNodes = this.model.containerNodes),
            (this.outputNames = this.model.outputNames),
            (this.inputNames = this.model.inputNames),
            (this.built = !0);
        }),
        (e.prototype.countParams = function () {
          return this.built || this.build(), t.prototype.countParams.call(this);
        }),
        (e.prototype.summary = function (e, n, r) {
          void 0 === r && (r = console.log),
            this.built || this.build(),
            t.prototype.summary.call(this, e, n, r);
        }),
        (e.prototype.setWeights = function (t) {
          null == this.model && this.build(), this.model.setWeights(t);
        }),
        (e.prototype.evaluate = function (t, e, n) {
          if ((void 0 === n && (n = {}), !this.built))
            throw new An("The model needs to be compiled before being used.");
          return this.model.evaluate(t, e, n);
        }),
        (e.prototype.evaluateDataset = function (t, e) {
          return Nn(this, void 0, void 0, function () {
            return In(this, function (n) {
              if (!this.built)
                throw new An(
                  "The model needs to be compiled before being used."
                );
              return [2, this.model.evaluateDataset(t, e)];
            });
          });
        }),
        (e.prototype.predict = function (t, e) {
          return (
            void 0 === e && (e = {}),
            null == this.model && this.build(),
            this.model.predict(t, e)
          );
        }),
        (e.prototype.predictOnBatch = function (t) {
          return (
            null == this.model && this.build(), this.model.predictOnBatch(t)
          );
        }),
        (e.prototype.compile = function (t) {
          this.build(),
            this.model.compile(t),
            (this.optimizer_ = this.model.optimizer),
            (this.isOptimizerOwned = this.model.isOptimizerOwned),
            (this.loss = this.model.loss),
            (this.metrics = this.model.metrics),
            (this.metricsTensors = this.model.metricsTensors),
            (this.metricsNames = this.model.metricsNames);
        }),
        Object.defineProperty(e.prototype, "optimizer", {
          get: function () {
            return null == this.model ? void 0 : this.model.optimizer;
          },
          set: function (t) {
            this.model.optimizer = t;
          },
          enumerable: !0,
          configurable: !0,
        }),
        (e.prototype.fit = function (t, e, n) {
          return (
            void 0 === n && (n = {}),
            Nn(this, void 0, void 0, function () {
              return In(this, function (r) {
                if (!this.built)
                  throw new An(
                    "The model needs to be compiled before being used."
                  );
                return [2, this.model.fit(t, e, n)];
              });
            })
          );
        }),
        (e.prototype.fitDataset = function (t, e) {
          return Nn(this, void 0, void 0, function () {
            return In(this, function (n) {
              if (!this.built)
                throw new An(
                  "The model needs to be compiled before being used."
                );
              return [2, this.model.fitDataset(t, e)];
            });
          });
        }),
        (e.prototype.trainOnBatch = function (t, e) {
          return Nn(this, void 0, void 0, function () {
            return In(this, function (n) {
              return [2, this.model.trainOnBatch(t, e)];
            });
          });
        }),
        (e.fromConfig = function (t, n, r, i) {
          var o;
          void 0 === r && (r = {}), void 0 === i && (i = !1);
          var s = {};
          if (n instanceof Array) {
            if (null == n[0].className || "Merge" === n[0].className)
              throw new Tn("Legacy serialization format not supported yet.");
            o = n;
          } else
            a.gd.assert(null != n.layers, function () {
              return "When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.";
            }),
              (o = n.layers),
              delete n.layers,
              (s = n);
          var u = new t(s);
          if (!(u instanceof e))
            throw new Rn(
              "Sequential.fromConfig called on non-Sequential input: " + u
            );
          for (var c = 0, l = o; c < l.length; c++) {
            var p = Vi(l[c], void 0, i);
            i && p.setFastWeightInitDuringBuild(!0), u.add(p);
          }
          return u;
        }),
        Object.defineProperty(e.prototype, "stopTraining", {
          get: function () {
            if (null == this.model)
              throw new Tn(
                "Cannot get the stopTraining property of a sequential model before it is compiled."
              );
            return this.model.stopTraining;
          },
          set: function (t) {
            if (null == this.model)
              throw new Tn(
                "Cannot set the stopTraining property of a sequential model before it is compiled."
              );
            this.model.stopTraining = t;
          },
          enumerable: !0,
          configurable: !0,
        }),
        (e.prototype.getConfig = function () {
          for (var t = [], e = 0, n = this.layers; e < n.length; e++) {
            var r = n[e],
              i = {};
            (i.className = r.getClassName()),
              (i.config = r.getConfig()),
              t.push(i);
          }
          return { name: this.name, layers: t };
        }),
        (e.className = "Sequential"),
        e
      );
    })(qa);
    a.tc.registerClass(Ka);
    var Za = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          On(e, t),
          (e.prototype.getConfig = function () {
            return {};
          }),
          e
        );
      })(a.tc.Serializable),
      Xa = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          On(e, t),
          (e.prototype.apply = function (t, e) {
            return (
              void 0 === e && (e = 1),
              (function (t, e) {
                if ((void 0 === e && (e = 1), 1 !== e))
                  throw new Rn(
                    "Support for alpha values other than 1 (" +
                      e +
                      ") is not implemented yet."
                  );
                return Object(a.W)(t);
              })(t, e)
            );
          }),
          (e.className = "elu"),
          e
        );
      })(Za);
    a.tc.registerClass(Xa);
    var Ya = (function (t) {
      function e() {
        return (null !== t && t.apply(this, arguments)) || this;
      }
      return (
        On(e, t),
        (e.prototype.apply = function (t) {
          return Object(a.rc)(t);
        }),
        (e.className = "selu"),
        e
      );
    })(Za);
    a.tc.registerClass(Ya);
    var Ja = (function (t) {
      function e() {
        return (null !== t && t.apply(this, arguments)) || this;
      }
      return (
        On(e, t),
        (e.prototype.apply = function (t) {
          return Object(a.jc)(t);
        }),
        (e.className = "relu"),
        e
      );
    })(Za);
    a.tc.registerClass(Ja);
    var $a = (function (t) {
      function e() {
        return (null !== t && t.apply(this, arguments)) || this;
      }
      return (
        On(e, t),
        (e.prototype.apply = function (t) {
          return Object(a.Zc)(function () {
            return Object(a.Ob)(6, Object(a.jc)(t));
          });
        }),
        (e.className = "relu6"),
        e
      );
    })(Za);
    a.tc.registerClass($a);
    var Qa = (function (t) {
      function e() {
        return (null !== t && t.apply(this, arguments)) || this;
      }
      return (
        On(e, t),
        (e.prototype.apply = function (t) {
          return t;
        }),
        (e.className = "linear"),
        e
      );
    })(Za);
    a.tc.registerClass(Qa);
    var to = (function (t) {
      function e() {
        return (null !== t && t.apply(this, arguments)) || this;
      }
      return (
        On(e, t),
        (e.prototype.apply = function (t) {
          return Object(a.vc)(t);
        }),
        (e.className = "sigmoid"),
        e
      );
    })(Za);
    a.tc.registerClass(to);
    var eo = (function (t) {
      function e() {
        return (null !== t && t.apply(this, arguments)) || this;
      }
      return (
        On(e, t),
        (e.prototype.apply = function (t) {
          return (function (t) {
            return Object(a.Zc)(function () {
              var e = Object(a.g)(0.5, Object(a.Rb)(0.2, t));
              return Object(a.C)(e, 0, 1);
            });
          })(t);
        }),
        (e.className = "hardSigmoid"),
        e
      );
    })(Za);
    a.tc.registerClass(eo);
    var no = (function (t) {
      function e() {
        return (null !== t && t.apply(this, arguments)) || this;
      }
      return (
        On(e, t),
        (e.prototype.apply = function (t) {
          return Object(a.Fc)(t);
        }),
        (e.className = "softplus"),
        e
      );
    })(Za);
    a.tc.registerClass(no);
    var ro = (function (t) {
      function e() {
        return (null !== t && t.apply(this, arguments)) || this;
      }
      return (
        On(e, t),
        (e.prototype.apply = function (t) {
          return (function (t) {
            return Object(a.Zc)(function () {
              return Object(a.T)(t, Object(a.d)(t).add(1));
            });
          })(t);
        }),
        (e.className = "softsign"),
        e
      );
    })(Za);
    a.tc.registerClass(ro);
    var io = (function (t) {
      function e() {
        return (null !== t && t.apply(this, arguments)) || this;
      }
      return (
        On(e, t),
        (e.prototype.apply = function (t) {
          return Object(a.Sc)(t);
        }),
        (e.className = "tanh"),
        e
      );
    })(Za);
    a.tc.registerClass(io);
    var ao = (function (t) {
      function e() {
        return (null !== t && t.apply(this, arguments)) || this;
      }
      return (
        On(e, t),
        (e.prototype.apply = function (t, e) {
          return void 0 === e && (e = -1), Object(a.Ec)(t, e);
        }),
        (e.className = "softmax"),
        e
      );
    })(Za);
    a.tc.registerClass(ao);
    var oo = (function (t) {
      function e() {
        return (null !== t && t.apply(this, arguments)) || this;
      }
      return (
        On(e, t),
        (e.prototype.apply = function (t, e) {
          return void 0 === e && (e = -1), Object(a.Cb)(t, e);
        }),
        (e.className = "logSoftmax"),
        e
      );
    })(Za);
    function so(t) {
      return t.getClassName();
    }
    function uo(t, e) {
      return (
        void 0 === e && (e = {}),
        Vn(t, a.tc.SerializationMap.getMap().classNameMap, e, "activation")
      );
    }
    function co(t) {
      var e;
      return null == t
        ? uo((e = { className: "linear", config: {} }))
        : "string" == typeof t
        ? (((e = {}).className = t), (e.config = {}), uo(e))
        : t instanceof Za
        ? t
        : uo(t);
    }
    function lo(t) {
      if (null != t && "object" != typeof t)
        throw new Error(
          "Argument to L1L2 regularizer's constructor is expected to be an object, but received: " +
            t
        );
    }
    a.tc.registerClass(oo);
    var po = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return On(e, t), e;
      })(a.tc.Serializable),
      ho = (function (t) {
        function e(e) {
          var n = t.call(this) || this;
          return (
            lo(e),
            (n.l1 = null == e || null == e.l1 ? 0.01 : e.l1),
            (n.l2 = null == e || null == e.l2 ? 0.01 : e.l2),
            (n.hasL1 = 0 !== n.l1),
            (n.hasL2 = 0 !== n.l2),
            n
          );
        }
        return (
          On(e, t),
          (e.prototype.apply = function (t) {
            var e = this;
            return Object(a.Zc)(function () {
              var n = Object(a.ld)([1]);
              return (
                e.hasL1 &&
                  (n = Object(a.g)(
                    n,
                    Object(a.Qc)(Object(a.Rb)(e.l1, Object(a.d)(t)))
                  )),
                e.hasL2 &&
                  (n = Object(a.g)(n, Object(a.Qc)(Object(a.Rb)(e.l2, zr(t))))),
                n.asScalar()
              );
            });
          }),
          (e.prototype.getConfig = function () {
            return { l1: this.l1, l2: this.l2 };
          }),
          (e.fromConfig = function (t, e) {
            return new t({ l1: e.l1, l2: e.l2 });
          }),
          (e.className = "L1L2"),
          e
        );
      })(po);
    a.tc.registerClass(ho);
    var fo = { l1l2: "L1L2" };
    function mo(t) {
      return Un(t);
    }
    function vo(t, e) {
      return (
        void 0 === e && (e = {}),
        Vn(t, a.tc.SerializationMap.getMap().classNameMap, e, "regularizer")
      );
    }
    function go(t) {
      return null == t
        ? null
        : "string" == typeof t
        ? vo({ className: t in fo ? fo[t] : t, config: {} })
        : t instanceof po
        ? t
        : vo(t);
    }
    var yo = (function (t) {
      function e(e) {
        var n = t.call(this, null == e ? {} : e) || this;
        return (
          (n.supportsMasking = !0), null != e && (n.maxValue = e.maxValue), n
        );
      }
      return (
        On(e, t),
        (e.prototype.call = function (t, e) {
          t = gi(t);
          var n = Object(a.jc)(t);
          return (
            null != this.maxValue && (n = Object(a.C)(n, 0, this.maxValue)), n
          );
        }),
        (e.prototype.computeOutputShape = function (t) {
          return t;
        }),
        (e.prototype.getConfig = function () {
          var e = { maxValue: this.maxValue },
            n = t.prototype.getConfig.call(this);
          return Object.assign(e, n), e;
        }),
        (e.className = "ReLU"),
        e
      );
    })(ki);
    a.tc.registerClass(yo);
    var bo = (function (t) {
      function e(e) {
        var n = t.call(this, null == e ? {} : e) || this;
        return (
          (n.DEFAULT_ALPHA = 0.3),
          null == e && (e = {}),
          (n.alpha = null == e.alpha ? n.DEFAULT_ALPHA : e.alpha),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype.call = function (t, e) {
          var n = gi(t);
          return Object(a.ub)(n, this.alpha);
        }),
        (e.prototype.computeOutputShape = function (t) {
          return t;
        }),
        (e.prototype.getConfig = function () {
          var e = { alpha: this.alpha },
            n = t.prototype.getConfig.call(this);
          return Object.assign(e, n), e;
        }),
        (e.className = "LeakyReLU"),
        e
      );
    })(ki);
    a.tc.registerClass(bo);
    var wo = (function (t) {
      function e(e) {
        var n = t.call(this, null == e ? {} : e) || this;
        if (
          ((n.DEFAULT_ALPHA_INITIALIZER = "zeros"),
          null == e && (e = {}),
          (n.supportsMasking = !0),
          (n.alphaInitializer = li(
            e.alphaInitializer || n.DEFAULT_ALPHA_INITIALIZER
          )),
          (n.alphaRegularizer = go(e.alphaRegularizer)),
          (n.alphaConstraint = or(e.alphaConstraint)),
          null == e.sharedAxes)
        )
          n.sharedAxes = null;
        else if (Array.isArray(e.sharedAxes)) n.sharedAxes = e.sharedAxes;
        else {
          if ("number" != typeof e.sharedAxes)
            throw new Tn(
              "Expected sharedAxes to be a number or an array of numbers, but got " +
                e.sharedAxes
            );
          n.sharedAxes = [e.sharedAxes];
        }
        return n;
      }
      return (
        On(e, t),
        (e.prototype.build = function (t) {
          var e = (t = yi(t)).slice(1);
          if (null != this.sharedAxes)
            for (var n = 0, r = this.sharedAxes; n < r.length; n++)
              e[(a = r[n]) - 1] = 1;
          this.alpha = this.addWeight(
            "alpha",
            e,
            "float32",
            this.alphaInitializer,
            this.alphaRegularizer,
            !0,
            this.alphaConstraint
          );
          var i = {};
          if (null != this.sharedAxes)
            for (var a = 1; a < t.length; ++a) i[a] = t[a];
          (this.inputSpec = [new Oi({ ndim: t.length, axes: i })]),
            (this.built = !0);
        }),
        (e.prototype.call = function (t, e) {
          return (t = gi(t)), Object(a.cc)(t, this.alpha.read());
        }),
        (e.prototype.getConfig = function () {
          var e = {
              alphaInitializer: ci(this.alphaInitializer),
              alphaRegularizer: mo(this.alphaRegularizer),
              alphaConstraint: ir(this.alphaConstraint),
              sharedAxes: this.sharedAxes,
            },
            n = t.prototype.getConfig.call(this);
          return Object.assign(e, n), e;
        }),
        (e.className = "PReLU"),
        e
      );
    })(ki);
    a.tc.registerClass(wo);
    var xo = (function (t) {
      function e(e) {
        var n = t.call(this, null == e ? {} : e) || this;
        if (
          ((n.DEFAULT_ALPHA = 1),
          null == e && (e = {}),
          null != e.alpha && e.alpha !== n.DEFAULT_ALPHA)
        )
          throw new Rn(
            "Non-default alpha value (" +
              e.alpha +
              ") is not supported by the ELU layer yet."
          );
        return (n.alpha = null == e.alpha ? n.DEFAULT_ALPHA : e.alpha), n;
      }
      return (
        On(e, t),
        (e.prototype.call = function (t, e) {
          var n = gi(t);
          return Object(a.W)(n);
        }),
        (e.prototype.computeOutputShape = function (t) {
          return t;
        }),
        (e.prototype.getConfig = function () {
          var e = { alpha: this.alpha },
            n = t.prototype.getConfig.call(this);
          return Object.assign(e, n), e;
        }),
        (e.className = "ELU"),
        e
      );
    })(ki);
    a.tc.registerClass(xo);
    var Co = (function (t) {
      function e(e) {
        var n = t.call(this, null == e ? {} : e) || this;
        return (
          (n.DEFAULT_THETA = 1),
          null == e && (e = {}),
          (n.theta = null == e.theta ? n.DEFAULT_THETA : e.theta),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype.call = function (t, e) {
          var n = gi(t);
          return n.mul(Ir(n.greater(this.theta), "float32"));
        }),
        (e.prototype.computeOutputShape = function (t) {
          return t;
        }),
        (e.prototype.getConfig = function () {
          var e = { theta: this.theta },
            n = t.prototype.getConfig.call(this);
          return Object.assign(e, n), e;
        }),
        (e.className = "ThresholdedReLU"),
        e
      );
    })(ki);
    a.tc.registerClass(Co);
    var Oo = (function (t) {
      function e(e) {
        var n = t.call(this, null == e ? {} : e) || this;
        return (
          (n.DEFAULT_AXIS = 1),
          null == e && (e = {}),
          (n.softmax = new ao().apply),
          (n.axis = null == e.axis ? n.DEFAULT_AXIS : e.axis),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype.call = function (t, e) {
          var n = gi(t);
          return this.softmax(n, this.axis);
        }),
        (e.prototype.computeOutputShape = function (t) {
          return t;
        }),
        (e.prototype.getConfig = function () {
          var e = { axis: this.axis },
            n = t.prototype.getConfig.call(this);
          return Object.assign(e, n), e;
        }),
        (e.className = "Softmax"),
        e
      );
    })(ki);
    function Eo(t, e, n) {
      if ("number" == typeof t) return Fn(t, e);
      if (t.length !== e)
        throw new Tn(
          "The " +
            n +
            " argument must be an integer or tuple of " +
            e +
            " integers. Received: " +
            t.length +
            " elements."
        );
      for (var r = 0; r < e; ++r) {
        var i = t[r];
        if (!xr(i))
          throw new Tn(
            "The " +
              n +
              " argument must be an integer or tuple of " +
              e +
              " integers. Received: " +
              JSON.stringify(t) +
              " including a non-integer number " +
              i
          );
      }
      return t;
    }
    function So(t, e, n, r, i) {
      return (
        void 0 === i && (i = 1),
        null == t
          ? t
          : ((a = "same" === n ? t : t - (e + (e - 1) * (i - 1)) + 1),
            Math.floor((a + r - 1) / r))
      );
      var a;
    }
    function No(t, e, n, r) {
      if (null == t) return null;
      if ("valid" === r) t = t * e + Sr([n - e, 0]);
      else {
        if ("same" !== r) throw new Tn("Unsupport padding mode: " + r + ".");
        t *= e;
      }
      return t;
    }
    function Io(t, e) {
      return Object(a.Zc)(function () {
        return hr(e), "channelsFirst" === e ? Object(a.dd)(t, [0, 2, 3, 1]) : t;
      });
    }
    function ko(t, e) {
      return Object(a.Zc)(function () {
        return (
          hr(e), "channelsFirst" === e ? Object(a.dd)(t, [0, 2, 3, 4, 1]) : t
        );
      });
    }
    function _o(t, e, n, r, i, o, s, u) {
      return (
        void 0 === r && (r = [1, 1]),
        void 0 === i && (i = "valid"),
        void 0 === u && (u = null),
        Object(a.Zc)(function () {
          if (
            (null == o && (o = "channelsLast"),
            hr(o),
            3 !== t.rank && 4 !== t.rank)
          )
            throw new Tn(
              "conv2dWithBiasActivation expects input to be of rank 3 or 4, but received " +
                t.rank +
                "."
            );
          if (3 !== e.rank && 4 !== e.rank)
            throw new Tn(
              "conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received " +
                t.rank +
                "."
            );
          var c = Io(t, o);
          if ("causal" === i)
            throw new Rn(
              "The support for CAUSAL padding mode in conv1dWithBias is not implemented yet."
            );
          return (
            (c = a.jb.conv2d({
              x: c,
              filter: e,
              strides: r,
              pad: "same" === i ? "same" : "valid",
              dilations: s,
              dataFormat: "NHWC",
              bias: n,
              activation: u,
            })),
            "channelsFirst" === o && (c = Object(a.dd)(c, [0, 3, 1, 2])),
            c
          );
        })
      );
    }
    a.tc.registerClass(Oo);
    var Ao = (function (t) {
        function e(n, r) {
          var i = t.call(this, r) || this;
          if (
            ((i.bias = null),
            (i.DEFAULT_KERNEL_INITIALIZER = "glorotNormal"),
            (i.DEFAULT_BIAS_INITIALIZER = "zeros"),
            e.verifyArgs(r),
            (i.rank = n),
            Xn(i.rank, "rank"),
            1 !== i.rank && 2 !== i.rank && 3 !== i.rank)
          )
            throw new Rn(
              "Convolution layer for rank other than 1, 2, or 3 (" +
                i.rank +
                ") is not implemented yet."
            );
          if (
            ((i.kernelSize = Eo(r.kernelSize, n, "kernelSize")),
            (i.strides = Eo(null == r.strides ? 1 : r.strides, n, "strides")),
            (i.padding = null == r.padding ? "valid" : r.padding),
            fr(i.padding),
            (i.dataFormat =
              null == r.dataFormat ? "channelsLast" : r.dataFormat),
            hr(i.dataFormat),
            (i.activation = co(r.activation)),
            (i.useBias = null == r.useBias || r.useBias),
            (i.biasInitializer = li(
              r.biasInitializer || i.DEFAULT_BIAS_INITIALIZER
            )),
            (i.biasConstraint = or(r.biasConstraint)),
            (i.biasRegularizer = go(r.biasRegularizer)),
            (i.activityRegularizer = go(r.activityRegularizer)),
            (i.dilationRate = Eo(
              null == r.dilationRate ? 1 : r.dilationRate,
              n,
              "dilationRate"
            )),
            1 === i.rank &&
              Array.isArray(i.dilationRate) &&
              1 !== i.dilationRate.length)
          )
            throw new Tn(
              "dilationRate must be a number or an array of a single number for 1D convolution, but received " +
                JSON.stringify(i.dilationRate)
            );
          if (2 === i.rank) {
            if ("number" == typeof i.dilationRate)
              i.dilationRate = [i.dilationRate, i.dilationRate];
            else if (2 !== i.dilationRate.length)
              throw new Tn(
                "dilationRate must be a number or array of two numbers for 2D convolution, but received " +
                  JSON.stringify(i.dilationRate)
              );
          } else if (3 === i.rank)
            if ("number" == typeof i.dilationRate)
              i.dilationRate = [i.dilationRate, i.dilationRate, i.dilationRate];
            else if (3 !== i.dilationRate.length)
              throw new Tn(
                "dilationRate must be a number or array of three numbers for 3D convolution, but received " +
                  JSON.stringify(i.dilationRate)
              );
          return i;
        }
        return (
          On(e, t),
          (e.verifyArgs = function (t) {
            if (
              (Mn("kernelSize" in t, "required key 'kernelSize' not in config"),
              "number" != typeof t.kernelSize &&
                !Zn(t.kernelSize, "number", 1, 3))
            )
              throw new Tn(
                "BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received " +
                  JSON.stringify(t.kernelSize) +
                  "."
              );
          }),
          (e.prototype.getConfig = function () {
            var e = {
                kernelSize: this.kernelSize,
                strides: this.strides,
                padding: this.padding,
                dataFormat: this.dataFormat,
                dilationRate: this.dilationRate,
                activation: so(this.activation),
                useBias: this.useBias,
                biasInitializer: ci(this.biasInitializer),
                biasRegularizer: mo(this.biasRegularizer),
                activityRegularizer: mo(this.activityRegularizer),
                biasConstraint: ir(this.biasConstraint),
              },
              n = t.prototype.getConfig.call(this);
            return Object.assign(e, n), e;
          }),
          e
        );
      })(ki),
      To = (function (t) {
        function e(n, r) {
          var i = t.call(this, n, r) || this;
          return (
            (i.kernel = null),
            e.verifyArgs(r),
            (i.filters = r.filters),
            Xn(i.filters, "filters"),
            (i.kernelInitializer = li(
              r.kernelInitializer || i.DEFAULT_KERNEL_INITIALIZER
            )),
            (i.kernelConstraint = or(r.kernelConstraint)),
            (i.kernelRegularizer = go(r.kernelRegularizer)),
            i
          );
        }
        return (
          On(e, t),
          (e.prototype.build = function (t) {
            var e;
            t = yi(t);
            var n = "channelsFirst" === this.dataFormat ? 1 : t.length - 1;
            if (null == t[n])
              throw new Tn(
                "The channel dimension of the input should be defined. Found " +
                  t[n]
              );
            var r = t[n],
              i = this.kernelSize.concat([r, this.filters]);
            (this.kernel = this.addWeight(
              "kernel",
              i,
              null,
              this.kernelInitializer,
              this.kernelRegularizer,
              !0,
              this.kernelConstraint
            )),
              this.useBias &&
                (this.bias = this.addWeight(
                  "bias",
                  [this.filters],
                  null,
                  this.biasInitializer,
                  this.biasRegularizer,
                  !0,
                  this.biasConstraint
                )),
              (this.inputSpec = [
                { ndim: this.rank + 2, axes: ((e = {}), (e[n] = r), e) },
              ]),
              (this.built = !0);
          }),
          (e.prototype.call = function (t, e) {
            var n = this;
            return Object(a.Zc)(function () {
              var e;
              t = gi(t);
              var r = null == n.bias ? null : n.bias.read(),
                i = Yn(n.activation.getClassName());
              if (null != i && 2 === n.rank)
                e = _o(
                  t,
                  n.kernel.read(),
                  r,
                  n.strides,
                  n.padding,
                  n.dataFormat,
                  n.dilationRate,
                  i
                );
              else {
                if (1 === n.rank)
                  e = (function (t, e, n, r, i, o, s) {
                    return (
                      void 0 === r && (r = 1),
                      void 0 === i && (i = "valid"),
                      void 0 === s && (s = 1),
                      Object(a.Zc)(function () {
                        if (
                          (null == o && (o = "channelsLast"),
                          hr(o),
                          3 !== t.shape.length)
                        )
                          throw new Tn(
                            "The input of a conv1dWithBias operation should be 3, but is " +
                              t.shape.length +
                              " instead."
                          );
                        if (3 !== e.shape.length)
                          throw new Tn(
                            "The kernel for a conv1dWithBias operation should be 3, but is " +
                              e.shape.length +
                              " instead"
                          );
                        if (null != n && 1 !== n.shape.length)
                          throw new Tn(
                            "The bias for a conv1dWithBias operation should be 1, but is " +
                              e.shape.length +
                              " instead"
                          );
                        if (
                          ("channelsFirst" === o &&
                            (t = Object(a.dd)(t, [0, 2, 1])),
                          "causal" === i)
                        )
                          throw new Rn(
                            "The support for CAUSAL padding mode in conv1dWithBias is not implemented yet."
                          );
                        var u = Object(a.J)(
                          t,
                          e,
                          r,
                          "same" === i ? "same" : "valid",
                          "NWC",
                          s
                        );
                        return null != n && (u = Br(u, n)), u;
                      })
                    );
                  })(
                    t,
                    n.kernel.read(),
                    r,
                    n.strides[0],
                    n.padding,
                    n.dataFormat,
                    n.dilationRate[0]
                  );
                else if (2 === n.rank)
                  e = _o(
                    t,
                    n.kernel.read(),
                    r,
                    n.strides,
                    n.padding,
                    n.dataFormat,
                    n.dilationRate
                  );
                else {
                  if (3 !== n.rank)
                    throw new Rn(
                      "convolutions greater than 3D are not implemented yet."
                    );
                  e = (function (t, e, n, r, i, o, s) {
                    return (
                      void 0 === r && (r = [1, 1, 1]),
                      void 0 === i && (i = "valid"),
                      Object(a.Zc)(function () {
                        if (
                          (null == o && (o = "channelsLast"),
                          hr(o),
                          4 !== t.rank && 5 !== t.rank)
                        )
                          throw new Tn(
                            "conv3dWithBias expects input to be of rank 4 or 5, but received " +
                              t.rank +
                              "."
                          );
                        if (4 !== e.rank && 5 !== e.rank)
                          throw new Tn(
                            "conv3dWithBias expects kernel to be of rank 4 or 5, but received " +
                              t.rank +
                              "."
                          );
                        var u = ko(t, o);
                        if ("causal" === i)
                          throw new Rn(
                            "The support for CAUSAL padding mode in conv3dWithBias is not implemented yet."
                          );
                        return (
                          (u = Object(a.M)(
                            u,
                            e,
                            r,
                            "same" === i ? "same" : "valid",
                            "NDHWC",
                            s
                          )),
                          null != n && (u = Br(u, n)),
                          "channelsFirst" === o &&
                            (u = Object(a.dd)(u, [0, 4, 1, 2, 3])),
                          u
                        );
                      })
                    );
                  })(
                    t,
                    n.kernel.read(),
                    r,
                    n.strides,
                    n.padding,
                    n.dataFormat,
                    n.dilationRate
                  );
                }
                null != n.activation && (e = n.activation.apply(e));
              }
              return e;
            });
          }),
          (e.prototype.computeOutputShape = function (t) {
            t = yi(t);
            for (
              var e = [],
                n =
                  "channelsLast" === this.dataFormat
                    ? t.slice(1, t.length - 1)
                    : t.slice(2),
                r = 0;
              r < n.length;
              ++r
            ) {
              var i = So(
                n[r],
                this.kernelSize[r],
                this.padding,
                this.strides[r],
                "number" == typeof this.dilationRate
                  ? this.dilationRate
                  : this.dilationRate[r]
              );
              e.push(i);
            }
            var a = [t[0]];
            return (
              "channelsLast" === this.dataFormat
                ? (a = a.concat(e)).push(this.filters)
                : (a.push(this.filters), (a = a.concat(e))),
              a
            );
          }),
          (e.prototype.getConfig = function () {
            var e = {
                filters: this.filters,
                kernelInitializer: ci(this.kernelInitializer),
                kernelRegularizer: mo(this.kernelRegularizer),
                kernelConstraint: ir(this.kernelConstraint),
              },
              n = t.prototype.getConfig.call(this);
            return Object.assign(e, n), e;
          }),
          (e.verifyArgs = function (t) {
            if (
              !("filters" in t) ||
              "number" != typeof t.filters ||
              t.filters < 1
            )
              throw new Tn(
                "Convolution layer expected config.filters to be a 'number' > 0 but got " +
                  JSON.stringify(t.filters)
              );
          }),
          e
        );
      })(Ao),
      Ro = (function (t) {
        function e(n) {
          var r = t.call(this, 2, n) || this;
          return e.verifyArgs(n), r;
        }
        return (
          On(e, t),
          (e.prototype.getConfig = function () {
            var e = t.prototype.getConfig.call(this);
            return delete e.rank, e;
          }),
          (e.verifyArgs = function (t) {
            if (
              "number" != typeof t.kernelSize &&
              !Zn(t.kernelSize, "number", 1, 2)
            )
              throw new Tn(
                "Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received " +
                  JSON.stringify(t.kernelSize) +
                  "."
              );
          }),
          (e.className = "Conv2D"),
          e
        );
      })(To);
    a.tc.registerClass(Ro);
    var Do = (function (t) {
      function e(n) {
        var r = t.call(this, 3, n) || this;
        return e.verifyArgs(n), r;
      }
      return (
        On(e, t),
        (e.prototype.getConfig = function () {
          var e = t.prototype.getConfig.call(this);
          return delete e.rank, e;
        }),
        (e.verifyArgs = function (t) {
          if (
            "number" != typeof t.kernelSize &&
            (!Array.isArray(t.kernelSize) ||
              (1 !== t.kernelSize.length && 3 !== t.kernelSize.length))
          )
            throw new Tn(
              "Conv3D expects config.kernelSize to be number or [number, number, number], but received " +
                JSON.stringify(t.kernelSize) +
                "."
            );
        }),
        (e.className = "Conv3D"),
        e
      );
    })(To);
    a.tc.registerClass(Do);
    var Fo = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        if (
          ((n.inputSpec = [new Oi({ ndim: 4 })]),
          "same" !== n.padding && "valid" !== n.padding)
        )
          throw new Tn(
            "Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode " +
              n.padding
          );
        return n;
      }
      return (
        On(e, t),
        (e.prototype.build = function (t) {
          var e;
          if (4 !== (t = yi(t)).length)
            throw new Tn(
              "Input should have rank 4; Received input shape: " +
                JSON.stringify(t)
            );
          var n = "channelsFirst" === this.dataFormat ? 1 : t.length - 1;
          if (null == t[n])
            throw new Tn(
              "The channel dimension of the inputs should be defined. Found `None`."
            );
          var r = t[n],
            i = this.kernelSize.concat([this.filters, r]);
          (this.kernel = this.addWeight(
            "kernel",
            i,
            "float32",
            this.kernelInitializer,
            this.kernelRegularizer,
            !0,
            this.kernelConstraint
          )),
            this.useBias &&
              (this.bias = this.addWeight(
                "bias",
                [this.filters],
                "float32",
                this.biasInitializer,
                this.biasRegularizer,
                !0,
                this.biasConstraint
              )),
            (this.inputSpec = [
              new Oi({ ndim: 4, axes: ((e = {}), (e[n] = r), e) }),
            ]),
            (this.built = !0);
        }),
        (e.prototype.call = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            var e = gi(t);
            if (4 !== e.shape.length)
              throw new Tn(
                "Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-" +
                  e.shape.length
              );
            var r,
              i,
              o = e.shape,
              s = o[0];
            "channelsFirst" === n.dataFormat
              ? ((r = 2), (i = 3))
              : ((r = 1), (i = 2));
            var u = o[r],
              c = o[i],
              l = n.kernelSize[0],
              p = n.kernelSize[1],
              h = n.strides[0],
              f = n.strides[1],
              d = [
                s,
                No(u, h, l, n.padding),
                No(c, f, p, n.padding),
                n.filters,
              ];
            "channelsLast" !== n.dataFormat &&
              (e = Object(a.dd)(e, [0, 2, 3, 1]));
            var m = Object(a.L)(e, n.kernel.read(), d, n.strides, n.padding);
            return (
              "channelsLast" !== n.dataFormat &&
                (m = Object(a.dd)(m, [0, 3, 1, 2])),
              null != n.bias && (m = Br(m, n.bias.read(), n.dataFormat)),
              null != n.activation && (m = n.activation.apply(m)),
              m
            );
          });
        }),
        (e.prototype.computeOutputShape = function (t) {
          var e,
            n,
            r,
            i = (t = yi(t)).slice();
          "channelsFirst" === this.dataFormat
            ? ((e = 1), (n = 2), (r = 3))
            : ((e = 3), (n = 1), (r = 2));
          var a = this.kernelSize[0],
            o = this.kernelSize[1],
            s = this.strides[0],
            u = this.strides[1];
          return (
            (i[e] = this.filters),
            (i[n] = No(i[n], s, a, this.padding)),
            (i[r] = No(i[r], u, o, this.padding)),
            i
          );
        }),
        (e.prototype.getConfig = function () {
          var e = t.prototype.getConfig.call(this);
          return delete e.dilationRate, e;
        }),
        (e.className = "Conv2DTranspose"),
        e
      );
    })(Ro);
    a.tc.registerClass(Fo);
    var Mo = (function (t) {
      function e(e) {
        return t.call(this, 2, e) || this;
      }
      return On(e, t), (e.className = "SeparableConv2D"), e;
    })(
      (function (t) {
        function e(e, n) {
          var r = t.call(this, e, n) || this;
          if (
            ((r.DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform"),
            (r.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform"),
            (r.depthwiseKernel = null),
            (r.pointwiseKernel = null),
            null == n.filters)
          )
            throw new Tn(
              "The `filters` configuration field is required by SeparableConv, but is unspecified."
            );
          if (
            null != n.kernelInitializer ||
            null != n.kernelRegularizer ||
            null != n.kernelConstraint
          )
            throw new Tn(
              "Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead."
            );
          if (
            null != n.padding &&
            "same" !== n.padding &&
            "valid" !== n.padding
          )
            throw new Tn(
              "SeparableConv" +
                r.rank +
                "D supports only padding modes: 'same' and 'valid', but received " +
                JSON.stringify(n.padding)
            );
          return (
            (r.depthMultiplier =
              null == n.depthMultiplier ? 1 : n.depthMultiplier),
            (r.depthwiseInitializer = li(
              n.depthwiseInitializer || r.DEFAULT_DEPTHWISE_INITIALIZER
            )),
            (r.depthwiseRegularizer = go(n.depthwiseRegularizer)),
            (r.depthwiseConstraint = or(n.depthwiseConstraint)),
            (r.pointwiseInitializer = li(
              n.depthwiseInitializer || r.DEFAULT_POINTWISE_INITIALIZER
            )),
            (r.pointwiseRegularizer = go(n.pointwiseRegularizer)),
            (r.pointwiseConstraint = or(n.pointwiseConstraint)),
            r
          );
        }
        return (
          On(e, t),
          (e.prototype.build = function (t) {
            var e;
            if ((t = yi(t)).length < this.rank + 2)
              throw new Tn(
                "Inputs to SeparableConv" +
                  this.rank +
                  "D should have rank " +
                  (this.rank + 2) +
                  ", but received input shape: " +
                  JSON.stringify(t)
              );
            var n = "channelsFirst" === this.dataFormat ? 1 : t.length - 1;
            if (null == t[n] || t[n] < 0)
              throw new Tn(
                "The channel dimension of the inputs should be defined, but found " +
                  JSON.stringify(t[n])
              );
            for (
              var r = t[n],
                i = this.kernelSize.concat([r, this.depthMultiplier]),
                a = [],
                o = 0;
              o < this.rank;
              ++o
            )
              a.push(1);
            a.push(r * this.depthMultiplier, this.filters),
              (this.depthwiseKernel = this.addWeight(
                "depthwise_kernel",
                i,
                "float32",
                this.depthwiseInitializer,
                this.depthwiseRegularizer,
                !0,
                this.depthwiseConstraint
              )),
              (this.pointwiseKernel = this.addWeight(
                "pointwise_kernel",
                a,
                "float32",
                this.pointwiseInitializer,
                this.pointwiseRegularizer,
                !0,
                this.pointwiseConstraint
              )),
              this.useBias
                ? (this.bias = this.addWeight(
                    "bias",
                    [this.filters],
                    "float32",
                    this.biasInitializer,
                    this.biasRegularizer,
                    !0,
                    this.biasConstraint
                  ))
                : (this.bias = null),
              (this.inputSpec = [
                new Oi({
                  ndim: this.rank + 2,
                  axes: ((e = {}), (e[n] = r), e),
                }),
              ]),
              (this.built = !0);
          }),
          (e.prototype.call = function (t, e) {
            var n = this;
            return Object(a.Zc)(function () {
              var e;
              if (((t = gi(t)), 1 === n.rank))
                throw new Rn(
                  "1D separable convolution is not implemented yet."
                );
              return (
                2 === n.rank &&
                  ("channelsFirst" === n.dataFormat &&
                    (t = Object(a.dd)(t, [0, 2, 3, 1])),
                  (e = Object(a.sc)(
                    t,
                    n.depthwiseKernel.read(),
                    n.pointwiseKernel.read(),
                    n.strides,
                    n.padding,
                    n.dilationRate,
                    "NHWC"
                  ))),
                n.useBias && (e = Br(e, n.bias.read(), n.dataFormat)),
                null != n.activation && (e = n.activation.apply(e)),
                "channelsFirst" === n.dataFormat &&
                  (e = Object(a.dd)(e, [0, 3, 1, 2])),
                e
              );
            });
          }),
          (e.prototype.getConfig = function () {
            var e = t.prototype.getConfig.call(this);
            return (
              delete e.rank,
              delete e.kernelInitializer,
              delete e.kernelRegularizer,
              delete e.kernelConstraint,
              (e.depthwiseInitializer = ci(this.depthwiseInitializer)),
              (e.pointwiseInitializer = ci(this.pointwiseInitializer)),
              (e.depthwiseRegularizer = mo(this.depthwiseRegularizer)),
              (e.pointwiseRegularizer = mo(this.pointwiseRegularizer)),
              (e.depthwiseConstraint = ir(this.depthwiseConstraint)),
              (e.pointwiseConstraint = ir(this.pointwiseConstraint)),
              e
            );
          }),
          (e.className = "SeparableConv"),
          e
        );
      })(To)
    );
    a.tc.registerClass(Mo);
    var jo = (function (t) {
      function e(n) {
        var r = t.call(this, 1, n) || this;
        return e.verifyArgs(n), (r.inputSpec = [{ ndim: 3 }]), r;
      }
      return (
        On(e, t),
        (e.prototype.getConfig = function () {
          var e = t.prototype.getConfig.call(this);
          return delete e.rank, delete e.dataFormat, e;
        }),
        (e.verifyArgs = function (t) {
          if (
            "number" != typeof t.kernelSize &&
            !Zn(t.kernelSize, "number", 1, 1)
          )
            throw new Tn(
              "Conv1D expects config.kernelSize to be number or number[] with length 1, but received " +
                JSON.stringify(t.kernelSize) +
                "."
            );
        }),
        (e.className = "Conv1D"),
        e
      );
    })(To);
    a.tc.registerClass(jo);
    var Po = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return (
          "number" == typeof e.cropping
            ? (n.cropping = [
                [e.cropping, e.cropping],
                [e.cropping, e.cropping],
              ])
            : "number" == typeof e.cropping[0]
            ? (n.cropping = [
                [e.cropping[0], e.cropping[0]],
                [e.cropping[1], e.cropping[1]],
              ])
            : (n.cropping = e.cropping),
          (n.dataFormat =
            void 0 === e.dataFormat ? "channelsLast" : e.dataFormat),
          (n.inputSpec = [{ ndim: 4 }]),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype.computeOutputShape = function (t) {
          return "channelsFirst" === this.dataFormat
            ? [
                t[0],
                t[1],
                t[2] - this.cropping[0][0] - this.cropping[0][1],
                t[3] - this.cropping[1][0] - this.cropping[1][1],
              ]
            : [
                t[0],
                t[1] - this.cropping[0][0] - this.cropping[0][1],
                t[2] - this.cropping[1][0] - this.cropping[1][1],
                t[3],
              ];
        }),
        (e.prototype.call = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            return (
              (t = gi(t)),
              "channelsLast" === n.dataFormat
                ? Tr(
                    Tr(
                      t,
                      n.cropping[0][0],
                      t.shape[1] - n.cropping[0][0] - n.cropping[0][1],
                      2
                    ),
                    n.cropping[1][0],
                    t.shape[2] - n.cropping[1][1] - n.cropping[1][0],
                    3
                  )
                : Tr(
                    Tr(
                      t,
                      n.cropping[0][0],
                      t.shape[2] - n.cropping[0][0] - n.cropping[0][1],
                      3
                    ),
                    n.cropping[1][0],
                    t.shape[3] - n.cropping[1][1] - n.cropping[1][0],
                    4
                  )
            );
          });
        }),
        (e.prototype.getConfig = function () {
          var e = { cropping: this.cropping, dataFormat: this.dataFormat },
            n = t.prototype.getConfig.call(this);
          return Object.assign(e, n), e;
        }),
        (e.className = "Cropping2D"),
        e
      );
    })(ki);
    a.tc.registerClass(Po);
    var zo = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return (
          (n.DEFAULT_SIZE = [2, 2]),
          (n.inputSpec = [{ ndim: 4 }]),
          (n.size = null == e.size ? n.DEFAULT_SIZE : e.size),
          (n.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype.computeOutputShape = function (t) {
          if ("channelsFirst" === this.dataFormat) {
            var e = null == t[2] ? null : this.size[0] * t[2],
              n = null == t[3] ? null : this.size[1] * t[3];
            return [t[0], t[1], e, n];
          }
          return (
            (e = null == t[1] ? null : this.size[0] * t[1]),
            (n = null == t[2] ? null : this.size[1] * t[2]),
            [t[0], e, n, t[3]]
          );
        }),
        (e.prototype.call = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            var e = gi(t),
              r = e.shape;
            if ("channelsFirst" === n.dataFormat) {
              e = Object(a.dd)(e, [0, 2, 3, 1]);
              var i = n.size[0] * r[2],
                o = n.size[1] * r[3],
                s = e.resizeNearestNeighbor([i, o]);
              return Object(a.dd)(s, [0, 3, 1, 2]);
            }
            return (
              (i = n.size[0] * r[1]),
              (o = n.size[1] * r[2]),
              e.resizeNearestNeighbor([i, o])
            );
          });
        }),
        (e.prototype.getConfig = function () {
          var e = { size: this.size, dataFormat: this.dataFormat },
            n = t.prototype.getConfig.call(this);
          return Object.assign(e, n), e;
        }),
        (e.className = "UpSampling2D"),
        e
      );
    })(ki);
    a.tc.registerClass(zo);
    var Lo = (function (t) {
      function e(e) {
        var n = t.call(this, 2, e) || this;
        return (
          (n.depthwiseKernel = null),
          (n.depthMultiplier =
            null == e.depthMultiplier ? 1 : e.depthMultiplier),
          (n.depthwiseInitializer = li(
            e.depthwiseInitializer || n.DEFAULT_KERNEL_INITIALIZER
          )),
          (n.depthwiseConstraint = or(e.depthwiseConstraint)),
          (n.depthwiseRegularizer = go(e.depthwiseRegularizer)),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype.build = function (t) {
          if ((t = yi(t)).length < 4)
            throw new Tn(
              "Inputs to DepthwiseConv2D should have rank 4. Received input shape: " +
                JSON.stringify(t) +
                "."
            );
          var e = "channelsFirst" === this.dataFormat ? 1 : 3;
          if (null == t[e] || t[e] < 0)
            throw new Tn(
              "The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (" +
                t[e] +
                ")."
            );
          var n = t[e],
            r = [
              this.kernelSize[0],
              this.kernelSize[1],
              n,
              this.depthMultiplier,
            ];
          (this.depthwiseKernel = this.addWeight(
            "depthwise_kernel",
            r,
            null,
            this.depthwiseInitializer,
            this.depthwiseRegularizer,
            !0,
            this.depthwiseConstraint
          )),
            this.useBias
              ? (this.bias = this.addWeight(
                  "bias",
                  [n * this.depthMultiplier],
                  null,
                  this.biasInitializer,
                  this.biasRegularizer,
                  !0,
                  this.biasConstraint
                ))
              : (this.bias = null),
            (this.built = !0);
        }),
        (e.prototype.call = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            var e = (function (t, e, n, r, i, o) {
              return (
                void 0 === n && (n = [1, 1]),
                void 0 === r && (r = "valid"),
                Object(a.Zc)(function () {
                  null == i && (i = "channelsLast"), hr(i);
                  var s = Io(t, i);
                  if (4 !== t.rank)
                    throw new Tn(
                      "Input for depthwiseConv2d is required to be 4-D, but is instead " +
                        t.rank +
                        "-D"
                    );
                  if (4 !== e.rank)
                    throw new Tn(
                      "depthwiseKernel is required to be 4-D, but is instead " +
                        e.rank +
                        "-D"
                    );
                  return (
                    (s = Object(a.R)(
                      s,
                      e,
                      n,
                      "same" === r ? "same" : "valid",
                      "NHWC",
                      o
                    )),
                    "channelsFirst" === i &&
                      (s = Object(a.dd)(s, [0, 3, 1, 2])),
                    s
                  );
                })
              );
            })(
              (t = gi(t)),
              n.depthwiseKernel.read(),
              n.strides,
              n.padding,
              n.dataFormat,
              null
            );
            return (
              n.useBias && (e = Br(e, n.bias.read(), n.dataFormat)),
              null != n.activation && (e = n.activation.apply(e)),
              e
            );
          });
        }),
        (e.prototype.computeOutputShape = function (t) {
          t = yi(t);
          var e = "channelsFirst" === this.dataFormat ? t[2] : t[1],
            n = "channelsFirst" === this.dataFormat ? t[3] : t[2],
            r =
              "channelsFirst" === this.dataFormat
                ? t[1] * this.depthMultiplier
                : t[3] * this.depthMultiplier,
            i = So(e, this.kernelSize[0], this.padding, this.strides[0]),
            a = So(n, this.kernelSize[1], this.padding, this.strides[1]);
          return "channelsFirst" === this.dataFormat
            ? [t[0], r, i, a]
            : [t[0], i, a, r];
        }),
        (e.prototype.getConfig = function () {
          var e = t.prototype.getConfig.call(this);
          return (
            (e.depthMultiplier = this.depthMultiplier),
            (e.depthwiseInitializer = ci(this.depthwiseInitializer)),
            (e.depthwiseRegularizer = mo(this.depthwiseRegularizer)),
            (e.depthwiseConstraint = ir(this.depthwiseRegularizer)),
            e
          );
        }),
        (e.className = "DepthwiseConv2D"),
        e
      );
    })(Ao);
    a.tc.registerClass(Lo);
    var Bo = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return (
          (n.rate = Math.max(Math.min(e.rate, 1), 0)),
          (n.noiseShape = e.noiseShape),
          (n.seed = e.seed),
          (n.supportsMasking = !0),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype.getNoiseShape = function (t) {
          if (null == this.noiseShape) return this.noiseShape;
          for (var e = t.shape, n = [], r = 0; r < this.noiseShape.length; ++r)
            n.push(null == this.noiseShape[r] ? e[r] : this.noiseShape[r]);
          return n;
        }),
        (e.prototype.call = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            n.invokeCallHook(t, e);
            var r = gi(t);
            if (0 < n.rate && n.rate < 1) {
              var i = null != e.training && e.training,
                a = n.getNoiseShape(r);
              return Ur(
                function () {
                  return Wr(r, n.rate, a, n.seed);
                },
                function () {
                  return r;
                },
                i
              );
            }
            return t;
          });
        }),
        (e.prototype.getConfig = function () {
          var e = {
              rate: this.rate,
              noiseShape: this.noiseShape,
              seed: this.seed,
            },
            n = t.prototype.getConfig.call(this);
          return Object.assign(e, n), e;
        }),
        (e.prototype.dispose = function () {
          return t.prototype.dispose.call(this);
        }),
        (e.className = "Dropout"),
        e
      );
    })(ki);
    a.tc.registerClass(Bo);
    var Wo = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return (n.inputSpec = [{ ndim: 3 }]), n;
      }
      return (
        On(e, t),
        (e.prototype.getNoiseShape = function (t) {
          var e = t.shape;
          return [e[0], 1, e[2]];
        }),
        (e.className = "SpatialDropout1D"),
        e
      );
    })(Bo);
    a.tc.registerClass(Wo);
    var Uo = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        if (
          ((n.activation = null),
          (n.useBias = !0),
          (n.kernel = null),
          (n.bias = null),
          (n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal"),
          (n.DEFAULT_BIAS_INITIALIZER = "zeros"),
          null == e.batchInputShape &&
            null == e.inputShape &&
            null != e.inputDim)
        ) {
          var r = null;
          null != e.batchSize && (r = e.batchSize),
            (n.batchInputShape = [r, e.inputDim]);
        }
        return (
          (n.units = e.units),
          Xn(n.units, "units"),
          (n.activation = co(e.activation)),
          null != e.useBias && (n.useBias = e.useBias),
          (n.kernelInitializer = li(
            e.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER
          )),
          (n.biasInitializer = li(
            e.biasInitializer || n.DEFAULT_BIAS_INITIALIZER
          )),
          (n.kernelConstraint = or(e.kernelConstraint)),
          (n.biasConstraint = or(e.biasConstraint)),
          (n.kernelRegularizer = go(e.kernelRegularizer)),
          (n.biasRegularizer = go(e.biasRegularizer)),
          (n.activityRegularizer = go(e.activityRegularizer)),
          (n.supportsMasking = !0),
          (n.inputSpec = [{ minNDim: 2 }]),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype.build = function (t) {
          var e,
            n = (t = yi(t))[t.length - 1];
          null == this.kernel &&
            ((this.kernel = this.addWeight(
              "kernel",
              [n, this.units],
              null,
              this.kernelInitializer,
              this.kernelRegularizer,
              !0,
              this.kernelConstraint
            )),
            this.useBias &&
              (this.bias = this.addWeight(
                "bias",
                [this.units],
                null,
                this.biasInitializer,
                this.biasRegularizer,
                !0,
                this.biasConstraint
              ))),
            (this.inputSpec = [
              { minNDim: 2, axes: ((e = {}), (e[-1] = n), e) },
            ]),
            (this.built = !0);
        }),
        (e.prototype.computeOutputShape = function (t) {
          var e = (t = yi(t)).slice();
          return (e[e.length - 1] = this.units), e;
        }),
        (e.prototype.call = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            n.invokeCallHook(t, e);
            var r,
              i = gi(t),
              a = Yn(n.activation.getClassName());
            return (
              null != a
                ? (r = jr(i, n.kernel.read(), a, n.bias ? n.bias.read() : null))
                : ((r = jr(i, n.kernel.read())),
                  null != n.bias && (r = Br(r, n.bias.read())),
                  null != n.activation && (r = n.activation.apply(r))),
              r
            );
          });
        }),
        (e.prototype.getConfig = function () {
          var e = {
              units: this.units,
              activation: so(this.activation),
              useBias: this.useBias,
              kernelInitializer: ci(this.kernelInitializer),
              biasInitializer: ci(this.biasInitializer),
              kernelRegularizer: mo(this.kernelRegularizer),
              biasRegularizer: mo(this.biasRegularizer),
              activityRegularizer: mo(this.activityRegularizer),
              kernelConstraint: ir(this.kernelConstraint),
              biasConstraint: ir(this.biasConstraint),
            },
            n = t.prototype.getConfig.call(this);
          return Object.assign(e, n), e;
        }),
        (e.className = "Dense"),
        e
      );
    })(ki);
    a.tc.registerClass(Uo);
    var Vo = (function (t) {
      function e(e) {
        var n = this;
        return (
          (e = e || {}),
          ((n = t.call(this, e) || this).inputSpec = [{ minNDim: 3 }]),
          (n.dataFormat = e.dataFormat),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype.computeOutputShape = function (t) {
          for (var e = 0, n = (t = yi(t)).slice(1); e < n.length; e++)
            if (null == n[e])
              throw new Tn(
                'The shape of the input to "Flatten" is not fully defined (got ' +
                  t.slice(1) +
                  '). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.'
              );
          return [t[0], Cr(t, 1)];
        }),
        (e.prototype.call = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            n.invokeCallHook(t, e);
            var r = gi(t);
            if ("channelsFirst" === n.dataFormat && r.rank > 1) {
              for (var i = [0], a = 2; a < r.rank; ++a) i.push(a);
              i.push(1), (r = r.transpose(i));
            }
            return (function (t) {
              if (t.rank <= 1)
                throw new Tn(
                  "batchFlatten requires a minimum rank of 2. Got rank: " +
                    t.rank +
                    "."
                );
              var e = [t.shape[0], Cr(t.shape, 1)];
              return t.reshape(e);
            })(r);
          });
        }),
        (e.prototype.getConfig = function () {
          var e = {};
          null != this.dataFormat && (e.dataFormat = this.dataFormat);
          var n = t.prototype.getConfig.call(this);
          return Object.assign(e, n), e;
        }),
        (e.className = "Flatten"),
        e
      );
    })(ki);
    a.tc.registerClass(Vo);
    var Go = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return (n.supportsMasking = !0), (n.activation = co(e.activation)), n;
      }
      return (
        On(e, t),
        (e.prototype.call = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            n.invokeCallHook(t, e);
            var r = gi(t);
            return n.activation.apply(r);
          });
        }),
        (e.prototype.getConfig = function () {
          var e = { activation: so(this.activation) },
            n = t.prototype.getConfig.call(this);
          return Object.assign(e, n), e;
        }),
        (e.className = "Activation"),
        e
      );
    })(ki);
    a.tc.registerClass(Go);
    var Ho = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return (n.n = e.n), (n.inputSpec = [{ ndim: 2 }]), n;
      }
      return (
        On(e, t),
        (e.prototype.computeOutputShape = function (t) {
          return [t[0], this.n, t[1]];
        }),
        (e.prototype.call = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            return (function (t, e) {
              return Object(a.Zc)(function () {
                if (2 !== t.shape.length)
                  throw new Tn(
                    "repeat() expects a rank-2 tensor, but received a rank-" +
                      t.shape.length +
                      " tensor."
                  );
                return Fr(kr(t, 1), [1, e, 1]);
              });
            })((t = gi(t)), n.n);
          });
        }),
        (e.prototype.getConfig = function () {
          var e = { n: this.n },
            n = t.prototype.getConfig.call(this);
          return Object.assign(e, n), e;
        }),
        (e.className = "RepeatVector"),
        e
      );
    })(ki);
    a.tc.registerClass(Ho);
    var qo = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        n.targetShape = e.targetShape;
        for (var r = 0; r < n.targetShape.length; ++r)
          n.isUnknown(n.targetShape[r]) && (n.targetShape[r] = null);
        return n;
      }
      return (
        On(e, t),
        (e.prototype.isUnknown = function (t) {
          return t < 0 || null == t;
        }),
        (e.prototype.fixUnknownDimension = function (t, e) {
          for (
            var n = "Total size of new array must be unchanged.",
              r = e.slice(),
              i = 1,
              a = null,
              o = 0;
            o < r.length;
            ++o
          ) {
            var s = r[o];
            if (this.isUnknown(s)) {
              if (null !== a)
                throw new Tn("Can only specifiy one unknown dimension.");
              a = o;
            } else i *= s;
          }
          var u = Cr(t);
          if (null !== a) {
            if (0 === i || u % i != 0) throw new Tn(n);
            r[a] = u / i;
          } else if (u !== i) throw new Tn(n);
          return r;
        }),
        (e.prototype.computeOutputShape = function (t) {
          for (var e = !1, n = 0; n < t.length; ++n)
            if (this.isUnknown(t[n])) {
              e = !0;
              break;
            }
          return e
            ? t.slice(0, 1).concat(this.targetShape)
            : t
                .slice(0, 1)
                .concat(this.fixUnknownDimension(t.slice(1), this.targetShape));
        }),
        (e.prototype.call = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            n.invokeCallHook(t, e);
            var r = gi(t),
              i = r.shape,
              a = i
                .slice(0, 1)
                .concat(n.fixUnknownDimension(i.slice(1), n.targetShape));
            return r.reshape(a);
          });
        }),
        (e.prototype.getConfig = function () {
          var e = { targetShape: this.targetShape },
            n = t.prototype.getConfig.call(this);
          return Object.assign(e, n), e;
        }),
        (e.className = "Reshape"),
        e
      );
    })(ki);
    a.tc.registerClass(qo);
    var Ko = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        if (null == e.dims)
          throw new Error(
            "Required configuration field `dims` is missing during Permute constructor call."
          );
        if (!Array.isArray(e.dims))
          throw new Error(
            "Permute constructor requires `dims` to be an Array, but received " +
              e.dims +
              " instead."
          );
        var r = Nr(1, e.dims.length + 1);
        if (!a.gd.arraysEqual(e.dims.slice().sort(), r))
          throw new Error(
            "Invalid permutation `dims`: " +
              JSON.stringify(e.dims) +
              " `dims` must contain consecutive integers starting from 1."
          );
        return (
          (n.dims = e.dims),
          (n.dimsIncludingBatch = [0].concat(n.dims)),
          (n.inputSpec = [new Oi({ ndim: n.dims.length + 1 })]),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype.computeOutputShape = function (t) {
          var e = (t = yi(t)).slice();
          return (
            this.dims.forEach(function (n, r) {
              e[r + 1] = t[n];
            }),
            e
          );
        }),
        (e.prototype.call = function (t, e) {
          return Object(a.dd)(gi(t), this.dimsIncludingBatch);
        }),
        (e.prototype.getConfig = function () {
          var e = { dims: this.dims },
            n = t.prototype.getConfig.call(this);
          return Object.assign(e, n), e;
        }),
        (e.className = "Permute"),
        e
      );
    })(ki);
    a.tc.registerClass(Ko);
    var Zo = (function (t) {
      function e(e) {
        var n = t.call(this, null == e ? {} : e) || this;
        return (
          (n.supportsMasking = !0),
          (n.maskValue =
            null != e ? (null == e.maskValue ? 0 : e.maskValue) : 0),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype.computeOutputShape = function (t) {
          return t;
        }),
        (e.prototype.getConfig = function () {
          var e = t.prototype.getConfig.call(this),
            n = { maskValue: this.maskValue };
          return Object.assign(n, e), n;
        }),
        (e.prototype.computeMask = function (t, e) {
          var n = gi(t);
          return Object(a.j)(Object(a.Wb)(n, this.maskValue), -1);
        }),
        (e.prototype.call = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            n.invokeCallHook(t, e);
            var r = gi(t),
              i = Object(a.j)(Object(a.Wb)(r, n.maskValue), -1, !0);
            return r.mul(i.asType(r.dtype));
          });
        }),
        (e.className = "Masking"),
        e
      );
    })(ki);
    a.tc.registerClass(Zo);
    var Xo = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        if (
          ((n.embeddings = null),
          (n.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform"),
          null == e.batchInputShape && null == e.inputShape)
        ) {
          var r = null;
          null != e.batchSize && (r = e.batchSize),
            null == e.inputLength
              ? (n.batchInputShape = [r, null])
              : (n.batchInputShape = [r].concat(zn(e.inputLength)));
        }
        return (
          (n.inputDim = e.inputDim),
          Xn(n.inputDim, "inputDim"),
          (n.outputDim = e.outputDim),
          Xn(n.outputDim, "outputDim"),
          (n.embeddingsInitializer = li(
            e.embeddingsInitializer || n.DEFAULT_EMBEDDINGS_INITIALIZER
          )),
          (n.embeddingsRegularizer = go(e.embeddingsRegularizer)),
          (n.activityRegularizer = go(e.activityRegularizer)),
          (n.embeddingsConstraint = or(e.embeddingsConstraint)),
          (n.maskZero = e.maskZero),
          (n.supportsMasking = e.maskZero),
          (n.inputLength = e.inputLength),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype.build = function (t) {
          (this.embeddings = this.addWeight(
            "embeddings",
            [this.inputDim, this.outputDim],
            this.dtype,
            this.embeddingsInitializer,
            this.embeddingsRegularizer,
            !0,
            this.embeddingsConstraint
          )),
            (this.built = !0);
        }),
        (e.prototype.warnOnIncompatibleInputShape = function (t) {}),
        (e.prototype.computeMask = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            return n.maskZero
              ? ((t = gi(t)), Object(a.Wb)(t, Object(a.md)(t)))
              : null;
          });
        }),
        (e.prototype.computeOutputShape = function (t) {
          if (((t = yi(t)), null == this.inputLength))
            return t.concat([this.outputDim]);
          var e = zn(this.inputLength);
          if (e.length !== t.length - 1)
            throw new Tn(
              '"inputLength" is ' +
                this.inputLength +
                ", but received input shape has shape " +
                t
            );
          for (var n = 0, r = 0; r < e.length; ++r) {
            var i = e[r],
              a = t[r + 1];
            if (null != i && null != a && i !== a)
              throw new Tn(
                '"inputLength" is ' +
                  this.inputLength +
                  ", but received input shape has shape " +
                  t
              );
            null == i && (e[n] = a), n++;
          }
          return [t[0]].concat(e, [this.outputDim]);
        }),
        (e.prototype.call = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            n.invokeCallHook(t, e);
            var r = gi(t);
            return (
              "int32" !== r.dtype && (r = Ir(r, "int32")),
              Pr(n.embeddings.read(), r.as1D()).reshape(
                yi(n.computeOutputShape(r.shape))
              )
            );
          });
        }),
        (e.prototype.getConfig = function () {
          var e = {
              inputDim: this.inputDim,
              outputDim: this.outputDim,
              embeddingsInitializer: ci(this.embeddingsInitializer),
              embeddingsRegularizer: mo(this.embeddingsRegularizer),
              activityRegularizer: mo(this.activityRegularizer),
              embeddingsConstraint: ir(this.embeddingsConstraint),
              maskZero: this.maskZero,
              inputLength: this.inputLength,
            },
            n = t.prototype.getConfig.call(this);
          return Object.assign(e, n), e;
        }),
        (e.className = "Embedding"),
        e
      );
    })(ki);
    a.tc.registerClass(Xo);
    var Yo = (function (t) {
        function e(e) {
          var n = t.call(this, e || {}) || this;
          return (n.supportsMasking = !0), n;
        }
        return (
          On(e, t),
          (e.prototype.mergeFunction = function (t) {
            throw new Rn();
          }),
          (e.prototype.computeElementwiseOpOutputShape = function (t, e) {
            if (null == t || null == e) return null;
            if (t.length < e.length)
              return this.computeElementwiseOpOutputShape(e, t);
            if (0 === e.length) return t;
            for (
              var n = t.slice(0, t.length - e.length), r = 0;
              r < e.length;
              ++r
            ) {
              var i = t[t.length - e.length + r],
                a = e[r];
              if (null == i || null == a || i < 0 || a < 0) n.push(null);
              else if (1 === i) n.push(a);
              else if (1 === a) n.push(i);
              else {
                if (i !== a)
                  throw new Tn(
                    "Operands could not be broadcast together with shapes " +
                      JSON.stringify(t) +
                      " " +
                      JSON.stringify(e)
                  );
                n.push(i);
              }
            }
            return n;
          }),
          (e.prototype.build = function (t) {
            if (
              (Array.isArray(t) && !Array.isArray(t[0]) && (t = [yi(t)]),
              (t = t).length < 2)
            )
              throw new Tn(
                "A merge layer should be called on an Array of at least 2 inputs. Got " +
                  t.length +
                  " input(s)."
              );
            for (var e = [], n = 0, r = t; n < r.length; n++)
              null != (o = r[n]) && null !== o[0] && e.push(o[0]);
            if ((e = Hn(e)).length > 1)
              throw new Tn(
                "Can not merge tensors with different batch sizes. Got tensors with shapes: " +
                  JSON.stringify(t) +
                  "."
              );
            for (
              var i = null == t[0] ? null : t[0].slice(1), a = 1;
              a < t.length;
              ++a
            ) {
              var o = null == t[a] ? null : t[a].slice(1);
              i = this.computeElementwiseOpOutputShape(i, o);
            }
            var s = t.map(function (t) {
              return t.length;
            });
            -1 === t.indexOf(null) && 1 === Hn(s).length
              ? (this.reshapeRequired = !1)
              : (this.reshapeRequired = !0);
          }),
          (e.prototype.call = function (t, e) {
            var n = this;
            return Object(a.Zc)(function () {
              if (((t = t), n.reshapeRequired)) {
                var e = [],
                  r = t.map(function (t) {
                    return t.rank;
                  });
                if (-1 === r.indexOf(null)) {
                  for (var i = Sr(r), o = 0, s = t; o < s.length; o++) {
                    for (var u = (f = s[o]).rank, c = 0; c < i - u; ++c)
                      f = kr(f, 1);
                    e.push(f);
                  }
                  return n.mergeFunction(e);
                }
                for (var l = !1, p = 0, h = t; p < h.length; p++) {
                  var f;
                  if (null == (u = (f = h[p]).rank)) {
                    var d = f.shape,
                      m = d[0],
                      v = d.slice(1).concat([m]),
                      g = f.reshape([m].concat(Cr(d.slice(1))));
                    (g = (g = Object(a.dd)(g, [1, 0])).reshape(v)),
                      e.push(g),
                      (l = !0);
                  } else if (u > 1) {
                    var y = Nr(1, u).concat([0]);
                    e.push(Object(a.dd)(f, y)), (l = !0);
                  } else e.push(f);
                }
                var b = n.mergeFunction(e),
                  w = b.rank;
                if (l)
                  if (null == w) {
                    var x = b.shape;
                    (v = [(m = x[x.length - 1])].concat(
                      x.slice(0, x.length - 1)
                    )),
                      (b = Object(a.dd)(b.reshape([-1, m]), [1, 0]).reshape(v));
                  } else
                    w > 1 &&
                      ((y = [w - 1].concat(Nr(0, w - 1))),
                      (b = Object(a.dd)(b, y)));
                return b;
              }
              return n.mergeFunction(t);
            });
          }),
          (e.prototype.computeOutputShape = function (t) {
            var e;
            e = null == (t = t)[0] ? null : t[0].slice(1);
            for (var n = 1; n < t.length; ++n) {
              var r = null == t[n] ? null : t[n].slice(1);
              e = this.computeElementwiseOpOutputShape(e, r);
            }
            for (var i = [], a = 0, o = t; a < o.length; a++)
              null != (r = o[a]) && null !== r[0] && i.push(r[0]);
            return 1 === (i = Hn(i)).length ? i.concat(e) : [null].concat(e);
          }),
          (e.prototype.computeMask = function (t, e) {
            return Object(a.Zc)(function () {
              if (null == e) return null;
              if (!Array.isArray(e)) throw new Tn("`mask` should be an Array");
              if (!Array.isArray(t))
                throw new Tn("`inputs` should be an Array");
              if (e.length !== t.length)
                throw new Tn(
                  "The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (" +
                    t.length +
                    " vs " +
                    e.length +
                    ")"
                );
              if (
                e.every(function (t) {
                  return null == t;
                })
              )
                return null;
              for (
                var n = (e = e.map(function (t) {
                    return null == t ? t : Object(a.cb)(t, 0);
                  }))[0],
                  r = 1;
                r < e.length - 1;
                ++r
              )
                n = Object(a.Db)(n, e[r]);
              return n;
            });
          }),
          e
        );
      })(ki),
      Jo = (function (t) {
        function e(e) {
          return t.call(this, e) || this;
        }
        return (
          On(e, t),
          (e.prototype.mergeFunction = function (t) {
            return Object(a.Zc)(function () {
              for (var e = t[0].clone(), n = 1; n < t.length; ++n)
                e = Object(a.g)(e, t[n]);
              return e;
            });
          }),
          (e.className = "Add"),
          e
        );
      })(Yo);
    a.tc.registerClass(Jo);
    var $o = (function (t) {
      function e(e) {
        return t.call(this, e) || this;
      }
      return (
        On(e, t),
        (e.prototype.mergeFunction = function (t) {
          return Object(a.Zc)(function () {
            for (var e = t[0].clone(), n = 1; n < t.length; ++n)
              e = Object(a.Rb)(e, t[n]);
            return e;
          });
        }),
        (e.className = "Multiply"),
        e
      );
    })(Yo);
    a.tc.registerClass($o);
    var Qo = (function (t) {
      function e(e) {
        return t.call(this, e) || this;
      }
      return (
        On(e, t),
        (e.prototype.mergeFunction = function (t) {
          return Object(a.Zc)(function () {
            for (var e = t[0].clone(), n = 1; n < t.length; ++n)
              e = Object(a.g)(e, t[n]);
            return Object(a.Rb)(1 / t.length, e);
          });
        }),
        (e.className = "Average"),
        e
      );
    })(Yo);
    a.tc.registerClass(Qo);
    var ts = (function (t) {
      function e(e) {
        return t.call(this, e) || this;
      }
      return (
        On(e, t),
        (e.prototype.mergeFunction = function (t) {
          return Object(a.Zc)(function () {
            for (var e = t[0], n = 1; n < t.length; ++n)
              e = Object(a.Kb)(e, t[n]);
            return e;
          });
        }),
        (e.className = "Maximum"),
        e
      );
    })(Yo);
    a.tc.registerClass(ts);
    var es = (function (t) {
      function e(e) {
        return t.call(this, e) || this;
      }
      return (
        On(e, t),
        (e.prototype.mergeFunction = function (t) {
          return Object(a.Zc)(function () {
            for (var e = t[0], n = 1; n < t.length; ++n)
              e = Object(a.Ob)(e, t[n]);
            return e;
          });
        }),
        (e.className = "Minimum"),
        e
      );
    })(Yo);
    a.tc.registerClass(es);
    var ns = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return (
          (n.DEFAULT_AXIS = -1),
          null == e && (e = {}),
          (n.axis = null == e.axis ? n.DEFAULT_AXIS : e.axis),
          (n.supportsMasking = !0),
          (n.reshapeRequired = !1),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype.build = function (t) {
          if (!Array.isArray(t) || !Array.isArray(t[0]) || 1 === t.length)
            throw new Tn(
              "A `Concatenate` layer should be called on a list of at least 2 inputs"
            );
          for (var e = !0, n = 0, r = (t = t); n < r.length; n++)
            if (null != (p = r[n])) {
              e = !1;
              break;
            }
          if (!e) {
            for (var i = [], o = 0; o < t.length; ++o) {
              var s = t[o].slice();
              s.splice(this.axis, 1);
              for (var u = !1, c = 0, l = i; c < l.length; c++) {
                var p = l[c];
                if (a.gd.arraysEqual(p, s)) {
                  u = !0;
                  break;
                }
              }
              u || i.push(s);
            }
            if (i.length > 1)
              throw new Tn(
                "A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " +
                  JSON.stringify(t)
              );
          }
        }),
        (e.prototype.mergeFunction = function (t) {
          var e = this;
          return Object(a.Zc)(function () {
            return Rr(t, e.axis);
          });
        }),
        (e.prototype.computeOutputShape = function (t) {
          if (!Array.isArray(t) || !Array.isArray(t[0]))
            throw new Tn(
              "A `Concatenate` layer should be called on a list of inputs."
            );
          for (
            var e = t,
              n = e[0].slice(),
              r = this.axis < 0 ? n.length + this.axis : this.axis,
              i = 0,
              a = e.slice(1);
            i < a.length;
            i++
          ) {
            var o = a[i];
            if (null == n[r] || null == o[r]) {
              n[r] = null;
              break;
            }
            n[r] += o[r];
          }
          return n;
        }),
        (e.prototype.computeMask = function (t, e) {
          var n = this;
          if (null == e) return null;
          if (!Array.isArray(e))
            throw new Tn("`mask` should be an array for Concatenate");
          if (!Array.isArray(t))
            throw new Tn("`inputs` should be an array for Concatenate");
          if (e.length !== t.length)
            throw new Tn(
              "Mismatch in the length of mask (" +
                e.length +
                ") and the legnth of inputs (" +
                t.length +
                ")"
            );
          return Object(a.Zc)(function () {
            var r = !0;
            if (
              (e.forEach(function (t) {
                null == t || (r = !1);
              }),
              r)
            )
              return null;
            for (var i = [], o = 0; o < t.length; ++o)
              null == e[o]
                ? i.push(Object(a.Zb)(t[o]).asType("bool"))
                : e[o].rank < t[o].rank
                ? i.push(Object(a.cb)(e[o], -1))
                : i.push(e[o]);
            var s = Object(a.E)(i, n.axis);
            return Object(a.i)(s, -1, !1);
          });
        }),
        (e.prototype.getConfig = function () {
          var e = { axis: this.axis },
            n = t.prototype.getConfig.call(this);
          return Object.assign(e, n), e;
        }),
        (e.className = "Concatenate"),
        e
      );
    })(Yo);
    function rs(t, e) {
      for (; t < 0; ) t += e;
      return t;
    }
    a.tc.registerClass(ns);
    var is = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return (
          (n.axes = e.axes),
          (n.normalize = null != e.normalize && e.normalize),
          (n.supportsMasking = !0),
          (n.reshapeRequired = !1),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype.build = function (t) {
          a.gd.assert(
            Array.isArray(t) &&
              2 === t.length &&
              Array.isArray(t[0]) &&
              Array.isArray(t[1]),
            function () {
              return "A `Dot` layer should be called on a list of exactly 2 inputs.";
            }
          );
          var e = t[0],
            n = t[1];
          if (e.length > 3 || n.length > 3)
            throw new Rn(
              "Dot layer does not support tensors of 4D or higher rank yet."
            );
          var r = this.interpretAxes(e, n);
          if (e[r[0]] !== n[r[1]])
            throw new Tn(
              "Dimension incompatibility: " + e[r[0]] + " !== " + n[r[1]]
            );
        }),
        (e.prototype.mergeFunction = function (t) {
          if (2 !== t.length)
            throw new Tn(
              "A `Dot` layer must be called on exactly 2 inputs, but received " +
                t.length +
                " input(s)."
            );
          var e,
            n = t[0],
            r = t[1];
          return (
            (e = Array.isArray(this.axes)
              ? this.axes.map(function (e, n) {
                  return rs(e, t[n].shape.length);
                })
              : [rs(this.axes, n.shape.length), rs(this.axes, r.shape.length)]),
            this.normalize && ((n = Gi(n, e[0])), (r = Gi(r, e[1]))),
            (function (t, e, n) {
              if (t.shape.length > 3 || e.shape.length > 3)
                throw new Rn(
                  "batchDot is not implemented for tensors of 4D or higher rank yet"
                );
              if (
                (a.gd.assert(t.shape.length >= 2, function () {
                  return (
                    "batchDot requires the rank of x to be >= 2, but got " +
                    t.shape.length
                  );
                }),
                a.gd.assert(t.shape.length >= 2, function () {
                  return (
                    "batchDot requires the rank of y to be >= 2, but got " +
                    e.shape.length
                  );
                }),
                "number" == typeof n && (n = [n, n]),
                "complex64" === t.dtype || "complex64" === e.dtype)
              )
                throw new Rn(
                  "batchDot is not implemented for complex64-type Tensors yet."
                );
              var r = t.shape.length,
                i = e.shape.length;
              null == n && (n = [r - 1, i - 2]);
              var o = n;
              return Object(a.Zc)(function () {
                var n, a;
                if (r > i) {
                  n = r - i;
                  for (var s = [], u = 0; u < n; ++u) s.push(1);
                  e = e.reshape(e.shape.concat(s));
                } else if (i > r) {
                  for (n = i - r, s = [], u = 0; u < n; ++u) s.push(1);
                  t = t.reshape(t.shape.concat(s));
                } else n = 0;
                if (2 === t.shape.length && 2 === e.shape.length)
                  a =
                    o[0] === o[1]
                      ? t.mulStrict(e).sum(o[0])
                      : t.transpose([1, 0]).mulStrict(e).sum(o[1]);
                else {
                  var c = o[0] !== t.shape.length - 1,
                    l = o[1] === e.shape.length - 1;
                  a = t.matMul(e, c, l);
                }
                if (n > 0) {
                  var p,
                    h = [];
                  for (u = p = r > i ? r + i - 3 : r - 1; u < p + n; ++u)
                    h.push(u);
                  a = a.squeeze(h);
                }
                return 1 === a.shape.length && (a = a.expandDims(1)), a;
              });
            })(n, r, e)
          );
        }),
        (e.prototype.interpretAxes = function (t, e) {
          return Array.isArray(this.axes)
            ? this.axes
            : [rs(this.axes, t.length), rs(this.axes, e.length)];
        }),
        (e.prototype.computeOutputShape = function (t) {
          a.gd.assert(
            Array.isArray(t) &&
              2 === t.length &&
              Array.isArray(t[0]) &&
              Array.isArray(t[1]),
            function () {
              return "A `Dot` layer should be called on a list of exactly 2 inputs.";
            }
          );
          var e = t[0].slice(),
            n = t[1].slice();
          if (e.length > 3 || n.length > 3)
            throw new Rn(
              "Dot layer does not support tensors of 4D or higher rank yet."
            );
          var r = this.interpretAxes(e, n);
          e.splice(r[0], 1), n.splice(r[1], 1), n.splice(0, 1);
          var i = e.concat(n);
          return 1 === i.length && i.push(1), i;
        }),
        (e.prototype.computeMask = function (t, e) {
          return null;
        }),
        (e.prototype.getConfig = function () {
          var e = { axes: this.axes, normalize: this.normalize },
            n = t.prototype.getConfig.call(this);
          return Object.assign(e, n), e;
        }),
        (e.className = "Dot"),
        e
      );
    })(Yo);
    a.tc.registerClass(is);
    var as = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return (n.supportsMasking = !0), (n.stddev = e.stddev), n;
      }
      return (
        On(e, t),
        (e.prototype.computeOutputShape = function (t) {
          return t;
        }),
        (e.prototype.getConfig = function () {
          var e = t.prototype.getConfig.call(this),
            n = { stddev: this.stddev };
          return Object.assign(n, e), n;
        }),
        (e.prototype.call = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            n.invokeCallHook(t, e);
            var r = gi(t);
            return Ur(
              function () {
                return Mr(r.shape, 0, n.stddev).add(r);
              },
              function () {
                return r;
              },
              e.training || !1
            );
          });
        }),
        (e.className = "GaussianNoise"),
        e
      );
    })(ki);
    a.tc.registerClass(as);
    var os = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return (n.supportsMasking = !0), (n.rate = e.rate), n;
      }
      return (
        On(e, t),
        (e.prototype.computeOutputShape = function (t) {
          return t;
        }),
        (e.prototype.getConfig = function () {
          var e = t.prototype.getConfig.call(this),
            n = { rate: this.rate };
          return Object.assign(n, e), n;
        }),
        (e.prototype.call = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            n.invokeCallHook(t, e);
            var r = gi(t);
            return n.rate > 0 && n.rate < 1
              ? Ur(
                  function () {
                    var t = Math.sqrt(n.rate / (1 - n.rate));
                    return r.mul(Mr(r.shape, 1, t));
                  },
                  function () {
                    return r;
                  },
                  e.training || !1
                )
              : r;
          });
        }),
        (e.className = "GaussianDropout"),
        e
      );
    })(ki);
    a.tc.registerClass(os);
    var ss = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return (
          (n.supportsMasking = !0),
          (n.rate = e.rate),
          (n.noiseShape = e.noiseShape),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype._getNoiseShape = function (t) {
          return this.noiseShape || gi(t).shape;
        }),
        (e.prototype.computeOutputShape = function (t) {
          return t;
        }),
        (e.prototype.getConfig = function () {
          var e = t.prototype.getConfig.call(this),
            n = { rate: this.rate };
          return Object.assign(n, e), n;
        }),
        (e.prototype.call = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            if (n.rate < 1 && n.rate > 0) {
              var r = n._getNoiseShape(t);
              return Ur(
                function () {
                  var e = gi(t),
                    i = -1.7580993408473766,
                    o = Object(a.nb)(Object(a.fc)(r), n.rate);
                  o = Ir(o, "float32");
                  var s = Math.pow(
                      (1 - n.rate) * (1 + n.rate * Math.pow(i, 2)),
                      -0.5
                    ),
                    u = -s * i * n.rate;
                  return e.mul(o).add(o.add(-1).mul(i)).mul(s).add(u);
                },
                function () {
                  return gi(t);
                },
                e.training || !1
              );
            }
            return t;
          });
        }),
        (e.className = "AlphaDropout"),
        e
      );
    })(ki);
    function us(t, e, n, r, i, o) {
      var s;
      if ((void 0 === o && (o = 0.001), 2 === t.rank))
        s = Object(a.v)(t, e, n, r, i, o);
      else if (3 === t.rank) s = Object(a.w)(t, e, n, r, i, o);
      else {
        if (4 !== t.rank)
          throw new Rn(
            "batchNormalization is not implemented for array of rank " +
              t.rank +
              " yet"
          );
        s = Object(a.x)(t, e, n, r, i, o);
      }
      return s;
    }
    function cs(t, e, n, r, i) {
      return (
        void 0 === i && (i = 0.001),
        a.gd.arraysEqual(r.slice().sort(), Nr(0, t.rank - 1))
          ? (function (t, e, n, r, i) {
              return (
                void 0 === i && (i = 0.001),
                Object(a.Zc)(function () {
                  var o = Object(a.Qb)(t, r),
                    s = o.mean,
                    u = o.variance;
                  return [us(t, s, u, n, e, i), s, u];
                })
              );
            })(t, e, n, r, i)
          : (function (t, e, n, r, i) {
              return (
                void 0 === i && (i = 0.001),
                Object(a.Zc)(function () {
                  for (
                    var o = Object(a.Qb)(t, r),
                      s = o.mean,
                      u = o.variance,
                      c = [],
                      l = 0,
                      p = Nr(0, t.rank);
                    l < p.length;
                    l++
                  ) {
                    var h = p[l];
                    -1 !== r.indexOf(h) ? c.push(1) : c.push(t.shape[h]);
                  }
                  var f = s.reshape(c),
                    d = u.reshape(c),
                    m = null == e ? null : e.reshape(c),
                    v = null == n ? null : n.reshape(c);
                  return [us(t, f, d, v, m, i), s, u];
                })
              );
            })(t, e, n, r, i)
      );
    }
    a.tc.registerClass(ss);
    var ls = (function (t) {
      function e(e) {
        var n = this;
        return (
          null == e && (e = {}),
          ((n = t.call(this, e) || this).supportsMasking = !0),
          (n.axis = null == e.axis ? -1 : e.axis),
          (n.momentum = null == e.momentum ? 0.99 : e.momentum),
          (n.epsilon = null == e.epsilon ? 0.001 : e.epsilon),
          (n.center = null == e.center || e.center),
          (n.scale = null == e.scale || e.scale),
          (n.betaInitializer = li(e.betaInitializer || "zeros")),
          (n.gammaInitializer = li(e.gammaInitializer || "ones")),
          (n.movingMeanInitializer = li(e.movingMeanInitializer || "zeros")),
          (n.movingVarianceInitializer = li(
            e.movingVarianceInitializer || "ones"
          )),
          (n.betaConstraint = or(e.betaConstraint)),
          (n.gammaConstraint = or(e.gammaConstraint)),
          (n.betaRegularizer = go(e.betaRegularizer)),
          (n.gammaRegularizer = go(e.gammaRegularizer)),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype.build = function (t) {
          var e;
          t = yi(t);
          var n = this.axis >= 0 ? this.axis : this.axis + t.length,
            r = t[n];
          if (null == r)
            throw new Tn(
              "Axis " +
                n +
                " of input tensor should have a defined dimension but the layer received an input with shape " +
                JSON.stringify(t) +
                "."
            );
          this.inputSpec = [
            new Oi({ ndim: t.length, axes: ((e = {}), (e[n] = r), e) }),
          ];
          var i = [r];
          this.scale &&
            (this.gamma = this.addWeight(
              "gamma",
              i,
              null,
              this.gammaInitializer,
              this.gammaRegularizer,
              !0,
              this.gammaConstraint
            )),
            this.center &&
              (this.beta = this.addWeight(
                "beta",
                i,
                null,
                this.betaInitializer,
                this.betaRegularizer,
                !0,
                this.betaConstraint
              )),
            (this.movingMean = this.addWeight(
              "moving_mean",
              i,
              null,
              this.movingMeanInitializer,
              null,
              !1
            )),
            (this.movingVariance = this.addWeight(
              "moving_variance",
              i,
              null,
              this.movingVarianceInitializer,
              null,
              !1
            )),
            (this.built = !0);
        }),
        (e.prototype.call = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            var r = null != e.training && e.training,
              i = gi(t),
              o = i.shape,
              s = o.length,
              u = Nr(0, s),
              c = n.axis >= 0 ? n.axis : n.axis + s;
            u.splice(c, 1);
            var l = Fn(1, s);
            l[c] = o[c];
            var p = u.slice();
            p.sort();
            var h = !a.gd.arraysEqual(p, Nr(0, s).slice(0, s - 1));
            if (!r)
              return (function () {
                if (h) {
                  var t = n.movingMean.read().reshape(l),
                    e = n.movingVariance.read().reshape(l),
                    r = n.center ? n.beta.read().reshape(l) : null,
                    a = n.scale ? n.gamma.read().reshape(l) : null;
                  return us(i, t, e, r, a, n.epsilon);
                }
                return us(
                  i,
                  n.movingMean.read(),
                  n.movingVariance.read(),
                  null == n.beta ? null : n.beta.read(),
                  null == n.gamma ? null : n.gamma.read(),
                  n.epsilon
                );
              })();
            var f = cs(i, n.gamma.read(), n.beta.read(), u, n.epsilon),
              d = f[0],
              m = f[1],
              v = f[2],
              g = function (t, e, n) {
                Object(a.Zc)(function () {
                  var r = 1 - n,
                    i = t.read(),
                    a = i.sub(e).mul(r);
                  t.write(i.sub(a));
                });
              };
            return (
              g(n.movingMean, m, n.momentum),
              g(n.movingVariance, v, n.momentum),
              d
            );
          });
        }),
        (e.prototype.getConfig = function () {
          var e = {
              axis: this.axis,
              momentum: this.momentum,
              epsilon: this.epsilon,
              center: this.center,
              scale: this.scale,
              betaInitializer: ci(this.betaInitializer),
              gammaInitializer: ci(this.gammaInitializer),
              movingMeanInitializer: ci(this.movingMeanInitializer),
              movingVarianceInitializer: ci(this.movingVarianceInitializer),
              betaRegularizer: mo(this.betaRegularizer),
              gammaRegularizer: mo(this.gammaRegularizer),
              betaConstraint: ir(this.betaConstraint),
              gammaConstraint: ir(this.gammaConstraint),
            },
            n = t.prototype.getConfig.call(this);
          return Object.assign(e, n), e;
        }),
        (e.className = "BatchNormalization"),
        e
      );
    })(ki);
    a.tc.registerClass(ls);
    var ps = (function (t) {
      function e(e) {
        var n = this;
        if (
          (null == e && (e = {}),
          ((n = t.call(this, e) || this).axis = null == e.axis ? -1 : e.axis),
          "number" == typeof n.axis)
        ) {
          if (!Number.isInteger(n.axis))
            throw new Error(
              "Expected axis to be an integer, but received " + n.axis
            );
        } else {
          if (!Array.isArray(n.axis))
            throw new Error(
              "Expected axis to be an integer or an array of integers, but received " +
                JSON.stringify(n.axis)
            );
          for (var r = 0, i = n.axis; r < i.length; r++) {
            var a = i[r];
            if (!Number.isInteger(a))
              throw new Error(
                "Expected axis to be an array of integers, but received " +
                  JSON.stringify(n.axis)
              );
          }
        }
        return (
          (n.epsilon = null == e.epsilon ? 0.001 : e.epsilon),
          (n.center = null == e.center || e.center),
          (n.scale = null == e.scale || e.scale),
          (n.betaInitializer = li(e.betaInitializer || "zeros")),
          (n.gammaInitializer = li(e.gammaInitializer || "ones")),
          (n.betaRegularizer = go(e.betaRegularizer)),
          (n.gammaRegularizer = go(e.gammaRegularizer)),
          (n.supportsMasking = !0),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype.build = function (t) {
          var e = (t = yi(t)).length;
          "number" == typeof this.axis && (this.axis = [this.axis]);
          for (var n = 0; n < this.axis.length; ++n)
            this.axis[n] < 0 && (this.axis[n] += e);
          for (var r = 0, i = this.axis; r < i.length; r++) {
            var a = i[r];
            if (a < 0 || a >= e) throw new Error("Invalid axis: " + a);
          }
          if (this.axis.length !== Hn(this.axis).length)
            throw new Error("Found duplicate axes in: " + this.axis);
          var o = this.axis.map(function (e) {
            return t[e];
          });
          this.scale
            ? (this.gamma = this.addWeight(
                "gamma",
                o,
                "float32",
                this.gammaInitializer,
                this.gammaRegularizer,
                !0
              ))
            : (this.gamma = null),
            this.center
              ? (this.beta = this.addWeight(
                  "beta",
                  o,
                  "float32",
                  this.betaInitializer,
                  this.betaRegularizer,
                  !0
                ))
              : (this.beta = null),
            (this.built = !0);
        }),
        (e.prototype.call = function (t, e) {
          var n = this,
            r = gi(t),
            i = r.shape,
            o = i.length;
          return Object(a.Zc)(function () {
            for (
              var t = Object(a.Qb)(r, n.axis, !0),
                e = t.mean,
                s = t.variance,
                u = Fn(1, o),
                c = 0,
                l = n.axis;
              c < l.length;
              c++
            ) {
              var p = l[c];
              u[p] = i[p];
            }
            for (
              var h = function (t) {
                  return null != t && t.shape.length !== o && n.axis !== [o - 1]
                    ? t.reshape(u)
                    : t;
                },
                f = h(n.gamma.read()),
                d = h(n.beta.read()),
                m = [],
                v = [],
                g = 0;
              g < o;
              ++g
            )
              -1 !== n.axis.indexOf(g)
                ? (m.push(i[g]), v.push(1))
                : (m.push(1), v.push(i[g]));
            return (
              (e = e.tile(m)),
              (s = s.tile(m)),
              (f = f.tile(v)),
              (d = d.tile(v)),
              us(r, e, s, d, f, n.epsilon)
            );
          });
        }),
        (e.prototype.getConfig = function () {
          var e = {
              axis: this.axis,
              epsilon: this.epsilon,
              center: this.center,
              scale: this.scale,
              betaInitializer: ci(this.betaInitializer),
              gammaInitializer: ci(this.gammaInitializer),
              betaRegularizer: mo(this.betaRegularizer),
              gammaRegularizer: mo(this.gammaRegularizer),
            },
            n = t.prototype.getConfig.call(this);
          return Object.assign(e, n), e;
        }),
        (e.className = "LayerNormalization"),
        e
      );
    })(ki);
    a.tc.registerClass(ps);
    var hs = (function (t) {
      function e(e) {
        var n = this;
        if (
          (null == e && (e = {}),
          ((n = t.call(this, e) || this).dataFormat =
            null == e.dataFormat ? "channelsLast" : e.dataFormat),
          null == e.padding)
        )
          n.padding = [
            [1, 1],
            [1, 1],
          ];
        else if ("number" == typeof e.padding)
          n.padding = [
            [e.padding, e.padding],
            [e.padding, e.padding],
          ];
        else {
          if (((e.padding = e.padding), 2 !== e.padding.length))
            throw new Tn(
              "ZeroPadding2D expects padding to be a length-2 array, but received a length-" +
                e.padding.length +
                " array."
            );
          var r = void 0,
            i = void 0;
          if ("number" == typeof e.padding[0])
            (r = [e.padding[0], e.padding[0]]),
              (i = [e.padding[1], e.padding[1]]);
          else {
            if (((e.padding = e.padding), 2 !== e.padding[0].length))
              throw new Tn(
                "ZeroPadding2D expects height padding to be a length-2 array, but received a length-" +
                  e.padding[0].length +
                  " array."
              );
            if (((r = e.padding[0]), 2 !== e.padding[1].length))
              throw new Tn(
                "ZeroPadding2D expects width padding to be a length-2 array, but received a length-" +
                  e.padding[1].length +
                  " array."
              );
            i = e.padding[1];
          }
          n.padding = [r, i];
        }
        return (n.inputSpec = [new Oi({ ndim: 4 })]), n;
      }
      return (
        On(e, t),
        (e.prototype.computeOutputShape = function (t) {
          var e, n;
          return (
            (t = yi(t)),
            "channelsFirst" === this.dataFormat
              ? ((e =
                  null != t[2] && t[2] >= 0
                    ? t[2] + this.padding[0][0] + this.padding[0][1]
                    : null),
                (n =
                  null != t[3] && t[3] >= 0
                    ? t[3] + this.padding[1][0] + this.padding[1][1]
                    : null),
                [t[0], t[1], e, n])
              : ((e =
                  null != t[1] && t[1] >= 0
                    ? t[1] + this.padding[0][0] + this.padding[0][1]
                    : null),
                (n =
                  null != t[2] && t[2] >= 0
                    ? t[2] + this.padding[1][0] + this.padding[1][1]
                    : null),
                [t[0], e, n, t[3]])
          );
        }),
        (e.prototype.call = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            return (function (t, e, n) {
              return Object(a.Zc)(function () {
                if (4 !== t.rank)
                  throw new Tn(
                    "temporalPadding expects input tensor to be 4-D, but received a " +
                      t.rank +
                      "-D tensor."
                  );
                if (
                  (null == e &&
                    (e = [
                      [1, 1],
                      [1, 1],
                    ]),
                  2 !== e.length || 2 !== e[0].length || 2 !== e[1].length)
                )
                  throw new Tn(
                    "spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers."
                  );
                if (
                  (null == n && (n = "channelsLast"),
                  "channelsLast" !== n && "channelsFirst" !== n)
                )
                  throw new Tn(
                    "Unknown data format: " +
                      n +
                      ". Supported data formats are 'channelsLast' and 'channelsFirst."
                  );
                var r;
                return (
                  (r =
                    "channelsFirst" === n
                      ? [[0, 0], [0, 0], e[0], e[1]]
                      : [[0, 0], e[0], e[1], [0, 0]]),
                  Object(a.ac)(t, r)
                );
              });
            })(gi(t), n.padding, n.dataFormat);
          });
        }),
        (e.prototype.getConfig = function () {
          var e = { padding: this.padding, dataFormat: this.dataFormat },
            n = t.prototype.getConfig.call(this);
          return Object.assign(e, n), e;
        }),
        (e.className = "ZeroPadding2D"),
        e
      );
    })(ki);
    function fs(t, e, n, r, i, o) {
      return Object(a.Zc)(function () {
        var s;
        hr(i),
          dr(o),
          fr(r),
          null == n && (n = [1, 1]),
          null == r && (r = "valid"),
          null == i && (i = "channelsLast"),
          null == o && (o = "max"),
          (t = Io(t, i));
        var u = "same" === r ? "same" : "valid";
        return (
          (s =
            "max" === o ? Object(a.Ib)(t, e, n, u) : Object(a.r)(t, e, n, u)),
          "channelsFirst" === i && (s = Object(a.dd)(s, [0, 3, 1, 2])),
          s
        );
      });
    }
    function ds(t, e, n, r, i, o) {
      return Object(a.Zc)(function () {
        var s;
        hr(i),
          dr(o),
          fr(r),
          null == n && (n = [1, 1, 1]),
          null == r && (r = "valid"),
          null == i && (i = "channelsLast"),
          null == o && (o = "max"),
          (t = ko(t, i));
        var u = "same" === r ? "same" : "valid";
        return (
          (s =
            "max" === o ? Object(a.Jb)(t, e, n, u) : Object(a.s)(t, e, n, u)),
          "channelsFirst" === i && (s = Object(a.dd)(s, [0, 4, 1, 2, 3])),
          s
        );
      });
    }
    a.tc.registerClass(hs);
    var ms = (function (t) {
        function e(e) {
          var n = this;
          if (
            (null == e.poolSize && (e.poolSize = 2),
            (n = t.call(this, e) || this),
            "number" == typeof e.poolSize)
          )
            n.poolSize = [e.poolSize];
          else {
            if (
              !Array.isArray(e.poolSize) ||
              1 !== e.poolSize.length ||
              "number" != typeof e.poolSize[0]
            )
              throw new Tn(
                "poolSize for 1D convolutional layer must be a number or an Array of a single number, but received " +
                  JSON.stringify(e.poolSize)
              );
            n.poolSize = e.poolSize;
          }
          if ((Xn(n.poolSize, "poolSize"), null == e.strides))
            n.strides = n.poolSize;
          else if ("number" == typeof e.strides) n.strides = [e.strides];
          else {
            if (
              !Array.isArray(e.strides) ||
              1 !== e.strides.length ||
              "number" != typeof e.strides[0]
            )
              throw new Tn(
                "strides for 1D convolutional layer must be a number or an Array of a single number, but received " +
                  JSON.stringify(e.strides)
              );
            n.strides = e.strides;
          }
          return (
            Xn(n.strides, "strides"),
            (n.padding = null == e.padding ? "valid" : e.padding),
            fr(n.padding),
            (n.inputSpec = [new Oi({ ndim: 3 })]),
            n
          );
        }
        return (
          On(e, t),
          (e.prototype.computeOutputShape = function (t) {
            var e = So(
              (t = yi(t))[1],
              this.poolSize[0],
              this.padding,
              this.strides[0]
            );
            return [t[0], e, t[2]];
          }),
          (e.prototype.call = function (t, e) {
            var n = this;
            return Object(a.Zc)(function () {
              n.invokeCallHook(t, e), (t = kr(gi(t), 2));
              var r = n.poolingFunction(
                gi(t),
                [n.poolSize[0], 1],
                [n.strides[0], 1],
                n.padding,
                "channelsLast"
              );
              return Object(a.Mc)(r, [2]);
            });
          }),
          (e.prototype.getConfig = function () {
            var e = {
                poolSize: this.poolSize,
                padding: this.padding,
                strides: this.strides,
              },
              n = t.prototype.getConfig.call(this);
            return Object.assign(e, n), e;
          }),
          e
        );
      })(ki),
      vs = (function (t) {
        function e(e) {
          return t.call(this, e) || this;
        }
        return (
          On(e, t),
          (e.prototype.poolingFunction = function (t, e, n, r, i) {
            return hr(i), fr(r), fs(t, e, n, r, i, "max");
          }),
          (e.className = "MaxPooling1D"),
          e
        );
      })(ms);
    a.tc.registerClass(vs);
    var gs = (function (t) {
      function e(e) {
        return t.call(this, e) || this;
      }
      return (
        On(e, t),
        (e.prototype.poolingFunction = function (t, e, n, r, i) {
          return hr(i), fr(r), fs(t, e, n, r, i, "avg");
        }),
        (e.className = "AveragePooling1D"),
        e
      );
    })(ms);
    a.tc.registerClass(gs);
    var ys = (function (t) {
        function e(e) {
          var n = this;
          if (
            (null == e.poolSize && (e.poolSize = [2, 2]),
            ((n = t.call(this, e) || this).poolSize = Array.isArray(e.poolSize)
              ? e.poolSize
              : [e.poolSize, e.poolSize]),
            null == e.strides)
          )
            n.strides = n.poolSize;
          else if (Array.isArray(e.strides)) {
            if (2 !== e.strides.length)
              throw new Tn(
                "If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length " +
                  e.strides.length +
                  "."
              );
            n.strides = e.strides;
          } else n.strides = [e.strides, e.strides];
          return (
            Xn(n.poolSize, "poolSize"),
            Xn(n.strides, "strides"),
            (n.padding = null == e.padding ? "valid" : e.padding),
            (n.dataFormat =
              null == e.dataFormat ? "channelsLast" : e.dataFormat),
            hr(n.dataFormat),
            fr(n.padding),
            (n.inputSpec = [new Oi({ ndim: 4 })]),
            n
          );
        }
        return (
          On(e, t),
          (e.prototype.computeOutputShape = function (t) {
            t = yi(t);
            var e = "channelsFirst" === this.dataFormat ? t[2] : t[1],
              n = "channelsFirst" === this.dataFormat ? t[3] : t[2];
            return (
              (e = So(e, this.poolSize[0], this.padding, this.strides[0])),
              (n = So(n, this.poolSize[1], this.padding, this.strides[1])),
              "channelsFirst" === this.dataFormat
                ? [t[0], t[1], e, n]
                : [t[0], e, n, t[3]]
            );
          }),
          (e.prototype.call = function (t, e) {
            var n = this;
            return Object(a.Zc)(function () {
              return (
                n.invokeCallHook(t, e),
                n.poolingFunction(
                  gi(t),
                  n.poolSize,
                  n.strides,
                  n.padding,
                  n.dataFormat
                )
              );
            });
          }),
          (e.prototype.getConfig = function () {
            var e = {
                poolSize: this.poolSize,
                padding: this.padding,
                strides: this.strides,
                dataFormat: this.dataFormat,
              },
              n = t.prototype.getConfig.call(this);
            return Object.assign(e, n), e;
          }),
          e
        );
      })(ki),
      bs = (function (t) {
        function e(e) {
          return t.call(this, e) || this;
        }
        return (
          On(e, t),
          (e.prototype.poolingFunction = function (t, e, n, r, i) {
            return hr(i), fr(r), fs(t, e, n, r, i, "max");
          }),
          (e.className = "MaxPooling2D"),
          e
        );
      })(ys);
    a.tc.registerClass(bs);
    var ws = (function (t) {
      function e(e) {
        return t.call(this, e) || this;
      }
      return (
        On(e, t),
        (e.prototype.poolingFunction = function (t, e, n, r, i) {
          return hr(i), fr(r), fs(t, e, n, r, i, "avg");
        }),
        (e.className = "AveragePooling2D"),
        e
      );
    })(ys);
    a.tc.registerClass(ws);
    var xs = (function (t) {
        function e(e) {
          var n = this;
          if (
            (null == e.poolSize && (e.poolSize = [2, 2, 2]),
            ((n = t.call(this, e) || this).poolSize = Array.isArray(e.poolSize)
              ? e.poolSize
              : [e.poolSize, e.poolSize, e.poolSize]),
            null == e.strides)
          )
            n.strides = n.poolSize;
          else if (Array.isArray(e.strides)) {
            if (3 !== e.strides.length)
              throw new Tn(
                "If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length " +
                  e.strides.length +
                  "."
              );
            n.strides = e.strides;
          } else n.strides = [e.strides, e.strides, e.strides];
          return (
            Xn(n.poolSize, "poolSize"),
            Xn(n.strides, "strides"),
            (n.padding = null == e.padding ? "valid" : e.padding),
            (n.dataFormat =
              null == e.dataFormat ? "channelsLast" : e.dataFormat),
            hr(n.dataFormat),
            fr(n.padding),
            (n.inputSpec = [new Oi({ ndim: 5 })]),
            n
          );
        }
        return (
          On(e, t),
          (e.prototype.computeOutputShape = function (t) {
            t = yi(t);
            var e = "channelsFirst" === this.dataFormat ? t[2] : t[1],
              n = "channelsFirst" === this.dataFormat ? t[3] : t[2],
              r = "channelsFirst" === this.dataFormat ? t[4] : t[3];
            return (
              (e = So(e, this.poolSize[0], this.padding, this.strides[0])),
              (n = So(n, this.poolSize[1], this.padding, this.strides[1])),
              (r = So(r, this.poolSize[2], this.padding, this.strides[2])),
              "channelsFirst" === this.dataFormat
                ? [t[0], t[1], e, n, r]
                : [t[0], e, n, r, t[4]]
            );
          }),
          (e.prototype.call = function (t, e) {
            var n = this;
            return Object(a.Zc)(function () {
              return (
                n.invokeCallHook(t, e),
                n.poolingFunction(
                  gi(t),
                  n.poolSize,
                  n.strides,
                  n.padding,
                  n.dataFormat
                )
              );
            });
          }),
          (e.prototype.getConfig = function () {
            var e = {
                poolSize: this.poolSize,
                padding: this.padding,
                strides: this.strides,
                dataFormat: this.dataFormat,
              },
              n = t.prototype.getConfig.call(this);
            return Object.assign(e, n), e;
          }),
          e
        );
      })(ki),
      Cs = (function (t) {
        function e(e) {
          return t.call(this, e) || this;
        }
        return (
          On(e, t),
          (e.prototype.poolingFunction = function (t, e, n, r, i) {
            return hr(i), fr(r), ds(t, e, n, r, i, "max");
          }),
          (e.className = "MaxPooling3D"),
          e
        );
      })(xs);
    a.tc.registerClass(Cs);
    var Os = (function (t) {
      function e(e) {
        return t.call(this, e) || this;
      }
      return (
        On(e, t),
        (e.prototype.poolingFunction = function (t, e, n, r, i) {
          return hr(i), fr(r), ds(t, e, n, r, i, "avg");
        }),
        (e.className = "AveragePooling3D"),
        e
      );
    })(xs);
    a.tc.registerClass(Os);
    var Es = (function (t) {
        function e(e) {
          var n = t.call(this, e) || this;
          return (n.inputSpec = [new Oi({ ndim: 3 })]), n;
        }
        return (
          On(e, t),
          (e.prototype.computeOutputShape = function (t) {
            return [t[0], t[2]];
          }),
          (e.prototype.call = function (t, e) {
            throw new Rn();
          }),
          e
        );
      })(ki),
      Ss = (function (t) {
        function e(e) {
          return t.call(this, e || {}) || this;
        }
        return (
          On(e, t),
          (e.prototype.call = function (t, e) {
            return Object(a.Zc)(function () {
              var e = gi(t);
              return Object(a.Lb)(e, 1);
            });
          }),
          (e.className = "GlobalAveragePooling1D"),
          e
        );
      })(Es);
    a.tc.registerClass(Ss);
    var Ns = (function (t) {
      function e(e) {
        return t.call(this, e || {}) || this;
      }
      return (
        On(e, t),
        (e.prototype.call = function (t, e) {
          return Object(a.Zc)(function () {
            var e = gi(t);
            return Object(a.Hb)(e, 1);
          });
        }),
        (e.className = "GlobalMaxPooling1D"),
        e
      );
    })(Es);
    a.tc.registerClass(Ns);
    var Is = (function (t) {
        function e(e) {
          var n = t.call(this, e) || this;
          return (
            (n.dataFormat =
              null == e.dataFormat ? "channelsLast" : e.dataFormat),
            hr(n.dataFormat),
            (n.inputSpec = [new Oi({ ndim: 4 })]),
            n
          );
        }
        return (
          On(e, t),
          (e.prototype.computeOutputShape = function (t) {
            return (
              (t = t),
              "channelsLast" === this.dataFormat ? [t[0], t[3]] : [t[0], t[1]]
            );
          }),
          (e.prototype.call = function (t, e) {
            throw new Rn();
          }),
          (e.prototype.getConfig = function () {
            var e = { dataFormat: this.dataFormat },
              n = t.prototype.getConfig.call(this);
            return Object.assign(e, n), e;
          }),
          e
        );
      })(ki),
      ks = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          On(e, t),
          (e.prototype.call = function (t, e) {
            var n = this;
            return Object(a.Zc)(function () {
              var e = gi(t);
              return "channelsLast" === n.dataFormat
                ? Object(a.Lb)(e, [1, 2])
                : Object(a.Lb)(e, [2, 3]);
            });
          }),
          (e.className = "GlobalAveragePooling2D"),
          e
        );
      })(Is);
    a.tc.registerClass(ks);
    var _s = (function (t) {
      function e() {
        return (null !== t && t.apply(this, arguments)) || this;
      }
      return (
        On(e, t),
        (e.prototype.call = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            var e = gi(t);
            return "channelsLast" === n.dataFormat
              ? Object(a.Hb)(e, [1, 2])
              : Object(a.Hb)(e, [2, 3]);
          });
        }),
        (e.className = "GlobalMaxPooling2D"),
        e
      );
    })(Is);
    function As(t, e, n, r) {
      if (Array.isArray(t)) {
        if (null != e || null != n)
          throw new Tn(
            "When inputs is an array, neither initialState or constants should be provided"
          );
        null != r &&
          ((n = t.slice(t.length - r, t.length)),
          (t = t.slice(0, t.length - r))),
          t.length > 1 && (e = t.slice(1, t.length)),
          (t = t[0]);
      }
      function i(t) {
        return null == t || Array.isArray(t) ? t : [t];
      }
      return { inputs: t, initialState: (e = i(e)), constants: (n = i(n)) };
    }
    function Ts(t, e, n, r, i, o, s, u) {
      return (
        void 0 === r && (r = !1),
        void 0 === s && (s = !1),
        void 0 === u && (u = !1),
        Object(a.Zc)(function () {
          var c = e.shape.length;
          if (c < 3)
            throw new Tn("Input should be at least 3D, but is " + c + "D.");
          var l = [1, 0].concat(Nr(2, c));
          if (((e = Object(a.dd)(e, l)), null != o))
            throw new Rn(
              "The rnn() functoin of the deeplearn.js backend does not support constants yet."
            );
          s &&
            console.warn(
              "Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."
            ),
            null != i &&
              ((i = i.asType("bool").asType("float32")).rank === c - 1 &&
                (i = Object(a.cb)(i, -1)),
              (i = Object(a.dd)(i, l))),
            r &&
              ((e = Object(a.lc)(e, 0)), null != i && (i = Object(a.lc)(i, 0)));
          var p,
            h,
            f = [],
            d = n,
            m = e.shape[0],
            v = Object(a.fd)(e);
          null != i && (h = Object(a.fd)(i));
          for (
            var g,
              y = function (e) {
                var n = v[e],
                  r = Object(a.Zc)(function () {
                    return t(n, d);
                  });
                if (null == i) (p = r[0]), (d = r[1]);
                else {
                  var o = Object(a.Zc)(function () {
                    var t = h[e],
                      n = Object(a.Zb)(t).sub(t);
                    return {
                      output: r[0].mul(t).addStrict(d[0].mul(n)),
                      newStates: d.map(function (e, i) {
                        return r[1][i].mul(t).addStrict(e.mul(n));
                      }),
                    };
                  });
                  (p = o.output), (d = o.newStates);
                }
                u && f.push(p);
              },
              b = 0;
            b < m;
            ++b
          )
            y(b);
          return u && (g = Object(a.Nc)(f, 1)), [p, g, d];
        })
      );
    }
    a.tc.registerClass(_s);
    var Rs = (function (t) {
      function e(e) {
        var n,
          r = t.call(this, e) || this;
        if (null == e.cell)
          throw new Tn("cell property is missing for the constructor of RNN.");
        if (
          null ==
          (n = Array.isArray(e.cell) ? new Bs({ cells: e.cell }) : e.cell)
            .stateSize
        )
          throw new Tn(
            "The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state)."
          );
        return (
          (r.cell = n),
          (r.returnSequences = null != e.returnSequences && e.returnSequences),
          (r.returnState = null != e.returnState && e.returnState),
          (r.goBackwards = null != e.goBackwards && e.goBackwards),
          (r._stateful = null != e.stateful && e.stateful),
          (r.unroll = null != e.unroll && e.unroll),
          (r.supportsMasking = !0),
          (r.inputSpec = [new Oi({ ndim: 3 })]),
          (r.stateSpec = null),
          (r.states_ = null),
          (r.numConstants = null),
          (r.keptStates = []),
          r
        );
      }
      return (
        On(e, t),
        (e.prototype.getStates = function () {
          return null == this.states_
            ? Nr(
                0,
                Array.isArray(this.cell.stateSize)
                  ? this.cell.stateSize.length
                  : 1
              ).map(function (t) {
                return null;
              })
            : this.states_;
        }),
        (e.prototype.setStates = function (t) {
          this.states_ = t;
        }),
        (e.prototype.computeOutputShape = function (t) {
          mi(t) && (t = t[0]), (t = t);
          var e = this.cell.stateSize;
          Array.isArray(e) || (e = [e]);
          var n,
            r = e[0];
          if (
            ((n = this.returnSequences ? [t[0], t[1], r] : [t[0], r]),
            this.returnState)
          ) {
            for (var i = [], a = 0, o = e; a < o.length; a++) {
              var s = o[a];
              i.push([t[0], s]);
            }
            return [n].concat(i);
          }
          return n;
        }),
        (e.prototype.computeMask = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            Array.isArray(e) && (e = e[0]);
            var t = n.returnSequences ? e : null;
            if (n.returnState) {
              var r = n.states.map(function (t) {
                return null;
              });
              return [t].concat(r);
            }
            return t;
          });
        }),
        Object.defineProperty(e.prototype, "states", {
          get: function () {
            if (null == this.states_) {
              for (
                var t = Array.isArray(this.cell.stateSize)
                    ? this.cell.stateSize.length
                    : 1,
                  e = [],
                  n = 0;
                n < t;
                ++n
              )
                e.push(null);
              return e;
            }
            return this.states_;
          },
          set: function (t) {
            this.states_ = t;
          },
          enumerable: !0,
          configurable: !0,
        }),
        (e.prototype.build = function (t) {
          if (null != this.numConstants)
            throw new Rn("Constants support is not implemented in RNN yet.");
          mi(t) && (t = t[0]), (t = t);
          var e = this.stateful ? t[0] : null,
            n = t[t.length - 1];
          this.inputSpec[0] = new Oi({ shape: [e, null, n] });
          var r,
            i = [t[0]].concat(t.slice(2));
          if (
            (this.cell.build(i),
            (r = Array.isArray(this.cell.stateSize)
              ? this.cell.stateSize
              : [this.cell.stateSize]),
            null != this.stateSpec)
          ) {
            if (
              !a.gd.arraysEqual(
                this.stateSpec.map(function (t) {
                  return t.shape[t.shape.length - 1];
                }),
                r
              )
            )
              throw new Tn(
                "An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=" +
                  this.stateSpec +
                  "; However cell.stateSize is " +
                  this.cell.stateSize
              );
          } else
            this.stateSpec = r.map(function (t) {
              return new Oi({ shape: [null, t] });
            });
          this.stateful && this.resetStates();
        }),
        (e.prototype.resetStates = function (t, e) {
          var n = this;
          void 0 === e && (e = !1),
            Object(a.Zc)(function () {
              if (!n.stateful)
                throw new _n(
                  "Cannot call resetStates() on an RNN Layer that is not stateful."
                );
              var r = n.inputSpec[0].shape[0];
              if (null == r)
                throw new Tn(
                  "If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer."
                );
              if (null == n.states_)
                Array.isArray(n.cell.stateSize)
                  ? (n.states_ = n.cell.stateSize.map(function (t) {
                      return Object(a.ld)([r, t]);
                    }))
                  : (n.states_ = [Object(a.ld)([r, n.cell.stateSize])]);
              else if (null == t)
                Object(a.S)(n.states_),
                  null != n.keptStates &&
                    (Object(a.S)(n.keptStates), (n.keptStates = [])),
                  Array.isArray(n.cell.stateSize)
                    ? (n.states_ = n.cell.stateSize.map(function (t) {
                        return Object(a.ld)([r, t]);
                      }))
                    : (n.states_[0] = Object(a.ld)([r, n.cell.stateSize]));
              else {
                if (
                  (Array.isArray(t) || (t = [t]), t.length !== n.states_.length)
                )
                  throw new Tn(
                    "Layer " +
                      n.name +
                      " expects " +
                      n.states_.length +
                      " state(s), but it received " +
                      t.length +
                      " state value(s). Input received: " +
                      t
                  );
                !0 === e
                  ? n.keptStates.push(n.states_.slice())
                  : Object(a.S)(n.states_);
                for (var i = 0; i < n.states_.length; ++i) {
                  var o = t[i],
                    s = Array.isArray(n.cell.stateSize)
                      ? n.cell.stateSize[i]
                      : n.cell.stateSize,
                    u = [r, s];
                  if (!a.gd.arraysEqual(o.shape, u))
                    throw new Tn(
                      "State " +
                        i +
                        " is incompatible with layer " +
                        n.name +
                        ": expected shape=" +
                        u +
                        ", received shape=" +
                        o.shape
                    );
                  n.states_[i] = o;
                }
              }
              n.states_ = n.states_.map(function (t) {
                return Object(a.tb)(t.clone());
              });
            });
        }),
        (e.prototype.apply = function (e, n) {
          var r = null == n ? null : n.initialState,
            i = null == n ? null : n.constants;
          null == n && (n = {});
          var a = As(e, r, i, this.numConstants);
          (e = a.inputs), (r = a.initialState), (i = a.constants);
          var o = [],
            s = [];
          if (null != r) {
            (n.initialState = r), (o = o.concat(r)), (this.stateSpec = []);
            for (var u = 0, c = r; u < c.length; u++) {
              var l = c[u];
              this.stateSpec.push(new Oi({ shape: l.shape }));
            }
            s = s.concat(this.stateSpec);
          }
          if (
            (null != i &&
              ((n.constants = i),
              (o = o.concat(i)),
              (this.numConstants = i.length)),
            o[0] instanceof Ei)
          ) {
            var p = [e].concat(o),
              h = this.inputSpec.concat(s),
              f = this.inputSpec;
            this.inputSpec = h;
            var d = t.prototype.apply.call(this, p, n);
            return (this.inputSpec = f), d;
          }
          return t.prototype.apply.call(this, e, n);
        }),
        (e.prototype.call = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            var r = null == e ? null : e.mask,
              i = null == e ? null : e.training,
              a = null == e ? null : e.initialState;
            (t = gi(t)),
              null == a && (a = n.stateful ? n.states_ : n.getInitialState(t));
            var o = Array.isArray(n.cell.stateSize)
              ? n.cell.stateSize.length
              : 1;
            if (a.length !== o)
              throw new Tn(
                "RNN Layer has " +
                  o +
                  " state(s) but was passed " +
                  a.length +
                  " initial state(s)."
              );
            n.unroll &&
              console.warn(
                "Ignoring unroll = true for RNN layer, due to imperative backend."
              );
            var s = { training: i },
              u = Ts(
                function (t, e) {
                  var r = n.cell.call([t].concat(e), s);
                  return [r[0], r.slice(1)];
                },
                t,
                a,
                n.goBackwards,
                r,
                null,
                n.unroll,
                n.returnSequences
              ),
              c = u[0],
              l = u[1],
              p = u[2];
            n.stateful && n.resetStates(p, i);
            var h = n.returnSequences ? l : c;
            return n.returnState ? [h].concat(p) : h;
          });
        }),
        (e.prototype.getInitialState = function (t) {
          var e = this;
          return Object(a.Zc)(function () {
            var n = Object(a.ld)(t.shape);
            return (
              (n = kr((n = Object(a.Qc)(n, [1, 2])))),
              Array.isArray(e.cell.stateSize)
                ? e.cell.stateSize.map(function (t) {
                    return t > 1 ? Fr(n, [1, t]) : n;
                  })
                : e.cell.stateSize > 1
                ? [Fr(n, [1, e.cell.stateSize])]
                : [n]
            );
          });
        }),
        Object.defineProperty(e.prototype, "trainableWeights", {
          get: function () {
            return this.trainable ? this.cell.trainableWeights : [];
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "nonTrainableWeights", {
          get: function () {
            return this.trainable
              ? this.cell.nonTrainableWeights
              : this.cell.weights;
          },
          enumerable: !0,
          configurable: !0,
        }),
        (e.prototype.setFastWeightInitDuringBuild = function (e) {
          t.prototype.setFastWeightInitDuringBuild.call(this, e),
            null != this.cell && this.cell.setFastWeightInitDuringBuild(e);
        }),
        (e.prototype.getConfig = function () {
          var e = {
            returnSequences: this.returnSequences,
            returnState: this.returnState,
            goBackwards: this.goBackwards,
            stateful: this.stateful,
            unroll: this.unroll,
          };
          null != this.numConstants && (e.numConstants = this.numConstants);
          var n = this.cell.getConfig();
          e.cell = { className: this.cell.getClassName(), config: n };
          var r = t.prototype.getConfig.call(this);
          return Object.assign(e, r), e;
        }),
        (e.fromConfig = function (t, e, n) {
          void 0 === n && (n = {});
          var r = Vi(e.cell, n);
          return new t(Object.assign(e, { cell: r }));
        }),
        (e.className = "RNN"),
        e
      );
    })(ki);
    a.tc.registerClass(Rs);
    var Ds = (function (t) {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return On(e, t), e;
      })(ki),
      Fs = (function (t) {
        function e(e) {
          var n = t.call(this, e) || this;
          return (
            (n.DEFAULT_ACTIVATION = "tanh"),
            (n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal"),
            (n.DEFAULT_RECURRENT_INITIALIZER = "orthogonal"),
            (n.DEFAULT_BIAS_INITIALIZER = "zeros"),
            (n.units = e.units),
            Xn(n.units, "units"),
            (n.activation = co(
              null == e.activation ? n.DEFAULT_ACTIVATION : e.activation
            )),
            (n.useBias = null == e.useBias || e.useBias),
            (n.kernelInitializer = li(
              e.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER
            )),
            (n.recurrentInitializer = li(
              e.recurrentInitializer || n.DEFAULT_RECURRENT_INITIALIZER
            )),
            (n.biasInitializer = li(
              e.biasInitializer || n.DEFAULT_BIAS_INITIALIZER
            )),
            (n.kernelRegularizer = go(e.kernelRegularizer)),
            (n.recurrentRegularizer = go(e.recurrentRegularizer)),
            (n.biasRegularizer = go(e.biasRegularizer)),
            (n.kernelConstraint = or(e.kernelConstraint)),
            (n.recurrentConstraint = or(e.recurrentConstraint)),
            (n.biasConstraint = or(e.biasConstraint)),
            (n.dropout = Er([1, Sr([0, null == e.dropout ? 0 : e.dropout])])),
            (n.recurrentDropout = Er([
              1,
              Sr([0, null == e.recurrentDropout ? 0 : e.recurrentDropout]),
            ])),
            (n.stateSize = n.units),
            (n.dropoutMask = null),
            (n.recurrentDropoutMask = null),
            n
          );
        }
        return (
          On(e, t),
          (e.prototype.build = function (t) {
            (t = yi(t)),
              (this.kernel = this.addWeight(
                "kernel",
                [t[t.length - 1], this.units],
                null,
                this.kernelInitializer,
                this.kernelRegularizer,
                !0,
                this.kernelConstraint
              )),
              (this.recurrentKernel = this.addWeight(
                "recurrent_kernel",
                [this.units, this.units],
                null,
                this.recurrentInitializer,
                this.recurrentRegularizer,
                !0,
                this.recurrentConstraint
              )),
              this.useBias
                ? (this.bias = this.addWeight(
                    "bias",
                    [this.units],
                    null,
                    this.biasInitializer,
                    this.biasRegularizer,
                    !0,
                    this.biasConstraint
                  ))
                : (this.bias = null),
              (this.built = !0);
          }),
          (e.prototype.call = function (t, e) {
            var n = this;
            return Object(a.Zc)(function () {
              if (2 !== (t = t).length)
                throw new Tn(
                  "SimpleRNNCell expects 2 input Tensors, got " + t.length + "."
                );
              var r = t[1];
              t = t[0];
              var i,
                o = null != e.training && e.training;
              0 < n.dropout &&
                n.dropout < 1 &&
                null == n.dropoutMask &&
                (n.dropoutMask = Ws(
                  function () {
                    return Object(a.Zb)(t);
                  },
                  n.dropout,
                  o
                )),
                0 < n.recurrentDropout &&
                  n.recurrentDropout < 1 &&
                  null == n.recurrentDropoutMask &&
                  (n.recurrentDropoutMask = Ws(
                    function () {
                      return Object(a.Zb)(r);
                    },
                    n.recurrentDropout,
                    o
                  ));
              var s = n.dropoutMask,
                u = n.recurrentDropoutMask;
              (i = jr(null != s ? Object(a.Rb)(t, s) : t, n.kernel.read())),
                null != n.bias && (i = Br(i, n.bias.read())),
                null != u && (r = Object(a.Rb)(r, u));
              var c = Object(a.g)(i, jr(r, n.recurrentKernel.read()));
              return (
                null != n.activation && (c = n.activation.apply(c)), [c, c]
              );
            });
          }),
          (e.prototype.getConfig = function () {
            var e = {
                units: this.units,
                activation: so(this.activation),
                useBias: this.useBias,
                kernelInitializer: ci(this.kernelInitializer),
                recurrentInitializer: ci(this.recurrentInitializer),
                biasInitializer: ci(this.biasInitializer),
                kernelRegularizer: mo(this.kernelRegularizer),
                recurrentRegularizer: mo(this.recurrentRegularizer),
                biasRegularizer: mo(this.biasRegularizer),
                activityRegularizer: mo(this.activityRegularizer),
                kernelConstraint: ir(this.kernelConstraint),
                recurrentConstraint: ir(this.recurrentConstraint),
                biasConstraint: ir(this.biasConstraint),
                dropout: this.dropout,
                recurrentDropout: this.recurrentDropout,
              },
              n = t.prototype.getConfig.call(this);
            return Object.assign(e, n), e;
          }),
          (e.className = "SimpleRNNCell"),
          e
        );
      })(Ds);
    a.tc.registerClass(Fs);
    var Ms = (function (t) {
      function e(e) {
        return (e.cell = new Fs(e)), t.call(this, e) || this;
      }
      return (
        On(e, t),
        (e.prototype.call = function (e, n) {
          var r = this;
          return Object(a.Zc)(function () {
            null != r.cell.dropoutMask &&
              (Object(a.S)(r.cell.dropoutMask), (r.cell.dropoutMask = null)),
              null != r.cell.recurrentDropoutMask &&
                (Object(a.S)(r.cell.recurrentDropoutMask),
                (r.cell.recurrentDropoutMask = null));
            var i = null == n ? null : n.mask,
              o = null == n ? null : n.training,
              s = null == n ? null : n.initialState;
            return t.prototype.call.call(r, e, {
              mask: i,
              training: o,
              initialState: s,
            });
          });
        }),
        Object.defineProperty(e.prototype, "units", {
          get: function () {
            return this.cell.units;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "activation", {
          get: function () {
            return this.cell.activation;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "useBias", {
          get: function () {
            return this.cell.useBias;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "kernelInitializer", {
          get: function () {
            return this.cell.kernelInitializer;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "recurrentInitializer", {
          get: function () {
            return this.cell.recurrentInitializer;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "biasInitializer", {
          get: function () {
            return this.cell.biasInitializer;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "kernelRegularizer", {
          get: function () {
            return this.cell.kernelRegularizer;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "recurrentRegularizer", {
          get: function () {
            return this.cell.recurrentRegularizer;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "biasRegularizer", {
          get: function () {
            return this.cell.biasRegularizer;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "kernelConstraint", {
          get: function () {
            return this.cell.kernelConstraint;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "recurrentConstraint", {
          get: function () {
            return this.cell.recurrentConstraint;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "biasConstraint", {
          get: function () {
            return this.cell.biasConstraint;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "dropout", {
          get: function () {
            return this.cell.dropout;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "recurrentDropout", {
          get: function () {
            return this.cell.recurrentDropout;
          },
          enumerable: !0,
          configurable: !0,
        }),
        (e.prototype.getConfig = function () {
          var e = {
              units: this.units,
              activation: so(this.activation),
              useBias: this.useBias,
              kernelInitializer: ci(this.kernelInitializer),
              recurrentInitializer: ci(this.recurrentInitializer),
              biasInitializer: ci(this.biasInitializer),
              kernelRegularizer: mo(this.kernelRegularizer),
              recurrentRegularizer: mo(this.recurrentRegularizer),
              biasRegularizer: mo(this.biasRegularizer),
              activityRegularizer: mo(this.activityRegularizer),
              kernelConstraint: ir(this.kernelConstraint),
              recurrentConstraint: ir(this.recurrentConstraint),
              biasConstraint: ir(this.biasConstraint),
              dropout: this.dropout,
              recurrentDropout: this.recurrentDropout,
            },
            n = t.prototype.getConfig.call(this);
          return delete n.cell, Object.assign(e, n), e;
        }),
        (e.fromConfig = function (t, e) {
          return new t(e);
        }),
        (e.className = "SimpleRNN"),
        e
      );
    })(Rs);
    a.tc.registerClass(Ms);
    var js = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return (
          (n.DEFAULT_ACTIVATION = "tanh"),
          (n.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid"),
          (n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal"),
          (n.DEFAULT_RECURRENT_INITIALIZER = "orthogonal"),
          (n.DEFAULT_BIAS_INITIALIZER = "zeros"),
          (n.units = e.units),
          Xn(n.units, "units"),
          (n.activation = co(
            void 0 === e.activation ? n.DEFAULT_ACTIVATION : e.activation
          )),
          (n.recurrentActivation = co(
            void 0 === e.recurrentActivation
              ? n.DEFAULT_RECURRENT_ACTIVATION
              : e.recurrentActivation
          )),
          (n.useBias = null == e.useBias || e.useBias),
          (n.kernelInitializer = li(
            e.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER
          )),
          (n.recurrentInitializer = li(
            e.recurrentInitializer || n.DEFAULT_RECURRENT_INITIALIZER
          )),
          (n.biasInitializer = li(
            e.biasInitializer || n.DEFAULT_BIAS_INITIALIZER
          )),
          (n.kernelRegularizer = go(e.kernelRegularizer)),
          (n.recurrentRegularizer = go(e.recurrentRegularizer)),
          (n.biasRegularizer = go(e.biasRegularizer)),
          (n.kernelConstraint = or(e.kernelConstraint)),
          (n.recurrentConstraint = or(e.recurrentConstraint)),
          (n.biasConstraint = or(e.biasConstraint)),
          (n.dropout = Er([1, Sr([0, null == e.dropout ? 0 : e.dropout])])),
          (n.recurrentDropout = Er([
            1,
            Sr([0, null == e.recurrentDropout ? 0 : e.recurrentDropout]),
          ])),
          (n.implementation = e.implementation),
          (n.stateSize = n.units),
          (n.dropoutMask = null),
          (n.recurrentDropoutMask = null),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype.build = function (t) {
          var e = (t = yi(t))[t.length - 1];
          (this.kernel = this.addWeight(
            "kernel",
            [e, 3 * this.units],
            null,
            this.kernelInitializer,
            this.kernelRegularizer,
            !0,
            this.kernelConstraint
          )),
            (this.recurrentKernel = this.addWeight(
              "recurrent_kernel",
              [this.units, 3 * this.units],
              null,
              this.recurrentInitializer,
              this.recurrentRegularizer,
              !0,
              this.recurrentConstraint
            )),
            this.useBias
              ? (this.bias = this.addWeight(
                  "bias",
                  [3 * this.units],
                  null,
                  this.biasInitializer,
                  this.biasRegularizer,
                  !0,
                  this.biasConstraint
                ))
              : (this.bias = null),
            (this.built = !0);
        }),
        (e.prototype.call = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            if (2 !== (t = t).length)
              throw new Tn(
                "GRUCell expects 2 input Tensors (inputs, h, c), got " +
                  t.length +
                  "."
              );
            var r = null != e.training && e.training,
              i = t[1];
            (t = t[0]),
              0 < n.dropout &&
                n.dropout < 1 &&
                null == n.dropoutMask &&
                (n.dropoutMask = Ws(
                  function () {
                    return Object(a.Zb)(t);
                  },
                  n.dropout,
                  r,
                  3
                )),
              0 < n.recurrentDropout &&
                n.recurrentDropout < 1 &&
                null == n.recurrentDropoutMask &&
                (n.recurrentDropoutMask = Ws(
                  function () {
                    return Object(a.Zb)(i);
                  },
                  n.recurrentDropout,
                  r,
                  3
                ));
            var o,
              s,
              u,
              c = n.dropoutMask,
              l = n.recurrentDropoutMask;
            0 < n.dropout && n.dropout < 1 && (t = Object(a.Rb)(t, c[0]));
            var p = jr(t, n.kernel.read());
            n.useBias && (p = Br(p, n.bias.read())),
              0 < n.recurrentDropout &&
                n.recurrentDropout < 1 &&
                (i = Object(a.Rb)(i, l[0]));
            var h = n.recurrentKernel.read(),
              f = Object(a.Ic)(h, [2 * n.units, n.units], h.rank - 1),
              d = f[0],
              m = f[1],
              v = jr(i, d),
              g = Object(a.Ic)(p, 3, p.rank - 1),
              y = g[0],
              b = g[1],
              w = g[2],
              x = Object(a.Ic)(v, 2, v.rank - 1),
              C = x[0],
              O = x[1];
            (o = n.recurrentActivation.apply(Object(a.g)(y, C))),
              (s = n.recurrentActivation.apply(Object(a.g)(b, O)));
            var E = jr(Object(a.Rb)(s, i), m);
            u = n.activation.apply(Object(a.g)(w, E));
            var S = Object(a.g)(
              Object(a.Rb)(o, i),
              Object(a.Rb)(Object(a.g)(1, Object(a.Ub)(o)), u)
            );
            return [S, S];
          });
        }),
        (e.prototype.getConfig = function () {
          var e = {
              units: this.units,
              activation: so(this.activation),
              recurrentActivation: so(this.recurrentActivation),
              useBias: this.useBias,
              kernelInitializer: ci(this.kernelInitializer),
              recurrentInitializer: ci(this.recurrentInitializer),
              biasInitializer: ci(this.biasInitializer),
              kernelRegularizer: mo(this.kernelRegularizer),
              recurrentRegularizer: mo(this.recurrentRegularizer),
              biasRegularizer: mo(this.biasRegularizer),
              activityRegularizer: mo(this.activityRegularizer),
              kernelConstraint: ir(this.kernelConstraint),
              recurrentConstraint: ir(this.recurrentConstraint),
              biasConstraint: ir(this.biasConstraint),
              dropout: this.dropout,
              recurrentDropout: this.recurrentDropout,
              implementation: this.implementation,
            },
            n = t.prototype.getConfig.call(this);
          return Object.assign(e, n), e;
        }),
        (e.className = "GRUCell"),
        e
      );
    })(Ds);
    a.tc.registerClass(js);
    var Ps = (function (t) {
      function e(e) {
        return (
          0 === e.implementation &&
            console.warn(
              "`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."
            ),
          (e.cell = new js(e)),
          t.call(this, e) || this
        );
      }
      return (
        On(e, t),
        (e.prototype.call = function (e, n) {
          var r = this;
          return Object(a.Zc)(function () {
            null != r.cell.dropoutMask &&
              (Object(a.S)(r.cell.dropoutMask), (r.cell.dropoutMask = null)),
              null != r.cell.recurrentDropoutMask &&
                (Object(a.S)(r.cell.recurrentDropoutMask),
                (r.cell.recurrentDropoutMask = null));
            var i = null == n ? null : n.mask,
              o = null == n ? null : n.training,
              s = null == n ? null : n.initialState;
            return t.prototype.call.call(r, e, {
              mask: i,
              training: o,
              initialState: s,
            });
          });
        }),
        Object.defineProperty(e.prototype, "units", {
          get: function () {
            return this.cell.units;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "activation", {
          get: function () {
            return this.cell.activation;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "recurrentActivation", {
          get: function () {
            return this.cell.recurrentActivation;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "useBias", {
          get: function () {
            return this.cell.useBias;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "kernelInitializer", {
          get: function () {
            return this.cell.kernelInitializer;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "recurrentInitializer", {
          get: function () {
            return this.cell.recurrentInitializer;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "biasInitializer", {
          get: function () {
            return this.cell.biasInitializer;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "kernelRegularizer", {
          get: function () {
            return this.cell.kernelRegularizer;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "recurrentRegularizer", {
          get: function () {
            return this.cell.recurrentRegularizer;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "biasRegularizer", {
          get: function () {
            return this.cell.biasRegularizer;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "kernelConstraint", {
          get: function () {
            return this.cell.kernelConstraint;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "recurrentConstraint", {
          get: function () {
            return this.cell.recurrentConstraint;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "biasConstraint", {
          get: function () {
            return this.cell.biasConstraint;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "dropout", {
          get: function () {
            return this.cell.dropout;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "recurrentDropout", {
          get: function () {
            return this.cell.recurrentDropout;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "implementation", {
          get: function () {
            return this.cell.implementation;
          },
          enumerable: !0,
          configurable: !0,
        }),
        (e.prototype.getConfig = function () {
          var e = {
              units: this.units,
              activation: so(this.activation),
              recurrentActivation: so(this.recurrentActivation),
              useBias: this.useBias,
              kernelInitializer: ci(this.kernelInitializer),
              recurrentInitializer: ci(this.recurrentInitializer),
              biasInitializer: ci(this.biasInitializer),
              kernelRegularizer: mo(this.kernelRegularizer),
              recurrentRegularizer: mo(this.recurrentRegularizer),
              biasRegularizer: mo(this.biasRegularizer),
              activityRegularizer: mo(this.activityRegularizer),
              kernelConstraint: ir(this.kernelConstraint),
              recurrentConstraint: ir(this.recurrentConstraint),
              biasConstraint: ir(this.biasConstraint),
              dropout: this.dropout,
              recurrentDropout: this.recurrentDropout,
              implementation: this.implementation,
            },
            n = t.prototype.getConfig.call(this);
          return delete n.cell, Object.assign(e, n), e;
        }),
        (e.fromConfig = function (t, e) {
          return 0 === e.implmentation && (e.implementation = 1), new t(e);
        }),
        (e.className = "GRU"),
        e
      );
    })(Rs);
    a.tc.registerClass(Ps);
    var zs = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return (
          (n.DEFAULT_ACTIVATION = "tanh"),
          (n.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid"),
          (n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal"),
          (n.DEFAULT_RECURRENT_INITIALIZER = "orthogonal"),
          (n.DEFAULT_BIAS_INITIALIZER = "zeros"),
          (n.units = e.units),
          Xn(n.units, "units"),
          (n.activation = co(
            void 0 === e.activation ? n.DEFAULT_ACTIVATION : e.activation
          )),
          (n.recurrentActivation = co(
            void 0 === e.recurrentActivation
              ? n.DEFAULT_RECURRENT_ACTIVATION
              : e.recurrentActivation
          )),
          (n.useBias = null == e.useBias || e.useBias),
          (n.kernelInitializer = li(
            e.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER
          )),
          (n.recurrentInitializer = li(
            e.recurrentInitializer || n.DEFAULT_RECURRENT_INITIALIZER
          )),
          (n.biasInitializer = li(
            e.biasInitializer || n.DEFAULT_BIAS_INITIALIZER
          )),
          (n.unitForgetBias = e.unitForgetBias),
          (n.kernelRegularizer = go(e.kernelRegularizer)),
          (n.recurrentRegularizer = go(e.recurrentRegularizer)),
          (n.biasRegularizer = go(e.biasRegularizer)),
          (n.kernelConstraint = or(e.kernelConstraint)),
          (n.recurrentConstraint = or(e.recurrentConstraint)),
          (n.biasConstraint = or(e.biasConstraint)),
          (n.dropout = Er([1, Sr([0, null == e.dropout ? 0 : e.dropout])])),
          (n.recurrentDropout = Er([
            1,
            Sr([0, null == e.recurrentDropout ? 0 : e.recurrentDropout]),
          ])),
          (n.implementation = e.implementation),
          (n.stateSize = [n.units, n.units]),
          (n.dropoutMask = null),
          (n.recurrentDropoutMask = null),
          n
        );
      }
      return (
        On(e, t),
        (e.prototype.build = function (t) {
          var e,
            n,
            r = (t = yi(t))[t.length - 1];
          if (
            ((this.kernel = this.addWeight(
              "kernel",
              [r, 4 * this.units],
              null,
              this.kernelInitializer,
              this.kernelRegularizer,
              !0,
              this.kernelConstraint
            )),
            (this.recurrentKernel = this.addWeight(
              "recurrent_kernel",
              [this.units, 4 * this.units],
              null,
              this.recurrentInitializer,
              this.recurrentRegularizer,
              !0,
              this.recurrentConstraint
            )),
            this.useBias)
          ) {
            if (this.unitForgetBias) {
              var i = this.biasInitializer,
                a = this.units;
              n = new (((e = (function (t) {
                function e() {
                  return (null !== t && t.apply(this, arguments)) || this;
                }
                return (
                  On(e, t),
                  (e.prototype.apply = function (t, e) {
                    var n = i.apply([a]),
                      r = new Kr().apply([a]),
                      o = i.apply([2 * a]);
                    return Dr(Dr(n, r), o);
                  }),
                  e
                );
              })(Hr)).className = "CustomInit"),
              e)();
            } else n = this.biasInitializer;
            this.bias = this.addWeight(
              "bias",
              [4 * this.units],
              null,
              n,
              this.biasRegularizer,
              !0,
              this.biasConstraint
            );
          } else this.bias = null;
          this.built = !0;
        }),
        (e.prototype.call = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            var r = null != e.training && e.training;
            if (3 !== (t = t).length)
              throw new Tn(
                "LSTMCell expects 3 input Tensors (inputs, h, c), got " +
                  t.length +
                  "."
              );
            var i = t[1],
              o = t[2];
            (t = t[0]),
              0 < n.dropout &&
                n.dropout < 1 &&
                null == n.dropoutMask &&
                (n.dropoutMask = Ws(
                  function () {
                    return Object(a.Zb)(t);
                  },
                  n.dropout,
                  r,
                  4
                )),
              0 < n.recurrentDropout &&
                n.recurrentDropout < 1 &&
                null == n.recurrentDropoutMask &&
                (n.recurrentDropoutMask = Ws(
                  function () {
                    return Object(a.Zb)(i);
                  },
                  n.recurrentDropout,
                  r,
                  4
                ));
            var s,
              u,
              c,
              l,
              p = n.dropoutMask,
              h = n.recurrentDropoutMask;
            0 < n.dropout && n.dropout < 1 && (t = Object(a.Rb)(t, p[0]));
            var f = jr(t, n.kernel.read());
            0 < n.recurrentDropout &&
              n.recurrentDropout < 1 &&
              (i = Object(a.Rb)(i, h[0])),
              (f = Object(a.g)(f, jr(i, n.recurrentKernel.read()))),
              n.useBias && (f = Br(f, n.bias.read()));
            var d = Object(a.Ic)(f, 4, f.rank - 1),
              m = d[0],
              v = d[1],
              g = d[2],
              y = d[3];
            (s = n.recurrentActivation.apply(m)),
              (u = n.recurrentActivation.apply(v)),
              (c = Object(a.g)(
                Object(a.Rb)(u, o),
                Object(a.Rb)(s, n.activation.apply(g))
              )),
              (l = n.recurrentActivation.apply(y));
            var b = Object(a.Rb)(l, n.activation.apply(c));
            return [b, b, c];
          });
        }),
        (e.prototype.getConfig = function () {
          var e = {
              units: this.units,
              activation: so(this.activation),
              recurrentActivation: so(this.recurrentActivation),
              useBias: this.useBias,
              kernelInitializer: ci(this.kernelInitializer),
              recurrentInitializer: ci(this.recurrentInitializer),
              biasInitializer: ci(this.biasInitializer),
              unitForgetBias: this.unitForgetBias,
              kernelRegularizer: mo(this.kernelRegularizer),
              recurrentRegularizer: mo(this.recurrentRegularizer),
              biasRegularizer: mo(this.biasRegularizer),
              activityRegularizer: mo(this.activityRegularizer),
              kernelConstraint: ir(this.kernelConstraint),
              recurrentConstraint: ir(this.recurrentConstraint),
              biasConstraint: ir(this.biasConstraint),
              dropout: this.dropout,
              recurrentDropout: this.recurrentDropout,
              implementation: this.implementation,
            },
            n = t.prototype.getConfig.call(this);
          return Object.assign(e, n), e;
        }),
        (e.className = "LSTMCell"),
        e
      );
    })(Ds);
    a.tc.registerClass(zs);
    var Ls = (function (t) {
      function e(e) {
        return (
          0 === e.implementation &&
            console.warn(
              "`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."
            ),
          (e.cell = new zs(e)),
          t.call(this, e) || this
        );
      }
      return (
        On(e, t),
        (e.prototype.call = function (e, n) {
          var r = this;
          return Object(a.Zc)(function () {
            null != r.cell.dropoutMask &&
              (Object(a.S)(r.cell.dropoutMask), (r.cell.dropoutMask = null)),
              null != r.cell.recurrentDropoutMask &&
                (Object(a.S)(r.cell.recurrentDropoutMask),
                (r.cell.recurrentDropoutMask = null));
            var i = null == n ? null : n.mask,
              o = null == n ? null : n.training,
              s = null == n ? null : n.initialState;
            return t.prototype.call.call(r, e, {
              mask: i,
              training: o,
              initialState: s,
            });
          });
        }),
        Object.defineProperty(e.prototype, "units", {
          get: function () {
            return this.cell.units;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "activation", {
          get: function () {
            return this.cell.activation;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "recurrentActivation", {
          get: function () {
            return this.cell.recurrentActivation;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "useBias", {
          get: function () {
            return this.cell.useBias;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "kernelInitializer", {
          get: function () {
            return this.cell.kernelInitializer;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "recurrentInitializer", {
          get: function () {
            return this.cell.recurrentInitializer;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "biasInitializer", {
          get: function () {
            return this.cell.biasInitializer;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "unitForgetBias", {
          get: function () {
            return this.cell.unitForgetBias;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "kernelRegularizer", {
          get: function () {
            return this.cell.kernelRegularizer;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "recurrentRegularizer", {
          get: function () {
            return this.cell.recurrentRegularizer;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "biasRegularizer", {
          get: function () {
            return this.cell.biasRegularizer;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "kernelConstraint", {
          get: function () {
            return this.cell.kernelConstraint;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "recurrentConstraint", {
          get: function () {
            return this.cell.recurrentConstraint;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "biasConstraint", {
          get: function () {
            return this.cell.biasConstraint;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "dropout", {
          get: function () {
            return this.cell.dropout;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "recurrentDropout", {
          get: function () {
            return this.cell.recurrentDropout;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "implementation", {
          get: function () {
            return this.cell.implementation;
          },
          enumerable: !0,
          configurable: !0,
        }),
        (e.prototype.getConfig = function () {
          var e = {
              units: this.units,
              activation: so(this.activation),
              recurrentActivation: so(this.recurrentActivation),
              useBias: this.useBias,
              kernelInitializer: ci(this.kernelInitializer),
              recurrentInitializer: ci(this.recurrentInitializer),
              biasInitializer: ci(this.biasInitializer),
              unitForgetBias: this.unitForgetBias,
              kernelRegularizer: mo(this.kernelRegularizer),
              recurrentRegularizer: mo(this.recurrentRegularizer),
              biasRegularizer: mo(this.biasRegularizer),
              activityRegularizer: mo(this.activityRegularizer),
              kernelConstraint: ir(this.kernelConstraint),
              recurrentConstraint: ir(this.recurrentConstraint),
              biasConstraint: ir(this.biasConstraint),
              dropout: this.dropout,
              recurrentDropout: this.recurrentDropout,
              implementation: this.implementation,
            },
            n = t.prototype.getConfig.call(this);
          return delete n.cell, Object.assign(e, n), e;
        }),
        (e.fromConfig = function (t, e) {
          return 0 === e.implmentation && (e.implementation = 1), new t(e);
        }),
        (e.className = "LSTM"),
        e
      );
    })(Rs);
    a.tc.registerClass(Ls);
    var Bs = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return (n.cells = e.cells), n;
      }
      return (
        On(e, t),
        Object.defineProperty(e.prototype, "stateSize", {
          get: function () {
            for (
              var t = [], e = 0, n = this.cells.slice().reverse();
              e < n.length;
              e++
            ) {
              var r = n[e];
              Array.isArray(r.stateSize)
                ? t.push.apply(t, r.stateSize)
                : t.push(r.stateSize);
            }
            return t;
          },
          enumerable: !0,
          configurable: !0,
        }),
        (e.prototype.call = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            for (
              var r = (t = t).slice(1),
                i = [],
                a = 0,
                o = n.cells.slice().reverse();
              a < o.length;
              a++
            ) {
              var s = o[a];
              Array.isArray(s.stateSize)
                ? i.push(r.splice(0, s.stateSize.length))
                : i.push(r.splice(0, 1));
            }
            i.reverse();
            for (var u, c = [], l = 0; l < n.cells.length; ++l)
              (s = n.cells[l]),
                (r = i[l]),
                (u = 0 === l ? [t[0]].concat(r) : [u[0]].concat(r)),
                (u = s.call(u, e)),
                c.push(u.slice(1));
            r = [];
            for (var p = 0, h = c.slice().reverse(); p < h.length; p++) {
              var f = h[p];
              r.push.apply(r, f);
            }
            return [u[0]].concat(r);
          });
        }),
        (e.prototype.build = function (t) {
          var e;
          mi(t) && (t = t[0]),
            (t = t),
            this.cells.forEach(function (n, r) {
              vr("RNNCell_" + r, function () {
                n.build(t),
                  (e = Array.isArray(n.stateSize)
                    ? n.stateSize[0]
                    : n.stateSize),
                  (t = [t[0], e]);
              });
            }),
            (this.built = !0);
        }),
        (e.prototype.getConfig = function () {
          for (var e = [], n = 0, r = this.cells; n < r.length; n++) {
            var i = r[n];
            e.push({ className: i.getClassName(), config: i.getConfig() });
          }
          var a = { cells: e },
            o = t.prototype.getConfig.call(this);
          return Object.assign(a, o), a;
        }),
        (e.fromConfig = function (t, e, n) {
          void 0 === n && (n = {});
          for (var r = [], i = 0, a = e.cells; i < a.length; i++) {
            var o = a[i];
            r.push(Vi(o, n));
          }
          return new t({ cells: r });
        }),
        Object.defineProperty(e.prototype, "trainableWeights", {
          get: function () {
            if (!this.trainable) return [];
            for (var t = [], e = 0, n = this.cells; e < n.length; e++) {
              var r = n[e];
              t.push.apply(t, r.trainableWeights);
            }
            return t;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "nonTrainableWeights", {
          get: function () {
            for (var t = [], e = 0, n = this.cells; e < n.length; e++) {
              var r = n[e];
              t.push.apply(t, r.nonTrainableWeights);
            }
            if (!this.trainable) {
              for (var i = [], a = 0, o = this.cells; a < o.length; a++)
                (r = o[a]), i.push.apply(i, r.trainableWeights);
              return i.concat(t);
            }
            return t;
          },
          enumerable: !0,
          configurable: !0,
        }),
        (e.prototype.getWeights = function () {
          for (var t = [], e = 0, n = this.cells; e < n.length; e++) {
            var r = n[e];
            t.push.apply(t, r.weights);
          }
          return xi(t);
        }),
        (e.prototype.setWeights = function (t) {
          for (var e = [], n = 0, r = this.cells; n < r.length; n++)
            for (
              var i = r[n], a = i.weights.length, o = t.splice(a), s = 0;
              s < i.weights.length;
              ++s
            )
              e.push([i.weights[s], o[s]]);
          Ci(e);
        }),
        (e.className = "StackedRNNCells"),
        e
      );
    })(Ds);
    function Ws(t, e, n, r) {
      function i() {
        return Wr(t(), e);
      }
      if ((void 0 === n && (n = null), void 0 === r && (r = 1), r > 1)) {
        for (var o = [], s = 0; s < r; s++) o.push(Ur(i, t, n));
        return o.map(function (t) {
          return Object(a.tb)(t.clone());
        });
      }
      return Object(a.tb)(Ur(i, t, n).clone());
    }
    a.tc.registerClass(Bs);
    var Us = (function (t) {
        function e(e) {
          var n = t.call(this, e) || this;
          return (n.layer = e.layer), n;
        }
        return (
          On(e, t),
          (e.prototype.build = function (t) {
            this.built = !0;
          }),
          Object.defineProperty(e.prototype, "trainable", {
            get: function () {
              return null != this.layer && this.layer.trainable;
            },
            set: function (t) {
              null != this.layer && (this.layer.trainable = t);
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(e.prototype, "trainableWeights", {
            get: function () {
              return this.layer.trainableWeights;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(e.prototype, "nonTrainableWeights", {
            get: function () {
              return this.layer.nonTrainableWeights;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(e.prototype, "updates", {
            get: function () {
              return this.layer._updates;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(e.prototype, "losses", {
            get: function () {
              return this.layer.losses;
            },
            enumerable: !0,
            configurable: !0,
          }),
          (e.prototype.getWeights = function () {
            return this.layer.getWeights();
          }),
          (e.prototype.setWeights = function (t) {
            this.layer.setWeights(t);
          }),
          (e.prototype.getConfig = function () {
            var e = {
                layer: {
                  className: this.layer.getClassName(),
                  config: this.layer.getConfig(),
                },
              },
              n = t.prototype.getConfig.call(this);
            return Object.assign(e, n), e;
          }),
          (e.prototype.setFastWeightInitDuringBuild = function (e) {
            t.prototype.setFastWeightInitDuringBuild.call(this, e),
              null != this.layer && this.layer.setFastWeightInitDuringBuild(e);
          }),
          (e.fromConfig = function (t, e, n) {
            void 0 === n && (n = {});
            var r = Vi(e.layer, n);
            delete e.layer;
            var i = { layer: r };
            return Object.assign(i, e), new t(i);
          }),
          e
        );
      })(ki),
      Vs = (function (t) {
        function e(e) {
          var n = t.call(this, e) || this;
          return (n.supportsMasking = !0), n;
        }
        return (
          On(e, t),
          (e.prototype.build = function (e) {
            if ((e = yi(e)).length < 3)
              throw new Tn(
                "TimeDistributed layer expects an input shape >= 3D, but received input shape " +
                  JSON.stringify(e)
              );
            this.inputSpec = [{ shape: e }];
            var n = [e[0]].concat(e.slice(2));
            this.layer.built || (this.layer.build(n), (this.layer.built = !0)),
              t.prototype.build.call(this, e);
          }),
          (e.prototype.computeOutputShape = function (t) {
            var e = [(t = yi(t))[0]].concat(t.slice(2)),
              n = this.layer.computeOutputShape(e),
              r = t[1];
            return [n[0], r].concat(n.slice(1));
          }),
          (e.prototype.call = function (t, e) {
            var n = this;
            return Object(a.Zc)(function () {
              return Ts(
                function (t, r) {
                  return [gi(n.layer.call(t, e)), []];
                },
                (t = gi(t)),
                [],
                !1,
                null,
                null,
                !1,
                !0
              )[1];
            });
          }),
          (e.className = "TimeDistributed"),
          e
        );
      })(Us);
    a.tc.registerClass(Vs);
    var Gs = (function (t) {
      function e(e) {
        var n = t.call(this, e) || this,
          r = e.layer.getConfig(),
          i = {};
        (i.className = e.layer.getClassName()),
          (i.config = r),
          (n.forwardLayer = Vi(i)),
          (r.goBackwards = !0 !== r.goBackwards);
        var a = {};
        if (
          ((a.className = e.layer.getClassName()),
          (a.config = r),
          (n.backwardLayer = Vi(a)),
          (n.forwardLayer.name = "forward_" + n.forwardLayer.name),
          (n.backwardLayer.name = "backward_" + n.backwardLayer.name),
          (n.mergeMode = void 0 === e.mergeMode ? "concat" : e.mergeMode),
          (function (t) {
            Kn(lr, "BidirectionalMergeMode", t);
          })(n.mergeMode),
          e.weights)
        )
          throw new Rn(
            "weights support is not implemented for Bidirectional layer yet."
          );
        return (
          (n._stateful = e.layer.stateful),
          (n.returnSequences = e.layer.returnSequences),
          (n.returnState = e.layer.returnState),
          (n.supportsMasking = !0),
          (n._trainable = !0),
          (n.inputSpec = e.layer.inputSpec),
          (n.numConstants = null),
          n
        );
      }
      return (
        On(e, t),
        Object.defineProperty(e.prototype, "trainable", {
          get: function () {
            return this._trainable;
          },
          set: function (t) {
            (this._trainable = t),
              null != this.forwardLayer && (this.forwardLayer.trainable = t),
              null != this.backwardLayer && (this.backwardLayer.trainable = t);
          },
          enumerable: !0,
          configurable: !0,
        }),
        (e.prototype.getWeights = function () {
          return this.forwardLayer
            .getWeights()
            .concat(this.backwardLayer.getWeights());
        }),
        (e.prototype.setWeights = function (t) {
          var e = t.length,
            n = Math.floor(e / 2);
          this.forwardLayer.setWeights(t.slice(0, n)),
            this.backwardLayer.setWeights(t.slice(n));
        }),
        (e.prototype.computeOutputShape = function (t) {
          var e,
            n,
            r,
            i = this.forwardLayer.computeOutputShape(t);
          return (
            (Array.isArray(i) && Array.isArray(i[0])) || (i = [i]),
            (i = i),
            this.returnState ? ((r = i.slice(1)), (e = i[0])) : (e = i[0]),
            (e = e),
            "concat" === this.mergeMode
              ? ((e[e.length - 1] *= 2), (n = [e]))
              : (n = null == this.mergeMode ? [e, e.slice()] : [e]),
            this.returnState
              ? null == this.mergeMode
                ? n.concat(r).concat(r.slice())
                : [e].concat(r).concat(r.slice())
              : Pn(n)
          );
        }),
        (e.prototype.apply = function (e, n) {
          var r = null == n ? null : n.initialState,
            i = null == n ? null : n.constants;
          null == n && (n = {});
          var a = As(e, r, i, this.numConstants);
          if (
            ((e = a.inputs),
            (r = a.initialState),
            (i = a.constants),
            Array.isArray(e) && ((r = e.slice(1)), (e = e[0])),
            (null == r || 0 === r.length) && null == i)
          )
            return t.prototype.apply.call(this, e, n);
          var o = [],
            s = [];
          if (null != r) {
            var u = r.length;
            if (u % 2 > 0)
              throw new Tn(
                "When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs."
              );
            (n.initialState = r), o.push.apply(o, r);
            var c = r.map(function (t) {
              return new Oi({ shape: t.shape });
            });
            (this.forwardLayer.stateSpec = c.slice(0, u / 2)),
              (this.backwardLayer.stateSpec = c.slice(u / 2)),
              s.push.apply(s, c);
          }
          if (null != i)
            throw new Rn(
              "Support for constants in Bidirectional layers is not implemented yet."
            );
          for (var l = o[0] instanceof Ei, p = 0, h = o; p < h.length; p++)
            if (h[p] instanceof Ei !== l)
              throw new Tn(
                "The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors"
              );
          if (l) {
            var f = [e].concat(o),
              d = this.inputSpec.concat(s),
              m = this.inputSpec;
            this.inputSpec = d;
            var v = t.prototype.apply.call(this, f, n);
            return (this.inputSpec = m), v;
          }
          return t.prototype.apply.call(this, e, n);
        }),
        (e.prototype.call = function (t, e) {
          var n = this;
          return Object(a.Zc)(function () {
            var r,
              i,
              o,
              s,
              u = e.initialState;
            if (null == u)
              (r = n.forwardLayer.call(t, e)), (i = n.backwardLayer.call(t, e));
            else {
              var c = u.slice(0, u.length / 2),
                l = u.slice(u.length / 2);
              (r = n.forwardLayer.call(
                t,
                Object.assign(e, { initialState: c })
              )),
                (i = n.backwardLayer.call(
                  t,
                  Object.assign(e, { initialState: l })
                ));
            }
            return (
              n.returnState &&
                (Array.isArray(r) && (o = r.slice(1).concat(i.slice(1))),
                (r = r[0]),
                (i = i[0])),
              n.returnSequences && (i = Object(a.lc)(i, 1)),
              "concat" === n.mergeMode
                ? (s = Rr([r, i]))
                : "sum" === n.mergeMode
                ? (s = Object(a.g)(r, i))
                : "ave" === n.mergeMode
                ? (s = Object(a.Rb)(0.5, Object(a.g)(r, i)))
                : "mul" === n.mergeMode
                ? (s = Object(a.Rb)(r, i))
                : null == n.mergeMode && (s = [r, i]),
              n.returnState
                ? null == n.mergeMode
                  ? s.concat(o)
                  : [s].concat(o)
                : s
            );
          });
        }),
        (e.prototype.resetStates = function (t) {
          this.forwardLayer.resetStates(), this.backwardLayer.resetStates();
        }),
        (e.prototype.build = function (t) {
          var e = this;
          vr(this.forwardLayer.name, function () {
            e.forwardLayer.build(t);
          }),
            vr(this.backwardLayer.name, function () {
              e.backwardLayer.build(t);
            }),
            (this.built = !0);
        }),
        (e.prototype.computeMask = function (t, e) {
          var n;
          if (
            (Array.isArray(e) && (e = e[0]),
            (n = this.returnSequences
              ? null == this.mergeMode
                ? [e, e]
                : e
              : null == this.mergeMode
              ? [null, null]
              : null),
            this.returnState)
          ) {
            var r = this.forwardLayer.states.map(function (t) {
              return null;
            });
            return Array.isArray(n)
              ? n.concat(r).concat(r)
              : [n].concat(r).concat(r);
          }
          return n;
        }),
        Object.defineProperty(e.prototype, "trainableWeights", {
          get: function () {
            return this.forwardLayer.trainableWeights.concat(
              this.backwardLayer.trainableWeights
            );
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(e.prototype, "nonTrainableWeights", {
          get: function () {
            return this.forwardLayer.nonTrainableWeights.concat(
              this.backwardLayer.nonTrainableWeights
            );
          },
          enumerable: !0,
          configurable: !0,
        }),
        (e.prototype.setFastWeightInitDuringBuild = function (e) {
          t.prototype.setFastWeightInitDuringBuild.call(this, e),
            null != this.forwardLayer &&
              this.forwardLayer.setFastWeightInitDuringBuild(e),
            null != this.backwardLayer &&
              this.backwardLayer.setFastWeightInitDuringBuild(e);
        }),
        (e.prototype.getConfig = function () {
          var e = { mergeMode: this.mergeMode },
            n = t.prototype.getConfig.call(this);
          return Object.assign(e, n), e;
        }),
        (e.fromConfig = function (t, e) {
          var n = Vi(e.layer);
          if ((delete e.layer, null != e.numConstants))
            throw new Rn(
              "Deserialization of a Bidirectional layer with numConstants present is not supported yet."
            );
          var r = e;
          return (r.layer = n), new t(r);
        }),
        (e.className = "Bidirectional"),
        e
      );
    })(Us);
    function Hs(t) {
      return new gs(t);
    }
    function qs(t) {
      return new ws(t);
    }
    function Ks(t) {
      return new Os(t);
    }
    function Zs(t) {
      return new Ns(t);
    }
    function Xs(t) {
      return new _s(t);
    }
    function Ys(t) {
      return new vs(t);
    }
    function Js(t) {
      return new bs(t);
    }
    a.tc.registerClass(Gs);
    var $s = Zs,
      Qs = Xs,
      tu = Ys,
      eu = Js;
    Object.freeze({
      inputLayer: function (t) {
        return new Ti(t);
      },
      elu: function (t) {
        return new xo(t);
      },
      reLU: function (t) {
        return new yo(t);
      },
      leakyReLU: function (t) {
        return new bo(t);
      },
      prelu: function (t) {
        return new wo(t);
      },
      softmax: function (t) {
        return new Oo(t);
      },
      thresholdedReLU: function (t) {
        return new Co(t);
      },
      conv1d: function (t) {
        return new jo(t);
      },
      conv2d: function (t) {
        return new Ro(t);
      },
      conv2dTranspose: function (t) {
        return new Fo(t);
      },
      conv3d: function (t) {
        return new Do(t);
      },
      separableConv2d: function (t) {
        return new Mo(t);
      },
      cropping2D: function (t) {
        return new Po(t);
      },
      upSampling2d: function (t) {
        return new zo(t);
      },
      depthwiseConv2d: function (t) {
        return new Lo(t);
      },
      activation: function (t) {
        return new Go(t);
      },
      dense: function (t) {
        return new Uo(t);
      },
      dropout: function (t) {
        return new Bo(t);
      },
      spatialDropout1d: function (t) {
        return new Wo(t);
      },
      flatten: function (t) {
        return new Vo(t);
      },
      repeatVector: function (t) {
        return new Ho(t);
      },
      reshape: function (t) {
        return new qo(t);
      },
      permute: function (t) {
        return new Ko(t);
      },
      embedding: function (t) {
        return new Xo(t);
      },
      add: function (t) {
        return new Jo(t);
      },
      average: function (t) {
        return new Qo(t);
      },
      concatenate: function (t) {
        return new ns(t);
      },
      maximum: function (t) {
        return new ts(t);
      },
      minimum: function (t) {
        return new es(t);
      },
      multiply: function (t) {
        return new $o(t);
      },
      dot: function (t) {
        return new is(t);
      },
      batchNormalization: function (t) {
        return new ls(t);
      },
      layerNormalization: function (t) {
        return new ps(t);
      },
      zeroPadding2d: function (t) {
        return new hs(t);
      },
      averagePooling1d: Hs,
      avgPool1d: function (t) {
        return Hs(t);
      },
      avgPooling1d: function (t) {
        return Hs(t);
      },
      averagePooling2d: qs,
      avgPool2d: function (t) {
        return qs(t);
      },
      avgPooling2d: function (t) {
        return qs(t);
      },
      averagePooling3d: Ks,
      avgPool3d: function (t) {
        return Ks(t);
      },
      avgPooling3d: function (t) {
        return Ks(t);
      },
      globalAveragePooling1d: function (t) {
        return new Ss(t);
      },
      globalAveragePooling2d: function (t) {
        return new ks(t);
      },
      globalMaxPooling1d: Zs,
      globalMaxPooling2d: Xs,
      maxPooling1d: Ys,
      maxPooling2d: Js,
      maxPooling3d: function (t) {
        return new Cs(t);
      },
      gru: function (t) {
        return new Ps(t);
      },
      gruCell: function (t) {
        return new js(t);
      },
      lstm: function (t) {
        return new Ls(t);
      },
      lstmCell: function (t) {
        return new zs(t);
      },
      simpleRNN: function (t) {
        return new Ms(t);
      },
      simpleRNNCell: function (t) {
        return new Fs(t);
      },
      rnn: function (t) {
        return new Rs(t);
      },
      stackedRNNCells: function (t) {
        return new Bs(t);
      },
      bidirectional: function (t) {
        return new Gs(t);
      },
      timeDistributed: function (t) {
        return new Vs(t);
      },
      globalMaxPool1d: $s,
      globalMaxPool2d: Qs,
      maxPool1d: tu,
      maxPool2d: eu,
      Layer: ki,
      RNN: Rs,
      RNNCell: Ds,
      input: function (t) {
        return Ri(t);
      },
      gaussianNoise: function (t) {
        return new as(t);
      },
      gaussianDropout: function (t) {
        return new os(t);
      },
      alphaDropout: function (t) {
        return new ss(t);
      },
      masking: function (t) {
        return new Zo(t);
      },
    });
    Object.freeze({
      binaryAccuracy: function (t, e) {
        return ta(t, e);
      },
      binaryCrossentropy: function (t, e) {
        return aa(t, e);
      },
      sparseCategoricalAccuracy: function (t, e) {
        return oa(t, e);
      },
      categoricalAccuracy: function (t, e) {
        return ea(t, e);
      },
      categoricalCrossentropy: function (t, e) {
        return sa(t, e);
      },
      precision: function (t, e) {
        return ra(t, e);
      },
      recall: function (t, e) {
        return ia(t, e);
      },
      cosineProximity: function (t, e) {
        return Ji(t, e);
      },
      meanAbsoluteError: function (t, e) {
        return qi(t, e);
      },
      meanAbsolutePercentageError: function (t, e) {
        return Ki(t, e);
      },
      MAPE: function (t, e) {
        return Ki(t, e);
      },
      mape: function (t, e) {
        return Ki(t, e);
      },
      meanSquaredError: function (t, e) {
        return Hi(t, e);
      },
      MSE: function (t, e) {
        return Hi(t, e);
      },
      mse: function (t, e) {
        return Hi(t, e);
      },
    }),
      Object.freeze({
        modelFromJSON: function (t, e) {
          return Nn(this, void 0, void 0, function () {
            var n, r, i, o, s, u, c, l;
            return In(this, function (p) {
              switch (p.label) {
                case 0:
                  return (
                    "modelTopology" in t || (t = { modelTopology: t }),
                    null != (n = (t = t).modelTopology).model_config &&
                      (n = n.model_config),
                    (r = ga(n)),
                    (i = Vi(r, e)),
                    null == t.weightsManifest
                      ? [3, 2]
                      : [
                          4,
                          a.rb.loadWeights(
                            t.weightsManifest,
                            t.pathPrefix,
                            i.weights.map(function (t) {
                              return t.originalName;
                            })
                          ),
                        ]
                  );
                case 1:
                  for (
                    o = p.sent(), s = {}, u = 0, c = i.weights;
                    u < c.length;
                    u++
                  )
                    (l = c[u]), (s[l.originalName] = o[l.originalName]);
                  i.loadWeights(s), Object(a.S)(o), (p.label = 2);
                case 2:
                  return [2, i];
              }
            });
          });
        },
      });
    Object.freeze({
      l1l2: function (t) {
        return new ho(t);
      },
      l1: function (t) {
        return (function (t) {
          return lo(t), new ho({ l1: null != t ? t.l1 : null, l2: 0 });
        })(t);
      },
      l2: function (t) {
        return (function (t) {
          return lo(t), new ho({ l2: null != t ? t.l2 : null, l1: 0 });
        })(t);
      },
    });
    function nu(t, e) {
      return t < e;
    }
    function ru(t, e) {
      return t > e;
    }
    !(function (t) {
      function e(e) {
        var n = t.call(this) || this;
        if ((null == e && (e = {}), e.restoreBestWeights))
          throw new Rn(
            "restoreBestWeights = True is not implemented in EarlyStopping yet."
          );
        return (
          (n.monitor = e.monitor || "val_loss"),
          (n.minDelta = Math.abs(e.minDelta || 0)),
          (n.patience = e.patience || 0),
          (n.verbose = e.verbose || 0),
          (n.mode = e.mode || "auto"),
          (n.baseline = e.baseline),
          -1 === ["auto", "min", "max"].indexOf(n.mode) &&
            (console.warn(
              "EarlyStopping mode '" +
                n.mode +
                "' is invalid. Falling back to mode 'auto'."
            ),
            (n.mode = "auto")),
          "min" === n.mode
            ? (n.monitorFunc = nu)
            : "max" === n.mode || -1 !== n.monitor.indexOf("acc")
            ? (n.monitorFunc = ru)
            : (n.monitorFunc = nu),
          n.monitorFunc === nu && (n.minDelta *= -1),
          n
        );
      }
      On(e, t),
        (e.prototype.onTrainBegin = function (t) {
          return Nn(this, void 0, void 0, function () {
            return In(this, function (t) {
              return (
                (this.wait = 0),
                (this.stoppedEpoch = 0),
                null != this.baseline
                  ? (this.best = this.baseline)
                  : (this.best = this.monitorFunc === nu ? 1 / 0 : -1 / 0),
                [2]
              );
            });
          });
        }),
        (e.prototype.onEpochEnd = function (t, e) {
          return Nn(this, void 0, void 0, function () {
            var n;
            return In(this, function (r) {
              switch (r.label) {
                case 0:
                  return [4, Di(e)];
                case 1:
                  return (
                    r.sent(),
                    null == (n = this.getMonitorValue(e)) ||
                      (this.monitorFunc(n - this.minDelta, this.best)
                        ? ((this.best = n), (this.wait = 0))
                        : (this.wait++,
                          this.wait >= this.patience &&
                            ((this.stoppedEpoch = t),
                            (this.model.stopTraining = !0)))),
                    [2]
                  );
              }
            });
          });
        }),
        (e.prototype.onTrainEnd = function (t) {
          return Nn(this, void 0, void 0, function () {
            return In(this, function (t) {
              return (
                this.stoppedEpoch > 0 &&
                  this.verbose &&
                  console.log(
                    "Epoch " + this.stoppedEpoch + ": early stopping."
                  ),
                [2]
              );
            });
          });
        }),
        (e.prototype.getMonitorValue = function (t) {
          null == t && (t = {});
          var e = t[this.monitor];
          return (
            null == e &&
              console.warn(
                "Metric for EarlyStopping " +
                  this.monitor +
                  " is not available. Available metrics are: " +
                  Object.keys(t)
              ),
            e
          );
        });
    })(
      (function (t) {
        function e() {
          var e = (null !== t && t.apply(this, arguments)) || this;
          return (e.model = null), e;
        }
        return (
          On(e, t),
          (e.prototype.setModel = function (t) {
            if (!(t instanceof qa))
              throw new Error(
                "model must be a LayersModel, not some other Container"
              );
            this.model = t;
          }),
          e
        );
      })(Mi)
    );
    var iu = n(3),
      au = n(4);
    a.id, au.version_data, iu.b;
    let ou = {
      undetected: !1,
      turned: !1,
      turnedFactor: 0,
      bowed: !1,
      bowedFactor: 0,
      eyesClosed: !1,
      eyesClosedFactor: 0,
    };
    const su = { undetected: 50, turned: 30, bowed: 40, eyesClosed: 50 };
    function uu(t, e) {
      return Math.sqrt(Math.pow(t._x - e._x, 2) + Math.pow(t._y - e._y, 2));
    }
    function cu(t) {
      const e = uu(t[33], t[3]),
        n = uu(t[33], t[13]),
        [r, i] = (function (t, e, n) {
          if (t < e) {
            let n = t;
            (t = e), (e = n);
          }
          return [e * n < t, (t / e).toFixed(2) + ">3.5"];
        })(e, n, 3.5),
        a = (t[1]._y + t[15]._y) / 2,
        o = (t[39]._y + t[42]._y) / 2,
        s = (uu(t[0], t[1]) + uu(t[15], t[16])) / 2,
        u = a < o + 0.1 * s,
        c = (-(a - o) / s).toFixed(2) + ">-0.1",
        l = (uu(t[38], t[40]) + uu(t[43], t[47])) / 2,
        p = (uu(t[36], t[39]) + uu(t[42], t[45])) / 2,
        h =
          Math.pow(Math.max(e, n) - Math.min(e, n), 2) /
          Math.pow(Math.max(e, n), 2);
      return {
        turned: r,
        turnedFactor: i,
        bowed: u,
        bowedFactor: c,
        eyesClosed: p / l + 2.5 * h >= 5.8,
        eyesClosedFactor: (p / l + 2.5 * h).toFixed(2) + ">5.8",
      };
    }
    const lu = new (class {
      constructor() {
        (this.model = null),
          (this.loadModel = this.loadFromUri.bind(this)),
          (this.execute = this.execute.bind(this));
      }
      async loadFromUri(t) {
        return (
          await iu.a(t).then((t) => {
            this.model = t;
          }),
          new Promise((t) => {
            t();
          })
        );
      }
      execute(t, e) {
        if (void 0 !== t) return this.model.execute(t, e);
      }
    })();
    const pu = new (class {
      constructor() {
        (this.cam = null),
          (this.setCam = this.setCam.bind(this)),
          (this.capture = this.capture.bind(this));
      }
      async setCam(t) {
        this.cam = await au.webcam(t);
      }
      capture(t) {
        return new Promise((e, n) => {
          try {
            this.cam.capture().then((n) => {
              const r = a.kc(n, t);
              a.S(n), e(r);
            });
          } catch (t) {
            n(t);
          }
        });
      }
    })();
    a.X();
    let hu = 0,
      fu = 0;
    const du = document.getElementById("video"),
      { ImageData: mu } = i,
      vu = new je({ inputSize: 160, scoreThreshold: 0.3 });
    q.monkeyPatch({
      Canvas: HTMLCanvasElement,
      Image: HTMLImageElement,
      ImageData: mu,
      Video: HTMLVideoElement,
      createCanvasElement: () => document.createElement("canvas"),
      createImageElement: () => document.createElement("img"),
    }),
      Promise.all([
        en.tinyFaceDetector.loadFromUri("./models-faceapi"),
        lu.loadFromUri("../dist/models-tfjs/keypoints_tfjs/model.json"),
      ]).then(function () {
        navigator.getUserMedia(
          { video: { width: 640, height: 480 } },
          (t) => (du.srcObject = t),
          (t) => console.error(t)
        );
      }),
      du.addEventListener("play", async () => {
        const t = rt(du),
          e = t.getContext("2d");
        document.body.append(t);
        const n = { width: 640, height: 480 };
        !(function (t, e, n) {
          void 0 === n && (n = !1);
          var r = n ? et(e) : e,
            i = r.width,
            a = r.height;
          (t.width = i), (t.height = a);
        })(t, n),
          pu.setCam(du),
          setInterval(async () => {
            fu % 10 == 0 && console.time("time fd" + fu);
            const [i, o] = await Promise.all([
              ((s = du),
              (c = vu),
              void 0 === c && (c = new xe()),
              new xn(s, c)),
              pu.capture([1, 480, 640, 3]),
            ]);
            var s, c;
            fu % 10 == 0 && console.timeEnd("time fd" + fu),
              fu % 10 == 0 && console.time("time lm" + fu);
            const l = i ? i._box : void 0,
              p = (function (t, e) {
                return void 0 === t
                  ? void 0
                  : a.qb.cropAndResize(
                      e,
                      [
                        [
                          t.y / 480,
                          t.x / 640,
                          (t.y + t.height) / 480,
                          (t.x + t.width) / 640,
                        ],
                      ],
                      [0],
                      [160, 160]
                    );
              })(l, o),
              h = lu.execute(p, "Identity_2");
            (async function (t, e) {
              if (void 0 === t) return;
              const n = await t.array();
              let r = new Array();
              for (let t = 0; t < 136; ++t) {
                t % 2 || (r[Math.floor(t / 2)] = new Object());
                let i =
                  t % 2
                    ? { key: "_y", offset: e.y, mult: e.height }
                    : { key: "_x", offset: e.x, mult: e.width };
                r[Math.floor(t / 2)][i.key] = i.offset + n[0][t] * i.mult;
              }
              return r;
            })(h, l).then((o) => {
              (hu = (function (t, e) {
                return (
                  (ou = {}),
                  (ou.undetected = !t),
                  e && (ou = { ...ou, ...cu(e) }),
                  Object.keys(su).reduce(
                    (t, e) => (ou[e] ? t + ou[e] * su[e] : t),
                    0
                  )
                );
              })(i, o)),
                (function (t, e, n, i, o, s) {
                  if ((e.clearRect(0, 0, t.width, t.height), void 0 !== n)) {
                    const e = (function t(e, n) {
                      var r = new u(n.width, n.height),
                        i = r.width,
                        a = r.height;
                      if (i <= 0 || a <= 0)
                        throw new Error(
                          "resizeResults - invalid dimensions: " +
                            JSON.stringify({ width: i, height: a })
                        );
                      if (Array.isArray(e))
                        return e.map(function (e) {
                          return t(e, { width: i, height: a });
                        });
                      if (Lt(e)) {
                        var o = e.detection.forSize(i, a),
                          s = e.unshiftedLandmarks.forSize(
                            o.box.width,
                            o.box.height
                          );
                        return Bt(j(e, o), s);
                      }
                      return M(e)
                        ? j(e, e.detection.forSize(i, a))
                        : e instanceof _ || e instanceof O
                        ? e.forSize(i, a)
                        : e;
                    })(n, o);
                    r.drawDetections(t, e);
                  }
                  if (((e.fillStyle = "#FF00FF"), void 0 !== i))
                    for (let t = 0; t < 68; ++t)
                      e.fillRect(i[t]._x, i[t]._y, 3, 3);
                  !(function (t, e) {
                    (t.fillStyle = "#FF00FF"),
                      (t.font = "30px Arial"),
                      t.fillText("score: " + e, 30, 50),
                      (t.font = "18px Arial");
                    for (
                      var n = JSON.stringify(ou, null, 2).split("\n"), r = 0;
                      r < n.length;
                      r++
                    )
                      t.fillText(n[r], 10, 310 + 20 * r);
                    (t.font = "12px Arial"),
                      t.fillText(JSON.stringify(a.Mb()), 20, 470);
                  })(e, s);
                })(t, e, i, o, n, hu);
            }),
              a.S(h),
              a.S(p),
              fu % 10 == 0 && console.timeEnd("time lm" + fu),
              (fu += 1),
              a.S(o);
          }, 50);
      });
  },
]);
